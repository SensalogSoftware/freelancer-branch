
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
   0:	b8 30 00 20 b5 1e 00 00 a1 a4 00 00 6d 1e 00 00     .0. ........m...
	const char *s;
	bool parsing = false;
	/* Flag indicates that rw strings are stored as array with positions,
	 * instead of appending them to the package.
	 */
	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
  10:	6d 1e 00 00 6d 1e 00 00 6d 1e 00 00 6d 1e 00 00     m...m...m...m...
	...

	/*
	 * Otherwise we must ensure we can store at least
	 * the pointer to the format string itself.
	 */
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
  2c:	a1 18 00 00 6d 1e 00 00 00 00 00 00 49 18 00 00     ....m.......I...
	unsigned int s_ro_cnt = 0; /* number of ro strings */
  3c:	6d 1e 00 00                                         m...

00000040 <_irq_vector_table>:
	unsigned int s_rw_cnt = 0; /* number of rw strings */
  40:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...

		/* copy va_list data over to our buffer */
		if (is_str_arg) {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  50:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);

			if (is_ro && !do_ro) {
  60:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
				 * In the do_ro case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
  70:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
					__ASSERT(false, "str_ptr_pos[] too small");
					return -EINVAL;
				}

				if (buf0 != NULL) {
  80:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
					/*
					 * Remember string pointer location.
					 * We will append non-ro strings later.
					 */
					str_ptr_pos[s_idx] = s_ptr_idx;
  90:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
					str_ptr_arg[s_idx] = arg_idx;
					if (is_ro) {
						/* flag read-only string. */
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  a0:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
					 * and size of the pointer position prefix.
					 */
					len += strlen(s) + 1 + 1;
				}

				s_idx++;
  b0:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  c0:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
				parsing = false;
  d0:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
					arg_idx++;
  e0:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
			switch (*fmt) {
  f0:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
 100:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
 110:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
				arg_idx--;
 120:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
			switch (*fmt) {
 130:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
			if (*++fmt == '\0') {
 140:	29 19 00 00 29 19 00 00 29 19 00 00 29 19 00 00     )...)...)...)...
			switch (*fmt) {
 150:	29 19 00 00                                         )...

Disassembly of section text:

00000154 <__aeabi_uldivmod>:
     154:	b953      	cbnz	r3, 16c <__aeabi_uldivmod+0x18>
     156:	b94a      	cbnz	r2, 16c <__aeabi_uldivmod+0x18>
     158:	2900      	cmp	r1, #0
     15a:	bf08      	it	eq
     15c:	2800      	cmpeq	r0, #0
     15e:	bf1c      	itt	ne
     160:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
     164:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
     168:	f000 b80c 	b.w	184 <__aeabi_idiv0>
     16c:	f1ad 0c08 	sub.w	ip, sp, #8
     170:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     174:	f000 f81b 	bl	1ae <__udivmoddi4>
     178:	f8dd e004 	ldr.w	lr, [sp, #4]
     17c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     180:	b004      	add	sp, #16
     182:	4770      	bx	lr

00000184 <__aeabi_idiv0>:
     184:	4770      	bx	lr
     186:	bf00      	nop

00000188 <__popcountsi2>:
     188:	0843      	lsrs	r3, r0, #1
     18a:	f003 3355 	and.w	r3, r3, #1431655765	; 0x55555555
     18e:	1ac0      	subs	r0, r0, r3
     190:	f000 3333 	and.w	r3, r0, #858993459	; 0x33333333
     194:	0880      	lsrs	r0, r0, #2
     196:	f000 3033 	and.w	r0, r0, #858993459	; 0x33333333
     19a:	4418      	add	r0, r3
     19c:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
     1a0:	eb00 1010 	add.w	r0, r0, r0, lsr #4
     1a4:	f000 300f 	and.w	r0, r0, #252645135	; 0xf0f0f0f
     1a8:	4358      	muls	r0, r3
     1aa:	0e00      	lsrs	r0, r0, #24
     1ac:	4770      	bx	lr

000001ae <__udivmoddi4>:
     1ae:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     1b2:	4686      	mov	lr, r0
     1b4:	468c      	mov	ip, r1
     1b6:	4608      	mov	r0, r1
     1b8:	9e08      	ldr	r6, [sp, #32]
     1ba:	4615      	mov	r5, r2
     1bc:	4674      	mov	r4, lr
     1be:	4619      	mov	r1, r3
     1c0:	2b00      	cmp	r3, #0
     1c2:	f040 80c1 	bne.w	348 <__data_size+0x94>
     1c6:	4285      	cmp	r5, r0
     1c8:	fab2 f282 	clz	r2, r2
     1cc:	d945      	bls.n	25a <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x5a>
     1ce:	b14a      	cbz	r2, 1e4 <__udivmoddi4+0x36>
     1d0:	f1c2 0320 	rsb	r3, r2, #32
     1d4:	fa00 fc02 	lsl.w	ip, r0, r2
     1d8:	4095      	lsls	r5, r2
     1da:	4094      	lsls	r4, r2
     1dc:	fa2e f303 	lsr.w	r3, lr, r3
     1e0:	ea43 0c0c 	orr.w	ip, r3, ip
     1e4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     1e8:	b2a8      	uxth	r0, r5
     1ea:	0c23      	lsrs	r3, r4, #16
     1ec:	fbbc f8fe 	udiv	r8, ip, lr
     1f0:	fb0e cc18 	mls	ip, lr, r8, ip
     1f4:	fb08 f900 	mul.w	r9, r8, r0
     1f8:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
     1fc:	4599      	cmp	r9, r3
     1fe:	d928      	bls.n	252 <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x52>
     200:	18eb      	adds	r3, r5, r3
     202:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
     206:	d204      	bcs.n	212 <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x12>
     208:	4599      	cmp	r9, r3
     20a:	d902      	bls.n	212 <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x12>
     20c:	f1a8 0702 	sub.w	r7, r8, #2
     210:	442b      	add	r3, r5
     212:	eba3 0309 	sub.w	r3, r3, r9
     216:	b2a4      	uxth	r4, r4
				parsing = false;
     218:	fbb3 fcfe 	udiv	ip, r3, lr
				align = VA_STACK_ALIGN(size_t);
     21c:	fb0e 331c 	mls	r3, lr, ip, r3
				size = sizeof(size_t);
     220:	fb0c f000 	mul.w	r0, ip, r0
				align = VA_STACK_ALIGN(ptrdiff_t);
     224:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
				size = sizeof(ptrdiff_t);
     228:	42a0      	cmp	r0, r4
				continue;
     22a:	d914      	bls.n	256 <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x56>
				if (fmt[-1] == 'l') {
     22c:	192c      	adds	r4, r5, r4
     22e:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
				parsing = false;
     232:	d204      	bcs.n	23e <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x3e>
		buf = (void *) ROUND_UP(buf, align);
     234:	42a0      	cmp	r0, r4
     236:	d902      	bls.n	23e <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x3e>
     238:	f1ac 0302 	sub.w	r3, ip, #2
     23c:	442c      	add	r4, r5
     23e:	1a24      	subs	r4, r4, r0
		if (buf0 != NULL && BUF_OFFSET + size > len) {
     240:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
     244:	b11e      	cbz	r6, 24e <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x4e>
     246:	40d4      	lsrs	r4, r2
     248:	2300      	movs	r3, #0
     24a:	6034      	str	r4, [r6, #0]
		if (is_str_arg) {
     24c:	6073      	str	r3, [r6, #4]
     24e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			}
			buf += sizeof(char *);

			is_str_arg = false;
		} else if (size == sizeof(int)) {
     252:	4647      	mov	r7, r8
     254:	e7dd      	b.n	212 <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x12>
     256:	4663      	mov	r3, ip

			if (buf0 != NULL) {
				*(long *)buf = v;
			}
			buf += sizeof(long);
		} else if (size == sizeof(long long)) {
     258:	e7f1      	b.n	23e <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x3e>
     25a:	bb92      	cbnz	r2, 2c2 <__data_size+0xe>
     25c:	1b43      	subs	r3, r0, r5
     25e:	2101      	movs	r1, #1
			long long v = va_arg(ap, long long);
     260:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     264:	b2af      	uxth	r7, r5
     266:	0c20      	lsrs	r0, r4, #16
     268:	fbb3 fcfe 	udiv	ip, r3, lr
     26c:	fb0e 331c 	mls	r3, lr, ip, r3
     270:	fb0c f807 	mul.w	r8, ip, r7

			if (buf0 != NULL) {
				if (Z_CBPRINTF_VA_STACK_LL_DBL_MEMCPY) {
					memcpy(buf, &v, sizeof(long long));
				} else {
					*(long long *)buf = v;
     274:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
				}
			}
			buf += sizeof(long long);
     278:	4598      	cmp	r8, r3
     27a:	d961      	bls.n	340 <__data_size+0x8c>
					if (fmt[-2] == 'l') {
     27c:	18eb      	adds	r3, r5, r3
     27e:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
     282:	d204      	bcs.n	28e <CONFIG_PM_PARTITION_SIZE_PROVISION+0xe>
				parsing = false;
     284:	4598      	cmp	r8, r3
						align = VA_STACK_ALIGN(long);
     286:	d902      	bls.n	28e <CONFIG_PM_PARTITION_SIZE_PROVISION+0xe>
     288:	f1ac 0002 	sub.w	r0, ip, #2
						size = sizeof(long);
     28c:	442b      	add	r3, r5
				parsing = false;
     28e:	eba3 0308 	sub.w	r3, r3, r8
						align = VA_STACK_ALIGN(long long);
     292:	b2a4      	uxth	r4, r4
						size = sizeof(long long);
     294:	fbb3 fcfe 	udiv	ip, r3, lr
				if (fmt[-1] == 'L') {
     298:	fb0e 331c 	mls	r3, lr, ip, r3
     29c:	fb0c f707 	mul.w	r7, ip, r7
					v.d = va_arg(ap, double);
     2a0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     2a4:	42a7      	cmp	r7, r4
     2a6:	d94d      	bls.n	344 <__data_size+0x90>
     2a8:	192c      	adds	r4, r5, r4
     2aa:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
     2ae:	d204      	bcs.n	2ba <__data_size+0x6>
				buf = (void *) ROUND_UP(buf, align);
     2b0:	42a7      	cmp	r7, r4
     2b2:	d902      	bls.n	2ba <__data_size+0x6>
     2b4:	f1ac 0302 	sub.w	r3, ip, #2
					if (BUF_OFFSET + size > len) {
     2b8:	442c      	add	r4, r5
     2ba:	1be4      	subs	r4, r4, r7
     2bc:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
					} else if (fmt[-1] == 'L') {
     2c0:	e7c0      	b.n	244 <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x44>
     2c2:	f1c2 0320 	rsb	r3, r2, #32
						*(double *)buf = v.d;
     2c6:	4095      	lsls	r5, r2
     2c8:	4094      	lsls	r4, r2
				buf += size;
     2ca:	fa20 f103 	lsr.w	r1, r0, r3
				continue;
     2ce:	fa2e f303 	lsr.w	r3, lr, r3
     2d2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
					v.ld = va_arg(ap, long double);
     2d6:	4090      	lsls	r0, r2
     2d8:	b2af      	uxth	r7, r5
     2da:	4303      	orrs	r3, r0
     2dc:	fbb1 fcfe 	udiv	ip, r1, lr
     2e0:	fb0e 101c 	mls	r0, lr, ip, r1
     2e4:	0c19      	lsrs	r1, r3, #16
     2e6:	fb0c f807 	mul.w	r8, ip, r7
						return -ENOSPC;
     2ea:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
     2ee:	4588      	cmp	r8, r1
						*(long double *)buf = v.ld;
     2f0:	d922      	bls.n	338 <__data_size+0x84>
     2f2:	1869      	adds	r1, r5, r1
     2f4:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
				align = VA_STACK_ALIGN(void *);
     2f8:	d204      	bcs.n	304 <__data_size+0x50>
     2fa:	4588      	cmp	r8, r1
				size = sizeof(void *);
     2fc:	d902      	bls.n	304 <__data_size+0x50>
     2fe:	f1ac 0002 	sub.w	r0, ip, #2
				parsing = false;
     302:	4429      	add	r1, r5
				align = VA_STACK_ALIGN(void *);
     304:	eba1 0108 	sub.w	r1, r1, r8
				size = sizeof(void *);
     308:	b29b      	uxth	r3, r3
     30a:	fbb1 fcfe 	udiv	ip, r1, lr
			s = va_arg(ap, char *);
     30e:	fb0e 111c 	mls	r1, lr, ip, r1
     312:	fb0c f707 	mul.w	r7, ip, r7
     316:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
			if (*++fmt == '\0') {
     31a:	429f      	cmp	r7, r3
     31c:	d90e      	bls.n	33c <__data_size+0x88>
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
     31e:	18eb      	adds	r3, r5, r3
     320:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
     324:	d204      	bcs.n	330 <__data_size+0x7c>
     326:	429f      	cmp	r7, r3
     328:	d902      	bls.n	330 <__data_size+0x7c>
     32a:	f1ac 0102 	sub.w	r1, ip, #2
     32e:	442b      	add	r3, r5
     330:	1bdb      	subs	r3, r3, r7
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
     332:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
     336:	e793      	b.n	260 <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x60>
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
     338:	4660      	mov	r0, ip
     33a:	e7e3      	b.n	304 <__data_size+0x50>
     33c:	4661      	mov	r1, ip
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
     33e:	e7f7      	b.n	330 <__data_size+0x7c>
     340:	4660      	mov	r0, ip
     342:	e7a4      	b.n	28e <CONFIG_PM_PARTITION_SIZE_PROVISION+0xe>
     344:	4663      	mov	r3, ip
						s_rw_cnt++;
     346:	e7b8      	b.n	2ba <__data_size+0x6>
     348:	4283      	cmp	r3, r0
     34a:	d906      	bls.n	35a <__data_size+0xa6>
     34c:	b916      	cbnz	r6, 354 <__data_size+0xa0>
				} else if (is_ro) {
     34e:	2100      	movs	r1, #0
					len += 1;
     350:	4608      	mov	r0, r1
     352:	e77c      	b.n	24e <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x4e>
     354:	e9c6 e000 	strd	lr, r0, [r6]
				} else if (rws_pos_en) {
     358:	e7f9      	b.n	34e <__data_size+0x9a>
					len += 2;
     35a:	fab3 f783 	clz	r7, r3
     35e:	b98f      	cbnz	r7, 384 <__data_size+0xd0>
					len += strlen(s) + 1 + 1;
     360:	4283      	cmp	r3, r0
     362:	d301      	bcc.n	368 <__data_size+0xb4>
     364:	4572      	cmp	r2, lr
     366:	d808      	bhi.n	37a <__data_size+0xc6>
     368:	ebbe 0402 	subs.w	r4, lr, r2
			int v = va_arg(ap, int);
     36c:	eb60 0303 	sbc.w	r3, r0, r3
     370:	2001      	movs	r0, #1
     372:	469c      	mov	ip, r3
			if (buf0 != NULL) {
     374:	b91e      	cbnz	r6, 37e <__data_size+0xca>
				*(int *)buf = v;
     376:	2100      	movs	r1, #0
			buf += sizeof(int);
     378:	e769      	b.n	24e <CONFIG_FS_LITTLEFS_BLOCK_CYCLES+0x4e>
     37a:	4638      	mov	r0, r7
	 * We remember the size of the argument list as a multiple of
	 * sizeof(int) and limit it to a 8-bit field. That means 1020 bytes
	 * worth of va_list, or about 127 arguments on a 64-bit system
	 * (twice that on 32-bit systems). That ought to be good enough.
	 */
	if (BUF_OFFSET / sizeof(int) > 255) {
     37c:	e7fa      	b.n	374 <__data_size+0xc0>
     37e:	e9c6 4c00 	strd	r4, ip, [r6]
     382:	e7f8      	b.n	376 <__data_size+0xc2>
     384:	f1c7 0c20 	rsb	ip, r7, #32
	if (buf0 == NULL) {
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
	}

	/* Clear our buffer header. We made room for it initially. */
	*(char **)buf0 = NULL;
     388:	40bb      	lsls	r3, r7
     38a:	fa0e f507 	lsl.w	r5, lr, r7

	/* Record end of argument list. */
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
     38e:	fa22 f40c 	lsr.w	r4, r2, ip

	if (rws_pos_en) {
     392:	fa2e f10c 	lsr.w	r1, lr, ip
		/* Strings are appended, update location counter. */
		pkg_hdr->desc.str_cnt = 0;
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
     396:	40ba      	lsls	r2, r7
		/* Strings are appended, update append counter. */
		pkg_hdr->desc.str_cnt = s_rw_cnt;
		pkg_hdr->desc.rw_str_cnt = 0;
	}

	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
     398:	431c      	orrs	r4, r3
     39a:	fa20 f30c 	lsr.w	r3, r0, ip
			/* retrieve the string pointer */
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
			/* clear the in-buffer pointer (less entropy if compressed) */
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
			/* find the string length including terminating '\0' */
			size = strlen(s) + 1;
     39e:	40b8      	lsls	r0, r7
     3a0:	ea4f 4914 	mov.w	r9, r4, lsr #16
     3a4:	4301      	orrs	r1, r0
     3a6:	fa1f fe84 	uxth.w	lr, r4
     3aa:	fbb3 f8f9 	udiv	r8, r3, r9
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
     3ae:	fb09 3018 	mls	r0, r9, r8, r3
     3b2:	0c0b      	lsrs	r3, r1, #16
     3b4:	fb08 fa0e 	mul.w	sl, r8, lr
		pkg_hdr->desc.str_cnt = s_rw_cnt;
     3b8:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
		for (i = 0; i < s_idx; i++) {
     3bc:	459a      	cmp	sl, r3
     3be:	d940      	bls.n	442 <CONFIG_FLASH_SIZE+0x42>
     3c0:	18e3      	adds	r3, r4, r3
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
     3c2:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
     3c6:	d204      	bcs.n	3d2 <__data_size+0x11e>
     3c8:	459a      	cmp	sl, r3
     3ca:	d902      	bls.n	3d2 <__data_size+0x11e>
     3cc:	f1a8 0002 	sub.w	r0, r8, #2
     3d0:	4423      	add	r3, r4
     3d2:	eba3 030a 	sub.w	r3, r3, sl
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
     3d6:	b289      	uxth	r1, r1
			if (BUF_OFFSET + 1 > len) {
     3d8:	fbb3 f8f9 	udiv	r8, r3, r9
     3dc:	fb09 3318 	mls	r3, r9, r8, r3
			*buf++ = pos;
     3e0:	fb08 fe0e 	mul.w	lr, r8, lr
     3e4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
		for (i = 0; i < s_idx; i++) {
     3e8:	458e      	cmp	lr, r1
     3ea:	d92c      	bls.n	446 <CONFIG_FLASH_SIZE+0x46>
		if (rws_pos_en) {
     3ec:	1861      	adds	r1, r4, r1
     3ee:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
			*buf++ = str_ptr_arg[i];
     3f2:	d204      	bcs.n	3fe <__data_size+0x14a>
     3f4:	458e      	cmp	lr, r1
     3f6:	d902      	bls.n	3fe <__data_size+0x14a>
     3f8:	f1a8 0302 	sub.w	r3, r8, #2
     3fc:	4421      	add	r1, r4
			size = 0;
     3fe:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
		}

		/* make sure it fits */
		if (BUF_OFFSET + 1 + size > len) {
     402:	eba1 010e 	sub.w	r1, r1, lr
     406:	fba0 9802 	umull	r9, r8, r0, r2
			return -ENOSPC;
		}
		/* store the pointer position prefix */
		*buf++ = str_ptr_pos[i];
     40a:	4541      	cmp	r1, r8
     40c:	46ce      	mov	lr, r9
     40e:	4643      	mov	r3, r8
     410:	d302      	bcc.n	418 <CONFIG_FLASH_SIZE+0x18>
     412:	d106      	bne.n	422 <CONFIG_FLASH_SIZE+0x22>
     414:	454d      	cmp	r5, r9
     416:	d204      	bcs.n	422 <CONFIG_FLASH_SIZE+0x22>
		/* copy the string with its terminating '\0' */
		memcpy(buf, s, size);
     418:	3801      	subs	r0, #1
     41a:	ebb9 0e02 	subs.w	lr, r9, r2
     41e:	eb68 0304 	sbc.w	r3, r8, r4
		buf += size;
     422:	2e00      	cmp	r6, #0
	for (i = 0; i < s_idx; i++) {
     424:	d0a7      	beq.n	376 <__data_size+0xc2>
     426:	ebb5 020e 	subs.w	r2, r5, lr
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
     42a:	eb61 0103 	sbc.w	r1, r1, r3
     42e:	fa01 fc0c 	lsl.w	ip, r1, ip
     432:	fa22 f307 	lsr.w	r3, r2, r7
     436:	40f9      	lsrs	r1, r7
     438:	ea4c 0303 	orr.w	r3, ip, r3
     43c:	e9c6 3100 	strd	r3, r1, [r6]
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
     440:	e799      	b.n	376 <__data_size+0xc2>
     442:	4640      	mov	r0, r8
     444:	e7c5      	b.n	3d2 <__data_size+0x11e>
     446:	4643      	mov	r3, r8
     448:	e7d9      	b.n	3fe <__data_size+0x14a>
	...

0000044c <print_pattern>:

	p[size - 1] = 0xAA;
}

static void print_pattern(uint8_t *p, uint16_t size)
{
     44c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     450:	b087      	sub	sp, #28
     452:	4607      	mov	r7, r0
     454:	4688      	mov	r8, r1
	int i, j = size / 16, k;
     456:	ea4f 1911 	mov.w	r9, r1, lsr #4

	for (k = 0, i = 0; k < j; i += 16, k++) {
     45a:	2600      	movs	r6, #0
     45c:	4635      	mov	r5, r6
     45e:	e000      	b.n	462 <print_pattern+0x16>
     460:	3510      	adds	r5, #16
     462:	45b1      	cmp	r9, r6
     464:	dd31      	ble.n	4ca <print_pattern+0x7e>
		LOG_PRINTK("%02x %02x %02x %02x %02x %02x %02x %02x ",
     466:	197c      	adds	r4, r7, r5
     468:	78e3      	ldrb	r3, [r4, #3]
     46a:	7922      	ldrb	r2, [r4, #4]
     46c:	7961      	ldrb	r1, [r4, #5]
     46e:	79a0      	ldrb	r0, [r4, #6]
     470:	f894 c007 	ldrb.w	ip, [r4, #7]
     474:	f8cd c010 	str.w	ip, [sp, #16]
     478:	9003      	str	r0, [sp, #12]
     47a:	9102      	str	r1, [sp, #8]
     47c:	9201      	str	r2, [sp, #4]
     47e:	9300      	str	r3, [sp, #0]
     480:	78a3      	ldrb	r3, [r4, #2]
     482:	7862      	ldrb	r2, [r4, #1]
     484:	5d79      	ldrb	r1, [r7, r5]
     486:	4815      	ldr	r0, [pc, #84]	; (4dc <print_pattern+0x90>)
     488:	f009 ff58 	bl	a33c <z_log_minimal_printk>
			   p[i], p[i+1], p[i+2], p[i+3],
			   p[i+4], p[i+5], p[i+6], p[i+7]);
		LOG_PRINTK("%02x %02x %02x %02x %02x %02x %02x %02x\n",
     48c:	7ae3      	ldrb	r3, [r4, #11]
     48e:	7b22      	ldrb	r2, [r4, #12]
     490:	7b61      	ldrb	r1, [r4, #13]
     492:	7ba0      	ldrb	r0, [r4, #14]
     494:	f894 c00f 	ldrb.w	ip, [r4, #15]
     498:	f8cd c010 	str.w	ip, [sp, #16]
     49c:	9003      	str	r0, [sp, #12]
     49e:	9102      	str	r1, [sp, #8]
     4a0:	9201      	str	r2, [sp, #4]
     4a2:	9300      	str	r3, [sp, #0]
     4a4:	7aa3      	ldrb	r3, [r4, #10]
     4a6:	7a62      	ldrb	r2, [r4, #9]
     4a8:	7a21      	ldrb	r1, [r4, #8]
     4aa:	480d      	ldr	r0, [pc, #52]	; (4e0 <print_pattern+0x94>)
     4ac:	f009 ff46 	bl	a33c <z_log_minimal_printk>
			   p[i+8], p[i+9], p[i+10], p[i+11],
			   p[i+12], p[i+13], p[i+14], p[i+15]);

		/* Mark 512B (sector) chunks of the test file */
		if ((k + 1) % 32 == 0) {
     4b0:	3601      	adds	r6, #1
     4b2:	f016 0f1f 	tst.w	r6, #31
     4b6:	d1d3      	bne.n	460 <print_pattern+0x14>
			LOG_PRINTK("\n");
     4b8:	480a      	ldr	r0, [pc, #40]	; (4e4 <print_pattern+0x98>)
     4ba:	f009 ff3f 	bl	a33c <z_log_minimal_printk>
     4be:	e7cf      	b.n	460 <print_pattern+0x14>
		}
	}

	for (; i < size; i++) {
		LOG_PRINTK("%02x ", p[i]);
     4c0:	5d79      	ldrb	r1, [r7, r5]
     4c2:	4809      	ldr	r0, [pc, #36]	; (4e8 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE>)
     4c4:	f009 ff3a 	bl	a33c <z_log_minimal_printk>
	for (; i < size; i++) {
     4c8:	3501      	adds	r5, #1
     4ca:	45a8      	cmp	r8, r5
     4cc:	dcf8      	bgt.n	4c0 <print_pattern+0x74>
	}

	LOG_PRINTK("\n");
     4ce:	4805      	ldr	r0, [pc, #20]	; (4e4 <print_pattern+0x98>)
     4d0:	f009 ff34 	bl	a33c <z_log_minimal_printk>
}
     4d4:	b007      	add	sp, #28
     4d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     4da:	bf00      	nop
     4dc:	0000e098 	.word	0x0000e098
     4e0:	0000e0c4 	.word	0x0000e0c4
     4e4:	0000f124 	.word	0x0000f124
     4e8:	0000e0f0 	.word	0x0000e0f0

000004ec <littlefs_flash_erase>:
	return (rc < 0 ? rc : 0);
}

#ifdef CONFIG_APP_LITTLEFS_STORAGE_FLASH
static int littlefs_flash_erase(unsigned int id)
{
     4ec:	b530      	push	{r4, r5, lr}
     4ee:	b085      	sub	sp, #20
     4f0:	4605      	mov	r5, r0
	const struct flash_area *pfa;
	int rc;

	rc = flash_area_open(id, &pfa);
     4f2:	a903      	add	r1, sp, #12
     4f4:	b2c0      	uxtb	r0, r0
     4f6:	f000 ffa1 	bl	143c <flash_area_open>
	if (rc < 0) {
     4fa:	1e04      	subs	r4, r0, #0
     4fc:	db0f      	blt.n	51e <littlefs_flash_erase+0x32>
		LOG_ERR("FAIL: unable to find flash area %u: %d\n",
			id, rc);
		return rc;
	}

	LOG_PRINTK("Area %u at 0x%x on %s for %u bytes\n",
     4fe:	9903      	ldr	r1, [sp, #12]
     500:	684a      	ldr	r2, [r1, #4]
     502:	68cb      	ldr	r3, [r1, #12]
     504:	681b      	ldr	r3, [r3, #0]
     506:	6889      	ldr	r1, [r1, #8]
     508:	9100      	str	r1, [sp, #0]
     50a:	4629      	mov	r1, r5
     50c:	4807      	ldr	r0, [pc, #28]	; (52c <littlefs_flash_erase+0x40>)
     50e:	f009 ff15 	bl	a33c <z_log_minimal_printk>
	if (IS_ENABLED(CONFIG_APP_WIPE_STORAGE)) {
		rc = flash_area_erase(pfa, 0, pfa->fa_size);
		LOG_ERR("Erasing flash area ... %d", rc);
	}

	flash_area_close(pfa);
     512:	9803      	ldr	r0, [sp, #12]
     514:	f009 ff49 	bl	a3aa <flash_area_close>
	return rc;
}
     518:	4620      	mov	r0, r4
     51a:	b005      	add	sp, #20
     51c:	bd30      	pop	{r4, r5, pc}
		LOG_ERR("FAIL: unable to find flash area %u: %d\n",
     51e:	4623      	mov	r3, r4
     520:	462a      	mov	r2, r5
     522:	2145      	movs	r1, #69	; 0x45
     524:	4802      	ldr	r0, [pc, #8]	; (530 <littlefs_flash_erase+0x44>)
     526:	f009 ff09 	bl	a33c <z_log_minimal_printk>
		return rc;
     52a:	e7f5      	b.n	518 <littlefs_flash_erase+0x2c>
     52c:	0000e128 	.word	0x0000e128
     530:	0000e0f8 	.word	0x0000e0f8

00000534 <littlefs_mount>:
		&lfs_storage_mnt
#endif
		;

static int littlefs_mount(struct fs_mount_t *mp)
{
     534:	b538      	push	{r3, r4, r5, lr}
     536:	4605      	mov	r5, r0
	int rc;

	rc = littlefs_flash_erase((uintptr_t)mp->storage_dev);
     538:	6940      	ldr	r0, [r0, #20]
     53a:	f7ff ffd7 	bl	4ec <littlefs_flash_erase>
	if (rc < 0) {
     53e:	1e04      	subs	r4, r0, #0
     540:	db0a      	blt.n	558 <littlefs_mount+0x24>
	}

	/* Do not mount if auto-mount has been enabled */
#if !DT_NODE_EXISTS(PARTITION_NODE) ||						\
	!(FSTAB_ENTRY_DT_MOUNT_FLAGS(PARTITION_NODE) & FS_MOUNT_FLAG_AUTOMOUNT)
	rc = fs_mount(mp);
     542:	4628      	mov	r0, r5
     544:	f002 f9e4 	bl	2910 <fs_mount>
	if (rc < 0) {
     548:	1e04      	subs	r4, r0, #0
     54a:	db07      	blt.n	55c <littlefs_mount+0x28>
		LOG_PRINTK("FAIL: mount id %" PRIuPTR " at %s: %d\n",
		       (uintptr_t)mp->storage_dev, mp->mnt_point, rc);
		return rc;
	}
	LOG_PRINTK("%s mount: %d\n", mp->mnt_point, rc);
     54c:	4622      	mov	r2, r4
     54e:	68e9      	ldr	r1, [r5, #12]
     550:	4806      	ldr	r0, [pc, #24]	; (56c <littlefs_mount+0x38>)
     552:	f009 fef3 	bl	a33c <z_log_minimal_printk>
#else
	LOG_PRINTK("%s automounted\n", mp->mnt_point);
#endif

	return 0;
     556:	2400      	movs	r4, #0
}
     558:	4620      	mov	r0, r4
     55a:	bd38      	pop	{r3, r4, r5, pc}
		LOG_PRINTK("FAIL: mount id %" PRIuPTR " at %s: %d\n",
     55c:	4623      	mov	r3, r4
     55e:	68ea      	ldr	r2, [r5, #12]
     560:	6969      	ldr	r1, [r5, #20]
     562:	4803      	ldr	r0, [pc, #12]	; (570 <littlefs_mount+0x3c>)
     564:	f009 feea 	bl	a33c <z_log_minimal_printk>
		return rc;
     568:	e7f6      	b.n	558 <littlefs_mount+0x24>
     56a:	bf00      	nop
     56c:	0000e16c 	.word	0x0000e16c
     570:	0000e14c 	.word	0x0000e14c

00000574 <lsdir>:
{
     574:	b530      	push	{r4, r5, lr}
     576:	b083      	sub	sp, #12
     578:	4605      	mov	r5, r0
 * @param zdp Pointer to file object
 *
 */
static inline void fs_dir_t_init(struct fs_dir_t *zdp)
{
	*zdp = (struct fs_dir_t){ 0 };
     57a:	2300      	movs	r3, #0
     57c:	9300      	str	r3, [sp, #0]
     57e:	9301      	str	r3, [sp, #4]
	res = fs_opendir(&dirp, path);
     580:	4601      	mov	r1, r0
     582:	4668      	mov	r0, sp
     584:	f002 f844 	bl	2610 <fs_opendir>
	if (res) {
     588:	b920      	cbnz	r0, 594 <lsdir+0x20>
	LOG_PRINTK("\nListing dir %s ...\n", path);
     58a:	4629      	mov	r1, r5
     58c:	481a      	ldr	r0, [pc, #104]	; (5f8 <lsdir+0x84>)
     58e:	f009 fed5 	bl	a33c <z_log_minimal_printk>
     592:	e019      	b.n	5c8 <lsdir+0x54>
     594:	4604      	mov	r4, r0
		LOG_ERR("Error opening dir %s [%d]\n", path, res);
     596:	4603      	mov	r3, r0
     598:	462a      	mov	r2, r5
     59a:	2145      	movs	r1, #69	; 0x45
     59c:	4817      	ldr	r0, [pc, #92]	; (5fc <lsdir+0x88>)
     59e:	f009 fecd 	bl	a33c <z_log_minimal_printk>
		return res;
     5a2:	e004      	b.n	5ae <lsdir+0x3a>
			if (res < 0) {
     5a4:	2c00      	cmp	r4, #0
     5a6:	db05      	blt.n	5b4 <lsdir+0x40>
	fs_closedir(&dirp);
     5a8:	4668      	mov	r0, sp
     5aa:	f002 f91b 	bl	27e4 <fs_closedir>
}
     5ae:	4620      	mov	r0, r4
     5b0:	b003      	add	sp, #12
     5b2:	bd30      	pop	{r4, r5, pc}
				LOG_ERR("Error reading dir [%d]\n", res);
     5b4:	4622      	mov	r2, r4
     5b6:	2145      	movs	r1, #69	; 0x45
     5b8:	4811      	ldr	r0, [pc, #68]	; (600 <lsdir+0x8c>)
     5ba:	f009 febf 	bl	a33c <z_log_minimal_printk>
     5be:	e7f3      	b.n	5a8 <lsdir+0x34>
			LOG_PRINTK("[DIR ] %s\n", entry.name);
     5c0:	4910      	ldr	r1, [pc, #64]	; (604 <lsdir+0x90>)
     5c2:	4811      	ldr	r0, [pc, #68]	; (608 <lsdir+0x94>)
     5c4:	f009 feba 	bl	a33c <z_log_minimal_printk>
		res = fs_readdir(&dirp, &entry);
     5c8:	4910      	ldr	r1, [pc, #64]	; (60c <lsdir+0x98>)
     5ca:	4668      	mov	r0, sp
     5cc:	f002 f88e 	bl	26ec <fs_readdir>
		if (res || entry.name[0] == 0) {
     5d0:	4604      	mov	r4, r0
     5d2:	2800      	cmp	r0, #0
     5d4:	d1e6      	bne.n	5a4 <lsdir+0x30>
     5d6:	4b0d      	ldr	r3, [pc, #52]	; (60c <lsdir+0x98>)
     5d8:	785b      	ldrb	r3, [r3, #1]
     5da:	2b00      	cmp	r3, #0
     5dc:	d0e2      	beq.n	5a4 <lsdir+0x30>
		if (entry.type == FS_DIR_ENTRY_DIR) {
     5de:	4b0b      	ldr	r3, [pc, #44]	; (60c <lsdir+0x98>)
     5e0:	781b      	ldrb	r3, [r3, #0]
     5e2:	2b01      	cmp	r3, #1
     5e4:	d0ec      	beq.n	5c0 <lsdir+0x4c>
			LOG_PRINTK("[FILE] %s (size = %zu)\n",
     5e6:	4909      	ldr	r1, [pc, #36]	; (60c <lsdir+0x98>)
     5e8:	f8d1 2104 	ldr.w	r2, [r1, #260]	; 0x104
     5ec:	3101      	adds	r1, #1
     5ee:	4808      	ldr	r0, [pc, #32]	; (610 <lsdir+0x9c>)
     5f0:	f009 fea4 	bl	a33c <z_log_minimal_printk>
     5f4:	e7e8      	b.n	5c8 <lsdir+0x54>
     5f6:	bf00      	nop
     5f8:	0000e19c 	.word	0x0000e19c
     5fc:	0000e17c 	.word	0x0000e17c
     600:	0000e1b4 	.word	0x0000e1b4
     604:	200004a1 	.word	0x200004a1
     608:	0000e1d4 	.word	0x0000e1d4
     60c:	200004a0 	.word	0x200004a0
     610:	0000e1e0 	.word	0x0000e1e0

00000614 <littlefs_increase_infile_value>:
{
     614:	b570      	push	{r4, r5, r6, lr}
     616:	b084      	sub	sp, #16
     618:	4606      	mov	r6, r0
	uint8_t boot_count = 0;
     61a:	2300      	movs	r3, #0
     61c:	f88d 300f 	strb.w	r3, [sp, #15]
	*zfp = (struct fs_file_t){ 0 };
     620:	9300      	str	r3, [sp, #0]
     622:	9301      	str	r3, [sp, #4]
     624:	9302      	str	r3, [sp, #8]
	rc = fs_open(&file, fname, FS_O_CREATE | FS_O_RDWR);
     626:	2213      	movs	r2, #19
     628:	4601      	mov	r1, r0
     62a:	4668      	mov	r0, sp
     62c:	f001 ff32 	bl	2494 <fs_open>
	if (rc < 0) {
     630:	1e04      	subs	r4, r0, #0
     632:	db33      	blt.n	69c <littlefs_increase_infile_value+0x88>
	rc = fs_read(&file, &boot_count, sizeof(boot_count));
     634:	2201      	movs	r2, #1
     636:	f10d 010f 	add.w	r1, sp, #15
     63a:	4668      	mov	r0, sp
     63c:	f001 ff9a 	bl	2574 <fs_read>
	if (rc < 0) {
     640:	1e05      	subs	r5, r0, #0
     642:	db32      	blt.n	6aa <littlefs_increase_infile_value+0x96>
	LOG_PRINTK("%s read count:%u (bytes: %d)\n", fname, boot_count, rc);
     644:	462b      	mov	r3, r5
     646:	f89d 200f 	ldrb.w	r2, [sp, #15]
     64a:	4631      	mov	r1, r6
     64c:	4825      	ldr	r0, [pc, #148]	; (6e4 <littlefs_increase_infile_value+0xd0>)
     64e:	f009 fe75 	bl	a33c <z_log_minimal_printk>
	rc = fs_seek(&file, 0, FS_SEEK_SET);
     652:	2200      	movs	r2, #0
     654:	4611      	mov	r1, r2
     656:	4668      	mov	r0, sp
     658:	f001 ffc0 	bl	25dc <fs_seek>
	if (rc < 0) {
     65c:	1e05      	subs	r5, r0, #0
     65e:	db2b      	blt.n	6b8 <littlefs_increase_infile_value+0xa4>
	boot_count += 1;
     660:	f89d 300f 	ldrb.w	r3, [sp, #15]
     664:	3301      	adds	r3, #1
     666:	f88d 300f 	strb.w	r3, [sp, #15]
	rc = fs_write(&file, &boot_count, sizeof(boot_count));
     66a:	2201      	movs	r2, #1
     66c:	f10d 010f 	add.w	r1, sp, #15
     670:	4668      	mov	r0, sp
     672:	f001 ff99 	bl	25a8 <fs_write>
	if (rc < 0) {
     676:	1e05      	subs	r5, r0, #0
     678:	db25      	blt.n	6c6 <littlefs_increase_infile_value+0xb2>
	LOG_PRINTK("%s write new boot count %u: [wr:%d]\n", fname,
     67a:	462b      	mov	r3, r5
     67c:	f89d 200f 	ldrb.w	r2, [sp, #15]
     680:	4631      	mov	r1, r6
     682:	4819      	ldr	r0, [pc, #100]	; (6e8 <littlefs_increase_infile_value+0xd4>)
     684:	f009 fe5a 	bl	a33c <z_log_minimal_printk>
	ret = fs_close(&file);
     688:	4668      	mov	r0, sp
     68a:	f001 ff57 	bl	253c <fs_close>
	if (ret < 0) {
     68e:	1e04      	subs	r4, r0, #0
     690:	db20      	blt.n	6d4 <littlefs_increase_infile_value+0xc0>
	return (rc < 0 ? rc : 0);
     692:	ea05 74e5 	and.w	r4, r5, r5, asr #31
}
     696:	4620      	mov	r0, r4
     698:	b004      	add	sp, #16
     69a:	bd70      	pop	{r4, r5, r6, pc}
		LOG_ERR("FAIL: open %s: %d", fname, rc);
     69c:	4623      	mov	r3, r4
     69e:	4632      	mov	r2, r6
     6a0:	2145      	movs	r1, #69	; 0x45
     6a2:	4812      	ldr	r0, [pc, #72]	; (6ec <littlefs_increase_infile_value+0xd8>)
     6a4:	f009 fe4a 	bl	a33c <z_log_minimal_printk>
		return rc;
     6a8:	e7f5      	b.n	696 <littlefs_increase_infile_value+0x82>
		LOG_ERR("FAIL: read %s: [rd:%d]", fname, rc);
     6aa:	462b      	mov	r3, r5
     6ac:	4632      	mov	r2, r6
     6ae:	2145      	movs	r1, #69	; 0x45
     6b0:	480f      	ldr	r0, [pc, #60]	; (6f0 <littlefs_increase_infile_value+0xdc>)
     6b2:	f009 fe43 	bl	a33c <z_log_minimal_printk>
		goto out;
     6b6:	e7e7      	b.n	688 <littlefs_increase_infile_value+0x74>
		LOG_ERR("FAIL: seek %s: %d", fname, rc);
     6b8:	462b      	mov	r3, r5
     6ba:	4632      	mov	r2, r6
     6bc:	2145      	movs	r1, #69	; 0x45
     6be:	480d      	ldr	r0, [pc, #52]	; (6f4 <littlefs_increase_infile_value+0xe0>)
     6c0:	f009 fe3c 	bl	a33c <z_log_minimal_printk>
		goto out;
     6c4:	e7e0      	b.n	688 <littlefs_increase_infile_value+0x74>
		LOG_ERR("FAIL: write %s: %d", fname, rc);
     6c6:	462b      	mov	r3, r5
     6c8:	4632      	mov	r2, r6
     6ca:	2145      	movs	r1, #69	; 0x45
     6cc:	480a      	ldr	r0, [pc, #40]	; (6f8 <littlefs_increase_infile_value+0xe4>)
     6ce:	f009 fe35 	bl	a33c <z_log_minimal_printk>
		goto out;
     6d2:	e7d9      	b.n	688 <littlefs_increase_infile_value+0x74>
		LOG_ERR("FAIL: close %s: %d", fname, ret);
     6d4:	4623      	mov	r3, r4
     6d6:	4632      	mov	r2, r6
     6d8:	2145      	movs	r1, #69	; 0x45
     6da:	4808      	ldr	r0, [pc, #32]	; (6fc <littlefs_increase_infile_value+0xe8>)
     6dc:	f009 fe2e 	bl	a33c <z_log_minimal_printk>
		return ret;
     6e0:	e7d9      	b.n	696 <littlefs_increase_infile_value+0x82>
     6e2:	bf00      	nop
     6e4:	0000e22c 	.word	0x0000e22c
     6e8:	0000e27c 	.word	0x0000e27c
     6ec:	0000e1f8 	.word	0x0000e1f8
     6f0:	0000e210 	.word	0x0000e210
     6f4:	0000e24c 	.word	0x0000e24c
     6f8:	0000e264 	.word	0x0000e264
     6fc:	0000e2a4 	.word	0x0000e2a4

00000700 <littlefs_binary_file_adj>:
{
     700:	b570      	push	{r4, r5, r6, lr}
     702:	b0c6      	sub	sp, #280	; 0x118
     704:	4606      	mov	r6, r0
     706:	2300      	movs	r3, #0
     708:	9301      	str	r3, [sp, #4]
     70a:	9302      	str	r3, [sp, #8]
     70c:	9303      	str	r3, [sp, #12]
	rc = fs_open(&file, fname, FS_O_CREATE | FS_O_RDWR);
     70e:	2213      	movs	r2, #19
     710:	4601      	mov	r1, r0
     712:	a801      	add	r0, sp, #4
     714:	f001 febe 	bl	2494 <fs_open>
	if (rc < 0) {
     718:	1e05      	subs	r5, r0, #0
     71a:	db3c      	blt.n	796 <littlefs_binary_file_adj+0x96>
	rc = fs_stat(fname, &dirent);
     71c:	a904      	add	r1, sp, #16
     71e:	4630      	mov	r0, r6
     720:	f002 f87e 	bl	2820 <fs_stat>
	if (rc < 0) {
     724:	1e04      	subs	r4, r0, #0
     726:	db3d      	blt.n	7a4 <littlefs_binary_file_adj+0xa4>
	if (rc == 0 && dirent.type == FS_DIR_ENTRY_FILE && dirent.size == 0) {
     728:	b92c      	cbnz	r4, 736 <littlefs_binary_file_adj+0x36>
     72a:	f89d 3010 	ldrb.w	r3, [sp, #16]
     72e:	b913      	cbnz	r3, 736 <littlefs_binary_file_adj+0x36>
     730:	9b45      	ldr	r3, [sp, #276]	; 0x114
     732:	2b00      	cmp	r3, #0
     734:	d03d      	beq.n	7b2 <littlefs_binary_file_adj+0xb2>
		rc = fs_read(&file, file_test_pattern,
     736:	f240 2223 	movw	r2, #547	; 0x223
     73a:	4931      	ldr	r1, [pc, #196]	; (800 <CONFIG_ISR_STACK_SIZE>)
     73c:	a801      	add	r0, sp, #4
     73e:	f001 ff19 	bl	2574 <fs_read>
		if (rc < 0) {
     742:	1e04      	subs	r4, r0, #0
     744:	db40      	blt.n	7c8 <littlefs_binary_file_adj+0xc8>
		incr_pattern(file_test_pattern, sizeof(file_test_pattern), 0x1);
     746:	2201      	movs	r2, #1
     748:	f240 2123 	movw	r1, #547	; 0x223
     74c:	482c      	ldr	r0, [pc, #176]	; (800 <CONFIG_ISR_STACK_SIZE>)
     74e:	f008 fe3d 	bl	93cc <incr_pattern>
	LOG_PRINTK("------ FILE: %s ------\n", fname);
     752:	4631      	mov	r1, r6
     754:	482b      	ldr	r0, [pc, #172]	; (804 <CONFIG_ISR_STACK_SIZE+0x4>)
     756:	f009 fdf1 	bl	a33c <z_log_minimal_printk>
	print_pattern(file_test_pattern, sizeof(file_test_pattern));
     75a:	f240 2123 	movw	r1, #547	; 0x223
     75e:	4828      	ldr	r0, [pc, #160]	; (800 <CONFIG_ISR_STACK_SIZE>)
     760:	f7ff fe74 	bl	44c <print_pattern>
	rc = fs_seek(&file, 0, FS_SEEK_SET);
     764:	2200      	movs	r2, #0
     766:	4611      	mov	r1, r2
     768:	a801      	add	r0, sp, #4
     76a:	f001 ff37 	bl	25dc <fs_seek>
	if (rc < 0) {
     76e:	1e04      	subs	r4, r0, #0
     770:	db31      	blt.n	7d6 <littlefs_binary_file_adj+0xd6>
	rc = fs_write(&file, file_test_pattern, sizeof(file_test_pattern));
     772:	f240 2223 	movw	r2, #547	; 0x223
     776:	4922      	ldr	r1, [pc, #136]	; (800 <CONFIG_ISR_STACK_SIZE>)
     778:	a801      	add	r0, sp, #4
     77a:	f001 ff15 	bl	25a8 <fs_write>
	if (rc < 0) {
     77e:	1e04      	subs	r4, r0, #0
     780:	db30      	blt.n	7e4 <littlefs_binary_file_adj+0xe4>
	ret = fs_close(&file);
     782:	a801      	add	r0, sp, #4
     784:	f001 feda 	bl	253c <fs_close>
	if (ret < 0) {
     788:	1e05      	subs	r5, r0, #0
     78a:	db32      	blt.n	7f2 <littlefs_binary_file_adj+0xf2>
	return (rc < 0 ? rc : 0);
     78c:	ea04 75e4 	and.w	r5, r4, r4, asr #31
}
     790:	4628      	mov	r0, r5
     792:	b046      	add	sp, #280	; 0x118
     794:	bd70      	pop	{r4, r5, r6, pc}
		LOG_ERR("FAIL: open %s: %d", fname, rc);
     796:	462b      	mov	r3, r5
     798:	4632      	mov	r2, r6
     79a:	2145      	movs	r1, #69	; 0x45
     79c:	481a      	ldr	r0, [pc, #104]	; (808 <CONFIG_ISR_STACK_SIZE+0x8>)
     79e:	f009 fdcd 	bl	a33c <z_log_minimal_printk>
		return rc;
     7a2:	e7f5      	b.n	790 <littlefs_binary_file_adj+0x90>
		LOG_ERR("FAIL: stat %s: %d", fname, rc);
     7a4:	4623      	mov	r3, r4
     7a6:	4632      	mov	r2, r6
     7a8:	2145      	movs	r1, #69	; 0x45
     7aa:	4818      	ldr	r0, [pc, #96]	; (80c <CONFIG_ISR_STACK_SIZE+0xc>)
     7ac:	f009 fdc6 	bl	a33c <z_log_minimal_printk>
		goto out;
     7b0:	e7e7      	b.n	782 <littlefs_binary_file_adj+0x82>
		LOG_INF("Test file: %s not found, create one!",
     7b2:	4632      	mov	r2, r6
     7b4:	2149      	movs	r1, #73	; 0x49
     7b6:	4816      	ldr	r0, [pc, #88]	; (810 <CONFIG_ISR_STACK_SIZE+0x10>)
     7b8:	f009 fdc0 	bl	a33c <z_log_minimal_printk>
		init_pattern(file_test_pattern, sizeof(file_test_pattern));
     7bc:	f240 2123 	movw	r1, #547	; 0x223
     7c0:	480f      	ldr	r0, [pc, #60]	; (800 <CONFIG_ISR_STACK_SIZE>)
     7c2:	f008 fe26 	bl	9412 <init_pattern>
     7c6:	e7c4      	b.n	752 <littlefs_binary_file_adj+0x52>
			LOG_ERR("FAIL: read %s: [rd:%d]",
     7c8:	4623      	mov	r3, r4
     7ca:	4632      	mov	r2, r6
     7cc:	2145      	movs	r1, #69	; 0x45
     7ce:	4811      	ldr	r0, [pc, #68]	; (814 <CONFIG_ISR_STACK_SIZE+0x14>)
     7d0:	f009 fdb4 	bl	a33c <z_log_minimal_printk>
			goto out;
     7d4:	e7d5      	b.n	782 <littlefs_binary_file_adj+0x82>
		LOG_ERR("FAIL: seek %s: %d", fname, rc);
     7d6:	4623      	mov	r3, r4
     7d8:	4632      	mov	r2, r6
     7da:	2145      	movs	r1, #69	; 0x45
     7dc:	480e      	ldr	r0, [pc, #56]	; (818 <CONFIG_ISR_STACK_SIZE+0x18>)
     7de:	f009 fdad 	bl	a33c <z_log_minimal_printk>
		goto out;
     7e2:	e7ce      	b.n	782 <littlefs_binary_file_adj+0x82>
		LOG_ERR("FAIL: write %s: %d", fname, rc);
     7e4:	4623      	mov	r3, r4
     7e6:	4632      	mov	r2, r6
     7e8:	2145      	movs	r1, #69	; 0x45
     7ea:	480c      	ldr	r0, [pc, #48]	; (81c <CONFIG_ISR_STACK_SIZE+0x1c>)
     7ec:	f009 fda6 	bl	a33c <z_log_minimal_printk>
     7f0:	e7c7      	b.n	782 <littlefs_binary_file_adj+0x82>
		LOG_ERR("FAIL: close %s: %d", fname, ret);
     7f2:	462b      	mov	r3, r5
     7f4:	4632      	mov	r2, r6
     7f6:	2145      	movs	r1, #69	; 0x45
     7f8:	4809      	ldr	r0, [pc, #36]	; (820 <CONFIG_ISR_STACK_SIZE+0x20>)
     7fa:	f009 fd9f 	bl	a33c <z_log_minimal_printk>
		return ret;
     7fe:	e7c7      	b.n	790 <littlefs_binary_file_adj+0x90>
     800:	20000648 	.word	0x20000648
     804:	0000e300 	.word	0x0000e300
     808:	0000e1f8 	.word	0x0000e1f8
     80c:	0000e2bc 	.word	0x0000e2bc
     810:	0000e2d4 	.word	0x0000e2d4
     814:	0000e210 	.word	0x0000e210
     818:	0000e24c 	.word	0x0000e24c
     81c:	0000e264 	.word	0x0000e264
     820:	0000e2a4 	.word	0x0000e2a4

00000824 <main>:
	return fs_mount(mp);
}
#endif /* CONFIG_APP_LITTLEFS_STORAGE_BLK_SDMMC */

int main(void)
{
     824:	b510      	push	{r4, lr}
     826:	f5ad 7d06 	sub.w	sp, sp, #536	; 0x218
	char fname1[MAX_PATH_LEN];
	char fname2[MAX_PATH_LEN];
	struct fs_statvfs sbuf;
	int rc;

	LOG_PRINTK("Sample program to r/w files on littlefs\n");
     82a:	482c      	ldr	r0, [pc, #176]	; (8dc <main+0xb8>)
     82c:	f009 fd86 	bl	a33c <z_log_minimal_printk>

	rc = littlefs_mount(mountpoint);
     830:	4b2b      	ldr	r3, [pc, #172]	; (8e0 <main+0xbc>)
     832:	6818      	ldr	r0, [r3, #0]
     834:	f7ff fe7e 	bl	534 <littlefs_mount>
	if (rc < 0) {
     838:	2800      	cmp	r0, #0
     83a:	db44      	blt.n	8c6 <main+0xa2>
		return 0;
	}

	snprintf(fname1, sizeof(fname1), "%s/boot_count", mountpoint->mnt_point);
     83c:	4c28      	ldr	r4, [pc, #160]	; (8e0 <main+0xbc>)
     83e:	6823      	ldr	r3, [r4, #0]
     840:	68db      	ldr	r3, [r3, #12]
     842:	4a28      	ldr	r2, [pc, #160]	; (8e4 <main+0xc0>)
     844:	21ff      	movs	r1, #255	; 0xff
     846:	a846      	add	r0, sp, #280	; 0x118
     848:	f001 fd7a 	bl	2340 <snprintf>
	snprintf(fname2, sizeof(fname2), "%s/pattern.bin", mountpoint->mnt_point);
     84c:	6823      	ldr	r3, [r4, #0]
     84e:	68db      	ldr	r3, [r3, #12]
     850:	4a25      	ldr	r2, [pc, #148]	; (8e8 <main+0xc4>)
     852:	21ff      	movs	r1, #255	; 0xff
     854:	a806      	add	r0, sp, #24
     856:	f001 fd73 	bl	2340 <snprintf>

	rc = fs_statvfs(mountpoint->mnt_point, &sbuf);
     85a:	6823      	ldr	r3, [r4, #0]
     85c:	a902      	add	r1, sp, #8
     85e:	68d8      	ldr	r0, [r3, #12]
     860:	f002 f81c 	bl	289c <fs_statvfs>
	if (rc < 0) {
     864:	1e01      	subs	r1, r0, #0
     866:	db21      	blt.n	8ac <main+0x88>
		LOG_PRINTK("FAIL: statvfs: %d\n", rc);
		goto out;
	}

	LOG_PRINTK("%s: bsize = %lu ; frsize = %lu ;"
     868:	4c1d      	ldr	r4, [pc, #116]	; (8e0 <main+0xbc>)
     86a:	6821      	ldr	r1, [r4, #0]
     86c:	9b05      	ldr	r3, [sp, #20]
     86e:	9301      	str	r3, [sp, #4]
     870:	9b04      	ldr	r3, [sp, #16]
     872:	9300      	str	r3, [sp, #0]
     874:	9b03      	ldr	r3, [sp, #12]
     876:	9a02      	ldr	r2, [sp, #8]
     878:	68c9      	ldr	r1, [r1, #12]
     87a:	481c      	ldr	r0, [pc, #112]	; (8ec <main+0xc8>)
     87c:	f009 fd5e 	bl	a33c <z_log_minimal_printk>
		   " blocks = %lu ; bfree = %lu\n",
		   mountpoint->mnt_point,
		   sbuf.f_bsize, sbuf.f_frsize,
		   sbuf.f_blocks, sbuf.f_bfree);

	rc = lsdir(mountpoint->mnt_point);
     880:	6823      	ldr	r3, [r4, #0]
     882:	68d8      	ldr	r0, [r3, #12]
     884:	f7ff fe76 	bl	574 <lsdir>
	if (rc < 0) {
     888:	1e02      	subs	r2, r0, #0
     88a:	db20      	blt.n	8ce <main+0xaa>
		LOG_PRINTK("FAIL: lsdir %s: %d\n", mountpoint->mnt_point, rc);
		goto out;
	}

	while(1) {
		rc = littlefs_increase_infile_value(fname1);
     88c:	a846      	add	r0, sp, #280	; 0x118
     88e:	f7ff fec1 	bl	614 <littlefs_increase_infile_value>
		if (rc) {
     892:	b970      	cbnz	r0, 8b2 <main+0x8e>
			goto out;
		}

		rc = littlefs_binary_file_adj(fname2);
     894:	a806      	add	r0, sp, #24
     896:	f7ff ff33 	bl	700 <littlefs_binary_file_adj>
		if (rc) {
     89a:	b950      	cbnz	r0, 8b2 <main+0x8e>
			goto out;
		}

		LOG_PRINTK("\n");
     89c:	4814      	ldr	r0, [pc, #80]	; (8f0 <main+0xcc>)
     89e:	f009 fd4d 	bl	a33c <z_log_minimal_printk>
		k_msleep(1000);
     8a2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
     8a6:	f008 fdcc 	bl	9442 <k_msleep>
		rc = littlefs_increase_infile_value(fname1);
     8aa:	e7ef      	b.n	88c <main+0x68>
		LOG_PRINTK("FAIL: statvfs: %d\n", rc);
     8ac:	4811      	ldr	r0, [pc, #68]	; (8f4 <main+0xd0>)
     8ae:	f009 fd45 	bl	a33c <z_log_minimal_printk>
	}

out:
	rc = fs_unmount(mountpoint);
     8b2:	4c0b      	ldr	r4, [pc, #44]	; (8e0 <main+0xbc>)
     8b4:	6820      	ldr	r0, [r4, #0]
     8b6:	f002 f8cd 	bl	2a54 <fs_unmount>
     8ba:	4602      	mov	r2, r0
	LOG_PRINTK("%s unmount: %d\n", mountpoint->mnt_point, rc);
     8bc:	6823      	ldr	r3, [r4, #0]
     8be:	68d9      	ldr	r1, [r3, #12]
     8c0:	480d      	ldr	r0, [pc, #52]	; (8f8 <main+0xd4>)
     8c2:	f009 fd3b 	bl	a33c <z_log_minimal_printk>
	return 0;
}
     8c6:	2000      	movs	r0, #0
     8c8:	f50d 7d06 	add.w	sp, sp, #536	; 0x218
     8cc:	bd10      	pop	{r4, pc}
		LOG_PRINTK("FAIL: lsdir %s: %d\n", mountpoint->mnt_point, rc);
     8ce:	6823      	ldr	r3, [r4, #0]
     8d0:	68d9      	ldr	r1, [r3, #12]
     8d2:	480a      	ldr	r0, [pc, #40]	; (8fc <main+0xd8>)
     8d4:	f009 fd32 	bl	a33c <z_log_minimal_printk>
		goto out;
     8d8:	e7eb      	b.n	8b2 <main+0x8e>
     8da:	bf00      	nop
     8dc:	0000e318 	.word	0x0000e318
     8e0:	20000000 	.word	0x20000000
     8e4:	0000e344 	.word	0x0000e344
     8e8:	0000e354 	.word	0x0000e354
     8ec:	0000e378 	.word	0x0000e378
     8f0:	0000f124 	.word	0x0000f124
     8f4:	0000e364 	.word	0x0000e364
     8f8:	0000e3cc 	.word	0x0000e3cc
     8fc:	0000e3b8 	.word	0x0000e3b8

00000900 <char_out>:

	return c;
}

static int char_out(int c, void *ctx_p)
{
     900:	b508      	push	{r3, lr}
	(void) ctx_p;
	return _char_out(c);
     902:	4b02      	ldr	r3, [pc, #8]	; (90c <char_out+0xc>)
     904:	681b      	ldr	r3, [r3, #0]
     906:	4798      	blx	r3
}
     908:	bd08      	pop	{r3, pc}
     90a:	bf00      	nop
     90c:	2000012c 	.word	0x2000012c

00000910 <__printk_hook_install>:
	_char_out = fn;
     910:	4b01      	ldr	r3, [pc, #4]	; (918 <__printk_hook_install+0x8>)
     912:	6018      	str	r0, [r3, #0]
}
     914:	4770      	bx	lr
     916:	bf00      	nop
     918:	2000012c 	.word	0x2000012c

0000091c <vprintk>:

void vprintk(const char *fmt, va_list ap)
{
     91c:	b500      	push	{lr}
     91e:	b083      	sub	sp, #12
     920:	4602      	mov	r2, r0
     922:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
     924:	2100      	movs	r1, #0
     926:	9100      	str	r1, [sp, #0]
     928:	4802      	ldr	r0, [pc, #8]	; (934 <vprintk+0x18>)
     92a:	f000 f91d 	bl	b68 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
     92e:	b003      	add	sp, #12
     930:	f85d fb04 	ldr.w	pc, [sp], #4
     934:	00000901 	.word	0x00000901

00000938 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     938:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     93c:	b083      	sub	sp, #12
     93e:	4604      	mov	r4, r0
     940:	4608      	mov	r0, r1
     942:	4615      	mov	r5, r2
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     944:	8b23      	ldrh	r3, [r4, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     946:	f013 0f08 	tst.w	r3, #8
     94a:	d105      	bne.n	958 <process_event+0x20>
     94c:	f003 0607 	and.w	r6, r3, #7
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
     950:	2300      	movs	r3, #0
     952:	9300      	str	r3, [sp, #0]
	list->tail = NULL;
     954:	9301      	str	r3, [sp, #4]
}
     956:	e055      	b.n	a04 <process_event+0xcc>
		if (evt == EVT_COMPLETE) {
     958:	2901      	cmp	r1, #1
     95a:	d009      	beq.n	970 <process_event+0x38>
			mgr->flags |= ONOFF_FLAG_COMPLETE;
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     95c:	f043 0320 	orr.w	r3, r3, #32
     960:	8323      	strh	r3, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     962:	f385 8811 	msr	BASEPRI, r5
     966:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     96a:	b003      	add	sp, #12
     96c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     970:	f043 0310 	orr.w	r3, r3, #16
     974:	8323      	strh	r3, [r4, #24]
     976:	e7f4      	b.n	962 <process_event+0x2a>
			evt = process_recheck(mgr);
     978:	4620      	mov	r0, r4
     97a:	f009 f948 	bl	9c0e <process_recheck>
     97e:	e043      	b.n	a08 <process_event+0xd0>
			res = mgr->last_res;
     980:	f8d4 9014 	ldr.w	r9, [r4, #20]
			process_complete(mgr, &clients, res);
     984:	464a      	mov	r2, r9
     986:	4669      	mov	r1, sp
     988:	4620      	mov	r0, r4
     98a:	f009 f959 	bl	9c40 <process_complete>
		onoff_transition_fn transit = NULL;
     98e:	f04f 0800 	mov.w	r8, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     992:	8b23      	ldrh	r3, [r4, #24]
     994:	f003 0707 	and.w	r7, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
     998:	42b7      	cmp	r7, r6
     99a:	d069      	beq.n	a70 <process_event+0x138>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
     99c:	68a2      	ldr	r2, [r4, #8]
     99e:	2a00      	cmp	r2, #0
     9a0:	d066      	beq.n	a70 <process_event+0x138>
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     9a2:	2201      	movs	r2, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     9a4:	f043 0308 	orr.w	r3, r3, #8
			mgr->flags = flags;
     9a8:	8323      	strh	r3, [r4, #24]
     9aa:	f385 8811 	msr	BASEPRI, r5
     9ae:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
     9b2:	2a00      	cmp	r2, #0
     9b4:	d164      	bne.n	a80 <process_event+0x148>
     9b6:	9b00      	ldr	r3, [sp, #0]
			if (!sys_slist_is_empty(&clients)) {
     9b8:	b12b      	cbz	r3, 9c6 <process_event+0x8e>
				notify_all(mgr, &clients, state, res);
     9ba:	464b      	mov	r3, r9
     9bc:	463a      	mov	r2, r7
     9be:	4669      	mov	r1, sp
     9c0:	4620      	mov	r0, r4
     9c2:	f009 f9b6 	bl	9d32 <notify_all>
			if (transit != NULL) {
     9c6:	f1b8 0f00 	cmp.w	r8, #0
     9ca:	d002      	beq.n	9d2 <process_event+0x9a>
				transit(mgr, transition_complete);
     9cc:	4934      	ldr	r1, [pc, #208]	; (aa0 <process_event+0x168>)
     9ce:	4620      	mov	r0, r4
     9d0:	47c0      	blx	r8
	__asm__ volatile(
     9d2:	f04f 0320 	mov.w	r3, #32
     9d6:	f3ef 8511 	mrs	r5, BASEPRI
     9da:	f383 8812 	msr	BASEPRI_MAX, r3
     9de:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     9e2:	8b23      	ldrh	r3, [r4, #24]
     9e4:	f023 0308 	bic.w	r3, r3, #8
     9e8:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     9ea:	8b23      	ldrh	r3, [r4, #24]
     9ec:	f013 0f10 	tst.w	r3, #16
     9f0:	d04c      	beq.n	a8c <process_event+0x154>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     9f2:	f023 0310 	bic.w	r3, r3, #16
     9f6:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
     9f8:	2001      	movs	r0, #1
		state = mgr->flags & ONOFF_STATE_MASK;
     9fa:	8b26      	ldrh	r6, [r4, #24]
     9fc:	f006 0607 	and.w	r6, r6, #7
	} while (evt != EVT_NOP);
     a00:	2800      	cmp	r0, #0
     a02:	d0ae      	beq.n	962 <process_event+0x2a>
		if (evt == EVT_RECHECK) {
     a04:	2802      	cmp	r0, #2
     a06:	d0b7      	beq.n	978 <process_event+0x40>
		if (evt == EVT_NOP) {
     a08:	2800      	cmp	r0, #0
     a0a:	d0aa      	beq.n	962 <process_event+0x2a>
		if (evt == EVT_COMPLETE) {
     a0c:	3801      	subs	r0, #1
     a0e:	2804      	cmp	r0, #4
     a10:	d82a      	bhi.n	a68 <process_event+0x130>
     a12:	a301      	add	r3, pc, #4	; (adr r3, a18 <process_event+0xe0>)
     a14:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
     a18:	00000981 	.word	0x00000981
     a1c:	00000a69 	.word	0x00000a69
     a20:	00000a2d 	.word	0x00000a2d
     a24:	00000a41 	.word	0x00000a41
     a28:	00000a55 	.word	0x00000a55
			transit = mgr->transitions->start;
     a2c:	6923      	ldr	r3, [r4, #16]
     a2e:	f8d3 8000 	ldr.w	r8, [r3]
			set_state(mgr, ONOFF_STATE_TO_ON);
     a32:	2106      	movs	r1, #6
     a34:	4620      	mov	r0, r4
     a36:	f009 f8c0 	bl	9bba <set_state>
		res = 0;
     a3a:	f04f 0900 	mov.w	r9, #0
     a3e:	e7a8      	b.n	992 <process_event+0x5a>
			transit = mgr->transitions->stop;
     a40:	6923      	ldr	r3, [r4, #16]
     a42:	f8d3 8004 	ldr.w	r8, [r3, #4]
			set_state(mgr, ONOFF_STATE_TO_OFF);
     a46:	2104      	movs	r1, #4
     a48:	4620      	mov	r0, r4
     a4a:	f009 f8b6 	bl	9bba <set_state>
		res = 0;
     a4e:	f04f 0900 	mov.w	r9, #0
     a52:	e79e      	b.n	992 <process_event+0x5a>
			transit = mgr->transitions->reset;
     a54:	6923      	ldr	r3, [r4, #16]
     a56:	f8d3 8008 	ldr.w	r8, [r3, #8]
			set_state(mgr, ONOFF_STATE_RESETTING);
     a5a:	2105      	movs	r1, #5
     a5c:	4620      	mov	r0, r4
     a5e:	f009 f8ac 	bl	9bba <set_state>
		res = 0;
     a62:	f04f 0900 	mov.w	r9, #0
     a66:	e794      	b.n	992 <process_event+0x5a>
		if (evt == EVT_NOP) {
     a68:	f04f 0800 	mov.w	r8, #0
     a6c:	46c1      	mov	r9, r8
     a6e:	e790      	b.n	992 <process_event+0x5a>
     a70:	9a00      	ldr	r2, [sp, #0]
		    || !sys_slist_is_empty(&clients)
     a72:	b10a      	cbz	r2, a78 <process_event+0x140>
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     a74:	2200      	movs	r2, #0
     a76:	e795      	b.n	9a4 <process_event+0x6c>
		    || (transit != NULL)) {
     a78:	f1b8 0f00 	cmp.w	r8, #0
     a7c:	d192      	bne.n	9a4 <process_event+0x6c>
     a7e:	e7b4      	b.n	9ea <process_event+0xb2>
				notify_monitors(mgr, state, res);
     a80:	464a      	mov	r2, r9
     a82:	4639      	mov	r1, r7
     a84:	4620      	mov	r0, r4
     a86:	f009 f8a0 	bl	9bca <notify_monitors>
     a8a:	e794      	b.n	9b6 <process_event+0x7e>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     a8c:	f013 0f20 	tst.w	r3, #32
     a90:	d004      	beq.n	a9c <process_event+0x164>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     a92:	f023 0320 	bic.w	r3, r3, #32
     a96:	8323      	strh	r3, [r4, #24]
			evt = EVT_RECHECK;
     a98:	2002      	movs	r0, #2
     a9a:	e7ae      	b.n	9fa <process_event+0xc2>
		evt = EVT_NOP;
     a9c:	2000      	movs	r0, #0
     a9e:	e7ac      	b.n	9fa <process_event+0xc2>
     aa0:	00009d61 	.word	0x00009d61

00000aa4 <extract_flags>:
 *
 * @return a pointer the first character that follows the flags.
 */
static inline const char *extract_flags(struct conversion *conv,
					const char *sp)
{
     aa4:	4684      	mov	ip, r0
     aa6:	4608      	mov	r0, r1
	bool loop = true;
     aa8:	2201      	movs	r2, #1
     aaa:	e026      	b.n	afa <extract_flags+0x56>

	do {
		switch (*sp) {
		case '-':
			conv->flag_dash = true;
     aac:	f89c 3000 	ldrb.w	r3, [ip]
     ab0:	f043 0304 	orr.w	r3, r3, #4
     ab4:	f88c 3000 	strb.w	r3, [ip]
			conv->flag_zero = true;
			break;
		default:
			loop = false;
		}
		if (loop) {
     ab8:	b1f2      	cbz	r2, af8 <extract_flags+0x54>
			++sp;
     aba:	3001      	adds	r0, #1
     abc:	e01c      	b.n	af8 <extract_flags+0x54>
			conv->flag_plus = true;
     abe:	f89c 3000 	ldrb.w	r3, [ip]
     ac2:	f043 0308 	orr.w	r3, r3, #8
     ac6:	f88c 3000 	strb.w	r3, [ip]
			break;
     aca:	e7f5      	b.n	ab8 <extract_flags+0x14>
			conv->flag_space = true;
     acc:	f89c 3000 	ldrb.w	r3, [ip]
     ad0:	f043 0310 	orr.w	r3, r3, #16
     ad4:	f88c 3000 	strb.w	r3, [ip]
			break;
     ad8:	e7ee      	b.n	ab8 <extract_flags+0x14>
			conv->flag_hash = true;
     ada:	f89c 3000 	ldrb.w	r3, [ip]
     ade:	f043 0320 	orr.w	r3, r3, #32
     ae2:	f88c 3000 	strb.w	r3, [ip]
			break;
     ae6:	e7e7      	b.n	ab8 <extract_flags+0x14>
			conv->flag_zero = true;
     ae8:	f89c 3000 	ldrb.w	r3, [ip]
     aec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     af0:	f88c 3000 	strb.w	r3, [ip]
			break;
     af4:	e7e0      	b.n	ab8 <extract_flags+0x14>
		switch (*sp) {
     af6:	2200      	movs	r2, #0
		}
	} while (loop);
     af8:	b342      	cbz	r2, b4c <extract_flags+0xa8>
		switch (*sp) {
     afa:	7803      	ldrb	r3, [r0, #0]
     afc:	3b20      	subs	r3, #32
     afe:	2b10      	cmp	r3, #16
     b00:	d8f9      	bhi.n	af6 <extract_flags+0x52>
     b02:	a101      	add	r1, pc, #4	; (adr r1, b08 <extract_flags+0x64>)
     b04:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
     b08:	00000acd 	.word	0x00000acd
     b0c:	00000af7 	.word	0x00000af7
     b10:	00000af7 	.word	0x00000af7
     b14:	00000adb 	.word	0x00000adb
     b18:	00000af7 	.word	0x00000af7
     b1c:	00000af7 	.word	0x00000af7
     b20:	00000af7 	.word	0x00000af7
     b24:	00000af7 	.word	0x00000af7
     b28:	00000af7 	.word	0x00000af7
     b2c:	00000af7 	.word	0x00000af7
     b30:	00000af7 	.word	0x00000af7
     b34:	00000abf 	.word	0x00000abf
     b38:	00000af7 	.word	0x00000af7
     b3c:	00000aad 	.word	0x00000aad
     b40:	00000af7 	.word	0x00000af7
     b44:	00000af7 	.word	0x00000af7
     b48:	00000ae9 	.word	0x00000ae9

	/* zero && dash => !zero */
	if (conv->flag_zero && conv->flag_dash) {
     b4c:	f89c 3000 	ldrb.w	r3, [ip]
     b50:	f003 0344 	and.w	r3, r3, #68	; 0x44
     b54:	2b44      	cmp	r3, #68	; 0x44
     b56:	d000      	beq.n	b5a <extract_flags+0xb6>
	}

	/* space && plus => !plus, handled in emitter code */

	return sp;
}
     b58:	4770      	bx	lr
		conv->flag_zero = false;
     b5a:	f89c 3000 	ldrb.w	r3, [ip]
     b5e:	f36f 1386 	bfc	r3, #6, #1
     b62:	f88c 3000 	strb.w	r3, [ip]
     b66:	e7f7      	b.n	b58 <extract_flags+0xb4>

00000b68 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
     b68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     b6c:	b091      	sub	sp, #68	; 0x44
     b6e:	4606      	mov	r6, r0
     b70:	460d      	mov	r5, r1
     b72:	4691      	mov	r9, r2
     b74:	9303      	str	r3, [sp, #12]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
     b76:	2400      	movs	r4, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
     b78:	f899 0000 	ldrb.w	r0, [r9]
     b7c:	2800      	cmp	r0, #0
     b7e:	f000 82b9 	beq.w	10f4 <CONFIG_MAIN_STACK_SIZE+0xf4>
		if (*fp != '%') {
     b82:	2825      	cmp	r0, #37	; 0x25
     b84:	d008      	beq.n	b98 <z_cbvprintf_impl+0x30>
			OUTC(*fp++);
     b86:	f109 0901 	add.w	r9, r9, #1
     b8a:	4629      	mov	r1, r5
     b8c:	47b0      	blx	r6
     b8e:	2800      	cmp	r0, #0
     b90:	f2c0 82b1 	blt.w	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
     b94:	3401      	adds	r4, #1
			continue;
     b96:	e7ef      	b.n	b78 <z_cbvprintf_impl+0x10>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
     b98:	2300      	movs	r3, #0
     b9a:	9304      	str	r3, [sp, #16]
     b9c:	9305      	str	r3, [sp, #20]
     b9e:	9306      	str	r3, [sp, #24]
     ba0:	9307      	str	r3, [sp, #28]
     ba2:	9308      	str	r3, [sp, #32]
     ba4:	9309      	str	r3, [sp, #36]	; 0x24
		int precision = -1;
		const char *bps = NULL;
		const char *bpe = buf + sizeof(buf);
		char sign = 0;

		fp = extract_conversion(conv, sp);
     ba6:	4649      	mov	r1, r9
     ba8:	a806      	add	r0, sp, #24
     baa:	f009 faf5 	bl	a198 <extract_conversion>
     bae:	9002      	str	r0, [sp, #8]

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
     bb0:	f89d 3019 	ldrb.w	r3, [sp, #25]
     bb4:	f013 0f01 	tst.w	r3, #1
     bb8:	f000 8097 	beq.w	cea <z_cbvprintf_impl+0x182>
			width = va_arg(ap, int);
     bbc:	9b03      	ldr	r3, [sp, #12]
     bbe:	1d1a      	adds	r2, r3, #4
     bc0:	9203      	str	r2, [sp, #12]
     bc2:	681f      	ldr	r7, [r3, #0]

			if (width < 0) {
     bc4:	2f00      	cmp	r7, #0
     bc6:	f2c0 8088 	blt.w	cda <z_cbvprintf_impl+0x172>

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
     bca:	f89d 3019 	ldrb.w	r3, [sp, #25]
     bce:	f013 0f04 	tst.w	r3, #4
     bd2:	f000 809c 	beq.w	d0e <z_cbvprintf_impl+0x1a6>
			int arg = va_arg(ap, int);
     bd6:	9b03      	ldr	r3, [sp, #12]
     bd8:	1d1a      	adds	r2, r3, #4
     bda:	9203      	str	r2, [sp, #12]
     bdc:	f8d3 a000 	ldr.w	sl, [r3]

			if (arg < 0) {
     be0:	f1ba 0f00 	cmp.w	sl, #0
     be4:	f2c0 808a 	blt.w	cfc <z_cbvprintf_impl+0x194>
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv->pad0_value = 0;
     be8:	2300      	movs	r3, #0
     bea:	9307      	str	r3, [sp, #28]
		conv->pad0_pre_exp = 0;
     bec:	9308      	str	r3, [sp, #32]
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
     bee:	f89d 301a 	ldrb.w	r3, [sp, #26]
     bf2:	f003 0307 	and.w	r3, r3, #7
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
     bf6:	f89d 1019 	ldrb.w	r1, [sp, #25]
     bfa:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
     bfe:	2b01      	cmp	r3, #1
     c00:	f000 808e 	beq.w	d20 <z_cbvprintf_impl+0x1b8>
			if (length_mod == LENGTH_HH) {
				value->sint = (signed char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
     c04:	2b02      	cmp	r3, #2
     c06:	f000 80d3 	beq.w	db0 <z_cbvprintf_impl+0x248>
			if (length_mod == LENGTH_HH) {
				value->uint = (unsigned char)value->uint;
			} else if (length_mod == LENGTH_H) {
				value->uint = (unsigned short)value->uint;
			}
		} else if (specifier_cat == SPECIFIER_FP) {
     c0a:	2b04      	cmp	r3, #4
     c0c:	f000 8124 	beq.w	e58 <z_cbvprintf_impl+0x2f0>
			if (length_mod == LENGTH_UPPER_L) {
				value->ldbl = va_arg(ap, long double);
			} else {
				value->dbl = va_arg(ap, double);
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
     c10:	2b03      	cmp	r3, #3
     c12:	f000 813b 	beq.w	e8c <z_cbvprintf_impl+0x324>
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
     c16:	f89d 8018 	ldrb.w	r8, [sp, #24]
     c1a:	f018 0b03 	ands.w	fp, r8, #3
     c1e:	f040 813b 	bne.w	e98 <z_cbvprintf_impl+0x330>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
     c22:	f89d 301b 	ldrb.w	r3, [sp, #27]
     c26:	3b25      	subs	r3, #37	; 0x25
     c28:	2b53      	cmp	r3, #83	; 0x53
     c2a:	f200 81ca 	bhi.w	fc2 <z_cbvprintf_impl+0x45a>
     c2e:	e8df f013 	tbh	[pc, r3, lsl #1]
     c32:	0140      	.short	0x0140
     c34:	01c801c8 	.word	0x01c801c8
     c38:	01c801c8 	.word	0x01c801c8
     c3c:	01c801c8 	.word	0x01c801c8
     c40:	01c801c8 	.word	0x01c801c8
     c44:	01c801c8 	.word	0x01c801c8
     c48:	01c801c8 	.word	0x01c801c8
     c4c:	01c801c8 	.word	0x01c801c8
     c50:	01c801c8 	.word	0x01c801c8
     c54:	01c801c8 	.word	0x01c801c8
     c58:	01c801c8 	.word	0x01c801c8
     c5c:	01c801c8 	.word	0x01c801c8
     c60:	01c801c8 	.word	0x01c801c8
     c64:	01c801c8 	.word	0x01c801c8
     c68:	01c801c8 	.word	0x01c801c8
     c6c:	01c801c8 	.word	0x01c801c8
     c70:	01c801c8 	.word	0x01c801c8
     c74:	01c801c8 	.word	0x01c801c8
     c78:	01c801c8 	.word	0x01c801c8
     c7c:	01c801c8 	.word	0x01c801c8
     c80:	01c801c8 	.word	0x01c801c8
     c84:	01c801c8 	.word	0x01c801c8
     c88:	01c801c8 	.word	0x01c801c8
     c8c:	01c801c8 	.word	0x01c801c8
     c90:	01c801c8 	.word	0x01c801c8
     c94:	01c801c8 	.word	0x01c801c8
     c98:	01c80181 	.word	0x01c80181
     c9c:	01c801c8 	.word	0x01c801c8
     ca0:	01c801c8 	.word	0x01c801c8
     ca4:	01c801c8 	.word	0x01c801c8
     ca8:	01c801c8 	.word	0x01c801c8
     cac:	015e01c8 	.word	0x015e01c8
     cb0:	01c80167 	.word	0x01c80167
     cb4:	01c801c8 	.word	0x01c801c8
     cb8:	016701c8 	.word	0x016701c8
     cbc:	01c801c8 	.word	0x01c801c8
     cc0:	01c801c8 	.word	0x01c801c8
     cc4:	018101bd 	.word	0x018101bd
     cc8:	01c801a1 	.word	0x01c801a1
     ccc:	014d01c8 	.word	0x014d01c8
     cd0:	018101c8 	.word	0x018101c8
     cd4:	01c801c8 	.word	0x01c801c8
     cd8:	0181      	.short	0x0181
				conv->flag_dash = true;
     cda:	f89d 3018 	ldrb.w	r3, [sp, #24]
     cde:	f043 0304 	orr.w	r3, r3, #4
     ce2:	f88d 3018 	strb.w	r3, [sp, #24]
				width = -width;
     ce6:	427f      	negs	r7, r7
     ce8:	e76f      	b.n	bca <z_cbvprintf_impl+0x62>
		} else if (conv->width_present) {
     cea:	f99d 3018 	ldrsb.w	r3, [sp, #24]
     cee:	2b00      	cmp	r3, #0
     cf0:	db02      	blt.n	cf8 <z_cbvprintf_impl+0x190>
		int width = -1;
     cf2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
     cf6:	e768      	b.n	bca <z_cbvprintf_impl+0x62>
			width = conv->width_value;
     cf8:	9f07      	ldr	r7, [sp, #28]
     cfa:	e766      	b.n	bca <z_cbvprintf_impl+0x62>
				conv->prec_present = false;
     cfc:	f89d 3019 	ldrb.w	r3, [sp, #25]
     d00:	f36f 0341 	bfc	r3, #1, #1
     d04:	f88d 3019 	strb.w	r3, [sp, #25]
		int precision = -1;
     d08:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
     d0c:	e76c      	b.n	be8 <z_cbvprintf_impl+0x80>
		} else if (conv->prec_present) {
     d0e:	f013 0f02 	tst.w	r3, #2
     d12:	d002      	beq.n	d1a <z_cbvprintf_impl+0x1b2>
			precision = conv->prec_value;
     d14:	f8dd a020 	ldr.w	sl, [sp, #32]
     d18:	e766      	b.n	be8 <z_cbvprintf_impl+0x80>
		int precision = -1;
     d1a:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
     d1e:	e763      	b.n	be8 <z_cbvprintf_impl+0x80>
			switch (length_mod) {
     d20:	1ecb      	subs	r3, r1, #3
     d22:	2b04      	cmp	r3, #4
     d24:	d804      	bhi.n	d30 <z_cbvprintf_impl+0x1c8>
     d26:	e8df f003 	tbb	[pc, r3]
     d2a:	1d0b      	.short	0x1d0b
     d2c:	3529      	.short	0x3529
     d2e:	35          	.byte	0x35
     d2f:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
     d30:	9b03      	ldr	r3, [sp, #12]
     d32:	1d1a      	adds	r2, r3, #4
     d34:	9203      	str	r2, [sp, #12]
     d36:	681b      	ldr	r3, [r3, #0]
     d38:	17da      	asrs	r2, r3, #31
     d3a:	9304      	str	r3, [sp, #16]
     d3c:	9205      	str	r2, [sp, #20]
				break;
     d3e:	e006      	b.n	d4e <z_cbvprintf_impl+0x1e6>
					value->sint = va_arg(ap, long);
     d40:	9b03      	ldr	r3, [sp, #12]
     d42:	1d1a      	adds	r2, r3, #4
     d44:	9203      	str	r2, [sp, #12]
     d46:	681b      	ldr	r3, [r3, #0]
     d48:	17da      	asrs	r2, r3, #31
     d4a:	9304      	str	r3, [sp, #16]
     d4c:	9205      	str	r2, [sp, #20]
			if (length_mod == LENGTH_HH) {
     d4e:	2901      	cmp	r1, #1
     d50:	d028      	beq.n	da4 <z_cbvprintf_impl+0x23c>
			} else if (length_mod == LENGTH_H) {
     d52:	2902      	cmp	r1, #2
     d54:	f47f af5f 	bne.w	c16 <z_cbvprintf_impl+0xae>
				value->sint = (short)value->sint;
     d58:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
     d5c:	17da      	asrs	r2, r3, #31
     d5e:	9304      	str	r3, [sp, #16]
     d60:	9205      	str	r2, [sp, #20]
     d62:	e758      	b.n	c16 <z_cbvprintf_impl+0xae>
					(sint_value_type)va_arg(ap, long long);
     d64:	9b03      	ldr	r3, [sp, #12]
     d66:	3307      	adds	r3, #7
     d68:	f023 0307 	bic.w	r3, r3, #7
     d6c:	f103 0208 	add.w	r2, r3, #8
     d70:	9203      	str	r2, [sp, #12]
     d72:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
     d76:	e9cd 2304 	strd	r2, r3, [sp, #16]
				break;
     d7a:	e7e8      	b.n	d4e <z_cbvprintf_impl+0x1e6>
					(sint_value_type)va_arg(ap, intmax_t);
     d7c:	9b03      	ldr	r3, [sp, #12]
     d7e:	3307      	adds	r3, #7
     d80:	f023 0307 	bic.w	r3, r3, #7
     d84:	f103 0208 	add.w	r2, r3, #8
     d88:	9203      	str	r2, [sp, #12]
     d8a:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
     d8e:	e9cd 2304 	strd	r2, r3, [sp, #16]
				break;
     d92:	e7dc      	b.n	d4e <z_cbvprintf_impl+0x1e6>
					(sint_value_type)va_arg(ap, ptrdiff_t);
     d94:	9b03      	ldr	r3, [sp, #12]
     d96:	1d1a      	adds	r2, r3, #4
     d98:	9203      	str	r2, [sp, #12]
     d9a:	681b      	ldr	r3, [r3, #0]
     d9c:	17da      	asrs	r2, r3, #31
				value->sint =
     d9e:	9304      	str	r3, [sp, #16]
     da0:	9205      	str	r2, [sp, #20]
				break;
     da2:	e7d4      	b.n	d4e <z_cbvprintf_impl+0x1e6>
				value->sint = (signed char)value->sint;
     da4:	f99d 3010 	ldrsb.w	r3, [sp, #16]
     da8:	17da      	asrs	r2, r3, #31
     daa:	9304      	str	r3, [sp, #16]
     dac:	9205      	str	r2, [sp, #20]
     dae:	e732      	b.n	c16 <z_cbvprintf_impl+0xae>
			switch (length_mod) {
     db0:	1ecb      	subs	r3, r1, #3
     db2:	2b04      	cmp	r3, #4
     db4:	d804      	bhi.n	dc0 <z_cbvprintf_impl+0x258>
     db6:	e8df f003 	tbb	[pc, r3]
     dba:	1f0b      	.short	0x1f0b
     dbc:	4135      	.short	0x4135
     dbe:	41          	.byte	0x41
     dbf:	00          	.byte	0x00
				value->uint = va_arg(ap, unsigned int);
     dc0:	9b03      	ldr	r3, [sp, #12]
     dc2:	1d1a      	adds	r2, r3, #4
     dc4:	9203      	str	r2, [sp, #12]
     dc6:	681b      	ldr	r3, [r3, #0]
     dc8:	9304      	str	r3, [sp, #16]
     dca:	2300      	movs	r3, #0
     dcc:	9305      	str	r3, [sp, #20]
				break;
     dce:	e01e      	b.n	e0e <z_cbvprintf_impl+0x2a6>
				    && (conv->specifier == 'c')) {
     dd0:	f89d 301b 	ldrb.w	r3, [sp, #27]
				if ((!WCHAR_IS_SIGNED)
     dd4:	2b63      	cmp	r3, #99	; 0x63
     dd6:	d007      	beq.n	de8 <z_cbvprintf_impl+0x280>
					value->uint = va_arg(ap, unsigned long);
     dd8:	9b03      	ldr	r3, [sp, #12]
     dda:	1d1a      	adds	r2, r3, #4
     ddc:	9203      	str	r2, [sp, #12]
     dde:	681b      	ldr	r3, [r3, #0]
     de0:	9304      	str	r3, [sp, #16]
     de2:	2300      	movs	r3, #0
     de4:	9305      	str	r3, [sp, #20]
     de6:	e012      	b.n	e0e <z_cbvprintf_impl+0x2a6>
					value->uint = (wchar_t)va_arg(ap,
     de8:	9b03      	ldr	r3, [sp, #12]
     dea:	1d1a      	adds	r2, r3, #4
     dec:	9203      	str	r2, [sp, #12]
     dee:	681b      	ldr	r3, [r3, #0]
     df0:	9304      	str	r3, [sp, #16]
     df2:	2300      	movs	r3, #0
     df4:	9305      	str	r3, [sp, #20]
     df6:	e00a      	b.n	e0e <z_cbvprintf_impl+0x2a6>
					(uint_value_type)va_arg(ap,
     df8:	9b03      	ldr	r3, [sp, #12]
     dfa:	3307      	adds	r3, #7
     dfc:	f023 0307 	bic.w	r3, r3, #7
     e00:	f103 0208 	add.w	r2, r3, #8
     e04:	9203      	str	r2, [sp, #12]
     e06:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
     e0a:	e9cd 2304 	strd	r2, r3, [sp, #16]
			if (length_mod == LENGTH_HH) {
     e0e:	2901      	cmp	r1, #1
     e10:	d01c      	beq.n	e4c <z_cbvprintf_impl+0x2e4>
			} else if (length_mod == LENGTH_H) {
     e12:	2902      	cmp	r1, #2
     e14:	f47f aeff 	bne.w	c16 <z_cbvprintf_impl+0xae>
				value->uint = (unsigned short)value->uint;
     e18:	f8bd 3010 	ldrh.w	r3, [sp, #16]
     e1c:	9304      	str	r3, [sp, #16]
     e1e:	2300      	movs	r3, #0
     e20:	9305      	str	r3, [sp, #20]
     e22:	e6f8      	b.n	c16 <z_cbvprintf_impl+0xae>
					(uint_value_type)va_arg(ap,
     e24:	9b03      	ldr	r3, [sp, #12]
     e26:	3307      	adds	r3, #7
     e28:	f023 0307 	bic.w	r3, r3, #7
     e2c:	f103 0208 	add.w	r2, r3, #8
     e30:	9203      	str	r2, [sp, #12]
     e32:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
     e36:	e9cd 2304 	strd	r2, r3, [sp, #16]
				break;
     e3a:	e7e8      	b.n	e0e <z_cbvprintf_impl+0x2a6>
					(uint_value_type)va_arg(ap, size_t);
     e3c:	9b03      	ldr	r3, [sp, #12]
     e3e:	1d1a      	adds	r2, r3, #4
     e40:	9203      	str	r2, [sp, #12]
     e42:	681b      	ldr	r3, [r3, #0]
				value->uint =
     e44:	9304      	str	r3, [sp, #16]
     e46:	2300      	movs	r3, #0
     e48:	9305      	str	r3, [sp, #20]
				break;
     e4a:	e7e0      	b.n	e0e <z_cbvprintf_impl+0x2a6>
				value->uint = (unsigned char)value->uint;
     e4c:	f89d 3010 	ldrb.w	r3, [sp, #16]
     e50:	9304      	str	r3, [sp, #16]
     e52:	2300      	movs	r3, #0
     e54:	9305      	str	r3, [sp, #20]
     e56:	e6de      	b.n	c16 <z_cbvprintf_impl+0xae>
			if (length_mod == LENGTH_UPPER_L) {
     e58:	2908      	cmp	r1, #8
     e5a:	d00b      	beq.n	e74 <z_cbvprintf_impl+0x30c>
				value->dbl = va_arg(ap, double);
     e5c:	9b03      	ldr	r3, [sp, #12]
     e5e:	3307      	adds	r3, #7
     e60:	f023 0307 	bic.w	r3, r3, #7
     e64:	f103 0208 	add.w	r2, r3, #8
     e68:	9203      	str	r2, [sp, #12]
     e6a:	e9d3 2300 	ldrd	r2, r3, [r3]
     e6e:	e9cd 2304 	strd	r2, r3, [sp, #16]
     e72:	e6d0      	b.n	c16 <z_cbvprintf_impl+0xae>
				value->ldbl = va_arg(ap, long double);
     e74:	9b03      	ldr	r3, [sp, #12]
     e76:	3307      	adds	r3, #7
     e78:	f023 0307 	bic.w	r3, r3, #7
     e7c:	f103 0208 	add.w	r2, r3, #8
     e80:	9203      	str	r2, [sp, #12]
     e82:	e9d3 2300 	ldrd	r2, r3, [r3]
     e86:	e9cd 2304 	strd	r2, r3, [sp, #16]
     e8a:	e6c4      	b.n	c16 <z_cbvprintf_impl+0xae>
			value->ptr = va_arg(ap, void *);
     e8c:	9b03      	ldr	r3, [sp, #12]
     e8e:	1d1a      	adds	r2, r3, #4
     e90:	9203      	str	r2, [sp, #12]
     e92:	681b      	ldr	r3, [r3, #0]
     e94:	9304      	str	r3, [sp, #16]
     e96:	e6be      	b.n	c16 <z_cbvprintf_impl+0xae>
			OUTS(sp, fp);
     e98:	9f02      	ldr	r7, [sp, #8]
     e9a:	463b      	mov	r3, r7
     e9c:	464a      	mov	r2, r9
     e9e:	4629      	mov	r1, r5
     ea0:	4630      	mov	r0, r6
     ea2:	f009 fa1f 	bl	a2e4 <outs>
     ea6:	2800      	cmp	r0, #0
     ea8:	f2c0 8125 	blt.w	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
     eac:	4404      	add	r4, r0
		fp = extract_conversion(conv, sp);
     eae:	46b9      	mov	r9, r7
			continue;
     eb0:	e662      	b.n	b78 <z_cbvprintf_impl+0x10>
		case '%':
			OUTC('%');
     eb2:	4629      	mov	r1, r5
     eb4:	2025      	movs	r0, #37	; 0x25
     eb6:	47b0      	blx	r6
     eb8:	2800      	cmp	r0, #0
     eba:	f2c0 811c 	blt.w	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
     ebe:	3401      	adds	r4, #1
		char sign = 0;
     ec0:	46d8      	mov	r8, fp
		const char *bpe = buf + sizeof(buf);
     ec2:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
		const char *bps = NULL;
     ec6:	f04f 0900 	mov.w	r9, #0
			break;
     eca:	e07f      	b.n	fcc <z_cbvprintf_impl+0x464>
		case 's': {
			bps = (const char *)value->ptr;
     ecc:	f8dd 9010 	ldr.w	r9, [sp, #16]

			size_t len;

			if (precision >= 0) {
     ed0:	f1ba 0f00 	cmp.w	sl, #0
     ed4:	db07      	blt.n	ee6 <z_cbvprintf_impl+0x37e>
				len = strnlen(bps, precision);
     ed6:	4651      	mov	r1, sl
     ed8:	4648      	mov	r0, r9
     eda:	f009 fbb5 	bl	a648 <strnlen>
			} else {
				len = strlen(bps);
			}

			bpe = bps + len;
     ede:	eb09 0a00 	add.w	sl, r9, r0
		char sign = 0;
     ee2:	46d8      	mov	r8, fp
			precision = -1;

			break;
     ee4:	e072      	b.n	fcc <z_cbvprintf_impl+0x464>
				len = strlen(bps);
     ee6:	4648      	mov	r0, r9
     ee8:	f009 fba5 	bl	a636 <strlen>
     eec:	e7f7      	b.n	ede <z_cbvprintf_impl+0x376>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
     eee:	9b04      	ldr	r3, [sp, #16]
     ef0:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
		char sign = 0;
     ef4:	46d8      	mov	r8, fp
			bpe = buf + 1;
     ef6:	f10d 0a29 	add.w	sl, sp, #41	; 0x29
			bps = buf;
     efa:	f10d 0928 	add.w	r9, sp, #40	; 0x28
			break;
     efe:	e065      	b.n	fcc <z_cbvprintf_impl+0x464>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
     f00:	f018 0f08 	tst.w	r8, #8
     f04:	d105      	bne.n	f12 <z_cbvprintf_impl+0x3aa>
				sign = '+';
			} else if (conv->flag_space) {
     f06:	f018 0810 	ands.w	r8, r8, #16
     f0a:	d004      	beq.n	f16 <z_cbvprintf_impl+0x3ae>
				sign = ' ';
     f0c:	f04f 0820 	mov.w	r8, #32
     f10:	e001      	b.n	f16 <z_cbvprintf_impl+0x3ae>
				sign = '+';
     f12:	f04f 082b 	mov.w	r8, #43	; 0x2b

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
     f16:	9a04      	ldr	r2, [sp, #16]
     f18:	9b05      	ldr	r3, [sp, #20]
			if (sint < 0) {
     f1a:	2b00      	cmp	r3, #0
     f1c:	db02      	blt.n	f24 <z_cbvprintf_impl+0x3bc>
				sign = '-';
				value->uint = (uint_value_type)-sint;
			} else {
				value->uint = (uint_value_type)sint;
     f1e:	9204      	str	r2, [sp, #16]
     f20:	9305      	str	r3, [sp, #20]
     f22:	e008      	b.n	f36 <z_cbvprintf_impl+0x3ce>
				value->uint = (uint_value_type)-sint;
     f24:	4252      	negs	r2, r2
     f26:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     f2a:	9204      	str	r2, [sp, #16]
     f2c:	9305      	str	r3, [sp, #20]
				sign = '-';
     f2e:	f04f 082d 	mov.w	r8, #45	; 0x2d
     f32:	e000      	b.n	f36 <z_cbvprintf_impl+0x3ce>
		switch (conv->specifier) {
     f34:	46d8      	mov	r8, fp
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
     f36:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
     f3a:	9300      	str	r3, [sp, #0]
     f3c:	ab0a      	add	r3, sp, #40	; 0x28
     f3e:	aa06      	add	r2, sp, #24
     f40:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
     f44:	f009 f95f 	bl	a206 <encode_uint>
     f48:	4681      	mov	r9, r0
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
     f4a:	f1ba 0f00 	cmp.w	sl, #0
     f4e:	db6c      	blt.n	102a <CONFIG_MAIN_STACK_SIZE+0x2a>
				size_t len = bpe - bps;
     f50:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
     f54:	eba3 0309 	sub.w	r3, r3, r9

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
     f58:	f89d 2018 	ldrb.w	r2, [sp, #24]
     f5c:	f36f 1286 	bfc	r2, #6, #1
     f60:	f88d 2018 	strb.w	r2, [sp, #24]

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
     f64:	459a      	cmp	sl, r3
     f66:	d963      	bls.n	1030 <CONFIG_MAIN_STACK_SIZE+0x30>
					conv->pad0_value = precision - (int)len;
     f68:	ebaa 0303 	sub.w	r3, sl, r3
     f6c:	9307      	str	r3, [sp, #28]
		const char *bpe = buf + sizeof(buf);
     f6e:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
     f72:	e02b      	b.n	fcc <z_cbvprintf_impl+0x464>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
     f74:	9804      	ldr	r0, [sp, #16]
     f76:	b928      	cbnz	r0, f84 <z_cbvprintf_impl+0x41c>
		char sign = 0;
     f78:	46d8      	mov	r8, fp

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
     f7a:	f8df a180 	ldr.w	sl, [pc, #384]	; 10fc <CONFIG_MAIN_STACK_SIZE+0xfc>
			bps = "(nil)";
     f7e:	f1aa 0905 	sub.w	r9, sl, #5
     f82:	e023      	b.n	fcc <z_cbvprintf_impl+0x464>
				bps = encode_uint((uintptr_t)value->ptr, conv,
     f84:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
     f88:	9300      	str	r3, [sp, #0]
     f8a:	ab0a      	add	r3, sp, #40	; 0x28
     f8c:	aa06      	add	r2, sp, #24
     f8e:	2100      	movs	r1, #0
     f90:	f009 f939 	bl	a206 <encode_uint>
     f94:	4681      	mov	r9, r0
				conv->altform_0c = true;
     f96:	f89d 301a 	ldrb.w	r3, [sp, #26]
     f9a:	f043 0310 	orr.w	r3, r3, #16
     f9e:	f88d 301a 	strb.w	r3, [sp, #26]
				conv->specifier = 'x';
     fa2:	2378      	movs	r3, #120	; 0x78
     fa4:	f88d 301b 	strb.w	r3, [sp, #27]
		char sign = 0;
     fa8:	46d8      	mov	r8, fp
				goto prec_int_pad0;
     faa:	e7ce      	b.n	f4a <z_cbvprintf_impl+0x3e2>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
     fac:	4622      	mov	r2, r4
     fae:	9904      	ldr	r1, [sp, #16]
     fb0:	a806      	add	r0, sp, #24
     fb2:	f009 f978 	bl	a2a6 <store_count>
		char sign = 0;
     fb6:	46d8      	mov	r8, fp
		const char *bpe = buf + sizeof(buf);
     fb8:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
		const char *bps = NULL;
     fbc:	f04f 0900 	mov.w	r9, #0
			}

			break;
     fc0:	e004      	b.n	fcc <z_cbvprintf_impl+0x464>
		switch (conv->specifier) {
     fc2:	46d8      	mov	r8, fp
     fc4:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
     fc8:	f04f 0900 	mov.w	r9, #0
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
     fcc:	f1b9 0f00 	cmp.w	r9, #0
     fd0:	f000 808d 	beq.w	10ee <CONFIG_MAIN_STACK_SIZE+0xee>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
     fd4:	ebaa 0309 	sub.w	r3, sl, r9
		int pad_len = 0;

		if (sign != 0) {
     fd8:	f1b8 0f00 	cmp.w	r8, #0
     fdc:	d000      	beq.n	fe0 <z_cbvprintf_impl+0x478>
			nj_len += 1U;
     fde:	3301      	adds	r3, #1
		}

		if (conv->altform_0c) {
     fe0:	f89d 201a 	ldrb.w	r2, [sp, #26]
     fe4:	f012 0f10 	tst.w	r2, #16
     fe8:	d025      	beq.n	1036 <CONFIG_MAIN_STACK_SIZE+0x36>
			nj_len += 2U;
     fea:	3302      	adds	r3, #2
		} else if (conv->altform_0) {
			nj_len += 1U;
		}

		nj_len += conv->pad0_value;
     fec:	9907      	ldr	r1, [sp, #28]
     fee:	440b      	add	r3, r1
		if (conv->pad_fp) {
     ff0:	f012 0f40 	tst.w	r2, #64	; 0x40
     ff4:	d001      	beq.n	ffa <z_cbvprintf_impl+0x492>
			nj_len += conv->pad0_pre_exp;
     ff6:	9a08      	ldr	r2, [sp, #32]
     ff8:	4413      	add	r3, r2
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
     ffa:	2f00      	cmp	r7, #0
     ffc:	dd31      	ble.n	1062 <CONFIG_MAIN_STACK_SIZE+0x62>
			width -= (int)nj_len;
     ffe:	1aff      	subs	r7, r7, r3

			if (!conv->flag_dash) {
    1000:	f89d 3018 	ldrb.w	r3, [sp, #24]
    1004:	f013 0f04 	tst.w	r3, #4
    1008:	d12b      	bne.n	1062 <CONFIG_MAIN_STACK_SIZE+0x62>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    100a:	f013 0f40 	tst.w	r3, #64	; 0x40
    100e:	d017      	beq.n	1040 <CONFIG_MAIN_STACK_SIZE+0x40>
					if (sign != 0) {
    1010:	f1b8 0f00 	cmp.w	r8, #0
    1014:	d017      	beq.n	1046 <CONFIG_MAIN_STACK_SIZE+0x46>
						OUTC(sign);
    1016:	4629      	mov	r1, r5
    1018:	4640      	mov	r0, r8
    101a:	47b0      	blx	r6
    101c:	2800      	cmp	r0, #0
    101e:	db6a      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    1020:	3401      	adds	r4, #1
						sign = 0;
    1022:	46d8      	mov	r8, fp
					}
					pad = '0';
    1024:	f04f 0b30 	mov.w	fp, #48	; 0x30
    1028:	e00f      	b.n	104a <CONFIG_MAIN_STACK_SIZE+0x4a>
		const char *bpe = buf + sizeof(buf);
    102a:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
    102e:	e7cd      	b.n	fcc <z_cbvprintf_impl+0x464>
    1030:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
    1034:	e7ca      	b.n	fcc <z_cbvprintf_impl+0x464>
		} else if (conv->altform_0) {
    1036:	f012 0f08 	tst.w	r2, #8
    103a:	d0d7      	beq.n	fec <z_cbvprintf_impl+0x484>
			nj_len += 1U;
    103c:	3301      	adds	r3, #1
    103e:	e7d5      	b.n	fec <z_cbvprintf_impl+0x484>
				char pad = ' ';
    1040:	f04f 0b20 	mov.w	fp, #32
    1044:	e001      	b.n	104a <CONFIG_MAIN_STACK_SIZE+0x4a>
					pad = '0';
    1046:	f04f 0b30 	mov.w	fp, #48	; 0x30
    104a:	463b      	mov	r3, r7
				}

				while (width-- > 0) {
    104c:	1e5f      	subs	r7, r3, #1
    104e:	2b00      	cmp	r3, #0
    1050:	dd07      	ble.n	1062 <CONFIG_MAIN_STACK_SIZE+0x62>
					OUTC(pad);
    1052:	4629      	mov	r1, r5
    1054:	4658      	mov	r0, fp
    1056:	47b0      	blx	r6
    1058:	2800      	cmp	r0, #0
    105a:	db4c      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    105c:	3401      	adds	r4, #1
				while (width-- > 0) {
    105e:	463b      	mov	r3, r7
    1060:	e7f4      	b.n	104c <CONFIG_MAIN_STACK_SIZE+0x4c>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    1062:	f1b8 0f00 	cmp.w	r8, #0
    1066:	d005      	beq.n	1074 <CONFIG_MAIN_STACK_SIZE+0x74>
			OUTC(sign);
    1068:	4629      	mov	r1, r5
    106a:	4640      	mov	r0, r8
    106c:	47b0      	blx	r6
    106e:	2800      	cmp	r0, #0
    1070:	db41      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    1072:	3401      	adds	r4, #1
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    1074:	f89d 301a 	ldrb.w	r3, [sp, #26]
    1078:	f3c3 1200 	ubfx	r2, r3, #4, #1
    107c:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    1080:	431a      	orrs	r2, r3
    1082:	d005      	beq.n	1090 <CONFIG_MAIN_STACK_SIZE+0x90>
				OUTC('0');
    1084:	4629      	mov	r1, r5
    1086:	2030      	movs	r0, #48	; 0x30
    1088:	47b0      	blx	r6
    108a:	2800      	cmp	r0, #0
    108c:	db33      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    108e:	3401      	adds	r4, #1
			}

			if (conv->altform_0c) {
    1090:	f89d 301a 	ldrb.w	r3, [sp, #26]
    1094:	f013 0f10 	tst.w	r3, #16
    1098:	d006      	beq.n	10a8 <CONFIG_MAIN_STACK_SIZE+0xa8>
				OUTC(conv->specifier);
    109a:	4629      	mov	r1, r5
    109c:	f89d 001b 	ldrb.w	r0, [sp, #27]
    10a0:	47b0      	blx	r6
    10a2:	2800      	cmp	r0, #0
    10a4:	db27      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    10a6:	3401      	adds	r4, #1
			}

			pad_len = conv->pad0_value;
    10a8:	9b07      	ldr	r3, [sp, #28]
			while (pad_len-- > 0) {
    10aa:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    10ae:	2b00      	cmp	r3, #0
    10b0:	dd07      	ble.n	10c2 <CONFIG_MAIN_STACK_SIZE+0xc2>
				OUTC('0');
    10b2:	4629      	mov	r1, r5
    10b4:	2030      	movs	r0, #48	; 0x30
    10b6:	47b0      	blx	r6
    10b8:	2800      	cmp	r0, #0
    10ba:	db1c      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    10bc:	3401      	adds	r4, #1
			while (pad_len-- > 0) {
    10be:	4643      	mov	r3, r8
    10c0:	e7f3      	b.n	10aa <CONFIG_MAIN_STACK_SIZE+0xaa>
			}

			OUTS(bps, bpe);
    10c2:	4653      	mov	r3, sl
    10c4:	464a      	mov	r2, r9
    10c6:	4629      	mov	r1, r5
    10c8:	4630      	mov	r0, r6
    10ca:	f009 f90b 	bl	a2e4 <outs>
    10ce:	2800      	cmp	r0, #0
    10d0:	db11      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    10d2:	4404      	add	r4, r0
		}

		/* Finish left justification */
		while (width > 0) {
    10d4:	2f00      	cmp	r7, #0
    10d6:	dd07      	ble.n	10e8 <CONFIG_MAIN_STACK_SIZE+0xe8>
			OUTC(' ');
    10d8:	4629      	mov	r1, r5
    10da:	2020      	movs	r0, #32
    10dc:	47b0      	blx	r6
    10de:	2800      	cmp	r0, #0
    10e0:	db09      	blt.n	10f6 <CONFIG_MAIN_STACK_SIZE+0xf6>
    10e2:	3401      	adds	r4, #1
			--width;
    10e4:	3f01      	subs	r7, #1
    10e6:	e7f5      	b.n	10d4 <CONFIG_MAIN_STACK_SIZE+0xd4>
		fp = extract_conversion(conv, sp);
    10e8:	f8dd 9008 	ldr.w	r9, [sp, #8]
    10ec:	e544      	b.n	b78 <z_cbvprintf_impl+0x10>
    10ee:	f8dd 9008 	ldr.w	r9, [sp, #8]
    10f2:	e541      	b.n	b78 <z_cbvprintf_impl+0x10>
		}
	}

	return count;
    10f4:	4620      	mov	r0, r4
#undef OUTS
#undef OUTC
}
    10f6:	b011      	add	sp, #68	; 0x44
    10f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    10fc:	0000e405 	.word	0x0000e405

00001100 <nrfx_coredep_delay_us>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    1100:	b168      	cbz	r0, 111e <nrfx_coredep_delay_us+0x1e>
{
    1102:	b508      	push	{r3, lr}
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    1104:	4a06      	ldr	r2, [pc, #24]	; (1120 <nrfx_coredep_delay_us+0x20>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    1106:	4b07      	ldr	r3, [pc, #28]	; (1124 <nrfx_coredep_delay_us+0x24>)
    1108:	681b      	ldr	r3, [r3, #0]
    110a:	4907      	ldr	r1, [pc, #28]	; (1128 <nrfx_coredep_delay_us+0x28>)
    110c:	fba1 1303 	umull	r1, r3, r1, r3
    1110:	0c9b      	lsrs	r3, r3, #18
    delay_cycles(cycles);
    1112:	fb00 f003 	mul.w	r0, r0, r3
    1116:	f042 0301 	orr.w	r3, r2, #1
    111a:	4798      	blx	r3
}
    111c:	bd08      	pop	{r3, pc}
    111e:	4770      	bx	lr
    1120:	0000e090 	.word	0x0000e090
    1124:	200001cc 	.word	0x200001cc
    1128:	431bde83 	.word	0x431bde83

0000112c <nordicsemi_nrf53_init>:
    112c:	f04f 0320 	mov.w	r3, #32
    1130:	f3ef 8111 	mrs	r1, BASEPRI
    1134:	f383 8812 	msr	BASEPRI_MAX, r3
    1138:	f3bf 8f6f 	isb	sy

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_cache_enable(NRF_CACHE_Type * p_reg)
{
    p_reg->ENABLE = CACHE_ENABLE_ENABLE_Enabled;
    113c:	4b0f      	ldr	r3, [pc, #60]	; (117c <nordicsemi_nrf53_init+0x50>)
    113e:	2201      	movs	r2, #1
    1140:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}

NRF_STATIC_INLINE void nrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS_Type *     p_reg,
                                                    nrf_oscillators_lfxo_cap_t cap)
{
    p_reg->XOSC32KI.INTCAP = (uint32_t)cap;
    1144:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
    1148:	2202      	movs	r2, #2
    114a:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0

#if NRF_GPIO_HAS_SEL
NRF_STATIC_INLINE void nrf_gpio_pin_control_select(uint32_t pin_number, nrf_gpio_pin_sel_t ctrl)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    114e:	4a0c      	ldr	r2, [pc, #48]	; (1180 <nordicsemi_nrf53_init+0x54>)
    1150:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
    1154:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    reg->PIN_CNF[pin_number] = cnf | (ctrl << GPIO_PIN_CNF_MCUSEL_Pos);
    1158:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
    115c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    1160:	f8d2 3204 	ldr.w	r3, [r2, #516]	; 0x204
    1164:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    reg->PIN_CNF[pin_number] = cnf | (ctrl << GPIO_PIN_CNF_MCUSEL_Pos);
    1168:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
    116c:	f8c2 3204 	str.w	r3, [r2, #516]	; 0x204
	__asm__ volatile(
    1170:	f381 8811 	msr	BASEPRI, r1
    1174:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    1178:	2000      	movs	r0, #0
    117a:	4770      	bx	lr
    117c:	50001000 	.word	0x50001000
    1180:	50842500 	.word	0x50842500

00001184 <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
    1184:	2806      	cmp	r0, #6
    1186:	d000      	beq.n	118a <pm_state_set+0x6>
    1188:	4770      	bx	lr
{
    118a:	b508      	push	{r3, lr}
	case PM_STATE_SOFT_OFF:
		nrf_regulators_system_off(NRF_REGULATORS);
    118c:	4801      	ldr	r0, [pc, #4]	; (1194 <pm_state_set+0x10>)
    118e:	f009 f8c8 	bl	a322 <nrf_regulators_system_off>
    1192:	bf00      	nop
    1194:	50004000 	.word	0x50004000

00001198 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
    1198:	f003 b8e2 	b.w	4360 <SystemInit>

0000119c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
    119c:	b570      	push	{r4, r5, r6, lr}
    119e:	4605      	mov	r5, r0
	__asm__ volatile(
    11a0:	f04f 0320 	mov.w	r3, #32
    11a4:	f3ef 8611 	mrs	r6, BASEPRI
    11a8:	f383 8812 	msr	BASEPRI_MAX, r3
    11ac:	f3bf 8f6f 	isb	sy
    11b0:	4b0e      	ldr	r3, [pc, #56]	; (11ec <pm_state_notify+0x50>)
    11b2:	681c      	ldr	r4, [r3, #0]
    11b4:	e00d      	b.n	11d2 <pm_state_notify+0x36>
	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
		if (entering_state) {
			callback = notifier->state_entry;
		} else {
			callback = notifier->state_exit;
    11b6:	68a2      	ldr	r2, [r4, #8]
		}

		if (callback) {
    11b8:	b13a      	cbz	r2, 11ca <pm_state_notify+0x2e>
			callback(z_cpus_pm_state[_current_cpu->id].state);
    11ba:	4b0d      	ldr	r3, [pc, #52]	; (11f0 <pm_state_notify+0x54>)
    11bc:	7c1b      	ldrb	r3, [r3, #16]
    11be:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    11c2:	490c      	ldr	r1, [pc, #48]	; (11f4 <pm_state_notify+0x58>)
    11c4:	f811 0023 	ldrb.w	r0, [r1, r3, lsl #2]
    11c8:	4790      	blx	r2
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    11ca:	4623      	mov	r3, r4
	return node->next;
    11cc:	6824      	ldr	r4, [r4, #0]
    11ce:	b104      	cbz	r4, 11d2 <pm_state_notify+0x36>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    11d0:	b123      	cbz	r3, 11dc <pm_state_notify+0x40>
    11d2:	b12c      	cbz	r4, 11e0 <pm_state_notify+0x44>
		if (entering_state) {
    11d4:	2d00      	cmp	r5, #0
    11d6:	d0ee      	beq.n	11b6 <pm_state_notify+0x1a>
			callback = notifier->state_entry;
    11d8:	6862      	ldr	r2, [r4, #4]
    11da:	e7ed      	b.n	11b8 <pm_state_notify+0x1c>
    11dc:	461c      	mov	r4, r3
    11de:	e7f8      	b.n	11d2 <pm_state_notify+0x36>
	__asm__ volatile(
    11e0:	f386 8811 	msr	BASEPRI, r6
    11e4:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
    11e8:	bd70      	pop	{r4, r5, r6, pc}
    11ea:	bf00      	nop
    11ec:	20000884 	.word	0x20000884
    11f0:	200013e0 	.word	0x200013e0
    11f4:	20000878 	.word	0x20000878

000011f8 <pm_exit_pos_ops>:
{
    11f8:	b508      	push	{r3, lr}
	if (pm_state_exit_post_ops != NULL) {
    11fa:	4b06      	ldr	r3, [pc, #24]	; (1214 <pm_exit_pos_ops+0x1c>)
    11fc:	b123      	cbz	r3, 1208 <pm_exit_pos_ops+0x10>
		pm_state_exit_post_ops(info->state, info->substate_id);
    11fe:	7841      	ldrb	r1, [r0, #1]
    1200:	7800      	ldrb	r0, [r0, #0]
    1202:	f009 f895 	bl	a330 <pm_state_exit_post_ops>
}
    1206:	bd08      	pop	{r3, pc}
    1208:	2300      	movs	r3, #0
    120a:	f383 8811 	msr	BASEPRI, r3
    120e:	f3bf 8f6f 	isb	sy
    1212:	e7f8      	b.n	1206 <pm_exit_pos_ops+0xe>
    1214:	0000a331 	.word	0x0000a331

00001218 <pm_system_resume>:

void pm_system_resume(void)
{
    1218:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
    121a:	4b0e      	ldr	r3, [pc, #56]	; (1254 <pm_system_resume+0x3c>)
    121c:	7c1c      	ldrb	r4, [r3, #16]
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    121e:	4621      	mov	r1, r4
    1220:	480d      	ldr	r0, [pc, #52]	; (1258 <pm_system_resume+0x40>)
    1222:	f009 f899 	bl	a358 <atomic_test_and_clear_bit>
    1226:	b900      	cbnz	r0, 122a <pm_system_resume+0x12>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
			0, 0};
	}
}
    1228:	bd70      	pop	{r4, r5, r6, pc}
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
    122a:	0065      	lsls	r5, r4, #1
    122c:	eb04 0044 	add.w	r0, r4, r4, lsl #1
    1230:	4e0a      	ldr	r6, [pc, #40]	; (125c <pm_system_resume+0x44>)
    1232:	eb06 0080 	add.w	r0, r6, r0, lsl #2
    1236:	f7ff ffdf 	bl	11f8 <pm_exit_pos_ops>
		pm_state_notify(false);
    123a:	2000      	movs	r0, #0
    123c:	f7ff ffae 	bl	119c <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    1240:	192b      	adds	r3, r5, r4
    1242:	0099      	lsls	r1, r3, #2
    1244:	eb06 0383 	add.w	r3, r6, r3, lsl #2
    1248:	2200      	movs	r2, #0
    124a:	5072      	str	r2, [r6, r1]
    124c:	605a      	str	r2, [r3, #4]
    124e:	609a      	str	r2, [r3, #8]
}
    1250:	e7ea      	b.n	1228 <pm_system_resume+0x10>
    1252:	bf00      	nop
    1254:	200013e0 	.word	0x200013e0
    1258:	2000088c 	.word	0x2000088c
    125c:	20000878 	.word	0x20000878

00001260 <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
    1260:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1262:	4605      	mov	r5, r0
	uint8_t id = CURRENT_CPU;
    1264:	4b38      	ldr	r3, [pc, #224]	; (1348 <pm_system_suspend+0xe8>)
    1266:	7c1c      	ldrb	r4, [r3, #16]
	__asm__ volatile(
    1268:	f04f 0320 	mov.w	r3, #32
    126c:	f3ef 8611 	mrs	r6, BASEPRI
    1270:	f383 8812 	msr	BASEPRI_MAX, r3
    1274:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
    1278:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    127c:	4b33      	ldr	r3, [pc, #204]	; (134c <pm_system_suspend+0xec>)
    127e:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
    1282:	2b00      	cmp	r3, #0
    1284:	d039      	beq.n	12fa <pm_system_suspend+0x9a>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
    1286:	4b32      	ldr	r3, [pc, #200]	; (1350 <pm_system_suspend+0xf0>)
    1288:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
    128c:	4f2f      	ldr	r7, [pc, #188]	; (134c <pm_system_suspend+0xec>)
    128e:	ea4f 0e82 	mov.w	lr, r2, lsl #2
    1292:	eb07 0382 	add.w	r3, r7, r2, lsl #2
    1296:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    129a:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
    129e:	2300      	movs	r3, #0
    12a0:	f807 300e 	strb.w	r3, [r7, lr]
	__asm__ volatile(
    12a4:	f386 8811 	msr	BASEPRI, r6
    12a8:	f3bf 8f6f 	isb	sy
			z_cpus_pm_state[id] = *info;
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
    12ac:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    12b0:	4a27      	ldr	r2, [pc, #156]	; (1350 <pm_system_suspend+0xf0>)
    12b2:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    12b6:	2b00      	cmp	r3, #0
    12b8:	d044      	beq.n	1344 <pm_system_suspend+0xe4>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
    12ba:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
    12be:	d12b      	bne.n	1318 <pm_system_suspend+0xb8>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    12c0:	f007 fa6c 	bl	879c <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
    12c4:	2001      	movs	r0, #1
    12c6:	f7ff ff69 	bl	119c <pm_state_notify>
	atomic_set_bit(z_post_ops_required, id);
    12ca:	4621      	mov	r1, r4
    12cc:	4821      	ldr	r0, [pc, #132]	; (1354 <pm_system_suspend+0xf4>)
    12ce:	f009 f85b 	bl	a388 <atomic_set_bit>
	if (pm_state_set != NULL) {
    12d2:	4b21      	ldr	r3, [pc, #132]	; (1358 <pm_system_suspend+0xf8>)
    12d4:	b15b      	cbz	r3, 12ee <pm_system_suspend+0x8e>
		pm_state_set(info->state, info->substate_id);
    12d6:	4a1e      	ldr	r2, [pc, #120]	; (1350 <pm_system_suspend+0xf0>)
    12d8:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    12dc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    12e0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    12e4:	7859      	ldrb	r1, [r3, #1]
    12e6:	f812 0024 	ldrb.w	r0, [r2, r4, lsl #2]
    12ea:	f7ff ff4b 	bl	1184 <pm_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
    12ee:	f7ff ff93 	bl	1218 <pm_system_resume>
	k_sched_unlock();
    12f2:	f007 fc3f 	bl	8b74 <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
    12f6:	2001      	movs	r0, #1
}
    12f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		info = pm_policy_next_state(id, ticks);
    12fa:	4601      	mov	r1, r0
    12fc:	4620      	mov	r0, r4
    12fe:	f000 f831 	bl	1364 <pm_policy_next_state>
		if (info != NULL) {
    1302:	2800      	cmp	r0, #0
    1304:	d0ce      	beq.n	12a4 <pm_system_suspend+0x44>
			z_cpus_pm_state[id] = *info;
    1306:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    130a:	4b11      	ldr	r3, [pc, #68]	; (1350 <pm_system_suspend+0xf0>)
    130c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    1310:	c807      	ldmia	r0, {r0, r1, r2}
    1312:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    1316:	e7c5      	b.n	12a4 <pm_system_suspend+0x44>
		     k_us_to_ticks_ceil32(
    1318:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    131c:	4b0c      	ldr	r3, [pc, #48]	; (1350 <pm_system_suspend+0xf0>)
    131e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    1322:	6898      	ldr	r0, [r3, #8]
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    1324:	0c41      	lsrs	r1, r0, #17
    1326:	03c0      	lsls	r0, r0, #15
    1328:	4b0c      	ldr	r3, [pc, #48]	; (135c <pm_system_suspend+0xfc>)
    132a:	18c0      	adds	r0, r0, r3
    132c:	4a0c      	ldr	r2, [pc, #48]	; (1360 <pm_system_suspend+0x100>)
    132e:	f04f 0300 	mov.w	r3, #0
    1332:	f141 0100 	adc.w	r1, r1, #0
    1336:	f7fe ff0d 	bl	154 <__aeabi_uldivmod>
		sys_clock_set_timeout(ticks -
    133a:	2101      	movs	r1, #1
    133c:	1a28      	subs	r0, r5, r0
    133e:	f002 ffc9 	bl	42d4 <sys_clock_set_timeout>
    1342:	e7bd      	b.n	12c0 <pm_system_suspend+0x60>
		return false;
    1344:	2000      	movs	r0, #0
    1346:	e7d7      	b.n	12f8 <pm_system_suspend+0x98>
    1348:	200013e0 	.word	0x200013e0
    134c:	2000086c 	.word	0x2000086c
    1350:	20000878 	.word	0x20000878
    1354:	2000088c 	.word	0x2000088c
    1358:	00001185 	.word	0x00001185
    135c:	000f423f 	.word	0x000f423f
    1360:	000f4240 	.word	0x000f4240

00001364 <pm_policy_next_state>:
	}
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
    1364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1368:	b082      	sub	sp, #8
    136a:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
    136c:	a901      	add	r1, sp, #4
    136e:	f000 f845 	bl	13fc <pm_state_cpu_get_all>

	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    1372:	1e44      	subs	r4, r0, #1
    1374:	b224      	sxth	r4, r4
    1376:	e007      	b.n	1388 <pm_policy_next_state+0x24>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
		    (exit_latency >= max_latency_ticks)) {
			continue;
		}

		if ((ticks == K_TICKS_FOREVER) ||
    1378:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
    137c:	d033      	beq.n	13e6 <pm_policy_next_state+0x82>
		    (ticks >= (min_residency + exit_latency))) {
    137e:	4480      	add	r8, r0
		if ((ticks == K_TICKS_FOREVER) ||
    1380:	45b0      	cmp	r8, r6
    1382:	d930      	bls.n	13e6 <pm_policy_next_state+0x82>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    1384:	3c01      	subs	r4, #1
    1386:	b224      	sxth	r4, r4
    1388:	2c00      	cmp	r4, #0
    138a:	db2b      	blt.n	13e4 <pm_policy_next_state+0x80>
		const struct pm_state_info *state = &cpu_states[i];
    138c:	9b01      	ldr	r3, [sp, #4]
    138e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    1392:	eb03 0582 	add.w	r5, r3, r2, lsl #2
		if (pm_policy_state_lock_is_active(state->state, state->substate_id)) {
    1396:	7869      	ldrb	r1, [r5, #1]
    1398:	f813 0022 	ldrb.w	r0, [r3, r2, lsl #2]
    139c:	f009 f803 	bl	a3a6 <pm_policy_state_lock_is_active>
    13a0:	2800      	cmp	r0, #0
    13a2:	d1ef      	bne.n	1384 <pm_policy_next_state+0x20>
		min_residency = k_us_to_ticks_ceil32(state->min_residency_us);
    13a4:	6868      	ldr	r0, [r5, #4]
    13a6:	0c41      	lsrs	r1, r0, #17
    13a8:	03c0      	lsls	r0, r0, #15
    13aa:	4f11      	ldr	r7, [pc, #68]	; (13f0 <pm_policy_next_state+0x8c>)
    13ac:	19c0      	adds	r0, r0, r7
    13ae:	4a11      	ldr	r2, [pc, #68]	; (13f4 <pm_policy_next_state+0x90>)
    13b0:	f04f 0300 	mov.w	r3, #0
    13b4:	f141 0100 	adc.w	r1, r1, #0
    13b8:	f7fe fecc 	bl	154 <__aeabi_uldivmod>
    13bc:	4680      	mov	r8, r0
		exit_latency = k_us_to_ticks_ceil32(state->exit_latency_us);
    13be:	68ab      	ldr	r3, [r5, #8]
    13c0:	0c59      	lsrs	r1, r3, #17
    13c2:	03db      	lsls	r3, r3, #15
    13c4:	19d8      	adds	r0, r3, r7
    13c6:	4a0b      	ldr	r2, [pc, #44]	; (13f4 <pm_policy_next_state+0x90>)
    13c8:	f04f 0300 	mov.w	r3, #0
    13cc:	f141 0100 	adc.w	r1, r1, #0
    13d0:	f7fe fec0 	bl	154 <__aeabi_uldivmod>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
    13d4:	4b08      	ldr	r3, [pc, #32]	; (13f8 <pm_policy_next_state+0x94>)
    13d6:	681b      	ldr	r3, [r3, #0]
    13d8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    13dc:	d0cc      	beq.n	1378 <pm_policy_next_state+0x14>
    13de:	4283      	cmp	r3, r0
    13e0:	d8ca      	bhi.n	1378 <pm_policy_next_state+0x14>
    13e2:	e7cf      	b.n	1384 <pm_policy_next_state+0x20>
			return state;
		}
	}

	return NULL;
    13e4:	2500      	movs	r5, #0
}
    13e6:	4628      	mov	r0, r5
    13e8:	b002      	add	sp, #8
    13ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    13ee:	bf00      	nop
    13f0:	000f423f 	.word	0x000f423f
    13f4:	000f4240 	.word	0x000f4240
    13f8:	20000130 	.word	0x20000130

000013fc <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD_SEP(DT_PATH(cpus), DT_NUM_CPU_POWER_STATES, (,))
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
    13fc:	b908      	cbnz	r0, 1402 <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
    13fe:	4b02      	ldr	r3, [pc, #8]	; (1408 <pm_state_cpu_get_all+0xc>)
    1400:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
    1402:	2000      	movs	r0, #0
    1404:	4770      	bx	lr
    1406:	bf00      	nop
    1408:	0000e410 	.word	0x0000e410

0000140c <get_flash_area_from_id>:

extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static inline struct flash_area const *get_flash_area_from_id(int idx)
{
    140c:	4684      	mov	ip, r0
	for (int i = 0; i < flash_map_entries; i++) {
    140e:	2300      	movs	r3, #0
    1410:	e000      	b.n	1414 <get_flash_area_from_id+0x8>
    1412:	3301      	adds	r3, #1
    1414:	4a07      	ldr	r2, [pc, #28]	; (1434 <get_flash_area_from_id+0x28>)
    1416:	6812      	ldr	r2, [r2, #0]
    1418:	429a      	cmp	r2, r3
    141a:	dd08      	ble.n	142e <get_flash_area_from_id+0x22>
		if (flash_map[i].fa_id == idx) {
    141c:	011a      	lsls	r2, r3, #4
    141e:	4906      	ldr	r1, [pc, #24]	; (1438 <get_flash_area_from_id+0x2c>)
    1420:	6809      	ldr	r1, [r1, #0]
    1422:	eb01 1003 	add.w	r0, r1, r3, lsl #4
    1426:	5c8a      	ldrb	r2, [r1, r2]
    1428:	4562      	cmp	r2, ip
    142a:	d1f2      	bne.n	1412 <get_flash_area_from_id+0x6>
    142c:	e000      	b.n	1430 <get_flash_area_from_id+0x24>
			return &flash_map[i];
		}
	}

	return NULL;
    142e:	2000      	movs	r0, #0
}
    1430:	4770      	bx	lr
    1432:	bf00      	nop
    1434:	0000e410 	.word	0x0000e410
    1438:	20000134 	.word	0x20000134

0000143c <flash_area_open>:
		user_cb(&flash_map[i], user_data);
	}
}

int flash_area_open(uint8_t id, const struct flash_area **fap)
{
    143c:	b538      	push	{r3, r4, r5, lr}
	const struct flash_area *area;

	if (flash_map == NULL) {
    143e:	4b0c      	ldr	r3, [pc, #48]	; (1470 <flash_area_open+0x34>)
    1440:	681b      	ldr	r3, [r3, #0]
    1442:	b17b      	cbz	r3, 1464 <flash_area_open+0x28>
    1444:	460c      	mov	r4, r1
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
    1446:	f7ff ffe1 	bl	140c <get_flash_area_from_id>
	if (area == NULL) {
    144a:	4605      	mov	r5, r0
    144c:	b168      	cbz	r0, 146a <flash_area_open+0x2e>
		return -ENOENT;
	}

	if (!area->fa_dev || !device_is_ready(area->fa_dev)) {
    144e:	68c0      	ldr	r0, [r0, #12]
    1450:	b128      	cbz	r0, 145e <flash_area_open+0x22>
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
    1452:	f00c f906 	bl	d662 <z_device_is_ready>
    1456:	b110      	cbz	r0, 145e <flash_area_open+0x22>
		return -ENODEV;
	}

	*fap = area;
    1458:	6025      	str	r5, [r4, #0]

	return 0;
    145a:	2000      	movs	r0, #0
}
    145c:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
    145e:	f06f 0012 	mvn.w	r0, #18
    1462:	e7fb      	b.n	145c <flash_area_open+0x20>
		return -EACCES;
    1464:	f06f 000c 	mvn.w	r0, #12
    1468:	e7f8      	b.n	145c <flash_area_open+0x20>
		return -ENOENT;
    146a:	f06f 0001 	mvn.w	r0, #1
    146e:	e7f5      	b.n	145c <flash_area_open+0x20>
    1470:	20000134 	.word	0x20000134

00001474 <nrf_cc3xx_platform_abort_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform abort APIs.
 */
void nrf_cc3xx_platform_abort_init(void)
{
    1474:	b508      	push	{r3, lr}
	nrf_cc3xx_platform_set_abort(&apis);
    1476:	4802      	ldr	r0, [pc, #8]	; (1480 <nrf_cc3xx_platform_abort_init+0xc>)
    1478:	f007 fe66 	bl	9148 <nrf_cc3xx_platform_set_abort>
}
    147c:	bd08      	pop	{r3, pc}
    147e:	bf00      	nop
    1480:	0000e494 	.word	0x0000e494

00001484 <mutex_flags_unknown>:
                    NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_HW_MUTEX :
                    NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_VALID
};

static bool mutex_flags_unknown(uint32_t flags){
    switch(flags){
    1484:	f5b0 0f68 	cmp.w	r0, #15204352	; 0xe80000
    1488:	d017      	beq.n	14ba <mutex_flags_unknown+0x36>
    148a:	d80c      	bhi.n	14a6 <mutex_flags_unknown+0x22>
    148c:	f640 63ba 	movw	r3, #3770	; 0xeba
    1490:	4298      	cmp	r0, r3
    1492:	d014      	beq.n	14be <mutex_flags_unknown+0x3a>
    1494:	f5b0 3f68 	cmp.w	r0, #237568	; 0x3a000
    1498:	d013      	beq.n	14c2 <mutex_flags_unknown+0x3e>
    149a:	283a      	cmp	r0, #58	; 0x3a
    149c:	d001      	beq.n	14a2 <mutex_flags_unknown+0x1e>
        case NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID:
        case NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_HW_MUTEX:
        case NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC:
            return false;
        default:
            return true;
    149e:	2001      	movs	r0, #1
    14a0:	4770      	bx	lr
    switch(flags){
    14a2:	2000      	movs	r0, #0
    14a4:	4770      	bx	lr
    14a6:	4b09      	ldr	r3, [pc, #36]	; (14cc <mutex_flags_unknown+0x48>)
    14a8:	4298      	cmp	r0, r3
    14aa:	d00c      	beq.n	14c6 <mutex_flags_unknown+0x42>
    14ac:	4b08      	ldr	r3, [pc, #32]	; (14d0 <mutex_flags_unknown+0x4c>)
    14ae:	4298      	cmp	r0, r3
    14b0:	d001      	beq.n	14b6 <mutex_flags_unknown+0x32>
            return true;
    14b2:	2001      	movs	r0, #1
    }
}
    14b4:	4770      	bx	lr
    switch(flags){
    14b6:	2000      	movs	r0, #0
    14b8:	4770      	bx	lr
    14ba:	2000      	movs	r0, #0
    14bc:	4770      	bx	lr
    14be:	2000      	movs	r0, #0
    14c0:	4770      	bx	lr
    14c2:	2000      	movs	r0, #0
    14c4:	4770      	bx	lr
    14c6:	2000      	movs	r0, #0
    14c8:	4770      	bx	lr
    14ca:	bf00      	nop
    14cc:	3a00003a 	.word	0x3a00003a
    14d0:	a95c5f2c 	.word	0xa95c5f2c

000014d4 <mutex_unlock_platform>:
 */
static int32_t mutex_unlock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    14d4:	b328      	cbz	r0, 1522 <mutex_unlock_platform+0x4e>
static int32_t mutex_unlock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    14d6:	b508      	push	{r3, lr}
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    }

    switch (mutex->flags)
    14d8:	6843      	ldr	r3, [r0, #4]
    14da:	f5b3 3f68 	cmp.w	r3, #237568	; 0x3a000
    14de:	d00a      	beq.n	14f6 <mutex_unlock_platform+0x22>
    14e0:	f5b3 0f68 	cmp.w	r3, #15204352	; 0xe80000
    14e4:	d014      	beq.n	1510 <mutex_unlock_platform+0x3c>

#endif /* defined(NRF5340_XXAA_APPLICATION) */

    default:
        /* Ensure that the mutex has been initialized */
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    14e6:	4912      	ldr	r1, [pc, #72]	; (1530 <mutex_unlock_platform+0x5c>)
    14e8:	428b      	cmp	r3, r1
    14ea:	d01f      	beq.n	152c <mutex_unlock_platform+0x58>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
        }

        p_mutex = (struct k_mutex *)mutex->mutex;
    14ec:	6800      	ldr	r0, [r0, #0]
		union { uintptr_t x; struct k_mutex * val; } parm0 = { .val = mutex };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
    14ee:	f007 f82b 	bl	8548 <z_impl_k_mutex_unlock>

        k_mutex_unlock(p_mutex);
        return NRF_CC3XX_PLATFORM_SUCCESS;
    14f2:	2000      	movs	r0, #0
    14f4:	e014      	b.n	1520 <mutex_unlock_platform+0x4c>
        return atomic_cas((atomic_t *)mutex->mutex, 1, 0) ?
    14f6:	6803      	ldr	r3, [r0, #0]
 * @return true if @a new_value is written, false otherwise.
 */
static inline bool atomic_cas(atomic_t *target, atomic_val_t old_value,
			  atomic_val_t new_value)
{
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    14f8:	2200      	movs	r2, #0
    14fa:	e8d3 1fef 	ldaex	r1, [r3]
    14fe:	2901      	cmp	r1, #1
    1500:	d103      	bne.n	150a <mutex_unlock_platform+0x36>
    1502:	e8c3 2fe0 	stlex	r0, r2, [r3]
    1506:	2800      	cmp	r0, #0
    1508:	d1f7      	bne.n	14fa <mutex_unlock_platform+0x26>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    150a:	d10d      	bne.n	1528 <mutex_unlock_platform+0x54>
    150c:	4610      	mov	r0, r2
    150e:	e007      	b.n	1520 <mutex_unlock_platform+0x4c>
        nrf_mutex_unlock(NRF_MUTEX, *((uint8_t *)mutex->mutex));
    1510:	6803      	ldr	r3, [r0, #0]
    1512:	781b      	ldrb	r3, [r3, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
}

NRF_STATIC_INLINE void nrf_mutex_unlock(NRF_MUTEX_Type * p_reg, uint8_t mutex)
{
    p_reg->MUTEX[mutex] = MUTEX_MUTEX_MUTEX_Unlocked;
    1514:	f503 7380 	add.w	r3, r3, #256	; 0x100
    1518:	2000      	movs	r0, #0
    151a:	4a06      	ldr	r2, [pc, #24]	; (1534 <mutex_unlock_platform+0x60>)
    151c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    }
}
    1520:	bd08      	pop	{r3, pc}
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    1522:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
}
    1526:	4770      	bx	lr
                       NRF_CC3XX_PLATFORM_SUCCESS :
    1528:	4803      	ldr	r0, [pc, #12]	; (1538 <mutex_unlock_platform+0x64>)
    152a:	e7f9      	b.n	1520 <mutex_unlock_platform+0x4c>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    152c:	4803      	ldr	r0, [pc, #12]	; (153c <mutex_unlock_platform+0x68>)
    152e:	e7f7      	b.n	1520 <mutex_unlock_platform+0x4c>
    1530:	a95c5f2c 	.word	0xa95c5f2c
    1534:	50030000 	.word	0x50030000
    1538:	ffff8fe9 	.word	0xffff8fe9
    153c:	ffff8fea 	.word	0xffff8fea

00001540 <mutex_lock_platform>:
    if(mutex == NULL) {
    1540:	b388      	cbz	r0, 15a6 <mutex_lock_platform+0x66>
static int32_t mutex_lock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    1542:	b508      	push	{r3, lr}
    switch (mutex->flags) {
    1544:	6843      	ldr	r3, [r0, #4]
    1546:	f5b3 3f68 	cmp.w	r3, #237568	; 0x3a000
    154a:	d00f      	beq.n	156c <mutex_lock_platform+0x2c>
    154c:	f5b3 0f68 	cmp.w	r3, #15204352	; 0xe80000
    1550:	d019      	beq.n	1586 <mutex_lock_platform+0x46>
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    1552:	4916      	ldr	r1, [pc, #88]	; (15ac <mutex_lock_platform+0x6c>)
    1554:	428b      	cmp	r3, r1
    1556:	d024      	beq.n	15a2 <mutex_lock_platform+0x62>
        p_mutex = (struct k_mutex *)mutex->mutex;
    1558:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    155a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    155e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1562:	f006 ff6d 	bl	8440 <z_impl_k_mutex_lock>
        if (ret == 0) {
    1566:	b168      	cbz	r0, 1584 <mutex_lock_platform+0x44>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_FAILED;
    1568:	4811      	ldr	r0, [pc, #68]	; (15b0 <mutex_lock_platform+0x70>)
    156a:	e00b      	b.n	1584 <mutex_lock_platform+0x44>
        return atomic_cas((atomic_t *)mutex->mutex, 0, 1) ?
    156c:	6803      	ldr	r3, [r0, #0]
    156e:	2201      	movs	r2, #1
    1570:	e8d3 1fef 	ldaex	r1, [r3]
    1574:	2900      	cmp	r1, #0
    1576:	d103      	bne.n	1580 <mutex_lock_platform+0x40>
    1578:	e8c3 2fe0 	stlex	r0, r2, [r3]
    157c:	2800      	cmp	r0, #0
    157e:	d1f7      	bne.n	1570 <mutex_lock_platform+0x30>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    1580:	d10b      	bne.n	159a <mutex_lock_platform+0x5a>
    1582:	2000      	movs	r0, #0
}
    1584:	bd08      	pop	{r3, pc}
        return nrf_mutex_lock(NRF_MUTEX, *((uint8_t *)mutex->mutex)) ?
    1586:	6803      	ldr	r3, [r0, #0]
    1588:	781b      	ldrb	r3, [r3, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
    158a:	f503 7380 	add.w	r3, r3, #256	; 0x100
    158e:	4a09      	ldr	r2, [pc, #36]	; (15b4 <mutex_lock_platform+0x74>)
    1590:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
                       NRF_CC3XX_PLATFORM_SUCCESS :
    1594:	b91b      	cbnz	r3, 159e <mutex_lock_platform+0x5e>
    1596:	2000      	movs	r0, #0
    1598:	e7f4      	b.n	1584 <mutex_lock_platform+0x44>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    159a:	4805      	ldr	r0, [pc, #20]	; (15b0 <mutex_lock_platform+0x70>)
    159c:	e7f2      	b.n	1584 <mutex_lock_platform+0x44>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    159e:	4804      	ldr	r0, [pc, #16]	; (15b0 <mutex_lock_platform+0x70>)
    15a0:	e7f0      	b.n	1584 <mutex_lock_platform+0x44>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    15a2:	4805      	ldr	r0, [pc, #20]	; (15b8 <mutex_lock_platform+0x78>)
    15a4:	e7ee      	b.n	1584 <mutex_lock_platform+0x44>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    15a6:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
}
    15aa:	4770      	bx	lr
    15ac:	a95c5f2c 	.word	0xa95c5f2c
    15b0:	ffff8fe9 	.word	0xffff8fe9
    15b4:	50030000 	.word	0x50030000
    15b8:	ffff8fea 	.word	0xffff8fea

000015bc <mutex_free_platform>:
static void mutex_free_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    15bc:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    15be:	4604      	mov	r4, r0
    15c0:	b1a8      	cbz	r0, 15ee <mutex_free_platform+0x32>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    15c2:	6863      	ldr	r3, [r4, #4]
    15c4:	f5b3 3f68 	cmp.w	r3, #237568	; 0x3a000
    15c8:	d010      	beq.n	15ec <mutex_free_platform+0x30>
    15ca:	f5b3 0f68 	cmp.w	r3, #15204352	; 0xe80000
    15ce:	d00d      	beq.n	15ec <mutex_free_platform+0x30>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    15d0:	4a0c      	ldr	r2, [pc, #48]	; (1604 <mutex_free_platform+0x48>)
    15d2:	4293      	cmp	r3, r2
    15d4:	d00a      	beq.n	15ec <mutex_free_platform+0x30>
    if ((mutex->flags & NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED) != 0) {
    15d6:	f413 6f68 	tst.w	r3, #3712	; 0xe80
    15da:	d00d      	beq.n	15f8 <mutex_free_platform+0x3c>
        k_mem_slab_free(&mutex_slab, &mutex->mutex);
    15dc:	4621      	mov	r1, r4
    15de:	480a      	ldr	r0, [pc, #40]	; (1608 <mutex_free_platform+0x4c>)
    15e0:	f00c f90b 	bl	d7fa <k_mem_slab_free>
        mutex->mutex = NULL;
    15e4:	2300      	movs	r3, #0
    15e6:	6023      	str	r3, [r4, #0]
    mutex->flags = NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID;
    15e8:	4b06      	ldr	r3, [pc, #24]	; (1604 <mutex_free_platform+0x48>)
    15ea:	6063      	str	r3, [r4, #4]
}
    15ec:	bd10      	pop	{r4, pc}
        platform_abort_apis.abort_fn(
    15ee:	4b07      	ldr	r3, [pc, #28]	; (160c <mutex_free_platform+0x50>)
    15f0:	685b      	ldr	r3, [r3, #4]
    15f2:	4807      	ldr	r0, [pc, #28]	; (1610 <mutex_free_platform+0x54>)
    15f4:	4798      	blx	r3
    15f6:	e7e4      	b.n	15c2 <mutex_free_platform+0x6>
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    15f8:	2214      	movs	r2, #20
    15fa:	2100      	movs	r1, #0
    15fc:	6820      	ldr	r0, [r4, #0]
    15fe:	f009 f88c 	bl	a71a <memset>
    1602:	e7f1      	b.n	15e8 <mutex_free_platform+0x2c>
    1604:	a95c5f2c 	.word	0xa95c5f2c
    1608:	20000d90 	.word	0x20000d90
    160c:	20000254 	.word	0x20000254
    1610:	0000e49c 	.word	0x0000e49c

00001614 <mutex_init_platform>:
static void mutex_init_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    1614:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    1616:	4604      	mov	r4, r0
    1618:	b358      	cbz	r0, 1672 <mutex_init_platform+0x5e>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    161a:	6860      	ldr	r0, [r4, #4]
    161c:	f5b0 3f68 	cmp.w	r0, #237568	; 0x3a000
    1620:	d026      	beq.n	1670 <mutex_init_platform+0x5c>
    1622:	f5b0 0f68 	cmp.w	r0, #15204352	; 0xe80000
    1626:	d023      	beq.n	1670 <mutex_init_platform+0x5c>
    if ((mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID && mutex->mutex == NULL) ||
    1628:	4b16      	ldr	r3, [pc, #88]	; (1684 <mutex_init_platform+0x70>)
    162a:	4298      	cmp	r0, r3
    162c:	d026      	beq.n	167c <mutex_init_platform+0x68>
        mutex_flags_unknown(mutex->flags)) {
    162e:	f7ff ff29 	bl	1484 <mutex_flags_unknown>
    if ((mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID && mutex->mutex == NULL) ||
    1632:	b1b0      	cbz	r0, 1662 <mutex_init_platform+0x4e>
        ret = k_mem_slab_alloc(&mutex_slab, &mutex->mutex, K_FOREVER);
    1634:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    1638:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    163c:	4621      	mov	r1, r4
    163e:	4812      	ldr	r0, [pc, #72]	; (1688 <mutex_init_platform+0x74>)
    1640:	f006 fe24 	bl	828c <k_mem_slab_alloc>
        if(ret != 0 || mutex->mutex == NULL)
    1644:	b908      	cbnz	r0, 164a <mutex_init_platform+0x36>
    1646:	6823      	ldr	r3, [r4, #0]
    1648:	b91b      	cbnz	r3, 1652 <mutex_init_platform+0x3e>
            platform_abort_apis.abort_fn(
    164a:	4b10      	ldr	r3, [pc, #64]	; (168c <mutex_init_platform+0x78>)
    164c:	685b      	ldr	r3, [r3, #4]
    164e:	4810      	ldr	r0, [pc, #64]	; (1690 <mutex_init_platform+0x7c>)
    1650:	4798      	blx	r3
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    1652:	2214      	movs	r2, #20
    1654:	2100      	movs	r1, #0
    1656:	6820      	ldr	r0, [r4, #0]
    1658:	f009 f85f 	bl	a71a <memset>
        mutex->flags = NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED;
    165c:	f44f 6368 	mov.w	r3, #3712	; 0xe80
    1660:	6063      	str	r3, [r4, #4]
    p_mutex = (struct k_mutex *)mutex->mutex;
    1662:	6820      	ldr	r0, [r4, #0]
	return z_impl_k_mutex_init(mutex);
    1664:	f00c f933 	bl	d8ce <z_impl_k_mutex_init>
    mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_VALID;
    1668:	6863      	ldr	r3, [r4, #4]
    166a:	f043 033a 	orr.w	r3, r3, #58	; 0x3a
    166e:	6063      	str	r3, [r4, #4]
}
    1670:	bd10      	pop	{r4, pc}
        platform_abort_apis.abort_fn(
    1672:	4b06      	ldr	r3, [pc, #24]	; (168c <mutex_init_platform+0x78>)
    1674:	685b      	ldr	r3, [r3, #4]
    1676:	4807      	ldr	r0, [pc, #28]	; (1694 <mutex_init_platform+0x80>)
    1678:	4798      	blx	r3
    167a:	e7ce      	b.n	161a <mutex_init_platform+0x6>
    if ((mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID && mutex->mutex == NULL) ||
    167c:	6823      	ldr	r3, [r4, #0]
    167e:	2b00      	cmp	r3, #0
    1680:	d1d5      	bne.n	162e <mutex_init_platform+0x1a>
    1682:	e7d7      	b.n	1634 <mutex_init_platform+0x20>
    1684:	a95c5f2c 	.word	0xa95c5f2c
    1688:	20000d90 	.word	0x20000d90
    168c:	20000254 	.word	0x20000254
    1690:	0000e4c4 	.word	0x0000e4c4
    1694:	0000e49c 	.word	0x0000e49c

00001698 <nrf_cc3xx_platform_mutex_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform mutex APIs
 */
void nrf_cc3xx_platform_mutex_init(void)
{
    1698:	b508      	push	{r3, lr}
    k_mem_slab_init(&mutex_slab,
    169a:	2340      	movs	r3, #64	; 0x40
    169c:	2214      	movs	r2, #20
    169e:	4904      	ldr	r1, [pc, #16]	; (16b0 <nrf_cc3xx_platform_mutex_init+0x18>)
    16a0:	4804      	ldr	r0, [pc, #16]	; (16b4 <nrf_cc3xx_platform_mutex_init+0x1c>)
    16a2:	f00c f89c 	bl	d7de <k_mem_slab_init>
                mutex_slab_buffer,
                sizeof(struct k_mutex),
                NUM_MUTEXES);

    nrf_cc3xx_platform_set_mutexes(&mutex_apis, &mutexes);
    16a6:	4904      	ldr	r1, [pc, #16]	; (16b8 <nrf_cc3xx_platform_mutex_init+0x20>)
    16a8:	4804      	ldr	r0, [pc, #16]	; (16bc <nrf_cc3xx_platform_mutex_init+0x24>)
    16aa:	f007 fdbf 	bl	922c <nrf_cc3xx_platform_set_mutexes>
}
    16ae:	bd08      	pop	{r3, pc}
    16b0:	20000890 	.word	0x20000890
    16b4:	20000d90 	.word	0x20000d90
    16b8:	0000e4f4 	.word	0x0000e4f4
    16bc:	0000e508 	.word	0x0000e508

000016c0 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    16c0:	4901      	ldr	r1, [pc, #4]	; (16c8 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    16c2:	2210      	movs	r2, #16
	str	r2, [r1]
    16c4:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    16c6:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    16c8:	e000ed10 	.word	0xe000ed10

000016cc <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    16cc:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    16ce:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    16d0:	f380 8811 	msr	BASEPRI, r0
	isb
    16d4:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
    16d8:	f3bf 8f4f 	dsb	sy
    16dc:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    16de:	b662      	cpsie	i
	isb
    16e0:	f3bf 8f6f 	isb	sy

	bx	lr
    16e4:	4770      	bx	lr
    16e6:	bf00      	nop

000016e8 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    16e8:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    16ea:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    16ec:	f381 8811 	msr	BASEPRI, r1

	_sleep_if_allowed wfe
    16f0:	f3bf 8f4f 	dsb	sy
    16f4:	bf20      	wfe

	msr	BASEPRI, r0
    16f6:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    16fa:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    16fc:	4770      	bx	lr
    16fe:	bf00      	nop

00001700 <esf_dump>:
#include <kernel_arch_data.h>
#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

static void esf_dump(const z_arch_esf_t *esf)
{
    1700:	b510      	push	{r4, lr}
    1702:	b082      	sub	sp, #8
    1704:	4604      	mov	r4, r0
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    1706:	6883      	ldr	r3, [r0, #8]
    1708:	9300      	str	r3, [sp, #0]
    170a:	6843      	ldr	r3, [r0, #4]
    170c:	6802      	ldr	r2, [r0, #0]
    170e:	2145      	movs	r1, #69	; 0x45
    1710:	480b      	ldr	r0, [pc, #44]	; (1740 <esf_dump+0x40>)
    1712:	f008 fe13 	bl	a33c <z_log_minimal_printk>
		esf->basic.a1, esf->basic.a2, esf->basic.a3);
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    1716:	6963      	ldr	r3, [r4, #20]
    1718:	9300      	str	r3, [sp, #0]
    171a:	6923      	ldr	r3, [r4, #16]
    171c:	68e2      	ldr	r2, [r4, #12]
    171e:	2145      	movs	r1, #69	; 0x45
    1720:	4808      	ldr	r0, [pc, #32]	; (1744 <esf_dump+0x44>)
    1722:	f008 fe0b 	bl	a33c <z_log_minimal_printk>
		esf->basic.a4, esf->basic.ip, esf->basic.lr);
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    1726:	69e2      	ldr	r2, [r4, #28]
    1728:	2145      	movs	r1, #69	; 0x45
    172a:	4807      	ldr	r0, [pc, #28]	; (1748 <esf_dump+0x48>)
    172c:	f008 fe06 	bl	a33c <z_log_minimal_printk>
	}

	LOG_ERR("EXC_RETURN: 0x%0x", esf->extra_info.exc_return);

#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    1730:	69a2      	ldr	r2, [r4, #24]
    1732:	2145      	movs	r1, #69	; 0x45
    1734:	4805      	ldr	r0, [pc, #20]	; (174c <esf_dump+0x4c>)
    1736:	f008 fe01 	bl	a33c <z_log_minimal_printk>
		esf->basic.pc);
}
    173a:	b002      	add	sp, #8
    173c:	bd10      	pop	{r4, pc}
    173e:	bf00      	nop
    1740:	0000e518 	.word	0x0000e518
    1744:	0000e54c 	.word	0x0000e54c
    1748:	0000e580 	.word	0x0000e580
    174c:	0000e594 	.word	0x0000e594

00001750 <__NVIC_EnableIRQ>:
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    1750:	2800      	cmp	r0, #0
    1752:	db07      	blt.n	1764 <__NVIC_EnableIRQ+0x14>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1754:	f000 021f 	and.w	r2, r0, #31
    1758:	0940      	lsrs	r0, r0, #5
    175a:	2301      	movs	r3, #1
    175c:	4093      	lsls	r3, r2
    175e:	4a02      	ldr	r2, [pc, #8]	; (1768 <__NVIC_EnableIRQ+0x18>)
    1760:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    __COMPILER_BARRIER();
  }
}
    1764:	4770      	bx	lr
    1766:	bf00      	nop
    1768:	e000e100 	.word	0xe000e100

0000176c <__NVIC_DisableIRQ>:
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    176c:	2800      	cmp	r0, #0
    176e:	db0c      	blt.n	178a <__NVIC_DisableIRQ+0x1e>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1770:	f000 021f 	and.w	r2, r0, #31
    1774:	0940      	lsrs	r0, r0, #5
    1776:	2301      	movs	r3, #1
    1778:	4093      	lsls	r3, r2
    177a:	3020      	adds	r0, #32
    177c:	4a03      	ldr	r2, [pc, #12]	; (178c <__NVIC_DisableIRQ+0x20>)
    177e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    1782:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1786:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    178a:	4770      	bx	lr
    178c:	e000e100 	.word	0xe000e100

00001790 <__NVIC_SetPriority>:
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    1790:	2800      	cmp	r0, #0
    1792:	db08      	blt.n	17a6 <__NVIC_SetPriority+0x16>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1794:	0149      	lsls	r1, r1, #5
    1796:	b2c9      	uxtb	r1, r1
    1798:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
    179c:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
    17a0:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
    17a4:	4770      	bx	lr
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    17a6:	f000 000f 	and.w	r0, r0, #15
    17aa:	0149      	lsls	r1, r1, #5
    17ac:	b2c9      	uxtb	r1, r1
    17ae:	4b01      	ldr	r3, [pc, #4]	; (17b4 <__NVIC_SetPriority+0x24>)
    17b0:	5419      	strb	r1, [r3, r0]
  }
}
    17b2:	4770      	bx	lr
    17b4:	e000ed14 	.word	0xe000ed14

000017b8 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    17b8:	0942      	lsrs	r2, r0, #5
    17ba:	4b05      	ldr	r3, [pc, #20]	; (17d0 <arch_irq_is_enabled+0x18>)
    17bc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    17c0:	f000 001f 	and.w	r0, r0, #31
    17c4:	2301      	movs	r3, #1
    17c6:	fa03 f000 	lsl.w	r0, r3, r0
}
    17ca:	4010      	ands	r0, r2
    17cc:	4770      	bx	lr
    17ce:	bf00      	nop
    17d0:	e000e100 	.word	0xe000e100

000017d4 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    17d4:	bf30      	wfi
    b z_SysNmiOnReset
    17d6:	f7ff bffd 	b.w	17d4 <z_SysNmiOnReset>
    17da:	bf00      	nop

000017dc <z_arm_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
    17dc:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    17de:	4b0b      	ldr	r3, [pc, #44]	; (180c <z_arm_prep_c+0x30>)
    17e0:	4a0b      	ldr	r2, [pc, #44]	; (1810 <z_arm_prep_c+0x34>)
    17e2:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    17e6:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    17e8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    17ec:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    17f0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    17f4:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    17f8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    17fc:	f006 fc80 	bl	8100 <z_bss_zero>
	z_data_copy();
    1800:	f007 fb0a 	bl	8e18 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    1804:	f000 fb3c 	bl	1e80 <z_arm_interrupt_init>
	z_cstart();
    1808:	f006 fcd6 	bl	81b8 <z_cstart>
    180c:	e000ed00 	.word	0xe000ed00
    1810:	00000000 	.word	0x00000000

00001814 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    1814:	4a09      	ldr	r2, [pc, #36]	; (183c <arch_swap+0x28>)
    1816:	6893      	ldr	r3, [r2, #8]
    1818:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
    181a:	4909      	ldr	r1, [pc, #36]	; (1840 <arch_swap+0x2c>)
    181c:	6809      	ldr	r1, [r1, #0]
    181e:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1820:	4908      	ldr	r1, [pc, #32]	; (1844 <arch_swap+0x30>)
    1822:	684b      	ldr	r3, [r1, #4]
    1824:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    1828:	604b      	str	r3, [r1, #4]
    182a:	2300      	movs	r3, #0
    182c:	f383 8811 	msr	BASEPRI, r3
    1830:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    1834:	6893      	ldr	r3, [r2, #8]
}
    1836:	6f98      	ldr	r0, [r3, #120]	; 0x78
    1838:	4770      	bx	lr
    183a:	bf00      	nop
    183c:	200013e0 	.word	0x200013e0
    1840:	0000f730 	.word	0x0000f730
    1844:	e000ed00 	.word	0xe000ed00

00001848 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    1848:	4913      	ldr	r1, [pc, #76]	; (1898 <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
    184a:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    184c:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    1850:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    1852:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    1856:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    185a:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
    185c:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    1860:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    1864:	4f0d      	ldr	r7, [pc, #52]	; (189c <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    1866:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    186a:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
    186c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    186e:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    1870:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
    1872:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    1874:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    1876:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    187a:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    187e:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    1882:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
    1886:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
    188a:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
    188c:	f008 fe0e 	bl	a4ac <configure_builtin_stack_guard>
    pop {r2, lr}
    1890:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    1894:	4770      	bx	lr
    1896:	0000      	.short	0x0000
    ldr r1, =_kernel
    1898:	200013e0 	.word	0x200013e0
    ldr v4, =_SCS_ICSR
    189c:	e000ed04 	.word	0xe000ed04

000018a0 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    18a0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    18a4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    18a6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    18aa:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    18ae:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    18b0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    18b4:	2902      	cmp	r1, #2
    beq _oops
    18b6:	d0ff      	beq.n	18b8 <_oops>

000018b8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    18b8:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
    18ba:	f008 fdd5 	bl	a468 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
    18be:	bd01      	pop	{r0, pc}

000018c0 <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    18c0:	b410      	push	{r4}
		thread->stack_info.size -= FP_GUARD_EXTRA_SIZE;
	}
#endif /* FP_GUARD_EXTRA_SIZE */
#endif /* CONFIG_MPU_STACK_GUARD */

	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    18c2:	f1a2 0420 	sub.w	r4, r2, #32
		iframe->pc = (uint32_t)arch_user_mode_enter;
	} else {
		iframe->pc = (uint32_t)z_thread_entry;
	}
#else
	iframe->pc = (uint32_t)z_thread_entry;
    18c6:	490d      	ldr	r1, [pc, #52]	; (18fc <arch_new_thread+0x3c>)
    18c8:	f842 1c08 	str.w	r1, [r2, #-8]
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
    18cc:	f021 0101 	bic.w	r1, r1, #1
    18d0:	f842 1c08 	str.w	r1, [r2, #-8]
#endif
	iframe->a1 = (uint32_t)entry;
    18d4:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    18d8:	9b01      	ldr	r3, [sp, #4]
    18da:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
    18de:	9b02      	ldr	r3, [sp, #8]
    18e0:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    18e4:	9b03      	ldr	r3, [sp, #12]
    18e6:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    18ea:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    18ee:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe = (struct __basic_sf *)
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
    18f2:	6504      	str	r4, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    18f4:	2300      	movs	r3, #0
    18f6:	6743      	str	r3, [r0, #116]	; 0x74
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    18f8:	bc10      	pop	{r4}
    18fa:	4770      	bx	lr
    18fc:	0000948f 	.word	0x0000948f

00001900 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    1900:	4b08      	ldr	r3, [pc, #32]	; (1924 <arch_switch_to_main_thread+0x24>)
    1902:	6098      	str	r0, [r3, #8]
#endif

#if defined(CONFIG_BUILTIN_STACK_GUARD)
	/* Set PSPLIM register for built-in stack guarding of main thread. */
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
	__set_PSPLIM(main_thread->stack_info.start);
    1904:	6e43      	ldr	r3, [r0, #100]	; 0x64
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
    1906:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    190a:	4610      	mov	r0, r2
    190c:	f381 8809 	msr	PSP, r1
    1910:	2100      	movs	r1, #0
    1912:	b663      	cpsie	if
    1914:	f381 8811 	msr	BASEPRI, r1
    1918:	f3bf 8f6f 	isb	sy
    191c:	2200      	movs	r2, #0
    191e:	2300      	movs	r3, #0
    1920:	f007 fdb5 	bl	948e <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    1924:	200013e0 	.word	0x200013e0

00001928 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    1928:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    192a:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    192c:	4a0b      	ldr	r2, [pc, #44]	; (195c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    192e:	6950      	ldr	r0, [r2, #20]
	cmp r0, #0
    1930:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    1932:	bf1e      	ittt	ne
	movne	r1, #0
    1934:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    1936:	6151      	strne	r1, [r2, #20]
		blne	z_pm_save_idle_exit
    1938:	f00b ffad 	blne	d896 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    193c:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    193e:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    1942:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    1946:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    194a:	4905      	ldr	r1, [pc, #20]	; (1960 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    194c:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    194e:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    1950:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    1952:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    1956:	4903      	ldr	r1, [pc, #12]	; (1964 <_isr_wrapper+0x3c>)
	bx r1
    1958:	4708      	bx	r1
    195a:	0000      	.short	0x0000
	ldr r2, =_kernel
    195c:	200013e0 	.word	0x200013e0
	ldr r1, =_sw_isr_table
    1960:	0000ddb4 	.word	0x0000ddb4
	ldr r1, =z_arm_int_exit
    1964:	00001969 	.word	0x00001969

00001968 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    1968:	4b04      	ldr	r3, [pc, #16]	; (197c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    196a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    196c:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
    196e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    1970:	d003      	beq.n	197a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    1972:	4903      	ldr	r1, [pc, #12]	; (1980 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    1974:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    1978:	600a      	str	r2, [r1, #0]

0000197a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    197a:	4770      	bx	lr
	ldr r3, =_kernel
    197c:	200013e0 	.word	0x200013e0
	ldr r1, =_SCS_ICSR
    1980:	e000ed04 	.word	0xe000ed04

00001984 <z_arm_is_synchronous_svc>:
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

static inline bool z_arm_is_synchronous_svc(z_arch_esf_t *esf)
{
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
    1984:	6981      	ldr	r1, [r0, #24]
	/* Note: ARMv6-M does not support CCR.BFHFNMIGN so this access
	 * could generate a fault if the pc was invalid.
	 */
	uint16_t fault_insn = *(ret_addr - 1);
#else
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
    1986:	4b0d      	ldr	r3, [pc, #52]	; (19bc <z_arm_is_synchronous_svc+0x38>)
    1988:	695a      	ldr	r2, [r3, #20]
    198a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    198e:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    1990:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1994:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();

	uint16_t fault_insn = *(ret_addr - 1);
    1998:	f831 1c02 	ldrh.w	r1, [r1, #-2]

	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
    199c:	695a      	ldr	r2, [r3, #20]
    199e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    19a2:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
    19a4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    19a8:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
#endif /* ARMV6_M_ARMV8_M_BASELINE && !ARMV8_M_BASELINE */

	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    19ac:	f64d 7302 	movw	r3, #57090	; 0xdf02
    19b0:	4299      	cmp	r1, r3
    19b2:	d001      	beq.n	19b8 <z_arm_is_synchronous_svc+0x34>
		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
		return true;
	}
#undef _SVC_OPCODE
	return false;
    19b4:	2000      	movs	r0, #0
    19b6:	4770      	bx	lr
		return true;
    19b8:	2001      	movs	r0, #1
}
    19ba:	4770      	bx	lr
    19bc:	e000ed00 	.word	0xe000ed00

000019c0 <get_esf>:
	bool *nested_exc)
{
	bool alternative_state_exc = false;
	z_arch_esf_t *ptr_esf = NULL;

	*nested_exc = false;
    19c0:	f04f 0c00 	mov.w	ip, #0
    19c4:	f883 c000 	strb.w	ip, [r3]

	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    19c8:	f002 4c7f 	and.w	ip, r2, #4278190080	; 0xff000000
    19cc:	f1bc 4f7f 	cmp.w	ip, #4278190080	; 0xff000000
    19d0:	d113      	bne.n	19fa <get_esf+0x3a>
	}
#else
	/* The processor has a single execution state.
	 * We verify that the Thread mode is using PSP.
	 */
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    19d2:	f002 0c0c 	and.w	ip, r2, #12
    19d6:	f1bc 0f08 	cmp.w	ip, #8
    19da:	d004      	beq.n	19e6 <get_esf+0x26>
		return NULL;
	}
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	if (!alternative_state_exc) {
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    19dc:	f012 0f08 	tst.w	r2, #8
    19e0:	d008      	beq.n	19f4 <get_esf+0x34>
			/* Returning to thread mode */
			ptr_esf =  (z_arch_esf_t *)psp;
    19e2:	4608      	mov	r0, r1
    19e4:	4770      	bx	lr
{
    19e6:	b508      	push	{r3, lr}
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    19e8:	2145      	movs	r1, #69	; 0x45
    19ea:	4805      	ldr	r0, [pc, #20]	; (1a00 <get_esf+0x40>)
    19ec:	f008 fca6 	bl	a33c <z_log_minimal_printk>
		return NULL;
    19f0:	2000      	movs	r0, #0
			*nested_exc = true;
		}
	}

	return ptr_esf;
}
    19f2:	bd08      	pop	{r3, pc}
			*nested_exc = true;
    19f4:	2201      	movs	r2, #1
    19f6:	701a      	strb	r2, [r3, #0]
    19f8:	4770      	bx	lr
		return NULL;
    19fa:	2000      	movs	r0, #0
}
    19fc:	4770      	bx	lr
    19fe:	bf00      	nop
    1a00:	0000e5c8 	.word	0x0000e5c8

00001a04 <mem_manage_fault>:
{
    1a04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a06:	4605      	mov	r5, r0
    1a08:	460f      	mov	r7, r1
    1a0a:	4614      	mov	r4, r2
	PR_FAULT_INFO("***** MPU FAULT *****");
    1a0c:	2145      	movs	r1, #69	; 0x45
    1a0e:	4836      	ldr	r0, [pc, #216]	; (1ae8 <mem_manage_fault+0xe4>)
    1a10:	f008 fc94 	bl	a33c <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    1a14:	4b35      	ldr	r3, [pc, #212]	; (1aec <mem_manage_fault+0xe8>)
    1a16:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a18:	f013 0f10 	tst.w	r3, #16
    1a1c:	d131      	bne.n	1a82 <mem_manage_fault+0x7e>
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
    1a1e:	2610      	movs	r6, #16
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    1a20:	4b32      	ldr	r3, [pc, #200]	; (1aec <mem_manage_fault+0xe8>)
    1a22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a24:	f013 0f08 	tst.w	r3, #8
    1a28:	d131      	bne.n	1a8e <mem_manage_fault+0x8a>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    1a2a:	4b30      	ldr	r3, [pc, #192]	; (1aec <mem_manage_fault+0xe8>)
    1a2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a2e:	f013 0f02 	tst.w	r3, #2
    1a32:	d132      	bne.n	1a9a <mem_manage_fault+0x96>
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    1a34:	4b2d      	ldr	r3, [pc, #180]	; (1aec <mem_manage_fault+0xe8>)
    1a36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a38:	f013 0f01 	tst.w	r3, #1
    1a3c:	d147      	bne.n	1ace <mem_manage_fault+0xca>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    1a3e:	4b2b      	ldr	r3, [pc, #172]	; (1aec <mem_manage_fault+0xe8>)
    1a40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a42:	f013 0f20 	tst.w	r3, #32
    1a46:	d148      	bne.n	1ada <mem_manage_fault+0xd6>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    1a48:	4b28      	ldr	r3, [pc, #160]	; (1aec <mem_manage_fault+0xe8>)
    1a4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a4c:	f013 0f10 	tst.w	r3, #16
    1a50:	d101      	bne.n	1a56 <mem_manage_fault+0x52>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    1a52:	4b26      	ldr	r3, [pc, #152]	; (1aec <mem_manage_fault+0xe8>)
    1a54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    1a56:	4b25      	ldr	r3, [pc, #148]	; (1aec <mem_manage_fault+0xe8>)
    1a58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1a5a:	f013 0f20 	tst.w	r3, #32
    1a5e:	d004      	beq.n	1a6a <mem_manage_fault+0x66>
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
    1a60:	4a22      	ldr	r2, [pc, #136]	; (1aec <mem_manage_fault+0xe8>)
    1a62:	6a53      	ldr	r3, [r2, #36]	; 0x24
    1a64:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    1a68:	6253      	str	r3, [r2, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    1a6a:	4a20      	ldr	r2, [pc, #128]	; (1aec <mem_manage_fault+0xe8>)
    1a6c:	6a93      	ldr	r3, [r2, #40]	; 0x28
    1a6e:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    1a72:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    1a74:	2101      	movs	r1, #1
    1a76:	4628      	mov	r0, r5
    1a78:	f008 fd1c 	bl	a4b4 <memory_fault_recoverable>
    1a7c:	7020      	strb	r0, [r4, #0]
}
    1a7e:	4630      	mov	r0, r6
    1a80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		PR_FAULT_INFO("  Stacking error (context area might be"
    1a82:	2145      	movs	r1, #69	; 0x45
    1a84:	481a      	ldr	r0, [pc, #104]	; (1af0 <mem_manage_fault+0xec>)
    1a86:	f008 fc59 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_MEM_STACKING;
    1a8a:	2611      	movs	r6, #17
    1a8c:	e7c8      	b.n	1a20 <mem_manage_fault+0x1c>
		PR_FAULT_INFO("  Unstacking error");
    1a8e:	2145      	movs	r1, #69	; 0x45
    1a90:	4818      	ldr	r0, [pc, #96]	; (1af4 <mem_manage_fault+0xf0>)
    1a92:	f008 fc53 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_MEM_UNSTACKING;
    1a96:	2612      	movs	r6, #18
    1a98:	e7c7      	b.n	1a2a <mem_manage_fault+0x26>
		PR_FAULT_INFO("  Data Access Violation");
    1a9a:	2145      	movs	r1, #69	; 0x45
    1a9c:	4816      	ldr	r0, [pc, #88]	; (1af8 <mem_manage_fault+0xf4>)
    1a9e:	f008 fc4d 	bl	a33c <z_log_minimal_printk>
		uint32_t temp = SCB->MMFAR;
    1aa2:	4b12      	ldr	r3, [pc, #72]	; (1aec <mem_manage_fault+0xe8>)
    1aa4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    1aa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1aa8:	f013 0f80 	tst.w	r3, #128	; 0x80
    1aac:	d101      	bne.n	1ab2 <mem_manage_fault+0xae>
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
    1aae:	2613      	movs	r6, #19
    1ab0:	e7c0      	b.n	1a34 <mem_manage_fault+0x30>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    1ab2:	2145      	movs	r1, #69	; 0x45
    1ab4:	4811      	ldr	r0, [pc, #68]	; (1afc <mem_manage_fault+0xf8>)
    1ab6:	f008 fc41 	bl	a33c <z_log_minimal_printk>
			if (from_hard_fault != 0) {
    1aba:	b137      	cbz	r7, 1aca <mem_manage_fault+0xc6>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    1abc:	4a0b      	ldr	r2, [pc, #44]	; (1aec <mem_manage_fault+0xe8>)
    1abe:	6a93      	ldr	r3, [r2, #40]	; 0x28
    1ac0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    1ac4:	6293      	str	r3, [r2, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
    1ac6:	2613      	movs	r6, #19
    1ac8:	e7b4      	b.n	1a34 <mem_manage_fault+0x30>
    1aca:	2613      	movs	r6, #19
    1acc:	e7b2      	b.n	1a34 <mem_manage_fault+0x30>
		PR_FAULT_INFO("  Instruction Access Violation");
    1ace:	2145      	movs	r1, #69	; 0x45
    1ad0:	480b      	ldr	r0, [pc, #44]	; (1b00 <mem_manage_fault+0xfc>)
    1ad2:	f008 fc33 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
    1ad6:	2614      	movs	r6, #20
    1ad8:	e7b1      	b.n	1a3e <mem_manage_fault+0x3a>
		PR_FAULT_INFO(
    1ada:	2145      	movs	r1, #69	; 0x45
    1adc:	4809      	ldr	r0, [pc, #36]	; (1b04 <mem_manage_fault+0x100>)
    1ade:	f008 fc2d 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
    1ae2:	2615      	movs	r6, #21
    1ae4:	e7b0      	b.n	1a48 <mem_manage_fault+0x44>
    1ae6:	bf00      	nop
    1ae8:	0000e5f8 	.word	0x0000e5f8
    1aec:	e000ed00 	.word	0xe000ed00
    1af0:	0000e614 	.word	0x0000e614
    1af4:	0000e64c 	.word	0x0000e64c
    1af8:	0000e664 	.word	0x0000e664
    1afc:	0000e684 	.word	0x0000e684
    1b00:	0000e6a0 	.word	0x0000e6a0
    1b04:	0000e6c4 	.word	0x0000e6c4

00001b08 <bus_fault>:
{
    1b08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1b0a:	4605      	mov	r5, r0
    1b0c:	460f      	mov	r7, r1
    1b0e:	4614      	mov	r4, r2
	PR_FAULT_INFO("***** BUS FAULT *****");
    1b10:	2145      	movs	r1, #69	; 0x45
    1b12:	4833      	ldr	r0, [pc, #204]	; (1be0 <bus_fault+0xd8>)
    1b14:	f008 fc12 	bl	a33c <z_log_minimal_printk>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    1b18:	4b32      	ldr	r3, [pc, #200]	; (1be4 <bus_fault+0xdc>)
    1b1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b1c:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    1b20:	d125      	bne.n	1b6e <bus_fault+0x66>
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
    1b22:	2616      	movs	r6, #22
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    1b24:	4b2f      	ldr	r3, [pc, #188]	; (1be4 <bus_fault+0xdc>)
    1b26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b28:	f413 6f00 	tst.w	r3, #2048	; 0x800
    1b2c:	d125      	bne.n	1b7a <bus_fault+0x72>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    1b2e:	4b2d      	ldr	r3, [pc, #180]	; (1be4 <bus_fault+0xdc>)
    1b30:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b32:	f413 7f00 	tst.w	r3, #512	; 0x200
    1b36:	d126      	bne.n	1b86 <bus_fault+0x7e>
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    1b38:	4b2a      	ldr	r3, [pc, #168]	; (1be4 <bus_fault+0xdc>)
    1b3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b3c:	f413 6f80 	tst.w	r3, #1024	; 0x400
    1b40:	d13b      	bne.n	1bba <bus_fault+0xb2>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    1b42:	4b28      	ldr	r3, [pc, #160]	; (1be4 <bus_fault+0xdc>)
    1b44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b46:	f413 7f80 	tst.w	r3, #256	; 0x100
    1b4a:	d13c      	bne.n	1bc6 <bus_fault+0xbe>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    1b4c:	4b25      	ldr	r3, [pc, #148]	; (1be4 <bus_fault+0xdc>)
    1b4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b50:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    1b54:	d13d      	bne.n	1bd2 <bus_fault+0xca>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    1b56:	4a23      	ldr	r2, [pc, #140]	; (1be4 <bus_fault+0xdc>)
    1b58:	6a93      	ldr	r3, [r2, #40]	; 0x28
    1b5a:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    1b5e:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    1b60:	2101      	movs	r1, #1
    1b62:	4628      	mov	r0, r5
    1b64:	f008 fca6 	bl	a4b4 <memory_fault_recoverable>
    1b68:	7020      	strb	r0, [r4, #0]
}
    1b6a:	4630      	mov	r0, r6
    1b6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		PR_FAULT_INFO("  Stacking error");
    1b6e:	2145      	movs	r1, #69	; 0x45
    1b70:	481d      	ldr	r0, [pc, #116]	; (1be8 <bus_fault+0xe0>)
    1b72:	f008 fbe3 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_STACKING;
    1b76:	2617      	movs	r6, #23
    1b78:	e7d4      	b.n	1b24 <bus_fault+0x1c>
		PR_FAULT_INFO("  Unstacking error");
    1b7a:	2145      	movs	r1, #69	; 0x45
    1b7c:	481b      	ldr	r0, [pc, #108]	; (1bec <bus_fault+0xe4>)
    1b7e:	f008 fbdd 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_UNSTACKING;
    1b82:	2618      	movs	r6, #24
    1b84:	e7d3      	b.n	1b2e <bus_fault+0x26>
		PR_FAULT_INFO("  Precise data bus error");
    1b86:	2145      	movs	r1, #69	; 0x45
    1b88:	4819      	ldr	r0, [pc, #100]	; (1bf0 <bus_fault+0xe8>)
    1b8a:	f008 fbd7 	bl	a33c <z_log_minimal_printk>
		STORE_xFAR(bfar, SCB->BFAR);
    1b8e:	4b15      	ldr	r3, [pc, #84]	; (1be4 <bus_fault+0xdc>)
    1b90:	6b9a      	ldr	r2, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    1b92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b94:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    1b98:	d101      	bne.n	1b9e <bus_fault+0x96>
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
    1b9a:	2619      	movs	r6, #25
    1b9c:	e7cc      	b.n	1b38 <bus_fault+0x30>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    1b9e:	2145      	movs	r1, #69	; 0x45
    1ba0:	4814      	ldr	r0, [pc, #80]	; (1bf4 <bus_fault+0xec>)
    1ba2:	f008 fbcb 	bl	a33c <z_log_minimal_printk>
			if (from_hard_fault != 0) {
    1ba6:	b137      	cbz	r7, 1bb6 <bus_fault+0xae>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    1ba8:	4a0e      	ldr	r2, [pc, #56]	; (1be4 <bus_fault+0xdc>)
    1baa:	6a93      	ldr	r3, [r2, #40]	; 0x28
    1bac:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    1bb0:	6293      	str	r3, [r2, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
    1bb2:	2619      	movs	r6, #25
    1bb4:	e7c0      	b.n	1b38 <bus_fault+0x30>
    1bb6:	2619      	movs	r6, #25
    1bb8:	e7be      	b.n	1b38 <bus_fault+0x30>
		PR_FAULT_INFO("  Imprecise data bus error");
    1bba:	2145      	movs	r1, #69	; 0x45
    1bbc:	480e      	ldr	r0, [pc, #56]	; (1bf8 <bus_fault+0xf0>)
    1bbe:	f008 fbbd 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
    1bc2:	261a      	movs	r6, #26
    1bc4:	e7bd      	b.n	1b42 <bus_fault+0x3a>
		PR_FAULT_INFO("  Instruction bus error");
    1bc6:	2145      	movs	r1, #69	; 0x45
    1bc8:	480c      	ldr	r0, [pc, #48]	; (1bfc <bus_fault+0xf4>)
    1bca:	f008 fbb7 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
    1bce:	261b      	movs	r6, #27
    1bd0:	e7c1      	b.n	1b56 <bus_fault+0x4e>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    1bd2:	2145      	movs	r1, #69	; 0x45
    1bd4:	480a      	ldr	r0, [pc, #40]	; (1c00 <bus_fault+0xf8>)
    1bd6:	f008 fbb1 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
    1bda:	261c      	movs	r6, #28
    1bdc:	e7bb      	b.n	1b56 <bus_fault+0x4e>
    1bde:	bf00      	nop
    1be0:	0000e6f8 	.word	0x0000e6f8
    1be4:	e000ed00 	.word	0xe000ed00
    1be8:	0000e714 	.word	0x0000e714
    1bec:	0000e64c 	.word	0x0000e64c
    1bf0:	0000e72c 	.word	0x0000e72c
    1bf4:	0000e74c 	.word	0x0000e74c
    1bf8:	0000e768 	.word	0x0000e768
    1bfc:	0000e788 	.word	0x0000e788
    1c00:	0000e6c4 	.word	0x0000e6c4

00001c04 <usage_fault>:
{
    1c04:	b508      	push	{r3, lr}
	PR_FAULT_INFO("***** USAGE FAULT *****");
    1c06:	2145      	movs	r1, #69	; 0x45
    1c08:	482c      	ldr	r0, [pc, #176]	; (1cbc <usage_fault+0xb8>)
    1c0a:	f008 fb97 	bl	a33c <z_log_minimal_printk>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    1c0e:	4b2c      	ldr	r3, [pc, #176]	; (1cc0 <usage_fault+0xbc>)
    1c10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1c12:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    1c16:	d126      	bne.n	1c66 <usage_fault+0x62>
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
    1c18:	201d      	movs	r0, #29
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    1c1a:	4b29      	ldr	r3, [pc, #164]	; (1cc0 <usage_fault+0xbc>)
    1c1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1c1e:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
    1c22:	d126      	bne.n	1c72 <usage_fault+0x6e>
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    1c24:	4b26      	ldr	r3, [pc, #152]	; (1cc0 <usage_fault+0xbc>)
    1c26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1c28:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    1c2c:	d127      	bne.n	1c7e <usage_fault+0x7a>
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    1c2e:	4b24      	ldr	r3, [pc, #144]	; (1cc0 <usage_fault+0xbc>)
    1c30:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1c32:	f413 2f00 	tst.w	r3, #524288	; 0x80000
    1c36:	d128      	bne.n	1c8a <usage_fault+0x86>
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    1c38:	4b21      	ldr	r3, [pc, #132]	; (1cc0 <usage_fault+0xbc>)
    1c3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1c3c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    1c40:	d129      	bne.n	1c96 <usage_fault+0x92>
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    1c42:	4b1f      	ldr	r3, [pc, #124]	; (1cc0 <usage_fault+0xbc>)
    1c44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1c46:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    1c4a:	d12a      	bne.n	1ca2 <usage_fault+0x9e>
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    1c4c:	4b1c      	ldr	r3, [pc, #112]	; (1cc0 <usage_fault+0xbc>)
    1c4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1c50:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    1c54:	d12b      	bne.n	1cae <usage_fault+0xaa>
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    1c56:	4a1a      	ldr	r2, [pc, #104]	; (1cc0 <usage_fault+0xbc>)
    1c58:	6a93      	ldr	r3, [r2, #40]	; 0x28
    1c5a:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    1c5e:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    1c62:	6293      	str	r3, [r2, #40]	; 0x28
}
    1c64:	bd08      	pop	{r3, pc}
		PR_FAULT_INFO("  Division by zero");
    1c66:	2145      	movs	r1, #69	; 0x45
    1c68:	4816      	ldr	r0, [pc, #88]	; (1cc4 <usage_fault+0xc0>)
    1c6a:	f008 fb67 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_DIV_0;
    1c6e:	201e      	movs	r0, #30
    1c70:	e7d3      	b.n	1c1a <usage_fault+0x16>
		PR_FAULT_INFO("  Unaligned memory access");
    1c72:	2145      	movs	r1, #69	; 0x45
    1c74:	4814      	ldr	r0, [pc, #80]	; (1cc8 <usage_fault+0xc4>)
    1c76:	f008 fb61 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
    1c7a:	201f      	movs	r0, #31
    1c7c:	e7d2      	b.n	1c24 <usage_fault+0x20>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
    1c7e:	2145      	movs	r1, #69	; 0x45
    1c80:	4812      	ldr	r0, [pc, #72]	; (1ccc <usage_fault+0xc8>)
    1c82:	f008 fb5b 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_STACK_CHK_FAIL;
    1c86:	2002      	movs	r0, #2
    1c88:	e7d1      	b.n	1c2e <usage_fault+0x2a>
		PR_FAULT_INFO("  No coprocessor instructions");
    1c8a:	2145      	movs	r1, #69	; 0x45
    1c8c:	4810      	ldr	r0, [pc, #64]	; (1cd0 <usage_fault+0xcc>)
    1c8e:	f008 fb55 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
    1c92:	2021      	movs	r0, #33	; 0x21
    1c94:	e7d0      	b.n	1c38 <usage_fault+0x34>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    1c96:	2145      	movs	r1, #69	; 0x45
    1c98:	480e      	ldr	r0, [pc, #56]	; (1cd4 <usage_fault+0xd0>)
    1c9a:	f008 fb4f 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
    1c9e:	2022      	movs	r0, #34	; 0x22
    1ca0:	e7cf      	b.n	1c42 <usage_fault+0x3e>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    1ca2:	2145      	movs	r1, #69	; 0x45
    1ca4:	480c      	ldr	r0, [pc, #48]	; (1cd8 <usage_fault+0xd4>)
    1ca6:	f008 fb49 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
    1caa:	2023      	movs	r0, #35	; 0x23
    1cac:	e7ce      	b.n	1c4c <usage_fault+0x48>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    1cae:	2145      	movs	r1, #69	; 0x45
    1cb0:	480a      	ldr	r0, [pc, #40]	; (1cdc <usage_fault+0xd8>)
    1cb2:	f008 fb43 	bl	a33c <z_log_minimal_printk>
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
    1cb6:	2024      	movs	r0, #36	; 0x24
    1cb8:	e7cd      	b.n	1c56 <usage_fault+0x52>
    1cba:	bf00      	nop
    1cbc:	0000e7a8 	.word	0x0000e7a8
    1cc0:	e000ed00 	.word	0xe000ed00
    1cc4:	0000e7c8 	.word	0x0000e7c8
    1cc8:	0000e7e0 	.word	0x0000e7e0
    1ccc:	0000e800 	.word	0x0000e800
    1cd0:	0000e830 	.word	0x0000e830
    1cd4:	0000e854 	.word	0x0000e854
    1cd8:	0000e880 	.word	0x0000e880
    1cdc:	0000e8a0 	.word	0x0000e8a0

00001ce0 <hard_fault>:
{
    1ce0:	b570      	push	{r4, r5, r6, lr}
    1ce2:	4606      	mov	r6, r0
    1ce4:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** HARD FAULT *****");
    1ce6:	2145      	movs	r1, #69	; 0x45
    1ce8:	4828      	ldr	r0, [pc, #160]	; (1d8c <hard_fault+0xac>)
    1cea:	f008 fb27 	bl	a33c <z_log_minimal_printk>
	*recoverable = false;
    1cee:	2300      	movs	r3, #0
    1cf0:	702b      	strb	r3, [r5, #0]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    1cf2:	4b27      	ldr	r3, [pc, #156]	; (1d90 <hard_fault+0xb0>)
    1cf4:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    1cf6:	f014 0402 	ands.w	r4, r4, #2
    1cfa:	d10a      	bne.n	1d12 <hard_fault+0x32>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    1cfc:	4b24      	ldr	r3, [pc, #144]	; (1d90 <hard_fault+0xb0>)
    1cfe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d00:	2b00      	cmp	r3, #0
    1d02:	db0c      	blt.n	1d1e <hard_fault+0x3e>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    1d04:	4b22      	ldr	r3, [pc, #136]	; (1d90 <hard_fault+0xb0>)
    1d06:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    1d08:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
    1d0c:	d10c      	bne.n	1d28 <hard_fault+0x48>
}
    1d0e:	4620      	mov	r0, r4
    1d10:	bd70      	pop	{r4, r5, r6, pc}
		PR_EXC("  Bus fault on vector table read");
    1d12:	2145      	movs	r1, #69	; 0x45
    1d14:	481f      	ldr	r0, [pc, #124]	; (1d94 <hard_fault+0xb4>)
    1d16:	f008 fb11 	bl	a33c <z_log_minimal_printk>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    1d1a:	2400      	movs	r4, #0
    1d1c:	e7f7      	b.n	1d0e <hard_fault+0x2e>
		PR_EXC("  Debug event");
    1d1e:	2145      	movs	r1, #69	; 0x45
    1d20:	481d      	ldr	r0, [pc, #116]	; (1d98 <hard_fault+0xb8>)
    1d22:	f008 fb0b 	bl	a33c <z_log_minimal_printk>
    1d26:	e7f2      	b.n	1d0e <hard_fault+0x2e>
		PR_EXC("  Fault escalation (see below)");
    1d28:	2145      	movs	r1, #69	; 0x45
    1d2a:	481c      	ldr	r0, [pc, #112]	; (1d9c <hard_fault+0xbc>)
    1d2c:	f008 fb06 	bl	a33c <z_log_minimal_printk>
		if (z_arm_is_synchronous_svc(esf)) {
    1d30:	4630      	mov	r0, r6
    1d32:	f7ff fe27 	bl	1984 <z_arm_is_synchronous_svc>
    1d36:	b998      	cbnz	r0, 1d60 <hard_fault+0x80>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
    1d38:	4b15      	ldr	r3, [pc, #84]	; (1d90 <hard_fault+0xb0>)
    1d3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1d3c:	f013 0fff 	tst.w	r3, #255	; 0xff
    1d40:	d115      	bne.n	1d6e <hard_fault+0x8e>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
    1d42:	4b13      	ldr	r3, [pc, #76]	; (1d90 <hard_fault+0xb0>)
    1d44:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    1d46:	f414 447f 	ands.w	r4, r4, #65280	; 0xff00
    1d4a:	d117      	bne.n	1d7c <hard_fault+0x9c>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
    1d4c:	4b10      	ldr	r3, [pc, #64]	; (1d90 <hard_fault+0xb0>)
    1d4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1d50:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    1d54:	d3db      	bcc.n	1d0e <hard_fault+0x2e>
			reason = usage_fault(esf);
    1d56:	4630      	mov	r0, r6
    1d58:	f7ff ff54 	bl	1c04 <usage_fault>
    1d5c:	4604      	mov	r4, r0
	return reason;
    1d5e:	e7d6      	b.n	1d0e <hard_fault+0x2e>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
    1d60:	6832      	ldr	r2, [r6, #0]
    1d62:	2145      	movs	r1, #69	; 0x45
    1d64:	480e      	ldr	r0, [pc, #56]	; (1da0 <hard_fault+0xc0>)
    1d66:	f008 fae9 	bl	a33c <z_log_minimal_printk>
			reason = esf->basic.r0;
    1d6a:	6834      	ldr	r4, [r6, #0]
    1d6c:	e7cf      	b.n	1d0e <hard_fault+0x2e>
			reason = mem_manage_fault(esf, 1, recoverable);
    1d6e:	462a      	mov	r2, r5
    1d70:	2101      	movs	r1, #1
    1d72:	4630      	mov	r0, r6
    1d74:	f7ff fe46 	bl	1a04 <mem_manage_fault>
    1d78:	4604      	mov	r4, r0
    1d7a:	e7c8      	b.n	1d0e <hard_fault+0x2e>
			reason = bus_fault(esf, 1, recoverable);
    1d7c:	462a      	mov	r2, r5
    1d7e:	2101      	movs	r1, #1
    1d80:	4630      	mov	r0, r6
    1d82:	f7ff fec1 	bl	1b08 <bus_fault>
    1d86:	4604      	mov	r4, r0
    1d88:	e7c1      	b.n	1d0e <hard_fault+0x2e>
    1d8a:	bf00      	nop
    1d8c:	0000e8d0 	.word	0x0000e8d0
    1d90:	e000ed00 	.word	0xe000ed00
    1d94:	0000e8ec 	.word	0x0000e8ec
    1d98:	0000e914 	.word	0x0000e914
    1d9c:	0000e928 	.word	0x0000e928
    1da0:	0000e94c 	.word	0x0000e94c

00001da4 <debug_monitor>:
{
    1da4:	b508      	push	{r3, lr}
	*recoverable = false;
    1da6:	2300      	movs	r3, #0
    1da8:	700b      	strb	r3, [r1, #0]
	PR_FAULT_INFO(
    1daa:	2145      	movs	r1, #69	; 0x45
    1dac:	4801      	ldr	r0, [pc, #4]	; (1db4 <debug_monitor+0x10>)
    1dae:	f008 fac5 	bl	a33c <z_log_minimal_printk>
}
    1db2:	bd08      	pop	{r3, pc}
    1db4:	0000e970 	.word	0x0000e970

00001db8 <reserved_exception>:
{
    1db8:	b508      	push	{r3, lr}
	PR_FAULT_INFO("***** %s %d) *****",
    1dba:	290f      	cmp	r1, #15
    1dbc:	dc07      	bgt.n	1dce <reserved_exception+0x16>
    1dbe:	4a05      	ldr	r2, [pc, #20]	; (1dd4 <reserved_exception+0x1c>)
    1dc0:	f1a1 0310 	sub.w	r3, r1, #16
    1dc4:	2145      	movs	r1, #69	; 0x45
    1dc6:	4804      	ldr	r0, [pc, #16]	; (1dd8 <reserved_exception+0x20>)
    1dc8:	f008 fab8 	bl	a33c <z_log_minimal_printk>
}
    1dcc:	bd08      	pop	{r3, pc}
	PR_FAULT_INFO("***** %s %d) *****",
    1dce:	4a03      	ldr	r2, [pc, #12]	; (1ddc <reserved_exception+0x24>)
    1dd0:	e7f6      	b.n	1dc0 <reserved_exception+0x8>
    1dd2:	bf00      	nop
    1dd4:	0000e99c 	.word	0x0000e99c
    1dd8:	0000e9d0 	.word	0x0000e9d0
    1ddc:	0000e9b4 	.word	0x0000e9b4

00001de0 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    1de0:	b530      	push	{r4, r5, lr}
    1de2:	b08b      	sub	sp, #44	; 0x2c
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    1de4:	4b1a      	ldr	r3, [pc, #104]	; (1e50 <z_arm_fault+0x70>)
    1de6:	685c      	ldr	r4, [r3, #4]
    1de8:	f3c4 0408 	ubfx	r4, r4, #0, #9
    1dec:	2300      	movs	r3, #0
    1dee:	f383 8811 	msr	BASEPRI, r3
    1df2:	f3bf 8f6f 	isb	sy
	arch_irq_unlock(0);

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
    1df6:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    1dfa:	f7ff fde1 	bl	19c0 <get_esf>
    1dfe:	4605      	mov	r5, r0

#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
    1e00:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    1e04:	4621      	mov	r1, r4
    1e06:	f008 fb57 	bl	a4b8 <fault_handle>
	if (recoverable) {
    1e0a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    1e0e:	b10b      	cbz	r3, 1e14 <z_arm_fault+0x34>
	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
}
    1e10:	b00b      	add	sp, #44	; 0x2c
    1e12:	bd30      	pop	{r4, r5, pc}
    1e14:	4604      	mov	r4, r0
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    1e16:	2220      	movs	r2, #32
    1e18:	4629      	mov	r1, r5
    1e1a:	a801      	add	r0, sp, #4
    1e1c:	f008 fc4e 	bl	a6bc <memcpy>
	if (nested_exc) {
    1e20:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    1e24:	b14b      	cbz	r3, 1e3a <z_arm_fault+0x5a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    1e26:	9b08      	ldr	r3, [sp, #32]
    1e28:	f3c3 0208 	ubfx	r2, r3, #0, #9
    1e2c:	b95a      	cbnz	r2, 1e46 <z_arm_fault+0x66>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    1e2e:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    1e32:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    1e36:	9308      	str	r3, [sp, #32]
    1e38:	e005      	b.n	1e46 <z_arm_fault+0x66>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    1e3a:	9b08      	ldr	r3, [sp, #32]
    1e3c:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    1e40:	f023 0301 	bic.w	r3, r3, #1
    1e44:	9308      	str	r3, [sp, #32]
	z_arm_fatal_error(reason, &esf_copy);
    1e46:	a901      	add	r1, sp, #4
    1e48:	4620      	mov	r0, r4
    1e4a:	f008 fb01 	bl	a450 <z_arm_fatal_error>
    1e4e:	e7df      	b.n	1e10 <z_arm_fault+0x30>
    1e50:	e000ed00 	.word	0xe000ed00

00001e54 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    1e54:	4b04      	ldr	r3, [pc, #16]	; (1e68 <z_arm_fault_init+0x14>)
    1e56:	695a      	ldr	r2, [r3, #20]
    1e58:	f042 0210 	orr.w	r2, r2, #16
    1e5c:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
    1e5e:	695a      	ldr	r2, [r3, #20]
    1e60:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    1e64:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
    1e66:	4770      	bx	lr
    1e68:	e000ed00 	.word	0xe000ed00

00001e6c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    1e6c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    1e70:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    1e74:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    1e76:	4672      	mov	r2, lr
	bl z_arm_fault
    1e78:	f7ff ffb2 	bl	1de0 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    1e7c:	bd01      	pop	{r0, pc}
    1e7e:	bf00      	nop

00001e80 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    1e80:	2200      	movs	r2, #0

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    1e82:	e007      	b.n	1e94 <z_arm_interrupt_init+0x14>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1e84:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    1e88:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    1e8c:	2120      	movs	r1, #32
    1e8e:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    1e92:	3201      	adds	r2, #1
    1e94:	2a44      	cmp	r2, #68	; 0x44
    1e96:	dc09      	bgt.n	1eac <z_arm_interrupt_init+0x2c>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
    1e98:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
    1e9a:	2b00      	cmp	r3, #0
    1e9c:	daf2      	bge.n	1e84 <z_arm_interrupt_init+0x4>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1e9e:	f003 030f 	and.w	r3, r3, #15
    1ea2:	4903      	ldr	r1, [pc, #12]	; (1eb0 <z_arm_interrupt_init+0x30>)
    1ea4:	4419      	add	r1, r3
    1ea6:	2320      	movs	r3, #32
    1ea8:	760b      	strb	r3, [r1, #24]
    1eaa:	e7f2      	b.n	1e92 <z_arm_interrupt_init+0x12>
	}
}
    1eac:	4770      	bx	lr
    1eae:	bf00      	nop
    1eb0:	e000ecfc 	.word	0xe000ecfc

00001eb4 <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
    1eb4:	2000      	movs	r0, #0
    msr CONTROL, r0
    1eb6:	f380 8814 	msr	CONTROL, r0
    isb
    1eba:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
    1ebe:	2000      	movs	r0, #0
    msr MSPLIM, r0
    1ec0:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
    1ec4:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    1ec8:	f7ff f966 	bl	1198 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
    1ecc:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
    1ece:	490e      	ldr	r1, [pc, #56]	; (1f08 <__start+0x54>)
    str r0, [r1]
    1ed0:	6008      	str	r0, [r1, #0]
    dsb
    1ed2:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    1ed6:	480d      	ldr	r0, [pc, #52]	; (1f0c <__start+0x58>)
    msr msp, r0
    1ed8:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
    1edc:	f000 f82e 	bl	1f3c <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    1ee0:	2020      	movs	r0, #32
    msr BASEPRI, r0
    1ee2:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    1ee6:	480a      	ldr	r0, [pc, #40]	; (1f10 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    1ee8:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    1eec:	1840      	adds	r0, r0, r1
    msr PSP, r0
    1eee:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    1ef2:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    1ef6:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    1ef8:	4308      	orrs	r0, r1
    msr CONTROL, r0
    1efa:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    1efe:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    1f02:	f7ff fc6b 	bl	17dc <z_arm_prep_c>
    1f06:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
    1f08:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    1f0c:	200030b8 	.word	0x200030b8
    ldr r0, =z_interrupt_stacks
    1f10:	20001778 	.word	0x20001778

00001f14 <z_arm_clear_arm_mpu_config>:
void z_arm_clear_arm_mpu_config(void)
{
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
    1f14:	4b08      	ldr	r3, [pc, #32]	; (1f38 <z_arm_clear_arm_mpu_config+0x24>)
    1f16:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
	int num_regions =
    1f1a:	f3c0 2007 	ubfx	r0, r0, #8, #8

	for (i = 0; i < num_regions; i++) {
    1f1e:	2300      	movs	r3, #0
    1f20:	e006      	b.n	1f30 <z_arm_clear_arm_mpu_config+0x1c>
* \param mpu Pointer to MPU to be used.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
    1f22:	4a05      	ldr	r2, [pc, #20]	; (1f38 <z_arm_clear_arm_mpu_config+0x24>)
    1f24:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
  mpu->RLAR = 0U;
    1f28:	2100      	movs	r1, #0
    1f2a:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
    1f2e:	3301      	adds	r3, #1
    1f30:	4283      	cmp	r3, r0
    1f32:	dbf6      	blt.n	1f22 <z_arm_clear_arm_mpu_config+0xe>
		ARM_MPU_ClrRegion(i);
	}
}
    1f34:	4770      	bx	lr
    1f36:	bf00      	nop
    1f38:	e000ed00 	.word	0xe000ed00

00001f3c <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
    1f3c:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    1f3e:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
    1f40:	2400      	movs	r4, #0
    1f42:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
    1f46:	f7ff ffe5 	bl	1f14 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    1f4a:	4623      	mov	r3, r4
    1f4c:	e008      	b.n	1f60 <z_arm_init_arch_hw_at_boot+0x24>
		NVIC->ICER[i] = 0xFFFFFFFF;
    1f4e:	f103 0120 	add.w	r1, r3, #32
    1f52:	4a0e      	ldr	r2, [pc, #56]	; (1f8c <z_arm_init_arch_hw_at_boot+0x50>)
    1f54:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1f58:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    1f5c:	3301      	adds	r3, #1
    1f5e:	b2db      	uxtb	r3, r3
    1f60:	2b0f      	cmp	r3, #15
    1f62:	d9f4      	bls.n	1f4e <z_arm_init_arch_hw_at_boot+0x12>
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    1f64:	2300      	movs	r3, #0
    1f66:	e008      	b.n	1f7a <z_arm_init_arch_hw_at_boot+0x3e>
		NVIC->ICPR[i] = 0xFFFFFFFF;
    1f68:	f103 0160 	add.w	r1, r3, #96	; 0x60
    1f6c:	4a07      	ldr	r2, [pc, #28]	; (1f8c <z_arm_init_arch_hw_at_boot+0x50>)
    1f6e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1f72:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    1f76:	3301      	adds	r3, #1
    1f78:	b2db      	uxtb	r3, r3
    1f7a:	2b0f      	cmp	r3, #15
    1f7c:	d9f4      	bls.n	1f68 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
    1f7e:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
    1f80:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1f84:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
    1f88:	bd10      	pop	{r4, pc}
    1f8a:	bf00      	nop
    1f8c:	e000e100 	.word	0xe000e100

00001f90 <z_impl_k_thread_abort>:
#include <kswap.h>
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    1f90:	b508      	push	{r3, lr}
	if (_current == thread) {
    1f92:	4b0a      	ldr	r3, [pc, #40]	; (1fbc <z_impl_k_thread_abort+0x2c>)
    1f94:	689b      	ldr	r3, [r3, #8]
    1f96:	4283      	cmp	r3, r0
    1f98:	d002      	beq.n	1fa0 <z_impl_k_thread_abort+0x10>
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
		}
	}

	z_thread_abort(thread);
    1f9a:	f006 ff05 	bl	8da8 <z_thread_abort>
}
    1f9e:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    1fa0:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    1fa4:	2b00      	cmp	r3, #0
    1fa6:	d0f8      	beq.n	1f9a <z_impl_k_thread_abort+0xa>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    1fa8:	4b05      	ldr	r3, [pc, #20]	; (1fc0 <z_impl_k_thread_abort+0x30>)
    1faa:	685a      	ldr	r2, [r3, #4]
    1fac:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    1fb0:	605a      	str	r2, [r3, #4]
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
    1fb2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    1fb4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    1fb8:	625a      	str	r2, [r3, #36]	; 0x24
    1fba:	e7ee      	b.n	1f9a <z_impl_k_thread_abort+0xa>
    1fbc:	200013e0 	.word	0x200013e0
    1fc0:	e000ed00 	.word	0xe000ed00

00001fc4 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    1fc4:	b510      	push	{r4, lr}
    1fc6:	b084      	sub	sp, #16
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    1fc8:	4c0a      	ldr	r4, [pc, #40]	; (1ff4 <z_arm_configure_static_mpu_regions+0x30>)
    1fca:	4623      	mov	r3, r4
    1fcc:	4a0a      	ldr	r2, [pc, #40]	; (1ff8 <z_arm_configure_static_mpu_regions+0x34>)
    1fce:	2101      	movs	r1, #1
    1fd0:	480a      	ldr	r0, [pc, #40]	; (1ffc <z_arm_configure_static_mpu_regions+0x38>)
    1fd2:	f008 faf6 	bl	a5c2 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    1fd6:	2300      	movs	r3, #0
    1fd8:	9301      	str	r3, [sp, #4]
    1fda:	9302      	str	r3, [sp, #8]
    1fdc:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    1fde:	4b08      	ldr	r3, [pc, #32]	; (2000 <CONFIG_NRF_SPU_RAM_REGION_SIZE>)
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    1fe0:	9301      	str	r3, [sp, #4]
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    1fe2:	1ae4      	subs	r4, r4, r3
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    1fe4:	9402      	str	r4, [sp, #8]
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    1fe6:	2101      	movs	r1, #1
    1fe8:	a801      	add	r0, sp, #4
    1fea:	f008 faee 	bl	a5ca <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    1fee:	b004      	add	sp, #16
    1ff0:	bd10      	pop	{r4, pc}
    1ff2:	bf00      	nop
    1ff4:	20080000 	.word	0x20080000
    1ff8:	20000000 	.word	0x20000000
    1ffc:	0000e9e8 	.word	0x0000e9e8
    2000:	20000360 	.word	0x20000360

00002004 <mpu_init>:
static struct dynamic_region_info dyn_reg_info[MPU_DYNAMIC_REGION_AREAS_NUM];
#if defined(CONFIG_CPU_CORTEX_M23) || defined(CONFIG_CPU_CORTEX_M33) || \
	defined(CONFIG_CPU_CORTEX_M55)
static inline void mpu_set_mair0(uint32_t mair0)
{
	MPU->MAIR0 = mair0;
    2004:	4b02      	ldr	r3, [pc, #8]	; (2010 <mpu_init+0xc>)
    2006:	4a03      	ldr	r2, [pc, #12]	; (2014 <mpu_init+0x10>)
    2008:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
{
	/* Configure the cache-ability attributes for all the
	 * different types of memory regions.
	 */
	mpu_set_mair0(MPU_MAIR_ATTRS);
}
    200c:	4770      	bx	lr
    200e:	bf00      	nop
    2010:	e000ed00 	.word	0xe000ed00
    2014:	0044ffaa 	.word	0x0044ffaa

00002018 <mpu_set_region>:
	MPU->RNR = rnr;
    2018:	4b03      	ldr	r3, [pc, #12]	; (2028 <mpu_set_region+0x10>)
    201a:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
	MPU->RBAR = rbar;
    201e:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
	MPU->RLAR = rlar;
    2022:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
static void mpu_set_region(uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
	mpu_set_rnr(rnr);
	mpu_set_rbar(rbar);
	mpu_set_rlar(rlar);
}
    2026:	4770      	bx	lr
    2028:	e000ed00 	.word	0xe000ed00

0000202c <mpu_region_get_conf>:
	MPU->RNR = rnr;
    202c:	4b0e      	ldr	r3, [pc, #56]	; (2068 <mpu_region_get_conf+0x3c>)
    202e:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
    2032:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
	return MPU->RBAR;
    2036:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
static inline void mpu_region_get_access_attr(const uint32_t index,
	arm_mpu_region_attr_t *attr)
{
	mpu_set_rnr(index);

	attr->rbar = mpu_get_rbar() &
    203a:	7a0a      	ldrb	r2, [r1, #8]
    203c:	f360 0204 	bfi	r2, r0, #0, #5
    2040:	720a      	strb	r2, [r1, #8]
	return MPU->RLAR;
    2042:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
		(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk);
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
    2046:	f3c2 0242 	ubfx	r2, r2, #1, #3
    204a:	7a08      	ldrb	r0, [r1, #8]
    204c:	f362 1047 	bfi	r0, r2, #5, #3
    2050:	7208      	strb	r0, [r1, #8]
	return MPU->RBAR;
    2052:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
	 * - Access Permissions
	 */
	mpu_region_get_access_attr(index, &region_conf->attr);

	/* Region base address */
	region_conf->base = mpu_get_rbar() & MPU_RBAR_BASE_Msk;
    2056:	f022 021f 	bic.w	r2, r2, #31
    205a:	600a      	str	r2, [r1, #0]
	return MPU->RLAR;
    205c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0

	/* Region limit address */
	region_conf->attr.r_limit = mpu_get_rlar() & MPU_RLAR_LIMIT_Msk;
    2060:	f023 031f 	bic.w	r3, r3, #31
    2064:	60cb      	str	r3, [r1, #12]
}
    2066:	4770      	bx	lr
    2068:	e000ed00 	.word	0xe000ed00

0000206c <region_allocate_and_init>:
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
    206c:	b510      	push	{r4, lr}
    206e:	4604      	mov	r4, r0
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
    2070:	2807      	cmp	r0, #7
    2072:	d803      	bhi.n	207c <region_allocate_and_init+0x10>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    2074:	f008 fa4f 	bl	a516 <region_init>

	return index;
    2078:	4620      	mov	r0, r4
}
    207a:	bd10      	pop	{r4, pc}
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    207c:	4602      	mov	r2, r0
    207e:	2145      	movs	r1, #69	; 0x45
    2080:	4802      	ldr	r0, [pc, #8]	; (208c <region_allocate_and_init+0x20>)
    2082:	f008 f95b 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    2086:	f06f 0015 	mvn.w	r0, #21
    208a:	e7f6      	b.n	207a <region_allocate_and_init+0xe>
    208c:	0000e9f8 	.word	0x0000e9f8

00002090 <mpu_configure_regions_and_partition>:
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    2090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2094:	b087      	sub	sp, #28
    2096:	4681      	mov	r9, r0
    2098:	9100      	str	r1, [sp, #0]
    209a:	9301      	str	r3, [sp, #4]
	int i;
	int reg_index = start_reg_index;
    209c:	4614      	mov	r4, r2

	for (i = 0; i < regions_num; i++) {
    209e:	2700      	movs	r7, #0
    20a0:	e046      	b.n	2130 <mpu_configure_regions_and_partition+0xa0>
		}
		/* Non-empty region. */

		if (do_sanity_check &&
			(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    20a2:	463a      	mov	r2, r7
    20a4:	2145      	movs	r1, #69	; 0x45
    20a6:	4860      	ldr	r0, [pc, #384]	; (2228 <mpu_configure_regions_and_partition+0x198>)
    20a8:	f008 f948 	bl	a33c <z_log_minimal_printk>
			return -EINVAL;
    20ac:	f06f 0415 	mvn.w	r4, #21
    20b0:	e006      	b.n	20c0 <mpu_configure_regions_and_partition+0x30>
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
    20b2:	4632      	mov	r2, r6
    20b4:	2145      	movs	r1, #69	; 0x45
    20b6:	485d      	ldr	r0, [pc, #372]	; (222c <mpu_configure_regions_and_partition+0x19c>)
    20b8:	f008 f940 	bl	a33c <z_log_minimal_printk>
				u_reg_index);
			return -EINVAL;
    20bc:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    20c0:	4620      	mov	r0, r4
    20c2:	b007      	add	sp, #28
    20c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((regions[i].start == u_reg_base) &&
    20c8:	45d8      	cmp	r8, fp
    20ca:	d164      	bne.n	2196 <mpu_configure_regions_and_partition+0x106>
			mpu_configure_region(u_reg_index, &regions[i]);
    20cc:	4629      	mov	r1, r5
    20ce:	b2c0      	uxtb	r0, r0
    20d0:	f008 fa47 	bl	a562 <mpu_configure_region>
    20d4:	e02b      	b.n	212e <mpu_configure_regions_and_partition+0x9e>
	MPU->RNR = rnr;
    20d6:	4a56      	ldr	r2, [pc, #344]	; (2230 <mpu_configure_regions_and_partition+0x1a0>)
    20d8:	f8c2 6098 	str.w	r6, [r2, #152]	; 0x98
	return MPU->RBAR;
    20dc:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
	mpu_set_rbar((mpu_get_rbar() & (~MPU_RBAR_BASE_Msk))
    20e0:	f003 031f 	and.w	r3, r3, #31
		     | (base & MPU_RBAR_BASE_Msk));
    20e4:	f021 011f 	bic.w	r1, r1, #31
    20e8:	430b      	orrs	r3, r1
	MPU->RBAR = rbar;
    20ea:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
    20ee:	4629      	mov	r1, r5
    20f0:	b2e0      	uxtb	r0, r4
    20f2:	f008 fa36 	bl	a562 <mpu_configure_region>
    20f6:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    20f8:	f110 0f16 	cmn.w	r0, #22
    20fc:	d0e0      	beq.n	20c0 <mpu_configure_regions_and_partition+0x30>
			reg_index++;
    20fe:	3401      	adds	r4, #1
    2100:	e015      	b.n	212e <mpu_configure_regions_and_partition+0x9e>
				regions[i].start - 1);
    2102:	3b01      	subs	r3, #1
	MPU->RNR = rnr;
    2104:	494a      	ldr	r1, [pc, #296]	; (2230 <mpu_configure_regions_and_partition+0x1a0>)
    2106:	f8c1 6098 	str.w	r6, [r1, #152]	; 0x98
	return MPU->RLAR;
    210a:	f8d1 20a0 	ldr.w	r2, [r1, #160]	; 0xa0
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
    210e:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
    2112:	f023 031f 	bic.w	r3, r3, #31
    2116:	4313      	orrs	r3, r2
	MPU->RLAR = rlar;
    2118:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
    211c:	4629      	mov	r1, r5
    211e:	b2e0      	uxtb	r0, r4
    2120:	f008 fa1f 	bl	a562 <mpu_configure_region>
    2124:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    2126:	f110 0f16 	cmn.w	r0, #22
    212a:	d0c9      	beq.n	20c0 <mpu_configure_regions_and_partition+0x30>
			reg_index++;
    212c:	3401      	adds	r4, #1
	for (i = 0; i < regions_num; i++) {
    212e:	3701      	adds	r7, #1
    2130:	9b00      	ldr	r3, [sp, #0]
    2132:	429f      	cmp	r7, r3
    2134:	dac4      	bge.n	20c0 <mpu_configure_regions_and_partition+0x30>
		if (regions[i].size == 0U) {
    2136:	eb07 0547 	add.w	r5, r7, r7, lsl #1
    213a:	ea4f 0a85 	mov.w	sl, r5, lsl #2
    213e:	eb09 0585 	add.w	r5, r9, r5, lsl #2
    2142:	686e      	ldr	r6, [r5, #4]
    2144:	2e00      	cmp	r6, #0
    2146:	d0f2      	beq.n	212e <mpu_configure_regions_and_partition+0x9e>
		if (do_sanity_check &&
    2148:	9b01      	ldr	r3, [sp, #4]
    214a:	b123      	cbz	r3, 2156 <mpu_configure_regions_and_partition+0xc6>
			(!mpu_partition_is_valid(&regions[i]))) {
    214c:	4628      	mov	r0, r5
    214e:	f008 f9f6 	bl	a53e <mpu_partition_is_valid>
		if (do_sanity_check &&
    2152:	2800      	cmp	r0, #0
    2154:	d0a5      	beq.n	20a2 <mpu_configure_regions_and_partition+0x12>
			get_region_index(regions[i].start, regions[i].size);
    2156:	4631      	mov	r1, r6
    2158:	f859 000a 	ldr.w	r0, [r9, sl]
    215c:	f008 fa20 	bl	a5a0 <get_region_index>
    2160:	4606      	mov	r6, r0
		if ((u_reg_index == -EINVAL) ||
    2162:	f110 0f16 	cmn.w	r0, #22
    2166:	d0a4      	beq.n	20b2 <mpu_configure_regions_and_partition+0x22>
    2168:	42a0      	cmp	r0, r4
    216a:	daa2      	bge.n	20b2 <mpu_configure_regions_and_partition+0x22>
	MPU->RNR = rnr;
    216c:	4b30      	ldr	r3, [pc, #192]	; (2230 <mpu_configure_regions_and_partition+0x1a0>)
    216e:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
	return MPU->RBAR;
    2172:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
	return mpu_get_rbar() & MPU_RBAR_BASE_Msk;
    2176:	f022 021f 	bic.w	r2, r2, #31
	MPU->RNR = rnr;
    217a:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
	return MPU->RLAR;
    217e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
	return (mpu_get_rlar() & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    2182:	f043 081f 	orr.w	r8, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
    2186:	f859 300a 	ldr.w	r3, [r9, sl]
    218a:	6869      	ldr	r1, [r5, #4]
    218c:	4419      	add	r1, r3
    218e:	f101 3bff 	add.w	fp, r1, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
    2192:	429a      	cmp	r2, r3
    2194:	d098      	beq.n	20c8 <mpu_configure_regions_and_partition+0x38>
		} else if (regions[i].start == u_reg_base) {
    2196:	429a      	cmp	r2, r3
    2198:	d09d      	beq.n	20d6 <mpu_configure_regions_and_partition+0x46>
		} else if (reg_last == u_reg_last) {
    219a:	45d8      	cmp	r8, fp
    219c:	d0b1      	beq.n	2102 <mpu_configure_regions_and_partition+0x72>
				regions[i].start - 1);
    219e:	3b01      	subs	r3, #1
	MPU->RNR = rnr;
    21a0:	4923      	ldr	r1, [pc, #140]	; (2230 <mpu_configure_regions_and_partition+0x1a0>)
    21a2:	f8c1 6098 	str.w	r6, [r1, #152]	; 0x98
	return MPU->RLAR;
    21a6:	f8d1 20a0 	ldr.w	r2, [r1, #160]	; 0xa0
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
    21aa:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
    21ae:	f023 031f 	bic.w	r3, r3, #31
    21b2:	4313      	orrs	r3, r2
	MPU->RLAR = rlar;
    21b4:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
    21b8:	4629      	mov	r1, r5
    21ba:	b2e0      	uxtb	r0, r4
    21bc:	f008 f9d1 	bl	a562 <mpu_configure_region>
    21c0:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    21c2:	f110 0f16 	cmn.w	r0, #22
    21c6:	f43f af7b 	beq.w	20c0 <mpu_configure_regions_and_partition+0x30>
			reg_index++;
    21ca:	3001      	adds	r0, #1
	MPU->RNR = rnr;
    21cc:	4b18      	ldr	r3, [pc, #96]	; (2230 <mpu_configure_regions_and_partition+0x1a0>)
    21ce:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
	return MPU->RBAR;
    21d2:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
    21d6:	f89d 2010 	ldrb.w	r2, [sp, #16]
    21da:	f361 0204 	bfi	r2, r1, #0, #5
    21de:	f88d 2010 	strb.w	r2, [sp, #16]
	return MPU->RLAR;
    21e2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
    21e6:	f3c3 0342 	ubfx	r3, r3, #1, #3
    21ea:	b2d2      	uxtb	r2, r2
    21ec:	f363 1247 	bfi	r2, r3, #5, #3
    21f0:	f88d 2010 	strb.w	r2, [sp, #16]
			fill_region.base = regions[i].start +
    21f4:	f859 300a 	ldr.w	r3, [r9, sl]
				regions[i].size;
    21f8:	686a      	ldr	r2, [r5, #4]
			fill_region.base = regions[i].start +
    21fa:	4413      	add	r3, r2
    21fc:	9302      	str	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
    21fe:	f023 031f 	bic.w	r3, r3, #31
    2202:	eba8 080b 	sub.w	r8, r8, fp
    2206:	4443      	add	r3, r8
    2208:	3b01      	subs	r3, #1
    220a:	f023 031f 	bic.w	r3, r3, #31
			fill_region.attr.r_limit =
    220e:	9305      	str	r3, [sp, #20]
				region_allocate_and_init(reg_index,
    2210:	a902      	add	r1, sp, #8
    2212:	b2c0      	uxtb	r0, r0
    2214:	f7ff ff2a 	bl	206c <region_allocate_and_init>
    2218:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    221a:	f110 0f16 	cmn.w	r0, #22
    221e:	f43f af4f 	beq.w	20c0 <mpu_configure_regions_and_partition+0x30>
			reg_index++;
    2222:	3401      	adds	r4, #1
    2224:	e783      	b.n	212e <mpu_configure_regions_and_partition+0x9e>
    2226:	bf00      	nop
    2228:	0000ea24 	.word	0x0000ea24
    222c:	0000ea4c 	.word	0x0000ea4c
    2230:	e000ed00 	.word	0xe000ed00

00002234 <mpu_configure_static_mpu_regions>:
 */
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
    2234:	b510      	push	{r4, lr}
	int mpu_reg_index = static_regions_num;
    2236:	4c03      	ldr	r4, [pc, #12]	; (2244 <mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
    2238:	2301      	movs	r3, #1
    223a:	7822      	ldrb	r2, [r4, #0]
    223c:	f7ff ff28 	bl	2090 <mpu_configure_regions_and_partition>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    2240:	7020      	strb	r0, [r4, #0]

	return mpu_reg_index;
}
    2242:	bd10      	pop	{r4, pc}
    2244:	200015f0 	.word	0x200015f0

00002248 <mpu_mark_areas_for_dynamic_regions>:
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
		const struct z_arm_mpu_partition dyn_region_areas[],
		const uint8_t dyn_region_areas_num)
{
    2248:	b570      	push	{r4, r5, r6, lr}
    224a:	4605      	mov	r5, r0
    224c:	460e      	mov	r6, r1
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    224e:	2400      	movs	r4, #0
    2250:	e000      	b.n	2254 <mpu_mark_areas_for_dynamic_regions+0xc>
    2252:	3401      	adds	r4, #1
    2254:	42a6      	cmp	r6, r4
    2256:	dd1e      	ble.n	2296 <mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
    2258:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    225c:	009a      	lsls	r2, r3, #2
    225e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    2262:	6859      	ldr	r1, [r3, #4]
    2264:	2900      	cmp	r1, #0
    2266:	d0f4      	beq.n	2252 <mpu_mark_areas_for_dynamic_regions+0xa>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    2268:	58a8      	ldr	r0, [r5, r2]
    226a:	f008 f999 	bl	a5a0 <get_region_index>
		dyn_reg_info[i].index =
    226e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    2272:	4a0b      	ldr	r2, [pc, #44]	; (22a0 <mpu_mark_areas_for_dynamic_regions+0x58>)
    2274:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
    2278:	f110 0f16 	cmn.w	r0, #22
    227c:	d00c      	beq.n	2298 <mpu_mark_areas_for_dynamic_regions+0x50>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    227e:	4b09      	ldr	r3, [pc, #36]	; (22a4 <mpu_mark_areas_for_dynamic_regions+0x5c>)
    2280:	781b      	ldrb	r3, [r3, #0]
    2282:	4298      	cmp	r0, r3
    2284:	da09      	bge.n	229a <mpu_mark_areas_for_dynamic_regions+0x52>

			return -EINVAL;
		}

		/* Store default configuration */
		mpu_region_get_conf(dyn_reg_info[i].index,
    2286:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    228a:	eb02 0183 	add.w	r1, r2, r3, lsl #2
    228e:	3104      	adds	r1, #4
    2290:	f7ff fecc 	bl	202c <mpu_region_get_conf>
    2294:	e7dd      	b.n	2252 <mpu_mark_areas_for_dynamic_regions+0xa>
			&dyn_reg_info[i].region_conf);
	}

	return 0;
    2296:	2000      	movs	r0, #0
}
    2298:	bd70      	pop	{r4, r5, r6, pc}
			return -EINVAL;
    229a:	f06f 0015 	mvn.w	r0, #21
    229e:	e7fb      	b.n	2298 <mpu_mark_areas_for_dynamic_regions+0x50>
    22a0:	20000dac 	.word	0x20000dac
    22a4:	200015f0 	.word	0x200015f0

000022a8 <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    22a8:	4b04      	ldr	r3, [pc, #16]	; (22bc <arm_core_mpu_enable+0x14>)
    22aa:	2205      	movs	r2, #5
    22ac:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
    22b0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    22b4:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    22b8:	4770      	bx	lr
    22ba:	bf00      	nop
    22bc:	e000ed00 	.word	0xe000ed00

000022c0 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    22c0:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    22c4:	4b02      	ldr	r3, [pc, #8]	; (22d0 <arm_core_mpu_disable+0x10>)
    22c6:	2200      	movs	r2, #0
    22c8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    22cc:	4770      	bx	lr
    22ce:	bf00      	nop
    22d0:	e000ed00 	.word	0xe000ed00

000022d4 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
    22d4:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    22d6:	4b0e      	ldr	r3, [pc, #56]	; (2310 <z_arm_mpu_init+0x3c>)
    22d8:	681d      	ldr	r5, [r3, #0]
    22da:	2d08      	cmp	r5, #8
    22dc:	d815      	bhi.n	230a <z_arm_mpu_init+0x36>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    22de:	f7ff ffef 	bl	22c0 <arm_core_mpu_disable>
#endif
#endif
#endif /* CONFIG_NOCACHE_MEMORY */

	/* Architecture-specific configuration */
	mpu_init();
    22e2:	f7ff fe8f 	bl	2004 <mpu_init>

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    22e6:	2400      	movs	r4, #0
    22e8:	e007      	b.n	22fa <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    22ea:	4b09      	ldr	r3, [pc, #36]	; (2310 <z_arm_mpu_init+0x3c>)
    22ec:	6859      	ldr	r1, [r3, #4]
    22ee:	eb01 1104 	add.w	r1, r1, r4, lsl #4
    22f2:	4620      	mov	r0, r4
    22f4:	f008 f90f 	bl	a516 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    22f8:	3401      	adds	r4, #1
    22fa:	42a5      	cmp	r5, r4
    22fc:	d8f5      	bhi.n	22ea <z_arm_mpu_init+0x16>
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    22fe:	4b05      	ldr	r3, [pc, #20]	; (2314 <z_arm_mpu_init+0x40>)
    2300:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    2302:	f7ff ffd1 	bl	22a8 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    2306:	2000      	movs	r0, #0
}
    2308:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    230a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    230e:	e7fb      	b.n	2308 <z_arm_mpu_init+0x34>
    2310:	0000eaa4 	.word	0x0000eaa4
    2314:	200015f0 	.word	0x200015f0

00002318 <malloc>:
}

SYS_INIT(malloc_prepare, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#else /* No malloc arena */
void *malloc(size_t size)
{
    2318:	b508      	push	{r3, lr}
	ARG_UNUSED(size);

	LOG_ERR("CONFIG_MINIMAL_LIBC_MALLOC_ARENA_SIZE is 0");
    231a:	2145      	movs	r1, #69	; 0x45
    231c:	4804      	ldr	r0, [pc, #16]	; (2330 <malloc+0x18>)
    231e:	f008 f80d 	bl	a33c <z_log_minimal_printk>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
    2322:	f005 fdf3 	bl	7f0c <z_impl_z_errno>
	errno = ENOMEM;
    2326:	230c      	movs	r3, #12
    2328:	6003      	str	r3, [r0, #0]

	return NULL;
}
    232a:	2000      	movs	r0, #0
    232c:	bd08      	pop	{r3, pc}
    232e:	bf00      	nop
    2330:	0000ea74 	.word	0x0000ea74

00002334 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
    2334:	4b01      	ldr	r3, [pc, #4]	; (233c <__stdout_hook_install+0x8>)
    2336:	6018      	str	r0, [r3, #0]
}
    2338:	4770      	bx	lr
    233a:	bf00      	nop
    233c:	20000158 	.word	0x20000158

00002340 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
    2340:	b40c      	push	{r2, r3}
    2342:	b510      	push	{r4, lr}
    2344:	b086      	sub	sp, #24

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    2346:	460b      	mov	r3, r1
    2348:	b909      	cbnz	r1, 234e <snprintf+0xe>
		str = &dummy; /* write final NUL to dummy, can't change *s */
    234a:	f10d 000b 	add.w	r0, sp, #11
	}

	p.ptr = str;
    234e:	9003      	str	r0, [sp, #12]
	p.len = (int) len;
    2350:	9304      	str	r3, [sp, #16]

	va_start(vargs, format);
    2352:	ab09      	add	r3, sp, #36	; 0x24
    2354:	9305      	str	r3, [sp, #20]
    2356:	2400      	movs	r4, #0
    2358:	9400      	str	r4, [sp, #0]
    235a:	9a08      	ldr	r2, [sp, #32]
    235c:	a903      	add	r1, sp, #12
    235e:	4805      	ldr	r0, [pc, #20]	; (2374 <snprintf+0x34>)
    2360:	f7fe fc02 	bl	b68 <z_cbvprintf_impl>
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
	va_end(vargs);

	*(p.ptr) = 0;
    2364:	9b03      	ldr	r3, [sp, #12]
    2366:	701c      	strb	r4, [r3, #0]
	return r;
}
    2368:	b006      	add	sp, #24
    236a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    236e:	b002      	add	sp, #8
    2370:	4770      	bx	lr
    2372:	bf00      	nop
    2374:	0000a799 	.word	0x0000a799

00002378 <registry_add>:
static int registry_add(int type,
			const struct fs_file_system_t *fstp)
{
	int rv = -ENOSPC;

	for (size_t i = 0; i < ARRAY_SIZE(registry); ++i) {
    2378:	2300      	movs	r3, #0
    237a:	2b01      	cmp	r3, #1
    237c:	d80e      	bhi.n	239c <registry_add+0x24>
		struct registry_entry *ep = &registry[i];

		if (ep->fstp == NULL) {
    237e:	4a09      	ldr	r2, [pc, #36]	; (23a4 <registry_add+0x2c>)
    2380:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    2384:	6852      	ldr	r2, [r2, #4]
    2386:	b10a      	cbz	r2, 238c <registry_add+0x14>
	for (size_t i = 0; i < ARRAY_SIZE(registry); ++i) {
    2388:	3301      	adds	r3, #1
    238a:	e7f6      	b.n	237a <registry_add+0x2>
			ep->type = type;
    238c:	4a05      	ldr	r2, [pc, #20]	; (23a4 <registry_add+0x2c>)
    238e:	f842 0033 	str.w	r0, [r2, r3, lsl #3]
			ep->fstp = fstp;
    2392:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    2396:	6051      	str	r1, [r2, #4]
			rv = 0;
    2398:	2000      	movs	r0, #0
			break;
    239a:	4770      	bx	lr
	int rv = -ENOSPC;
    239c:	f06f 001b 	mvn.w	r0, #27
		}
	}

	return rv;
}
    23a0:	4770      	bx	lr
    23a2:	bf00      	nop
    23a4:	20000dc0 	.word	0x20000dc0

000023a8 <registry_find>:

static struct registry_entry *registry_find(int type)
{
    23a8:	4601      	mov	r1, r0
	for (size_t i = 0; i < ARRAY_SIZE(registry); ++i) {
    23aa:	2300      	movs	r3, #0
    23ac:	e000      	b.n	23b0 <registry_find+0x8>
    23ae:	3301      	adds	r3, #1
    23b0:	2b01      	cmp	r3, #1
    23b2:	d80b      	bhi.n	23cc <registry_find+0x24>
		struct registry_entry *ep = &registry[i];
    23b4:	4806      	ldr	r0, [pc, #24]	; (23d0 <registry_find+0x28>)
    23b6:	eb00 00c3 	add.w	r0, r0, r3, lsl #3

		if ((ep->fstp != NULL) && (ep->type == type)) {
    23ba:	6842      	ldr	r2, [r0, #4]
    23bc:	2a00      	cmp	r2, #0
    23be:	d0f6      	beq.n	23ae <registry_find+0x6>
    23c0:	4a03      	ldr	r2, [pc, #12]	; (23d0 <registry_find+0x28>)
    23c2:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
    23c6:	428a      	cmp	r2, r1
    23c8:	d1f1      	bne.n	23ae <registry_find+0x6>
    23ca:	e000      	b.n	23ce <registry_find+0x26>
			return ep;
		}
	}
	return NULL;
    23cc:	2000      	movs	r0, #0
}
    23ce:	4770      	bx	lr
    23d0:	20000dc0 	.word	0x20000dc0

000023d4 <fs_get_mnt_point>:
	return (ep != NULL) ? ep->fstp : NULL;
}

static int fs_get_mnt_point(struct fs_mount_t **mnt_pntp,
			    const char *name, size_t *match_len)
{
    23d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    23d8:	4683      	mov	fp, r0
    23da:	460f      	mov	r7, r1
    23dc:	4692      	mov	sl, r2
	struct fs_mount_t *mnt_p = NULL, *itr;
	size_t longest_match = 0;
	size_t len, name_len = strlen(name);
    23de:	4608      	mov	r0, r1
    23e0:	f008 f929 	bl	a636 <strlen>
    23e4:	4680      	mov	r8, r0
	return z_impl_k_mutex_lock(mutex, timeout);
    23e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    23ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    23ee:	4820      	ldr	r0, [pc, #128]	; (2470 <fs_get_mnt_point+0x9c>)
    23f0:	f006 f826 	bl	8440 <z_impl_k_mutex_lock>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    23f4:	4b1f      	ldr	r3, [pc, #124]	; (2474 <fs_get_mnt_point+0xa0>)
    23f6:	681c      	ldr	r4, [r3, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    23f8:	429c      	cmp	r4, r3
    23fa:	d01d      	beq.n	2438 <fs_get_mnt_point+0x64>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    23fc:	2600      	movs	r6, #0
    23fe:	46b1      	mov	r9, r6
    2400:	e00c      	b.n	241c <fs_get_mnt_point+0x48>
		if ((len > 1) && (name[len] != '/') && (name[len] != '\0')) {
			continue;
		}

		/* Check for mount point match */
		if (strncmp(name, itr->mnt_point, len) == 0) {
    2402:	462a      	mov	r2, r5
    2404:	68e1      	ldr	r1, [r4, #12]
    2406:	4638      	mov	r0, r7
    2408:	f008 f933 	bl	a672 <strncmp>
    240c:	b908      	cbnz	r0, 2412 <fs_get_mnt_point+0x3e>
			mnt_p = itr;
			longest_match = len;
    240e:	462e      	mov	r6, r5
			mnt_p = itr;
    2410:	46a1      	mov	r9, r4
    2412:	4b18      	ldr	r3, [pc, #96]	; (2474 <fs_get_mnt_point+0xa0>)
    2414:	685b      	ldr	r3, [r3, #4]
    2416:	429c      	cmp	r4, r3
    2418:	d010      	beq.n	243c <fs_get_mnt_point+0x68>
    241a:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    241c:	b184      	cbz	r4, 2440 <fs_get_mnt_point+0x6c>
		len = itr->mountp_len;
    241e:	69a5      	ldr	r5, [r4, #24]
		if ((len < longest_match) || (len > name_len)) {
    2420:	42ae      	cmp	r6, r5
    2422:	d8f6      	bhi.n	2412 <fs_get_mnt_point+0x3e>
    2424:	45a8      	cmp	r8, r5
    2426:	d3f4      	bcc.n	2412 <fs_get_mnt_point+0x3e>
		if ((len > 1) && (name[len] != '/') && (name[len] != '\0')) {
    2428:	2d01      	cmp	r5, #1
    242a:	d9ea      	bls.n	2402 <fs_get_mnt_point+0x2e>
    242c:	5d7b      	ldrb	r3, [r7, r5]
    242e:	2b2f      	cmp	r3, #47	; 0x2f
    2430:	d0e7      	beq.n	2402 <fs_get_mnt_point+0x2e>
    2432:	2b00      	cmp	r3, #0
    2434:	d0e5      	beq.n	2402 <fs_get_mnt_point+0x2e>
    2436:	e7ec      	b.n	2412 <fs_get_mnt_point+0x3e>
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2438:	2400      	movs	r4, #0
    243a:	e7df      	b.n	23fc <fs_get_mnt_point+0x28>
	return (node == list->tail) ? NULL : node->next;
    243c:	2400      	movs	r4, #0
    243e:	e7ed      	b.n	241c <fs_get_mnt_point+0x48>
	return z_impl_k_mutex_unlock(mutex);
    2440:	480b      	ldr	r0, [pc, #44]	; (2470 <fs_get_mnt_point+0x9c>)
    2442:	f006 f881 	bl	8548 <z_impl_k_mutex_unlock>
		}
	}
	k_mutex_unlock(&mutex);

	if (mnt_p == NULL) {
    2446:	f1b9 0f00 	cmp.w	r9, #0
    244a:	d00b      	beq.n	2464 <fs_get_mnt_point+0x90>
		return -ENOENT;
	}

	*mnt_pntp = mnt_p;
    244c:	f8cb 9000 	str.w	r9, [fp]
	if (match_len) {
    2450:	f1ba 0f00 	cmp.w	sl, #0
    2454:	d009      	beq.n	246a <fs_get_mnt_point+0x96>
		*match_len = mnt_p->mountp_len;
    2456:	f8d9 3018 	ldr.w	r3, [r9, #24]
    245a:	f8ca 3000 	str.w	r3, [sl]
	}

	return 0;
    245e:	2000      	movs	r0, #0
}
    2460:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -ENOENT;
    2464:	f06f 0001 	mvn.w	r0, #1
    2468:	e7fa      	b.n	2460 <fs_get_mnt_point+0x8c>
	return 0;
    246a:	2000      	movs	r0, #0
    246c:	e7f8      	b.n	2460 <fs_get_mnt_point+0x8c>
    246e:	bf00      	nop
    2470:	20000dd0 	.word	0x20000dd0
    2474:	20000de4 	.word	0x20000de4

00002478 <fs_init>:
	LOG_DBG("fs unregister %d: %d", type, rc);
	return rc;
}

static int fs_init(void)
{
    2478:	b508      	push	{r3, lr}
	return z_impl_k_mutex_init(mutex);
    247a:	4804      	ldr	r0, [pc, #16]	; (248c <fs_init+0x14>)
    247c:	f00b fa27 	bl	d8ce <z_impl_k_mutex_init>
	list->head = (sys_dnode_t *)list;
    2480:	4b03      	ldr	r3, [pc, #12]	; (2490 <fs_init+0x18>)
    2482:	601b      	str	r3, [r3, #0]
	list->tail = (sys_dnode_t *)list;
    2484:	605b      	str	r3, [r3, #4]
	k_mutex_init(&mutex);
	sys_dlist_init(&fs_mnt_list);
	return 0;
}
    2486:	2000      	movs	r0, #0
    2488:	bd08      	pop	{r3, pc}
    248a:	bf00      	nop
    248c:	20000dd0 	.word	0x20000dd0
    2490:	20000de4 	.word	0x20000de4

00002494 <fs_open>:
{
    2494:	b5f0      	push	{r4, r5, r6, r7, lr}
    2496:	b083      	sub	sp, #12
	if ((file_name == NULL) ||
    2498:	b369      	cbz	r1, 24f6 <fs_open+0x62>
    249a:	4605      	mov	r5, r0
    249c:	4616      	mov	r6, r2
    249e:	460f      	mov	r7, r1
			(strlen(file_name) <= 1) || (file_name[0] != '/')) {
    24a0:	4608      	mov	r0, r1
    24a2:	f008 f8c8 	bl	a636 <strlen>
	if ((file_name == NULL) ||
    24a6:	2801      	cmp	r0, #1
    24a8:	d925      	bls.n	24f6 <fs_open+0x62>
			(strlen(file_name) <= 1) || (file_name[0] != '/')) {
    24aa:	783b      	ldrb	r3, [r7, #0]
    24ac:	2b2f      	cmp	r3, #47	; 0x2f
    24ae:	d122      	bne.n	24f6 <fs_open+0x62>
	if (zfp->mp != NULL) {
    24b0:	686b      	ldr	r3, [r5, #4]
    24b2:	2b00      	cmp	r3, #0
    24b4:	d133      	bne.n	251e <fs_open+0x8a>
	rc = fs_get_mnt_point(&mp, file_name, NULL);
    24b6:	2200      	movs	r2, #0
    24b8:	4639      	mov	r1, r7
    24ba:	a801      	add	r0, sp, #4
    24bc:	f7ff ff8a 	bl	23d4 <fs_get_mnt_point>
	if (rc < 0) {
    24c0:	1e04      	subs	r4, r0, #0
    24c2:	db1f      	blt.n	2504 <fs_open+0x70>
	if (((mp->flags & FS_MOUNT_FLAG_READ_ONLY) != 0) &&
    24c4:	9b01      	ldr	r3, [sp, #4]
    24c6:	f893 2020 	ldrb.w	r2, [r3, #32]
    24ca:	f012 0f02 	tst.w	r2, #2
    24ce:	d002      	beq.n	24d6 <fs_open+0x42>
    24d0:	f016 0f12 	tst.w	r6, #18
    24d4:	d126      	bne.n	2524 <fs_open+0x90>
	CHECKIF(mp->fs->open == NULL) {
    24d6:	69da      	ldr	r2, [r3, #28]
    24d8:	6812      	ldr	r2, [r2, #0]
    24da:	b332      	cbz	r2, 252a <fs_open+0x96>
	zfp->mp = mp;
    24dc:	606b      	str	r3, [r5, #4]
	rc = mp->fs->open(zfp, file_name, flags);
    24de:	69db      	ldr	r3, [r3, #28]
    24e0:	681b      	ldr	r3, [r3, #0]
    24e2:	4632      	mov	r2, r6
    24e4:	4639      	mov	r1, r7
    24e6:	4628      	mov	r0, r5
    24e8:	4798      	blx	r3
	if (rc < 0) {
    24ea:	1e04      	subs	r4, r0, #0
    24ec:	db0f      	blt.n	250e <fs_open+0x7a>
	zfp->flags = flags;
    24ee:	722e      	strb	r6, [r5, #8]
}
    24f0:	4620      	mov	r0, r4
    24f2:	b003      	add	sp, #12
    24f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("invalid file name!!");
    24f6:	2145      	movs	r1, #69	; 0x45
    24f8:	480d      	ldr	r0, [pc, #52]	; (2530 <fs_open+0x9c>)
    24fa:	f007 ff1f 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    24fe:	f06f 0415 	mvn.w	r4, #21
    2502:	e7f5      	b.n	24f0 <fs_open+0x5c>
		LOG_ERR("mount point not found!!");
    2504:	2145      	movs	r1, #69	; 0x45
    2506:	480b      	ldr	r0, [pc, #44]	; (2534 <fs_open+0xa0>)
    2508:	f007 ff18 	bl	a33c <z_log_minimal_printk>
		return rc;
    250c:	e7f0      	b.n	24f0 <fs_open+0x5c>
		LOG_ERR("file open error (%d)", rc);
    250e:	4622      	mov	r2, r4
    2510:	2145      	movs	r1, #69	; 0x45
    2512:	4809      	ldr	r0, [pc, #36]	; (2538 <fs_open+0xa4>)
    2514:	f007 ff12 	bl	a33c <z_log_minimal_printk>
		zfp->mp = NULL;
    2518:	2300      	movs	r3, #0
    251a:	606b      	str	r3, [r5, #4]
		return rc;
    251c:	e7e8      	b.n	24f0 <fs_open+0x5c>
		return -EBUSY;
    251e:	f06f 040f 	mvn.w	r4, #15
    2522:	e7e5      	b.n	24f0 <fs_open+0x5c>
		return -EROFS;
    2524:	f06f 041d 	mvn.w	r4, #29
    2528:	e7e2      	b.n	24f0 <fs_open+0x5c>
		return -ENOTSUP;
    252a:	f06f 0485 	mvn.w	r4, #133	; 0x85
    252e:	e7df      	b.n	24f0 <fs_open+0x5c>
    2530:	0000eadc 	.word	0x0000eadc
    2534:	0000eaf8 	.word	0x0000eaf8
    2538:	0000eb18 	.word	0x0000eb18

0000253c <fs_close>:
{
    253c:	b538      	push	{r3, r4, r5, lr}
	if (zfp->mp == NULL) {
    253e:	6843      	ldr	r3, [r0, #4]
    2540:	b183      	cbz	r3, 2564 <fs_close+0x28>
    2542:	4604      	mov	r4, r0
	CHECKIF(zfp->mp->fs->close == NULL) {
    2544:	69db      	ldr	r3, [r3, #28]
    2546:	69db      	ldr	r3, [r3, #28]
    2548:	b173      	cbz	r3, 2568 <fs_close+0x2c>
	rc = zfp->mp->fs->close(zfp);
    254a:	4798      	blx	r3
	if (rc < 0) {
    254c:	1e05      	subs	r5, r0, #0
    254e:	db03      	blt.n	2558 <fs_close+0x1c>
	zfp->mp = NULL;
    2550:	2300      	movs	r3, #0
    2552:	6063      	str	r3, [r4, #4]
}
    2554:	4628      	mov	r0, r5
    2556:	bd38      	pop	{r3, r4, r5, pc}
		LOG_ERR("file close error (%d)", rc);
    2558:	462a      	mov	r2, r5
    255a:	2145      	movs	r1, #69	; 0x45
    255c:	4804      	ldr	r0, [pc, #16]	; (2570 <fs_close+0x34>)
    255e:	f007 feed 	bl	a33c <z_log_minimal_printk>
		return rc;
    2562:	e7f7      	b.n	2554 <fs_close+0x18>
		return 0;
    2564:	2500      	movs	r5, #0
    2566:	e7f5      	b.n	2554 <fs_close+0x18>
		return -ENOTSUP;
    2568:	f06f 0585 	mvn.w	r5, #133	; 0x85
    256c:	e7f2      	b.n	2554 <fs_close+0x18>
    256e:	bf00      	nop
    2570:	0000eb34 	.word	0x0000eb34

00002574 <fs_read>:
{
    2574:	b510      	push	{r4, lr}
	if (zfp->mp == NULL) {
    2576:	6843      	ldr	r3, [r0, #4]
    2578:	b16b      	cbz	r3, 2596 <fs_read+0x22>
	CHECKIF(zfp->mp->fs->read == NULL) {
    257a:	69db      	ldr	r3, [r3, #28]
    257c:	685b      	ldr	r3, [r3, #4]
    257e:	b16b      	cbz	r3, 259c <fs_read+0x28>
	rc = zfp->mp->fs->read(zfp, ptr, size);
    2580:	4798      	blx	r3
	if (rc < 0) {
    2582:	1e04      	subs	r4, r0, #0
    2584:	db01      	blt.n	258a <fs_read+0x16>
}
    2586:	4620      	mov	r0, r4
    2588:	bd10      	pop	{r4, pc}
		LOG_ERR("file read error (%d)", rc);
    258a:	4622      	mov	r2, r4
    258c:	2145      	movs	r1, #69	; 0x45
    258e:	4805      	ldr	r0, [pc, #20]	; (25a4 <fs_read+0x30>)
    2590:	f007 fed4 	bl	a33c <z_log_minimal_printk>
    2594:	e7f7      	b.n	2586 <fs_read+0x12>
		return -EBADF;
    2596:	f06f 0408 	mvn.w	r4, #8
    259a:	e7f4      	b.n	2586 <fs_read+0x12>
		return -ENOTSUP;
    259c:	f06f 0485 	mvn.w	r4, #133	; 0x85
    25a0:	e7f1      	b.n	2586 <fs_read+0x12>
    25a2:	bf00      	nop
    25a4:	0000eb50 	.word	0x0000eb50

000025a8 <fs_write>:
{
    25a8:	b510      	push	{r4, lr}
	if (zfp->mp == NULL) {
    25aa:	6843      	ldr	r3, [r0, #4]
    25ac:	b16b      	cbz	r3, 25ca <fs_write+0x22>
	CHECKIF(zfp->mp->fs->write == NULL) {
    25ae:	69db      	ldr	r3, [r3, #28]
    25b0:	689b      	ldr	r3, [r3, #8]
    25b2:	b16b      	cbz	r3, 25d0 <fs_write+0x28>
	rc = zfp->mp->fs->write(zfp, ptr, size);
    25b4:	4798      	blx	r3
	if (rc < 0) {
    25b6:	1e04      	subs	r4, r0, #0
    25b8:	db01      	blt.n	25be <fs_write+0x16>
}
    25ba:	4620      	mov	r0, r4
    25bc:	bd10      	pop	{r4, pc}
		LOG_ERR("file write error (%d)", rc);
    25be:	4622      	mov	r2, r4
    25c0:	2145      	movs	r1, #69	; 0x45
    25c2:	4805      	ldr	r0, [pc, #20]	; (25d8 <fs_write+0x30>)
    25c4:	f007 feba 	bl	a33c <z_log_minimal_printk>
    25c8:	e7f7      	b.n	25ba <fs_write+0x12>
		return -EBADF;
    25ca:	f06f 0408 	mvn.w	r4, #8
    25ce:	e7f4      	b.n	25ba <fs_write+0x12>
		return -ENOTSUP;
    25d0:	f06f 0485 	mvn.w	r4, #133	; 0x85
    25d4:	e7f1      	b.n	25ba <fs_write+0x12>
    25d6:	bf00      	nop
    25d8:	0000eb6c 	.word	0x0000eb6c

000025dc <fs_seek>:
{
    25dc:	b510      	push	{r4, lr}
	if (zfp->mp == NULL) {
    25de:	6843      	ldr	r3, [r0, #4]
    25e0:	b16b      	cbz	r3, 25fe <fs_seek+0x22>
	CHECKIF(zfp->mp->fs->lseek == NULL) {
    25e2:	69db      	ldr	r3, [r3, #28]
    25e4:	68db      	ldr	r3, [r3, #12]
    25e6:	b16b      	cbz	r3, 2604 <fs_seek+0x28>
	rc = zfp->mp->fs->lseek(zfp, offset, whence);
    25e8:	4798      	blx	r3
	if (rc < 0) {
    25ea:	1e04      	subs	r4, r0, #0
    25ec:	db01      	blt.n	25f2 <fs_seek+0x16>
}
    25ee:	4620      	mov	r0, r4
    25f0:	bd10      	pop	{r4, pc}
		LOG_ERR("file seek error (%d)", rc);
    25f2:	4622      	mov	r2, r4
    25f4:	2145      	movs	r1, #69	; 0x45
    25f6:	4805      	ldr	r0, [pc, #20]	; (260c <fs_seek+0x30>)
    25f8:	f007 fea0 	bl	a33c <z_log_minimal_printk>
    25fc:	e7f7      	b.n	25ee <fs_seek+0x12>
		return -EBADF;
    25fe:	f06f 0408 	mvn.w	r4, #8
    2602:	e7f4      	b.n	25ee <fs_seek+0x12>
		return -ENOTSUP;
    2604:	f06f 0485 	mvn.w	r4, #133	; 0x85
    2608:	e7f1      	b.n	25ee <fs_seek+0x12>
    260a:	bf00      	nop
    260c:	0000eb88 	.word	0x0000eb88

00002610 <fs_opendir>:
{
    2610:	b5f0      	push	{r4, r5, r6, r7, lr}
    2612:	b083      	sub	sp, #12
	if ((abs_path == NULL) ||
    2614:	b359      	cbz	r1, 266e <fs_opendir+0x5e>
    2616:	4604      	mov	r4, r0
    2618:	460e      	mov	r6, r1
			(strlen(abs_path) < 1) || (abs_path[0] != '/')) {
    261a:	4608      	mov	r0, r1
    261c:	f008 f80b 	bl	a636 <strlen>
	if ((abs_path == NULL) ||
    2620:	b328      	cbz	r0, 266e <fs_opendir+0x5e>
			(strlen(abs_path) < 1) || (abs_path[0] != '/')) {
    2622:	7833      	ldrb	r3, [r6, #0]
    2624:	2b2f      	cmp	r3, #47	; 0x2f
    2626:	d122      	bne.n	266e <fs_opendir+0x5e>
	if (zdp->mp != NULL || zdp->dirp != NULL) {
    2628:	6863      	ldr	r3, [r4, #4]
    262a:	2b00      	cmp	r3, #0
    262c:	d148      	bne.n	26c0 <fs_opendir+0xb0>
    262e:	6827      	ldr	r7, [r4, #0]
    2630:	2f00      	cmp	r7, #0
    2632:	d148      	bne.n	26c6 <fs_opendir+0xb6>
	if (strcmp(abs_path, "/") == 0) {
    2634:	4927      	ldr	r1, [pc, #156]	; (26d4 <fs_opendir+0xc4>)
    2636:	4630      	mov	r0, r6
    2638:	f008 f810 	bl	a65c <strcmp>
    263c:	4605      	mov	r5, r0
    263e:	b1e8      	cbz	r0, 267c <fs_opendir+0x6c>
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    2640:	2200      	movs	r2, #0
    2642:	4631      	mov	r1, r6
    2644:	a801      	add	r0, sp, #4
    2646:	f7ff fec5 	bl	23d4 <fs_get_mnt_point>
	if (rc < 0) {
    264a:	1e05      	subs	r5, r0, #0
    264c:	db2a      	blt.n	26a4 <fs_opendir+0x94>
	CHECKIF(mp->fs->opendir == NULL) {
    264e:	9b01      	ldr	r3, [sp, #4]
    2650:	69da      	ldr	r2, [r3, #28]
    2652:	6a12      	ldr	r2, [r2, #32]
    2654:	2a00      	cmp	r2, #0
    2656:	d039      	beq.n	26cc <fs_opendir+0xbc>
	zdp->mp = mp;
    2658:	6063      	str	r3, [r4, #4]
	rc = zdp->mp->fs->opendir(zdp, abs_path);
    265a:	69db      	ldr	r3, [r3, #28]
    265c:	6a1b      	ldr	r3, [r3, #32]
    265e:	4631      	mov	r1, r6
    2660:	4620      	mov	r0, r4
    2662:	4798      	blx	r3
	if (rc < 0) {
    2664:	1e05      	subs	r5, r0, #0
    2666:	db22      	blt.n	26ae <fs_opendir+0x9e>
}
    2668:	4628      	mov	r0, r5
    266a:	b003      	add	sp, #12
    266c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("invalid directory name!!");
    266e:	2145      	movs	r1, #69	; 0x45
    2670:	4819      	ldr	r0, [pc, #100]	; (26d8 <fs_opendir+0xc8>)
    2672:	f007 fe63 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    2676:	f06f 0515 	mvn.w	r5, #21
    267a:	e7f5      	b.n	2668 <fs_opendir+0x58>
	return z_impl_k_mutex_lock(mutex, timeout);
    267c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2680:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2684:	4815      	ldr	r0, [pc, #84]	; (26dc <fs_opendir+0xcc>)
    2686:	f005 fedb 	bl	8440 <z_impl_k_mutex_lock>
		zdp->mp = NULL;
    268a:	2300      	movs	r3, #0
    268c:	6063      	str	r3, [r4, #4]
	return list->head == list;
    268e:	4a14      	ldr	r2, [pc, #80]	; (26e0 <fs_opendir+0xd0>)
    2690:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2692:	4293      	cmp	r3, r2
    2694:	d004      	beq.n	26a0 <fs_opendir+0x90>
		zdp->dirp = sys_dlist_peek_head(&fs_mnt_list);
    2696:	6023      	str	r3, [r4, #0]
	return z_impl_k_mutex_unlock(mutex);
    2698:	4810      	ldr	r0, [pc, #64]	; (26dc <fs_opendir+0xcc>)
    269a:	f005 ff55 	bl	8548 <z_impl_k_mutex_unlock>
		return 0;
    269e:	e7e3      	b.n	2668 <fs_opendir+0x58>
    26a0:	463b      	mov	r3, r7
    26a2:	e7f8      	b.n	2696 <fs_opendir+0x86>
		LOG_ERR("mount point not found!!");
    26a4:	2145      	movs	r1, #69	; 0x45
    26a6:	480f      	ldr	r0, [pc, #60]	; (26e4 <fs_opendir+0xd4>)
    26a8:	f007 fe48 	bl	a33c <z_log_minimal_printk>
		return rc;
    26ac:	e7dc      	b.n	2668 <fs_opendir+0x58>
		zdp->mp = NULL;
    26ae:	2300      	movs	r3, #0
    26b0:	6063      	str	r3, [r4, #4]
		zdp->dirp = NULL;
    26b2:	6023      	str	r3, [r4, #0]
		LOG_ERR("directory open error (%d)", rc);
    26b4:	462a      	mov	r2, r5
    26b6:	2145      	movs	r1, #69	; 0x45
    26b8:	480b      	ldr	r0, [pc, #44]	; (26e8 <fs_opendir+0xd8>)
    26ba:	f007 fe3f 	bl	a33c <z_log_minimal_printk>
    26be:	e7d3      	b.n	2668 <fs_opendir+0x58>
		return -EBUSY;
    26c0:	f06f 050f 	mvn.w	r5, #15
    26c4:	e7d0      	b.n	2668 <fs_opendir+0x58>
    26c6:	f06f 050f 	mvn.w	r5, #15
    26ca:	e7cd      	b.n	2668 <fs_opendir+0x58>
		return -ENOTSUP;
    26cc:	f06f 0585 	mvn.w	r5, #133	; 0x85
    26d0:	e7ca      	b.n	2668 <fs_opendir+0x58>
    26d2:	bf00      	nop
    26d4:	0000ebc4 	.word	0x0000ebc4
    26d8:	0000eba4 	.word	0x0000eba4
    26dc:	20000dd0 	.word	0x20000dd0
    26e0:	20000de4 	.word	0x20000de4
    26e4:	0000eaf8 	.word	0x0000eaf8
    26e8:	0000ebc8 	.word	0x0000ebc8

000026ec <fs_readdir>:
{
    26ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    26ee:	4606      	mov	r6, r0
    26f0:	460d      	mov	r5, r1
	if (zdp->mp) {
    26f2:	6847      	ldr	r7, [r0, #4]
    26f4:	b33f      	cbz	r7, 2746 <fs_readdir+0x5a>
		CHECKIF(zdp->mp->fs->readdir == NULL) {
    26f6:	69fb      	ldr	r3, [r7, #28]
    26f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    26fa:	2b00      	cmp	r3, #0
    26fc:	d062      	beq.n	27c4 <fs_readdir+0xd8>
			rc = zdp->mp->fs->readdir(zdp, entry);
    26fe:	6873      	ldr	r3, [r6, #4]
    2700:	69db      	ldr	r3, [r3, #28]
    2702:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2704:	4629      	mov	r1, r5
    2706:	4630      	mov	r0, r6
    2708:	4798      	blx	r3
			if (rc < 0) {
    270a:	1e04      	subs	r4, r0, #0
    270c:	db11      	blt.n	2732 <fs_readdir+0x46>
			if (entry->name[0] == 0) {
    270e:	786b      	ldrb	r3, [r5, #1]
    2710:	b17b      	cbz	r3, 2732 <fs_readdir+0x46>
			if (entry->type != FS_DIR_ENTRY_DIR) {
    2712:	782b      	ldrb	r3, [r5, #0]
    2714:	2b01      	cmp	r3, #1
    2716:	d10c      	bne.n	2732 <fs_readdir+0x46>
			if ((strcmp(entry->name, ".") != 0)
    2718:	1c6f      	adds	r7, r5, #1
    271a:	492d      	ldr	r1, [pc, #180]	; (27d0 <fs_readdir+0xe4>)
    271c:	4638      	mov	r0, r7
    271e:	f007 ff9d 	bl	a65c <strcmp>
    2722:	2800      	cmp	r0, #0
    2724:	d0eb      	beq.n	26fe <fs_readdir+0x12>
			    && (strcmp(entry->name, "..") != 0)) {
    2726:	492b      	ldr	r1, [pc, #172]	; (27d4 <fs_readdir+0xe8>)
    2728:	4638      	mov	r0, r7
    272a:	f007 ff97 	bl	a65c <strcmp>
    272e:	2800      	cmp	r0, #0
    2730:	d0e5      	beq.n	26fe <fs_readdir+0x12>
		if (rc < 0) {
    2732:	2c00      	cmp	r4, #0
    2734:	db01      	blt.n	273a <fs_readdir+0x4e>
}
    2736:	4620      	mov	r0, r4
    2738:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			LOG_ERR("directory read error (%d)", rc);
    273a:	4622      	mov	r2, r4
    273c:	2145      	movs	r1, #69	; 0x45
    273e:	4826      	ldr	r0, [pc, #152]	; (27d8 <fs_readdir+0xec>)
    2740:	f007 fdfc 	bl	a33c <z_log_minimal_printk>
		return rc;
    2744:	e7f7      	b.n	2736 <fs_readdir+0x4a>
	if (zdp->dirp == NULL) {
    2746:	6803      	ldr	r3, [r0, #0]
    2748:	b163      	cbz	r3, 2764 <fs_readdir+0x78>
	return z_impl_k_mutex_lock(mutex, timeout);
    274a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    274e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2752:	4822      	ldr	r0, [pc, #136]	; (27dc <fs_readdir+0xf0>)
    2754:	f005 fe74 	bl	8440 <z_impl_k_mutex_lock>
	return list->head == list;
    2758:	4b21      	ldr	r3, [pc, #132]	; (27e0 <fs_readdir+0xf4>)
    275a:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    275c:	429c      	cmp	r4, r3
    275e:	d11c      	bne.n	279a <fs_readdir+0xae>
    2760:	463c      	mov	r4, r7
    2762:	e01a      	b.n	279a <fs_readdir+0xae>
		entry->name[0] = 0;
    2764:	2000      	movs	r0, #0
    2766:	7048      	strb	r0, [r1, #1]
		return 0;
    2768:	4604      	mov	r4, r0
    276a:	e7e4      	b.n	2736 <fs_readdir+0x4a>
			entry->type = FS_DIR_ENTRY_DIR;
    276c:	4628      	mov	r0, r5
    276e:	2301      	movs	r3, #1
    2770:	f800 3b01 	strb.w	r3, [r0], #1
			strncpy(entry->name, mnt->mnt_point + 1,
    2774:	68e1      	ldr	r1, [r4, #12]
    2776:	f44f 7280 	mov.w	r2, #256	; 0x100
    277a:	4419      	add	r1, r3
    277c:	f007 ff34 	bl	a5e8 <strncpy>
			entry->name[sizeof(entry->name) - 1] = 0;
    2780:	2300      	movs	r3, #0
    2782:	f885 3101 	strb.w	r3, [r5, #257]	; 0x101
			entry->size = 0;
    2786:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
	return (node == list->tail) ? NULL : node->next;
    278a:	4b15      	ldr	r3, [pc, #84]	; (27e0 <fs_readdir+0xf4>)
    278c:	685b      	ldr	r3, [r3, #4]
    278e:	42a3      	cmp	r3, r4
    2790:	d015      	beq.n	27be <fs_readdir+0xd2>
    2792:	6824      	ldr	r4, [r4, #0]
			found = true;
    2794:	2501      	movs	r5, #1
    2796:	e00b      	b.n	27b0 <fs_readdir+0xc4>
    2798:	463c      	mov	r4, r7
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    279a:	b144      	cbz	r4, 27ae <fs_readdir+0xc2>
		if (node == zdp->dirp) {
    279c:	6833      	ldr	r3, [r6, #0]
    279e:	429c      	cmp	r4, r3
    27a0:	d0e4      	beq.n	276c <fs_readdir+0x80>
    27a2:	4b0f      	ldr	r3, [pc, #60]	; (27e0 <fs_readdir+0xf4>)
    27a4:	685b      	ldr	r3, [r3, #4]
    27a6:	42a3      	cmp	r3, r4
    27a8:	d0f6      	beq.n	2798 <fs_readdir+0xac>
    27aa:	6824      	ldr	r4, [r4, #0]
    27ac:	e7f5      	b.n	279a <fs_readdir+0xae>
	bool found = false;
    27ae:	2500      	movs	r5, #0
	return z_impl_k_mutex_unlock(mutex);
    27b0:	480a      	ldr	r0, [pc, #40]	; (27dc <fs_readdir+0xf0>)
    27b2:	f005 fec9 	bl	8548 <z_impl_k_mutex_unlock>
	if (!found) {
    27b6:	b145      	cbz	r5, 27ca <fs_readdir+0xde>
	zdp->dirp = next;
    27b8:	6034      	str	r4, [r6, #0]
	return 0;
    27ba:	2400      	movs	r4, #0
    27bc:	e7bb      	b.n	2736 <fs_readdir+0x4a>
    27be:	463c      	mov	r4, r7
			found = true;
    27c0:	2501      	movs	r5, #1
    27c2:	e7f5      	b.n	27b0 <fs_readdir+0xc4>
			return  -ENOTSUP;
    27c4:	f06f 0485 	mvn.w	r4, #133	; 0x85
    27c8:	e7b5      	b.n	2736 <fs_readdir+0x4a>
		return -ENOENT;
    27ca:	f06f 0401 	mvn.w	r4, #1
    27ce:	e7b2      	b.n	2736 <fs_readdir+0x4a>
    27d0:	0000ebe8 	.word	0x0000ebe8
    27d4:	0000ebec 	.word	0x0000ebec
    27d8:	0000ebf0 	.word	0x0000ebf0
    27dc:	20000dd0 	.word	0x20000dd0
    27e0:	20000de4 	.word	0x20000de4

000027e4 <fs_closedir>:
{
    27e4:	b538      	push	{r3, r4, r5, lr}
    27e6:	4604      	mov	r4, r0
	if (zdp->mp == NULL) {
    27e8:	6843      	ldr	r3, [r0, #4]
    27ea:	b153      	cbz	r3, 2802 <fs_closedir+0x1e>
	CHECKIF(zdp->mp->fs->closedir == NULL) {
    27ec:	69db      	ldr	r3, [r3, #28]
    27ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    27f0:	b183      	cbz	r3, 2814 <fs_closedir+0x30>
	rc = zdp->mp->fs->closedir(zdp);
    27f2:	4798      	blx	r3
	if (rc < 0) {
    27f4:	1e05      	subs	r5, r0, #0
    27f6:	db07      	blt.n	2808 <fs_closedir+0x24>
	zdp->mp = NULL;
    27f8:	2300      	movs	r3, #0
    27fa:	6063      	str	r3, [r4, #4]
	zdp->dirp = NULL;
    27fc:	6023      	str	r3, [r4, #0]
}
    27fe:	4628      	mov	r0, r5
    2800:	bd38      	pop	{r3, r4, r5, pc}
		zdp->dirp = NULL;
    2802:	2500      	movs	r5, #0
    2804:	6005      	str	r5, [r0, #0]
		return 0;
    2806:	e7fa      	b.n	27fe <fs_closedir+0x1a>
		LOG_ERR("directory close error (%d)", rc);
    2808:	462a      	mov	r2, r5
    280a:	2145      	movs	r1, #69	; 0x45
    280c:	4803      	ldr	r0, [pc, #12]	; (281c <fs_closedir+0x38>)
    280e:	f007 fd95 	bl	a33c <z_log_minimal_printk>
		return rc;
    2812:	e7f4      	b.n	27fe <fs_closedir+0x1a>
		return -ENOTSUP;
    2814:	f06f 0585 	mvn.w	r5, #133	; 0x85
    2818:	e7f1      	b.n	27fe <fs_closedir+0x1a>
    281a:	bf00      	nop
    281c:	0000ec10 	.word	0x0000ec10

00002820 <fs_stat>:
{
    2820:	b570      	push	{r4, r5, r6, lr}
    2822:	b082      	sub	sp, #8
	if ((abs_path == NULL) ||
    2824:	b1f8      	cbz	r0, 2866 <fs_stat+0x46>
    2826:	460e      	mov	r6, r1
    2828:	4605      	mov	r5, r0
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    282a:	f007 ff04 	bl	a636 <strlen>
	if ((abs_path == NULL) ||
    282e:	2801      	cmp	r0, #1
    2830:	d919      	bls.n	2866 <fs_stat+0x46>
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    2832:	782b      	ldrb	r3, [r5, #0]
    2834:	2b2f      	cmp	r3, #47	; 0x2f
    2836:	d116      	bne.n	2866 <fs_stat+0x46>
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    2838:	2200      	movs	r2, #0
    283a:	4629      	mov	r1, r5
    283c:	a801      	add	r0, sp, #4
    283e:	f7ff fdc9 	bl	23d4 <fs_get_mnt_point>
	if (rc < 0) {
    2842:	1e04      	subs	r4, r0, #0
    2844:	db16      	blt.n	2874 <fs_stat+0x54>
	CHECKIF(mp->fs->stat == NULL) {
    2846:	9801      	ldr	r0, [sp, #4]
    2848:	69c3      	ldr	r3, [r0, #28]
    284a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    284c:	b1eb      	cbz	r3, 288a <fs_stat+0x6a>
	rc = mp->fs->stat(mp, abs_path, entry);
    284e:	4632      	mov	r2, r6
    2850:	4629      	mov	r1, r5
    2852:	4798      	blx	r3
    2854:	4604      	mov	r4, r0
	if (rc == -ENOENT) {
    2856:	f110 0f02 	cmn.w	r0, #2
    285a:	d001      	beq.n	2860 <fs_stat+0x40>
	} else if (rc < 0) {
    285c:	2800      	cmp	r0, #0
    285e:	db0e      	blt.n	287e <fs_stat+0x5e>
}
    2860:	4620      	mov	r0, r4
    2862:	b002      	add	sp, #8
    2864:	bd70      	pop	{r4, r5, r6, pc}
		LOG_ERR("invalid file or dir name!!");
    2866:	2145      	movs	r1, #69	; 0x45
    2868:	4809      	ldr	r0, [pc, #36]	; (2890 <fs_stat+0x70>)
    286a:	f007 fd67 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    286e:	f06f 0415 	mvn.w	r4, #21
    2872:	e7f5      	b.n	2860 <fs_stat+0x40>
		LOG_ERR("mount point not found!!");
    2874:	2145      	movs	r1, #69	; 0x45
    2876:	4807      	ldr	r0, [pc, #28]	; (2894 <fs_stat+0x74>)
    2878:	f007 fd60 	bl	a33c <z_log_minimal_printk>
		return rc;
    287c:	e7f0      	b.n	2860 <fs_stat+0x40>
		LOG_ERR("failed get file or dir stat (%d)", rc);
    287e:	4602      	mov	r2, r0
    2880:	2145      	movs	r1, #69	; 0x45
    2882:	4805      	ldr	r0, [pc, #20]	; (2898 <fs_stat+0x78>)
    2884:	f007 fd5a 	bl	a33c <z_log_minimal_printk>
    2888:	e7ea      	b.n	2860 <fs_stat+0x40>
		return -ENOTSUP;
    288a:	f06f 0485 	mvn.w	r4, #133	; 0x85
    288e:	e7e7      	b.n	2860 <fs_stat+0x40>
    2890:	0000ec30 	.word	0x0000ec30
    2894:	0000eaf8 	.word	0x0000eaf8
    2898:	0000ec50 	.word	0x0000ec50

0000289c <fs_statvfs>:
{
    289c:	b570      	push	{r4, r5, r6, lr}
    289e:	b082      	sub	sp, #8
	if ((abs_path == NULL) ||
    28a0:	b1d8      	cbz	r0, 28da <fs_statvfs+0x3e>
    28a2:	460e      	mov	r6, r1
    28a4:	4605      	mov	r5, r0
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    28a6:	f007 fec6 	bl	a636 <strlen>
	if ((abs_path == NULL) ||
    28aa:	2801      	cmp	r0, #1
    28ac:	d915      	bls.n	28da <fs_statvfs+0x3e>
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    28ae:	782b      	ldrb	r3, [r5, #0]
    28b0:	2b2f      	cmp	r3, #47	; 0x2f
    28b2:	d112      	bne.n	28da <fs_statvfs+0x3e>
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    28b4:	2200      	movs	r2, #0
    28b6:	4629      	mov	r1, r5
    28b8:	a801      	add	r0, sp, #4
    28ba:	f7ff fd8b 	bl	23d4 <fs_get_mnt_point>
	if (rc < 0) {
    28be:	1e04      	subs	r4, r0, #0
    28c0:	db12      	blt.n	28e8 <fs_statvfs+0x4c>
	CHECKIF(mp->fs->statvfs == NULL) {
    28c2:	9801      	ldr	r0, [sp, #4]
    28c4:	69c3      	ldr	r3, [r0, #28]
    28c6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    28c8:	b1cb      	cbz	r3, 28fe <fs_statvfs+0x62>
	rc = mp->fs->statvfs(mp, abs_path, stat);
    28ca:	4632      	mov	r2, r6
    28cc:	4629      	mov	r1, r5
    28ce:	4798      	blx	r3
	if (rc < 0) {
    28d0:	1e04      	subs	r4, r0, #0
    28d2:	db0e      	blt.n	28f2 <fs_statvfs+0x56>
}
    28d4:	4620      	mov	r0, r4
    28d6:	b002      	add	sp, #8
    28d8:	bd70      	pop	{r4, r5, r6, pc}
		LOG_ERR("invalid file or dir name!!");
    28da:	2145      	movs	r1, #69	; 0x45
    28dc:	4809      	ldr	r0, [pc, #36]	; (2904 <fs_statvfs+0x68>)
    28de:	f007 fd2d 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    28e2:	f06f 0415 	mvn.w	r4, #21
    28e6:	e7f5      	b.n	28d4 <fs_statvfs+0x38>
		LOG_ERR("mount point not found!!");
    28e8:	2145      	movs	r1, #69	; 0x45
    28ea:	4807      	ldr	r0, [pc, #28]	; (2908 <fs_statvfs+0x6c>)
    28ec:	f007 fd26 	bl	a33c <z_log_minimal_printk>
		return rc;
    28f0:	e7f0      	b.n	28d4 <fs_statvfs+0x38>
		LOG_ERR("failed get file or dir stat (%d)", rc);
    28f2:	4622      	mov	r2, r4
    28f4:	2145      	movs	r1, #69	; 0x45
    28f6:	4805      	ldr	r0, [pc, #20]	; (290c <fs_statvfs+0x70>)
    28f8:	f007 fd20 	bl	a33c <z_log_minimal_printk>
    28fc:	e7ea      	b.n	28d4 <fs_statvfs+0x38>
		return -ENOTSUP;
    28fe:	f06f 0485 	mvn.w	r4, #133	; 0x85
    2902:	e7e7      	b.n	28d4 <fs_statvfs+0x38>
    2904:	0000ec30 	.word	0x0000ec30
    2908:	0000eaf8 	.word	0x0000eaf8
    290c:	0000ec50 	.word	0x0000ec50

00002910 <fs_mount>:
{
    2910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((mp == NULL) || (mp->mnt_point == NULL)) {
    2912:	b1d0      	cbz	r0, 294a <fs_mount+0x3a>
    2914:	4606      	mov	r6, r0
    2916:	68c0      	ldr	r0, [r0, #12]
    2918:	b1b8      	cbz	r0, 294a <fs_mount+0x3a>
	return node->next != NULL;
    291a:	6837      	ldr	r7, [r6, #0]
	if (sys_dnode_is_linked(&mp->node)) {
    291c:	b9e7      	cbnz	r7, 2958 <fs_mount+0x48>
	len = strlen(mp->mnt_point);
    291e:	f007 fe8a 	bl	a636 <strlen>
    2922:	4605      	mov	r5, r0
	if ((len <= 1) || (mp->mnt_point[0] != '/')) {
    2924:	2801      	cmp	r0, #1
    2926:	d91e      	bls.n	2966 <fs_mount+0x56>
    2928:	68f3      	ldr	r3, [r6, #12]
    292a:	781b      	ldrb	r3, [r3, #0]
    292c:	2b2f      	cmp	r3, #47	; 0x2f
    292e:	d11a      	bne.n	2966 <fs_mount+0x56>
	return z_impl_k_mutex_lock(mutex, timeout);
    2930:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2934:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2938:	483c      	ldr	r0, [pc, #240]	; (2a2c <fs_mount+0x11c>)
    293a:	f005 fd81 	bl	8440 <z_impl_k_mutex_lock>
	return list->head == list;
    293e:	4b3c      	ldr	r3, [pc, #240]	; (2a30 <fs_mount+0x120>)
    2940:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    2942:	429c      	cmp	r4, r3
    2944:	d122      	bne.n	298c <fs_mount+0x7c>
    2946:	463c      	mov	r4, r7
    2948:	e020      	b.n	298c <fs_mount+0x7c>
		LOG_ERR("mount point not initialized!!");
    294a:	2145      	movs	r1, #69	; 0x45
    294c:	4839      	ldr	r0, [pc, #228]	; (2a34 <fs_mount+0x124>)
    294e:	f007 fcf5 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    2952:	f06f 0415 	mvn.w	r4, #21
    2956:	e04b      	b.n	29f0 <fs_mount+0xe0>
		LOG_ERR("file system already mounted!!");
    2958:	2145      	movs	r1, #69	; 0x45
    295a:	4837      	ldr	r0, [pc, #220]	; (2a38 <fs_mount+0x128>)
    295c:	f007 fcee 	bl	a33c <z_log_minimal_printk>
		return -EBUSY;
    2960:	f06f 040f 	mvn.w	r4, #15
    2964:	e044      	b.n	29f0 <fs_mount+0xe0>
		LOG_ERR("invalid mount point!!");
    2966:	2145      	movs	r1, #69	; 0x45
    2968:	4834      	ldr	r0, [pc, #208]	; (2a3c <fs_mount+0x12c>)
    296a:	f007 fce7 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    296e:	f06f 0415 	mvn.w	r4, #21
    2972:	e03d      	b.n	29f0 <fs_mount+0xe0>
			LOG_ERR("file system already mounted!!");
    2974:	2145      	movs	r1, #69	; 0x45
    2976:	4830      	ldr	r0, [pc, #192]	; (2a38 <fs_mount+0x128>)
    2978:	f007 fce0 	bl	a33c <z_log_minimal_printk>
			rc = -EBUSY;
    297c:	f06f 040f 	mvn.w	r4, #15
			goto mount_err;
    2980:	e033      	b.n	29ea <fs_mount+0xda>
	return (node == list->tail) ? NULL : node->next;
    2982:	4b2b      	ldr	r3, [pc, #172]	; (2a30 <fs_mount+0x120>)
    2984:	685b      	ldr	r3, [r3, #4]
    2986:	42a3      	cmp	r3, r4
    2988:	d016      	beq.n	29b8 <fs_mount+0xa8>
    298a:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    298c:	b1b4      	cbz	r4, 29bc <fs_mount+0xac>
		if (len != itr->mountp_len) {
    298e:	69a3      	ldr	r3, [r4, #24]
    2990:	42ab      	cmp	r3, r5
    2992:	d1f6      	bne.n	2982 <fs_mount+0x72>
		CHECKIF(mp->fs_data == itr->fs_data) {
    2994:	6932      	ldr	r2, [r6, #16]
    2996:	6923      	ldr	r3, [r4, #16]
    2998:	429a      	cmp	r2, r3
    299a:	d0eb      	beq.n	2974 <fs_mount+0x64>
		if (strncmp(mp->mnt_point, itr->mnt_point, len) == 0) {
    299c:	462a      	mov	r2, r5
    299e:	68e1      	ldr	r1, [r4, #12]
    29a0:	68f0      	ldr	r0, [r6, #12]
    29a2:	f007 fe66 	bl	a672 <strncmp>
    29a6:	2800      	cmp	r0, #0
    29a8:	d1eb      	bne.n	2982 <fs_mount+0x72>
			LOG_ERR("mount point already exists!!");
    29aa:	2145      	movs	r1, #69	; 0x45
    29ac:	4824      	ldr	r0, [pc, #144]	; (2a40 <fs_mount+0x130>)
    29ae:	f007 fcc5 	bl	a33c <z_log_minimal_printk>
			rc = -EBUSY;
    29b2:	f06f 040f 	mvn.w	r4, #15
			goto mount_err;
    29b6:	e018      	b.n	29ea <fs_mount+0xda>
    29b8:	463c      	mov	r4, r7
    29ba:	e7e7      	b.n	298c <fs_mount+0x7c>
	fs = fs_type_get(mp->type);
    29bc:	68b4      	ldr	r4, [r6, #8]
    29be:	4620      	mov	r0, r4
    29c0:	f007 fef7 	bl	a7b2 <fs_type_get>
	if (fs == NULL) {
    29c4:	4607      	mov	r7, r0
    29c6:	b1a8      	cbz	r0, 29f4 <fs_mount+0xe4>
	CHECKIF(fs->mount == NULL) {
    29c8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    29ca:	b1d3      	cbz	r3, 2a02 <fs_mount+0xf2>
	if (fs->unmount == NULL) {
    29cc:	6b03      	ldr	r3, [r0, #48]	; 0x30
    29ce:	b303      	cbz	r3, 2a12 <fs_mount+0x102>
	rc = fs->mount(mp);
    29d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    29d2:	4630      	mov	r0, r6
    29d4:	4798      	blx	r3
	if (rc < 0) {
    29d6:	1e04      	subs	r4, r0, #0
    29d8:	db21      	blt.n	2a1e <fs_mount+0x10e>
	mp->mountp_len = len;
    29da:	61b5      	str	r5, [r6, #24]
	mp->fs = fs;
    29dc:	61f7      	str	r7, [r6, #28]
 * @param node the element to append
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;
    29de:	4b14      	ldr	r3, [pc, #80]	; (2a30 <fs_mount+0x120>)
    29e0:	685a      	ldr	r2, [r3, #4]

	node->next = list;
    29e2:	6033      	str	r3, [r6, #0]
	node->prev = tail;
    29e4:	6072      	str	r2, [r6, #4]

	tail->next = node;
    29e6:	6016      	str	r6, [r2, #0]
	list->tail = node;
    29e8:	605e      	str	r6, [r3, #4]
	return z_impl_k_mutex_unlock(mutex);
    29ea:	4810      	ldr	r0, [pc, #64]	; (2a2c <fs_mount+0x11c>)
    29ec:	f005 fdac 	bl	8548 <z_impl_k_mutex_unlock>
}
    29f0:	4620      	mov	r0, r4
    29f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		LOG_ERR("requested file system type not registered!!");
    29f4:	2145      	movs	r1, #69	; 0x45
    29f6:	4813      	ldr	r0, [pc, #76]	; (2a44 <fs_mount+0x134>)
    29f8:	f007 fca0 	bl	a33c <z_log_minimal_printk>
		rc = -ENOENT;
    29fc:	f06f 0401 	mvn.w	r4, #1
		goto mount_err;
    2a00:	e7f3      	b.n	29ea <fs_mount+0xda>
		LOG_ERR("fs type %d does not support mounting", mp->type);
    2a02:	4622      	mov	r2, r4
    2a04:	2145      	movs	r1, #69	; 0x45
    2a06:	4810      	ldr	r0, [pc, #64]	; (2a48 <fs_mount+0x138>)
    2a08:	f007 fc98 	bl	a33c <z_log_minimal_printk>
		rc = -ENOTSUP;
    2a0c:	f06f 0485 	mvn.w	r4, #133	; 0x85
		goto mount_err;
    2a10:	e7eb      	b.n	29ea <fs_mount+0xda>
		LOG_WRN("mount path %s is not unmountable",
    2a12:	68f2      	ldr	r2, [r6, #12]
    2a14:	2157      	movs	r1, #87	; 0x57
    2a16:	480d      	ldr	r0, [pc, #52]	; (2a4c <fs_mount+0x13c>)
    2a18:	f007 fc90 	bl	a33c <z_log_minimal_printk>
    2a1c:	e7d8      	b.n	29d0 <fs_mount+0xc0>
		LOG_ERR("fs mount error (%d)", rc);
    2a1e:	4622      	mov	r2, r4
    2a20:	2145      	movs	r1, #69	; 0x45
    2a22:	480b      	ldr	r0, [pc, #44]	; (2a50 <fs_mount+0x140>)
    2a24:	f007 fc8a 	bl	a33c <z_log_minimal_printk>
		goto mount_err;
    2a28:	e7df      	b.n	29ea <fs_mount+0xda>
    2a2a:	bf00      	nop
    2a2c:	20000dd0 	.word	0x20000dd0
    2a30:	20000de4 	.word	0x20000de4
    2a34:	0000ec78 	.word	0x0000ec78
    2a38:	0000ec9c 	.word	0x0000ec9c
    2a3c:	0000ecc0 	.word	0x0000ecc0
    2a40:	0000ecdc 	.word	0x0000ecdc
    2a44:	0000ed00 	.word	0x0000ed00
    2a48:	0000ed34 	.word	0x0000ed34
    2a4c:	0000ed60 	.word	0x0000ed60
    2a50:	0000ed88 	.word	0x0000ed88

00002a54 <fs_unmount>:
{
    2a54:	b538      	push	{r3, r4, r5, lr}
	if (mp == NULL) {
    2a56:	2800      	cmp	r0, #0
    2a58:	d032      	beq.n	2ac0 <fs_unmount+0x6c>
    2a5a:	4604      	mov	r4, r0
	return z_impl_k_mutex_lock(mutex, timeout);
    2a5c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2a60:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2a64:	4818      	ldr	r0, [pc, #96]	; (2ac8 <fs_unmount+0x74>)
    2a66:	f005 fceb 	bl	8440 <z_impl_k_mutex_lock>
	return node->next != NULL;
    2a6a:	6823      	ldr	r3, [r4, #0]
	if (!sys_dnode_is_linked(&mp->node)) {
    2a6c:	b19b      	cbz	r3, 2a96 <fs_unmount+0x42>
	CHECKIF(mp->fs->unmount == NULL) {
    2a6e:	69e3      	ldr	r3, [r4, #28]
    2a70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2a72:	b1c3      	cbz	r3, 2aa6 <fs_unmount+0x52>
	rc = mp->fs->unmount(mp);
    2a74:	4620      	mov	r0, r4
    2a76:	4798      	blx	r3
	if (rc < 0) {
    2a78:	1e05      	subs	r5, r0, #0
    2a7a:	db1b      	blt.n	2ab4 <fs_unmount+0x60>
	mp->fs = NULL;
    2a7c:	2300      	movs	r3, #0
    2a7e:	61e3      	str	r3, [r4, #28]
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    2a80:	6861      	ldr	r1, [r4, #4]
	sys_dnode_t *const next = node->next;
    2a82:	6822      	ldr	r2, [r4, #0]

	prev->next = next;
    2a84:	600a      	str	r2, [r1, #0]
	next->prev = prev;
    2a86:	6051      	str	r1, [r2, #4]
	node->next = NULL;
    2a88:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
    2a8a:	6063      	str	r3, [r4, #4]
	return z_impl_k_mutex_unlock(mutex);
    2a8c:	480e      	ldr	r0, [pc, #56]	; (2ac8 <fs_unmount+0x74>)
    2a8e:	f005 fd5b 	bl	8548 <z_impl_k_mutex_unlock>
}
    2a92:	4628      	mov	r0, r5
    2a94:	bd38      	pop	{r3, r4, r5, pc}
		LOG_ERR("fs not mounted (mp == %p)", mp);
    2a96:	4622      	mov	r2, r4
    2a98:	2145      	movs	r1, #69	; 0x45
    2a9a:	480c      	ldr	r0, [pc, #48]	; (2acc <fs_unmount+0x78>)
    2a9c:	f007 fc4e 	bl	a33c <z_log_minimal_printk>
	int rc = -EINVAL;
    2aa0:	f06f 0515 	mvn.w	r5, #21
		goto unmount_err;
    2aa4:	e7f2      	b.n	2a8c <fs_unmount+0x38>
		LOG_ERR("fs unmount not supported!!");
    2aa6:	2145      	movs	r1, #69	; 0x45
    2aa8:	4809      	ldr	r0, [pc, #36]	; (2ad0 <fs_unmount+0x7c>)
    2aaa:	f007 fc47 	bl	a33c <z_log_minimal_printk>
		rc = -ENOTSUP;
    2aae:	f06f 0585 	mvn.w	r5, #133	; 0x85
		goto unmount_err;
    2ab2:	e7eb      	b.n	2a8c <fs_unmount+0x38>
		LOG_ERR("fs unmount error (%d)", rc);
    2ab4:	462a      	mov	r2, r5
    2ab6:	2145      	movs	r1, #69	; 0x45
    2ab8:	4806      	ldr	r0, [pc, #24]	; (2ad4 <fs_unmount+0x80>)
    2aba:	f007 fc3f 	bl	a33c <z_log_minimal_printk>
		goto unmount_err;
    2abe:	e7e5      	b.n	2a8c <fs_unmount+0x38>
		return rc;
    2ac0:	f06f 0515 	mvn.w	r5, #21
    2ac4:	e7e5      	b.n	2a92 <fs_unmount+0x3e>
    2ac6:	bf00      	nop
    2ac8:	20000dd0 	.word	0x20000dd0
    2acc:	0000eda4 	.word	0x0000eda4
    2ad0:	0000edc4 	.word	0x0000edc4
    2ad4:	0000ede4 	.word	0x0000ede4

00002ad8 <fs_register>:
{
    2ad8:	b538      	push	{r3, r4, r5, lr}
    2ada:	4604      	mov	r4, r0
    2adc:	460d      	mov	r5, r1
	return z_impl_k_mutex_lock(mutex, timeout);
    2ade:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2ae2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    2ae6:	480a      	ldr	r0, [pc, #40]	; (2b10 <fs_register+0x38>)
    2ae8:	f005 fcaa 	bl	8440 <z_impl_k_mutex_lock>
	if (fs_type_get(type) != NULL) {
    2aec:	4620      	mov	r0, r4
    2aee:	f007 fe60 	bl	a7b2 <fs_type_get>
    2af2:	b948      	cbnz	r0, 2b08 <fs_register+0x30>
		rc = registry_add(type, fs);
    2af4:	4629      	mov	r1, r5
    2af6:	4620      	mov	r0, r4
    2af8:	f7ff fc3e 	bl	2378 <registry_add>
    2afc:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    2afe:	4804      	ldr	r0, [pc, #16]	; (2b10 <fs_register+0x38>)
    2b00:	f005 fd22 	bl	8548 <z_impl_k_mutex_unlock>
}
    2b04:	4620      	mov	r0, r4
    2b06:	bd38      	pop	{r3, r4, r5, pc}
		rc = -EALREADY;
    2b08:	f06f 0477 	mvn.w	r4, #119	; 0x77
    2b0c:	e7f7      	b.n	2afe <fs_register+0x26>
    2b0e:	bf00      	nop
    2b10:	20000dd0 	.word	0x20000dd0

00002b14 <fs_impl_strip_prefix>:
const char *fs_impl_strip_prefix(const char *path,
				 const struct fs_mount_t *mp)
{
	static const char *const root = "/";

	if ((path == NULL) || (mp == NULL)) {
    2b14:	4603      	mov	r3, r0
    2b16:	b128      	cbz	r0, 2b24 <fs_impl_strip_prefix+0x10>
    2b18:	b129      	cbz	r1, 2b26 <fs_impl_strip_prefix+0x12>
		return path;
	}

	path += mp->mountp_len;
    2b1a:	698a      	ldr	r2, [r1, #24]
    2b1c:	4410      	add	r0, r2
	return *path ? path : root;
    2b1e:	5c9b      	ldrb	r3, [r3, r2]
    2b20:	b113      	cbz	r3, 2b28 <fs_impl_strip_prefix+0x14>
    2b22:	4770      	bx	lr
    2b24:	4770      	bx	lr
    2b26:	4770      	bx	lr
    2b28:	4800      	ldr	r0, [pc, #0]	; (2b2c <fs_impl_strip_prefix+0x18>)
}
    2b2a:	4770      	bx	lr
    2b2c:	0000ebc4 	.word	0x0000ebc4

00002b30 <littlefs_init>:
		}
	}
}

static int littlefs_init(void)
{
    2b30:	b508      	push	{r3, lr}
	static struct fs_mount_t *partitions[] = {
		DT_INST_FOREACH_STATUS_OKAY(REFERENCE_MOUNT)
	};

	int rc = fs_register(FS_LITTLEFS, &littlefs_fs);
    2b32:	4902      	ldr	r1, [pc, #8]	; (2b3c <littlefs_init+0xc>)
    2b34:	2001      	movs	r0, #1
    2b36:	f7ff ffcf 	bl	2ad8 <fs_register>
			mount_init(*mpi++);
		}
	}

	return rc;
}
    2b3a:	bd08      	pop	{r3, pc}
    2b3c:	0000ef94 	.word	0x0000ef94

00002b40 <littlefs_unmount>:
{
    2b40:	b570      	push	{r4, r5, r6, lr}
    2b42:	4605      	mov	r5, r0
	struct fs_littlefs *fs = mountp->fs_data;
    2b44:	6904      	ldr	r4, [r0, #16]
	fs_lock(fs);
    2b46:	4620      	mov	r0, r4
    2b48:	f007 fed5 	bl	a8f6 <fs_lock>
	lfs_unmount(&fs->lfs);
    2b4c:	f104 0074 	add.w	r0, r4, #116	; 0x74
    2b50:	f00a fcd0 	bl	d4f4 <lfs_unmount>
		flash_area_close(fs->backend);
    2b54:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
    2b58:	f007 fc27 	bl	a3aa <flash_area_close>
	fs->backend = NULL;
    2b5c:	2600      	movs	r6, #0
    2b5e:	f8c4 60ec 	str.w	r6, [r4, #236]	; 0xec
	k_mutex_unlock(&fs->mutex);
    2b62:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    2b66:	f005 fcef 	bl	8548 <z_impl_k_mutex_unlock>
	LOG_INF("%s unmounted", mountp->mnt_point);
    2b6a:	68ea      	ldr	r2, [r5, #12]
    2b6c:	2149      	movs	r1, #73	; 0x49
    2b6e:	4802      	ldr	r0, [pc, #8]	; (2b78 <littlefs_unmount+0x38>)
    2b70:	f007 fbe4 	bl	a33c <z_log_minimal_printk>
}
    2b74:	4630      	mov	r0, r6
    2b76:	bd70      	pop	{r4, r5, r6, pc}
    2b78:	0000ee04 	.word	0x0000ee04

00002b7c <littlefs_flash_init>:
{
    2b7c:	b538      	push	{r3, r4, r5, lr}
    2b7e:	4604      	mov	r4, r0
    2b80:	460d      	mov	r5, r1
	ret = flash_area_open(area_id, fap);
    2b82:	f100 01ec 	add.w	r1, r0, #236	; 0xec
    2b86:	b2e8      	uxtb	r0, r5
    2b88:	f7fe fc58 	bl	143c <flash_area_open>
	if ((ret < 0) || (*fap == NULL)) {
    2b8c:	2800      	cmp	r0, #0
    2b8e:	db07      	blt.n	2ba0 <littlefs_flash_init+0x24>
    2b90:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
    2b94:	b120      	cbz	r0, 2ba0 <littlefs_flash_init+0x24>
	dev = flash_area_get_device(*fap);
    2b96:	f007 fc58 	bl	a44a <flash_area_get_device>
	if (dev == NULL) {
    2b9a:	b148      	cbz	r0, 2bb0 <littlefs_flash_init+0x34>
	return 0;
    2b9c:	2000      	movs	r0, #0
}
    2b9e:	bd38      	pop	{r3, r4, r5, pc}
		LOG_ERR("can't open flash area %d", area_id);
    2ba0:	462a      	mov	r2, r5
    2ba2:	2145      	movs	r1, #69	; 0x45
    2ba4:	4808      	ldr	r0, [pc, #32]	; (2bc8 <littlefs_flash_init+0x4c>)
    2ba6:	f007 fbc9 	bl	a33c <z_log_minimal_printk>
		return -ENODEV;
    2baa:	f06f 0012 	mvn.w	r0, #18
    2bae:	e7f6      	b.n	2b9e <littlefs_flash_init+0x22>
		LOG_ERR("can't get flash device: %s",
    2bb0:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    2bb4:	68db      	ldr	r3, [r3, #12]
    2bb6:	681a      	ldr	r2, [r3, #0]
    2bb8:	2145      	movs	r1, #69	; 0x45
    2bba:	4804      	ldr	r0, [pc, #16]	; (2bcc <littlefs_flash_init+0x50>)
    2bbc:	f007 fbbe 	bl	a33c <z_log_minimal_printk>
		return -ENODEV;
    2bc0:	f06f 0012 	mvn.w	r0, #18
    2bc4:	e7eb      	b.n	2b9e <littlefs_flash_init+0x22>
    2bc6:	bf00      	nop
    2bc8:	0000ee18 	.word	0x0000ee18
    2bcc:	0000ee38 	.word	0x0000ee38

00002bd0 <get_block_size>:
{
    2bd0:	b500      	push	{lr}
    2bd2:	b083      	sub	sp, #12
	struct get_page_ctx ctx = {
    2bd4:	9000      	str	r0, [sp, #0]
    2bd6:	2300      	movs	r3, #0
    2bd8:	9301      	str	r3, [sp, #4]
	const struct device *dev = flash_area_get_device(fa);
    2bda:	f007 fc36 	bl	a44a <flash_area_get_device>
	flash_page_foreach(dev, get_page_cb, &ctx);
    2bde:	466a      	mov	r2, sp
    2be0:	4903      	ldr	r1, [pc, #12]	; (2bf0 <get_block_size+0x20>)
    2be2:	f008 fbc4 	bl	b36e <flash_page_foreach>
}
    2be6:	9801      	ldr	r0, [sp, #4]
    2be8:	b003      	add	sp, #12
    2bea:	f85d fb04 	ldr.w	pc, [sp], #4
    2bee:	bf00      	nop
    2bf0:	0000a8c1 	.word	0x0000a8c1

00002bf4 <littlefs_init_cfg>:
{
    2bf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2bf8:	b085      	sub	sp, #20
    2bfa:	4604      	mov	r4, r0
	lfs_size_t read_size = lcp->read_size;
    2bfc:	f8d0 9014 	ldr.w	r9, [r0, #20]
	if (read_size == 0) {
    2c00:	f1b9 0f00 	cmp.w	r9, #0
    2c04:	d101      	bne.n	2c0a <littlefs_init_cfg+0x16>
		read_size = CONFIG_FS_LITTLEFS_READ_SIZE;
    2c06:	f04f 0910 	mov.w	r9, #16
	lfs_size_t prog_size = lcp->prog_size;
    2c0a:	f8d4 8018 	ldr.w	r8, [r4, #24]
	if (prog_size == 0) {
    2c0e:	f1b8 0f00 	cmp.w	r8, #0
    2c12:	d101      	bne.n	2c18 <littlefs_init_cfg+0x24>
		prog_size = CONFIG_FS_LITTLEFS_PROG_SIZE;
    2c14:	f04f 0810 	mov.w	r8, #16
	lfs_size_t block_size = lcp->block_size;
    2c18:	69e5      	ldr	r5, [r4, #28]
	if (block_size == 0) {
    2c1a:	b135      	cbz	r5, 2c2a <littlefs_init_cfg+0x36>
	int32_t block_cycles = lcp->block_cycles;
    2c1c:	6a66      	ldr	r6, [r4, #36]	; 0x24
	if (block_cycles == 0) {
    2c1e:	b176      	cbz	r6, 2c3e <littlefs_init_cfg+0x4a>
	if (block_cycles <= 0) {
    2c20:	2e00      	cmp	r6, #0
    2c22:	dc0e      	bgt.n	2c42 <littlefs_init_cfg+0x4e>
		block_cycles = -1;
    2c24:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    2c28:	e00b      	b.n	2c42 <littlefs_init_cfg+0x4e>
			block_size = get_block_size((struct flash_area *)fs->backend);
    2c2a:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
    2c2e:	f7ff ffcf 	bl	2bd0 <get_block_size>
	if (block_size == 0) {
    2c32:	4605      	mov	r5, r0
    2c34:	2800      	cmp	r0, #0
    2c36:	d1f1      	bne.n	2c1c <littlefs_init_cfg+0x28>
		return -EINVAL;
    2c38:	f06f 0015 	mvn.w	r0, #21
    2c3c:	e042      	b.n	2cc4 <littlefs_init_cfg+0xd0>
		block_cycles = CONFIG_FS_LITTLEFS_BLOCK_CYCLES;
    2c3e:	f44f 7600 	mov.w	r6, #512	; 0x200
	lfs_size_t cache_size = lcp->cache_size;
    2c42:	f8d4 b028 	ldr.w	fp, [r4, #40]	; 0x28
	if (cache_size == 0) {
    2c46:	f1bb 0f00 	cmp.w	fp, #0
    2c4a:	d101      	bne.n	2c50 <littlefs_init_cfg+0x5c>
		cache_size = CONFIG_FS_LITTLEFS_CACHE_SIZE;
    2c4c:	f04f 0b40 	mov.w	fp, #64	; 0x40
	lfs_size_t lookahead_size = lcp->lookahead_size;
    2c50:	f8d4 a02c 	ldr.w	sl, [r4, #44]	; 0x2c
	if (lookahead_size == 0) {
    2c54:	f1ba 0f00 	cmp.w	sl, #0
    2c58:	d101      	bne.n	2c5e <littlefs_init_cfg+0x6a>
		lookahead_size = CONFIG_FS_LITTLEFS_LOOKAHEAD_SIZE;
    2c5a:	f04f 0a20 	mov.w	sl, #32
		block_count = ((struct flash_area *)fs->backend)->fa_size
    2c5e:	f8d4 00ec 	ldr.w	r0, [r4, #236]	; 0xec
    2c62:	6887      	ldr	r7, [r0, #8]
			/ block_size;
    2c64:	fbb7 f7f5 	udiv	r7, r7, r5
			flash_area_get_device((struct flash_area *)fs->backend);
    2c68:	f007 fbef 	bl	a44a <flash_area_get_device>
		LOG_INF("FS at %s:0x%x is %u 0x%x-byte blocks with %u cycle",
    2c6c:	6802      	ldr	r2, [r0, #0]
    2c6e:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    2c72:	685b      	ldr	r3, [r3, #4]
    2c74:	9602      	str	r6, [sp, #8]
    2c76:	9501      	str	r5, [sp, #4]
    2c78:	9700      	str	r7, [sp, #0]
    2c7a:	2149      	movs	r1, #73	; 0x49
    2c7c:	4813      	ldr	r0, [pc, #76]	; (2ccc <littlefs_init_cfg+0xd8>)
    2c7e:	f007 fb5d 	bl	a33c <z_log_minimal_printk>
		LOG_INF("sizes: rd %u ; pr %u ; ca %u ; la %u",
    2c82:	f8cd a004 	str.w	sl, [sp, #4]
    2c86:	f8cd b000 	str.w	fp, [sp]
    2c8a:	4643      	mov	r3, r8
    2c8c:	464a      	mov	r2, r9
    2c8e:	2149      	movs	r1, #73	; 0x49
    2c90:	480f      	ldr	r0, [pc, #60]	; (2cd0 <littlefs_init_cfg+0xdc>)
    2c92:	f007 fb53 	bl	a33c <z_log_minimal_printk>
	lcp->context = fs->backend;
    2c96:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    2c9a:	6023      	str	r3, [r4, #0]
		lcp->read = lfs_api_read;
    2c9c:	4b0d      	ldr	r3, [pc, #52]	; (2cd4 <littlefs_init_cfg+0xe0>)
    2c9e:	6063      	str	r3, [r4, #4]
		lcp->prog = lfs_api_prog;
    2ca0:	4b0d      	ldr	r3, [pc, #52]	; (2cd8 <littlefs_init_cfg+0xe4>)
    2ca2:	60a3      	str	r3, [r4, #8]
		lcp->erase = lfs_api_erase;
    2ca4:	4b0d      	ldr	r3, [pc, #52]	; (2cdc <littlefs_init_cfg+0xe8>)
    2ca6:	60e3      	str	r3, [r4, #12]
		lcp->read_size = read_size;
    2ca8:	f8c4 9014 	str.w	r9, [r4, #20]
		lcp->prog_size = prog_size;
    2cac:	f8c4 8018 	str.w	r8, [r4, #24]
		lcp->cache_size = cache_size;
    2cb0:	f8c4 b028 	str.w	fp, [r4, #40]	; 0x28
		lcp->lookahead_size = lookahead_size;
    2cb4:	f8c4 a02c 	str.w	sl, [r4, #44]	; 0x2c
		lcp->sync = lfs_api_sync;
    2cb8:	4b09      	ldr	r3, [pc, #36]	; (2ce0 <littlefs_init_cfg+0xec>)
    2cba:	6123      	str	r3, [r4, #16]
	lcp->block_size = block_size;
    2cbc:	61e5      	str	r5, [r4, #28]
	lcp->block_count = block_count;
    2cbe:	6227      	str	r7, [r4, #32]
	lcp->block_cycles = block_cycles;
    2cc0:	6266      	str	r6, [r4, #36]	; 0x24
	return 0;
    2cc2:	2000      	movs	r0, #0
}
    2cc4:	b005      	add	sp, #20
    2cc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2cca:	bf00      	nop
    2ccc:	0000ee58 	.word	0x0000ee58
    2cd0:	0000ee90 	.word	0x0000ee90
    2cd4:	0000aab7 	.word	0x0000aab7
    2cd8:	0000aa9b 	.word	0x0000aa9b
    2cdc:	0000aa87 	.word	0x0000aa87
    2ce0:	0000a8a1 	.word	0x0000a8a1

00002ce4 <littlefs_init_fs>:
{
    2ce4:	b570      	push	{r4, r5, r6, lr}
    2ce6:	b082      	sub	sp, #8
    2ce8:	4604      	mov	r4, r0
    2cea:	460e      	mov	r6, r1
    2cec:	4615      	mov	r5, r2
	LOG_INF("LittleFS version %u.%u, disk version %u.%u",
    2cee:	2300      	movs	r3, #0
    2cf0:	9301      	str	r3, [sp, #4]
    2cf2:	2202      	movs	r2, #2
    2cf4:	9200      	str	r2, [sp, #0]
    2cf6:	2305      	movs	r3, #5
    2cf8:	2149      	movs	r1, #73	; 0x49
    2cfa:	480c      	ldr	r0, [pc, #48]	; (2d2c <littlefs_init_fs+0x48>)
    2cfc:	f007 fb1e 	bl	a33c <z_log_minimal_printk>
	if (fs->backend) {
    2d00:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    2d04:	b97b      	cbnz	r3, 2d26 <littlefs_init_fs+0x42>
	ret = littlefs_init_backend(fs, dev_id, flags);
    2d06:	462a      	mov	r2, r5
    2d08:	4631      	mov	r1, r6
    2d0a:	4620      	mov	r0, r4
    2d0c:	f007 feb4 	bl	aa78 <littlefs_init_backend>
	if (ret < 0) {
    2d10:	2800      	cmp	r0, #0
    2d12:	db06      	blt.n	2d22 <littlefs_init_fs+0x3e>
	ret = littlefs_init_cfg(fs, flags);
    2d14:	4629      	mov	r1, r5
    2d16:	4620      	mov	r0, r4
    2d18:	f7ff ff6c 	bl	2bf4 <littlefs_init_cfg>
	if (ret < 0) {
    2d1c:	2800      	cmp	r0, #0
    2d1e:	db00      	blt.n	2d22 <littlefs_init_fs+0x3e>
	return 0;
    2d20:	2000      	movs	r0, #0
}
    2d22:	b002      	add	sp, #8
    2d24:	bd70      	pop	{r4, r5, r6, pc}
		return -EBUSY;
    2d26:	f06f 000f 	mvn.w	r0, #15
    2d2a:	e7fa      	b.n	2d22 <littlefs_init_fs+0x3e>
    2d2c:	0000eebc 	.word	0x0000eebc

00002d30 <littlefs_mount>:
{
    2d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2d34:	4607      	mov	r7, r0
	struct fs_littlefs *fs = mountp->fs_data;
    2d36:	6905      	ldr	r5, [r0, #16]
	k_mutex_init(&fs->mutex);
    2d38:	f105 06f0 	add.w	r6, r5, #240	; 0xf0
	return z_impl_k_mutex_init(mutex);
    2d3c:	4630      	mov	r0, r6
    2d3e:	f00a fdc6 	bl	d8ce <z_impl_k_mutex_init>
	fs_lock(fs);
    2d42:	4628      	mov	r0, r5
    2d44:	f007 fdd7 	bl	a8f6 <fs_lock>
	ret = littlefs_init_fs(fs, (uintptr_t)mountp->storage_dev, mountp->flags);
    2d48:	f897 2020 	ldrb.w	r2, [r7, #32]
    2d4c:	6979      	ldr	r1, [r7, #20]
    2d4e:	4628      	mov	r0, r5
    2d50:	f7ff ffc8 	bl	2ce4 <littlefs_init_fs>
	if (ret < 0) {
    2d54:	1e04      	subs	r4, r0, #0
    2d56:	db47      	blt.n	2de8 <littlefs_mount+0xb8>
	ret = lfs_mount(&fs->lfs, &fs->cfg);
    2d58:	f105 0474 	add.w	r4, r5, #116	; 0x74
    2d5c:	4629      	mov	r1, r5
    2d5e:	4620      	mov	r0, r4
    2d60:	f00a fbc4 	bl	d4ec <lfs_mount>
	if (ret < 0 &&
    2d64:	2800      	cmp	r0, #0
    2d66:	da3a      	bge.n	2dde <littlefs_mount+0xae>
	    (mountp->flags & FS_MOUNT_FLAG_NO_FORMAT) == 0) {
    2d68:	f897 3020 	ldrb.w	r3, [r7, #32]
	if (ret < 0 &&
    2d6c:	f013 0f01 	tst.w	r3, #1
    2d70:	d135      	bne.n	2dde <littlefs_mount+0xae>
		if ((mountp->flags & FS_MOUNT_FLAG_READ_ONLY) == 0) {
    2d72:	f013 0f02 	tst.w	r3, #2
    2d76:	d121      	bne.n	2dbc <littlefs_mount+0x8c>
			LOG_WRN("can't mount (LFS %d); formatting", ret);
    2d78:	4602      	mov	r2, r0
    2d7a:	2157      	movs	r1, #87	; 0x57
    2d7c:	481f      	ldr	r0, [pc, #124]	; (2dfc <littlefs_mount+0xcc>)
    2d7e:	f007 fadd 	bl	a33c <z_log_minimal_printk>
			ret = lfs_format(&fs->lfs, &fs->cfg);
    2d82:	4629      	mov	r1, r5
    2d84:	4620      	mov	r0, r4
    2d86:	f00a fbad 	bl	d4e4 <lfs_format>
			if (ret < 0) {
    2d8a:	f1b0 0800 	subs.w	r8, r0, #0
    2d8e:	db0b      	blt.n	2da8 <littlefs_mount+0x78>
		ret = lfs_mount(&fs->lfs, &fs->cfg);
    2d90:	4629      	mov	r1, r5
    2d92:	4620      	mov	r0, r4
    2d94:	f00a fbaa 	bl	d4ec <lfs_mount>
		if (ret < 0) {
    2d98:	1e04      	subs	r4, r0, #0
    2d9a:	db16      	blt.n	2dca <littlefs_mount+0x9a>
	LOG_INF("%s mounted", mountp->mnt_point);
    2d9c:	68fa      	ldr	r2, [r7, #12]
    2d9e:	2149      	movs	r1, #73	; 0x49
    2da0:	4817      	ldr	r0, [pc, #92]	; (2e00 <littlefs_mount+0xd0>)
    2da2:	f007 facb 	bl	a33c <z_log_minimal_printk>
    2da6:	e01d      	b.n	2de4 <littlefs_mount+0xb4>
				LOG_ERR("format failed (LFS %d)", ret);
    2da8:	4642      	mov	r2, r8
    2daa:	2145      	movs	r1, #69	; 0x45
    2dac:	4815      	ldr	r0, [pc, #84]	; (2e04 <littlefs_mount+0xd4>)
    2dae:	f007 fac5 	bl	a33c <z_log_minimal_printk>
				ret = lfs_to_errno(ret);
    2db2:	4640      	mov	r0, r8
    2db4:	f007 fd05 	bl	a7c2 <lfs_to_errno>
    2db8:	4604      	mov	r4, r0
				goto out;
    2dba:	e013      	b.n	2de4 <littlefs_mount+0xb4>
			LOG_ERR("can not format read-only system");
    2dbc:	2145      	movs	r1, #69	; 0x45
    2dbe:	4812      	ldr	r0, [pc, #72]	; (2e08 <littlefs_mount+0xd8>)
    2dc0:	f007 fabc 	bl	a33c <z_log_minimal_printk>
			ret = -EROFS;
    2dc4:	f06f 041d 	mvn.w	r4, #29
    2dc8:	e00e      	b.n	2de8 <littlefs_mount+0xb8>
			LOG_ERR("remount after format failed (LFS %d)", ret);
    2dca:	4622      	mov	r2, r4
    2dcc:	2145      	movs	r1, #69	; 0x45
    2dce:	480f      	ldr	r0, [pc, #60]	; (2e0c <littlefs_mount+0xdc>)
    2dd0:	f007 fab4 	bl	a33c <z_log_minimal_printk>
			ret = lfs_to_errno(ret);
    2dd4:	4620      	mov	r0, r4
    2dd6:	f007 fcf4 	bl	a7c2 <lfs_to_errno>
    2dda:	4604      	mov	r4, r0
			goto out;
    2ddc:	e002      	b.n	2de4 <littlefs_mount+0xb4>
		ret = lfs_to_errno(ret);
    2dde:	f007 fcf0 	bl	a7c2 <lfs_to_errno>
    2de2:	4604      	mov	r4, r0
	if (ret < 0) {
    2de4:	2c00      	cmp	r4, #0
    2de6:	da02      	bge.n	2dee <littlefs_mount+0xbe>
		fs->backend = NULL;
    2de8:	2300      	movs	r3, #0
    2dea:	f8c5 30ec 	str.w	r3, [r5, #236]	; 0xec
	return z_impl_k_mutex_unlock(mutex);
    2dee:	4630      	mov	r0, r6
    2df0:	f005 fbaa 	bl	8548 <z_impl_k_mutex_unlock>
}
    2df4:	4620      	mov	r0, r4
    2df6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2dfa:	bf00      	nop
    2dfc:	0000eeec 	.word	0x0000eeec
    2e00:	0000ef84 	.word	0x0000ef84
    2e04:	0000ef14 	.word	0x0000ef14
    2e08:	0000ef30 	.word	0x0000ef30
    2e0c:	0000ef58 	.word	0x0000ef58

00002e10 <littlefs_closedir>:
{
    2e10:	b570      	push	{r4, r5, r6, lr}
    2e12:	4604      	mov	r4, r0
	struct fs_littlefs *fs = dp->mp->fs_data;
    2e14:	6843      	ldr	r3, [r0, #4]
    2e16:	691d      	ldr	r5, [r3, #16]
	fs_lock(fs);
    2e18:	4628      	mov	r0, r5
    2e1a:	f007 fd6c 	bl	a8f6 <fs_lock>
	int ret = lfs_dir_close(&fs->lfs, dp->dirp);
    2e1e:	6821      	ldr	r1, [r4, #0]
    2e20:	f105 0074 	add.w	r0, r5, #116	; 0x74
    2e24:	f00a fba5 	bl	d572 <lfs_dir_close>
    2e28:	4606      	mov	r6, r0
	k_mutex_unlock(&fs->mutex);
    2e2a:	f105 00f0 	add.w	r0, r5, #240	; 0xf0
    2e2e:	f005 fb8b 	bl	8548 <z_impl_k_mutex_unlock>
	k_mem_slab_free(&lfs_dir_pool, &dp->dirp);
    2e32:	4621      	mov	r1, r4
    2e34:	4803      	ldr	r0, [pc, #12]	; (2e44 <littlefs_closedir+0x34>)
    2e36:	f00a fce0 	bl	d7fa <k_mem_slab_free>
	return lfs_to_errno(ret);
    2e3a:	4630      	mov	r0, r6
    2e3c:	f007 fcc1 	bl	a7c2 <lfs_to_errno>
}
    2e40:	bd70      	pop	{r4, r5, r6, pc}
    2e42:	bf00      	nop
    2e44:	200002dc 	.word	0x200002dc

00002e48 <littlefs_opendir>:
{
    2e48:	b570      	push	{r4, r5, r6, lr}
    2e4a:	4604      	mov	r4, r0
    2e4c:	460e      	mov	r6, r1
	struct fs_littlefs *fs = dp->mp->fs_data;
    2e4e:	6843      	ldr	r3, [r0, #4]
    2e50:	691d      	ldr	r5, [r3, #16]
	if (k_mem_slab_alloc(&lfs_dir_pool, &dp->dirp, K_NO_WAIT) != 0) {
    2e52:	2200      	movs	r2, #0
    2e54:	2300      	movs	r3, #0
    2e56:	4601      	mov	r1, r0
    2e58:	4814      	ldr	r0, [pc, #80]	; (2eac <littlefs_opendir+0x64>)
    2e5a:	f005 fa17 	bl	828c <k_mem_slab_alloc>
    2e5e:	b9e8      	cbnz	r0, 2e9c <littlefs_opendir+0x54>
	memset(dp->dirp, 0, sizeof(struct lfs_dir));
    2e60:	2234      	movs	r2, #52	; 0x34
    2e62:	2100      	movs	r1, #0
    2e64:	6820      	ldr	r0, [r4, #0]
    2e66:	f007 fc58 	bl	a71a <memset>
	path = fs_impl_strip_prefix(path, dp->mp);
    2e6a:	6861      	ldr	r1, [r4, #4]
    2e6c:	4630      	mov	r0, r6
    2e6e:	f7ff fe51 	bl	2b14 <fs_impl_strip_prefix>
    2e72:	4606      	mov	r6, r0
	fs_lock(fs);
    2e74:	4628      	mov	r0, r5
    2e76:	f007 fd3e 	bl	a8f6 <fs_lock>
	int ret = lfs_dir_open(&fs->lfs, dp->dirp, path);
    2e7a:	4632      	mov	r2, r6
    2e7c:	6821      	ldr	r1, [r4, #0]
    2e7e:	f105 0074 	add.w	r0, r5, #116	; 0x74
    2e82:	f00a fb72 	bl	d56a <lfs_dir_open>
    2e86:	4606      	mov	r6, r0
	k_mutex_unlock(&fs->mutex);
    2e88:	f105 00f0 	add.w	r0, r5, #240	; 0xf0
    2e8c:	f005 fb5c 	bl	8548 <z_impl_k_mutex_unlock>
	if (ret < 0) {
    2e90:	2e00      	cmp	r6, #0
    2e92:	db06      	blt.n	2ea2 <littlefs_opendir+0x5a>
	return lfs_to_errno(ret);
    2e94:	4630      	mov	r0, r6
    2e96:	f007 fc94 	bl	a7c2 <lfs_to_errno>
}
    2e9a:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
    2e9c:	f06f 000b 	mvn.w	r0, #11
    2ea0:	e7fb      	b.n	2e9a <littlefs_opendir+0x52>
		k_mem_slab_free(&lfs_dir_pool, &dp->dirp);
    2ea2:	4621      	mov	r1, r4
    2ea4:	4801      	ldr	r0, [pc, #4]	; (2eac <littlefs_opendir+0x64>)
    2ea6:	f00a fca8 	bl	d7fa <k_mem_slab_free>
    2eaa:	e7f3      	b.n	2e94 <littlefs_opendir+0x4c>
    2eac:	200002dc 	.word	0x200002dc

00002eb0 <release_file_data>:
{
    2eb0:	b510      	push	{r4, lr}
    2eb2:	4604      	mov	r4, r0
	struct lfs_file_data *fdp = fp->filep;
    2eb4:	6803      	ldr	r3, [r0, #0]
	if (fdp->config.buffer) {
    2eb6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    2eb8:	b11a      	cbz	r2, 2ec2 <release_file_data+0x12>
	k_heap_free(&file_cache_heap, buf);
    2eba:	6e19      	ldr	r1, [r3, #96]	; 0x60
    2ebc:	4804      	ldr	r0, [pc, #16]	; (2ed0 <release_file_data+0x20>)
    2ebe:	f00a fc5a 	bl	d776 <k_heap_free>
	k_mem_slab_free(&file_data_pool, &fp->filep);
    2ec2:	4621      	mov	r1, r4
    2ec4:	4803      	ldr	r0, [pc, #12]	; (2ed4 <release_file_data+0x24>)
    2ec6:	f00a fc98 	bl	d7fa <k_mem_slab_free>
	fp->filep = NULL;
    2eca:	2300      	movs	r3, #0
    2ecc:	6023      	str	r3, [r4, #0]
}
    2ece:	bd10      	pop	{r4, pc}
    2ed0:	200002f8 	.word	0x200002f8
    2ed4:	200002c0 	.word	0x200002c0

00002ed8 <fc_allocate>:
{
    2ed8:	b508      	push	{r3, lr}
    2eda:	4601      	mov	r1, r0
	ret = k_heap_alloc(&file_cache_heap, size, K_NO_WAIT);
    2edc:	2200      	movs	r2, #0
    2ede:	2300      	movs	r3, #0
    2ee0:	4801      	ldr	r0, [pc, #4]	; (2ee8 <fc_allocate+0x10>)
    2ee2:	f00a fc3d 	bl	d760 <k_heap_alloc>
}
    2ee6:	bd08      	pop	{r3, pc}
    2ee8:	200002f8 	.word	0x200002f8

00002eec <littlefs_open>:
{
    2eec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2ef0:	b083      	sub	sp, #12
    2ef2:	4604      	mov	r4, r0
    2ef4:	460e      	mov	r6, r1
	struct fs_littlefs *fs = fp->mp->fs_data;
    2ef6:	6843      	ldr	r3, [r0, #4]
    2ef8:	691f      	ldr	r7, [r3, #16]
	int flags = lfs_flags_from_zephyr(zflags);
    2efa:	4610      	mov	r0, r2
    2efc:	f007 fcd2 	bl	a8a4 <lfs_flags_from_zephyr>
    2f00:	4605      	mov	r5, r0
	int ret = k_mem_slab_alloc(&file_data_pool, &fp->filep, K_NO_WAIT);
    2f02:	2200      	movs	r2, #0
    2f04:	2300      	movs	r3, #0
    2f06:	4621      	mov	r1, r4
    2f08:	481e      	ldr	r0, [pc, #120]	; (2f84 <littlefs_open+0x98>)
    2f0a:	f005 f9bf 	bl	828c <k_mem_slab_alloc>
	if (ret != 0) {
    2f0e:	4602      	mov	r2, r0
    2f10:	b118      	cbz	r0, 2f1a <littlefs_open+0x2e>
}
    2f12:	4610      	mov	r0, r2
    2f14:	b003      	add	sp, #12
    2f16:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct lfs_file_data *fdp = fp->filep;
    2f1a:	f8d4 8000 	ldr.w	r8, [r4]
	memset(fdp, 0, sizeof(*fdp));
    2f1e:	2264      	movs	r2, #100	; 0x64
    2f20:	2100      	movs	r1, #0
    2f22:	4640      	mov	r0, r8
    2f24:	f007 fbf9 	bl	a71a <memset>
	fdp->cache_block = fc_allocate(lfs->cfg->cache_size);
    2f28:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
    2f2c:	6a98      	ldr	r0, [r3, #40]	; 0x28
    2f2e:	f7ff ffd3 	bl	2ed8 <fc_allocate>
    2f32:	f8c8 0060 	str.w	r0, [r8, #96]	; 0x60
	if (fdp->cache_block == NULL) {
    2f36:	b1d8      	cbz	r0, 2f70 <littlefs_open+0x84>
	fdp->config.buffer = fdp->cache_block;
    2f38:	46c1      	mov	r9, r8
    2f3a:	f849 0f54 	str.w	r0, [r9, #84]!
	path = fs_impl_strip_prefix(path, fp->mp);
    2f3e:	6861      	ldr	r1, [r4, #4]
    2f40:	4630      	mov	r0, r6
    2f42:	f7ff fde7 	bl	2b14 <fs_impl_strip_prefix>
    2f46:	4606      	mov	r6, r0
	fs_lock(fs);
    2f48:	4638      	mov	r0, r7
    2f4a:	f007 fcd4 	bl	a8f6 <fs_lock>
	ret = lfs_file_opencfg(&fs->lfs, &fdp->file,
    2f4e:	f8cd 9000 	str.w	r9, [sp]
    2f52:	462b      	mov	r3, r5
    2f54:	4632      	mov	r2, r6
    2f56:	4641      	mov	r1, r8
    2f58:	f107 0074 	add.w	r0, r7, #116	; 0x74
    2f5c:	f00a fada 	bl	d514 <lfs_file_opencfg>
    2f60:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    2f62:	f107 00f0 	add.w	r0, r7, #240	; 0xf0
    2f66:	f005 faef 	bl	8548 <z_impl_k_mutex_unlock>
	if (ret < 0) {
    2f6a:	2d00      	cmp	r5, #0
    2f6c:	da05      	bge.n	2f7a <littlefs_open+0x8e>
    2f6e:	e001      	b.n	2f74 <littlefs_open+0x88>
		ret = -ENOMEM;
    2f70:	f06f 050b 	mvn.w	r5, #11
		release_file_data(fp);
    2f74:	4620      	mov	r0, r4
    2f76:	f7ff ff9b 	bl	2eb0 <release_file_data>
	return lfs_to_errno(ret);
    2f7a:	4628      	mov	r0, r5
    2f7c:	f007 fc21 	bl	a7c2 <lfs_to_errno>
    2f80:	4602      	mov	r2, r0
    2f82:	e7c6      	b.n	2f12 <littlefs_open+0x26>
    2f84:	200002c0 	.word	0x200002c0

00002f88 <get_hf_flags>:
static uint32_t *get_hf_flags(void)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;

	return &data->subsys[CLOCK_CONTROL_NRF_TYPE_HFCLK].flags;
}
    2f88:	4800      	ldr	r0, [pc, #0]	; (2f8c <get_hf_flags+0x4>)
    2f8a:	4770      	bx	lr
    2f8c:	20000e78 	.word	0x20000e78

00002f90 <get_subsys>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    2f90:	4b03      	ldr	r3, [pc, #12]	; (2fa0 <get_subsys+0x10>)
    2f92:	1ac0      	subs	r0, r0, r3
    2f94:	1080      	asrs	r0, r0, #2

	return (clock_control_subsys_t)offset;
}
    2f96:	4b03      	ldr	r3, [pc, #12]	; (2fa4 <get_subsys+0x14>)
    2f98:	fb03 f000 	mul.w	r0, r3, r0
    2f9c:	4770      	bx	lr
    2f9e:	bf00      	nop
    2fa0:	20000e00 	.word	0x20000e00
    2fa4:	b6db6db7 	.word	0xb6db6db7

00002fa8 <onoff_stop>:

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    2fa8:	b538      	push	{r3, r4, r5, lr}
    2faa:	4605      	mov	r5, r0
    2fac:	460c      	mov	r4, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    2fae:	f7ff ffef 	bl	2f90 <get_subsys>
    2fb2:	4601      	mov	r1, r0
    2fb4:	2240      	movs	r2, #64	; 0x40
    2fb6:	4803      	ldr	r0, [pc, #12]	; (2fc4 <onoff_stop+0x1c>)
    2fb8:	f007 ff05 	bl	adc6 <stop>
    2fbc:	4601      	mov	r1, r0
	notify(mgr, res);
    2fbe:	4628      	mov	r0, r5
    2fc0:	47a0      	blx	r4
}
    2fc2:	bd38      	pop	{r3, r4, r5, pc}
    2fc4:	0000dd24 	.word	0x0000dd24

00002fc8 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    2fc8:	b530      	push	{r4, r5, lr}
    2fca:	b083      	sub	sp, #12
    2fcc:	4605      	mov	r5, r0
    2fce:	460c      	mov	r4, r1
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    2fd0:	f7ff ffde 	bl	2f90 <get_subsys>
    2fd4:	4601      	mov	r1, r0
    2fd6:	2340      	movs	r3, #64	; 0x40
    2fd8:	9300      	str	r3, [sp, #0]
    2fda:	4623      	mov	r3, r4
    2fdc:	4a05      	ldr	r2, [pc, #20]	; (2ff4 <onoff_start+0x2c>)
    2fde:	4806      	ldr	r0, [pc, #24]	; (2ff8 <onoff_start+0x30>)
    2fe0:	f007 ff0b 	bl	adfa <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    2fe4:	1e01      	subs	r1, r0, #0
    2fe6:	db01      	blt.n	2fec <onoff_start+0x24>
		notify(mgr, err);
	}
}
    2fe8:	b003      	add	sp, #12
    2fea:	bd30      	pop	{r4, r5, pc}
		notify(mgr, err);
    2fec:	4628      	mov	r0, r5
    2fee:	47a0      	blx	r4
}
    2ff0:	e7fa      	b.n	2fe8 <onoff_start+0x20>
    2ff2:	bf00      	nop
    2ff4:	0000ae43 	.word	0x0000ae43
    2ff8:	0000dd24 	.word	0x0000dd24

00002ffc <clock_event_handler>:
		__ASSERT_NO_MSG(false);
	}
}

static void clock_event_handler(nrfx_clock_evt_type_t event)
{
    2ffc:	b508      	push	{r3, lr}
	const struct device *dev = CLOCK_DEVICE;

	switch (event) {
    2ffe:	2805      	cmp	r0, #5
    3000:	d815      	bhi.n	302e <clock_event_handler+0x32>
    3002:	e8df f000 	tbb	[pc, r0]
    3006:	1a03      	.short	0x1a03
    3008:	10151414 	.word	0x10151414
	case NRFX_CLOCK_EVT_HFCLK_STARTED:
	{
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    300c:	2100      	movs	r1, #0
    300e:	480d      	ldr	r0, [pc, #52]	; (3044 <clock_event_handler+0x48>)
    3010:	f007 fe62 	bl	acd8 <get_sub_data>

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    3014:	6883      	ldr	r3, [r0, #8]
    3016:	f013 0f07 	tst.w	r3, #7
    301a:	d108      	bne.n	302e <clock_event_handler+0x32>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    301c:	2100      	movs	r1, #0
    301e:	4809      	ldr	r0, [pc, #36]	; (3044 <clock_event_handler+0x48>)
    3020:	f007 febf 	bl	ada2 <clkstarted_handle>
    3024:	e003      	b.n	302e <clock_event_handler+0x32>

		break;
	}
#if NRF_CLOCK_HAS_HFCLK192M
	case NRFX_CLOCK_EVT_HFCLK192M_STARTED:
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK192M);
    3026:	2102      	movs	r1, #2
    3028:	4806      	ldr	r0, [pc, #24]	; (3044 <clock_event_handler+0x48>)
    302a:	f007 feba 	bl	ada2 <clkstarted_handle>
		break;
	default:
		__ASSERT_NO_MSG(0);
		break;
	}
}
    302e:	bd08      	pop	{r3, pc}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLKAUDIO);
    3030:	2103      	movs	r1, #3
    3032:	4804      	ldr	r0, [pc, #16]	; (3044 <clock_event_handler+0x48>)
    3034:	f007 feb5 	bl	ada2 <clkstarted_handle>
		break;
    3038:	e7f9      	b.n	302e <clock_event_handler+0x32>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    303a:	2101      	movs	r1, #1
    303c:	4801      	ldr	r0, [pc, #4]	; (3044 <clock_event_handler+0x48>)
    303e:	f007 feb0 	bl	ada2 <clkstarted_handle>
}
    3042:	e7f4      	b.n	302e <clock_event_handler+0x32>
    3044:	0000dd24 	.word	0x0000dd24

00003048 <generic_hfclk_start>:
{
    3048:	b510      	push	{r4, lr}
    304a:	b082      	sub	sp, #8
	__asm__ volatile(
    304c:	f04f 0320 	mov.w	r3, #32
    3050:	f3ef 8411 	mrs	r4, BASEPRI
    3054:	f383 8812 	msr	BASEPRI_MAX, r3
    3058:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    305c:	4a14      	ldr	r2, [pc, #80]	; (30b0 <generic_hfclk_start+0x68>)
    305e:	6813      	ldr	r3, [r2, #0]
    3060:	f043 0102 	orr.w	r1, r3, #2
    3064:	6011      	str	r1, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    3066:	f013 0f01 	tst.w	r3, #1
    306a:	d109      	bne.n	3080 <generic_hfclk_start+0x38>
	bool already_started = false;
    306c:	2300      	movs	r3, #0
	__asm__ volatile(
    306e:	f384 8811 	msr	BASEPRI, r4
    3072:	f3bf 8f6f 	isb	sy
	if (already_started) {
    3076:	b9b3      	cbnz	r3, 30a6 <generic_hfclk_start+0x5e>
	hfclk_start();
    3078:	f007 feeb 	bl	ae52 <hfclk_start>
}
    307c:	b002      	add	sp, #8
    307e:	bd10      	pop	{r4, pc}
    return nrf_clock_event_address_get(NRF_CLOCK, event);
}

NRFX_STATIC_INLINE bool nrfx_clock_is_running(nrf_clock_domain_t domain, void * p_clk_src)
{
    return nrf_clock_is_running(NRF_CLOCK, domain, p_clk_src);
    3080:	f10d 0207 	add.w	r2, sp, #7
    3084:	2101      	movs	r1, #1
    3086:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    308a:	f007 fdeb 	bl	ac64 <nrf_clock_is_running>
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    308e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    3092:	2b01      	cmp	r3, #1
    3094:	d001      	beq.n	309a <generic_hfclk_start+0x52>
	bool already_started = false;
    3096:	2300      	movs	r3, #0
    3098:	e7e9      	b.n	306e <generic_hfclk_start+0x26>
			set_on_state(get_hf_flags());
    309a:	f7ff ff75 	bl	2f88 <get_hf_flags>
    309e:	f007 fe6d 	bl	ad7c <set_on_state>
			already_started = true;
    30a2:	2301      	movs	r3, #1
    30a4:	e7e3      	b.n	306e <generic_hfclk_start+0x26>
		clkstarted_handle(CLOCK_DEVICE,
    30a6:	2100      	movs	r1, #0
    30a8:	4802      	ldr	r0, [pc, #8]	; (30b4 <generic_hfclk_start+0x6c>)
    30aa:	f007 fe7a 	bl	ada2 <clkstarted_handle>
		return;
    30ae:	e7e5      	b.n	307c <generic_hfclk_start+0x34>
    30b0:	20000ea0 	.word	0x20000ea0
    30b4:	0000dd24 	.word	0x0000dd24

000030b8 <generic_hfclk_stop>:
{
    30b8:	b510      	push	{r4, lr}
	__asm__ volatile(
    30ba:	f04f 0320 	mov.w	r3, #32
    30be:	f3ef 8411 	mrs	r4, BASEPRI
    30c2:	f383 8812 	msr	BASEPRI_MAX, r3
    30c6:	f3bf 8f6f 	isb	sy
	hfclk_users &= ~HF_USER_GENERIC;
    30ca:	4a08      	ldr	r2, [pc, #32]	; (30ec <generic_hfclk_stop+0x34>)
    30cc:	6813      	ldr	r3, [r2, #0]
    30ce:	f023 0102 	bic.w	r1, r3, #2
    30d2:	6011      	str	r1, [r2, #0]
	if (!(hfclk_users & HF_USER_BT)) {
    30d4:	f013 0f01 	tst.w	r3, #1
    30d8:	d004      	beq.n	30e4 <generic_hfclk_stop+0x2c>
	__asm__ volatile(
    30da:	f384 8811 	msr	BASEPRI, r4
    30de:	f3bf 8f6f 	isb	sy
}
    30e2:	bd10      	pop	{r4, pc}
		hfclk_stop();
    30e4:	f007 fec9 	bl	ae7a <hfclk_stop>
    30e8:	e7f7      	b.n	30da <generic_hfclk_stop+0x22>
    30ea:	bf00      	nop
    30ec:	20000ea0 	.word	0x20000ea0

000030f0 <lfclk_spinwait>:
{
    30f0:	b570      	push	{r4, r5, r6, lr}
    30f2:	b082      	sub	sp, #8
    30f4:	4605      	mov	r5, r0
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    30f6:	2801      	cmp	r0, #1
    30f8:	d107      	bne.n	310a <lfclk_spinwait+0x1a>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    30fa:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    30fe:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    3102:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    3106:	2b02      	cmp	r3, #2
    3108:	d037      	beq.n	317a <lfclk_spinwait+0x8a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    310a:	f00a fbad 	bl	d868 <k_is_in_isr>
    310e:	4604      	mov	r4, r0
    3110:	b910      	cbnz	r0, 3118 <lfclk_spinwait+0x28>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    3112:	4b2b      	ldr	r3, [pc, #172]	; (31c0 <lfclk_spinwait+0xd0>)
    3114:	781b      	ldrb	r3, [r3, #0]
    3116:	b97b      	cbnz	r3, 3138 <lfclk_spinwait+0x48>
	__asm__ volatile(
    3118:	f04f 0320 	mov.w	r3, #32
    311c:	f3ef 8611 	mrs	r6, BASEPRI
    3120:	f383 8812 	msr	BASEPRI_MAX, r3
    3124:	f3bf 8f6f 	isb	sy
    3128:	2401      	movs	r4, #1
	if (!isr_mode) {
    312a:	b994      	cbnz	r4, 3152 <lfclk_spinwait+0x62>
    p_reg->INTENCLR = mask;
    312c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    3130:	2202      	movs	r2, #2
    3132:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    3136:	e00c      	b.n	3152 <lfclk_spinwait+0x62>
	int key = isr_mode ? irq_lock() : 0;
    3138:	2600      	movs	r6, #0
    313a:	e7f6      	b.n	312a <lfclk_spinwait+0x3a>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    313c:	b1fc      	cbz	r4, 317e <lfclk_spinwait+0x8e>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    313e:	4630      	mov	r0, r6
    3140:	f7fe fad2 	bl	16e8 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    3144:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    3148:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
    314c:	b2db      	uxtb	r3, r3
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    314e:	2b01      	cmp	r3, #1
    3150:	d019      	beq.n	3186 <lfclk_spinwait+0x96>
    3152:	f10d 0207 	add.w	r2, sp, #7
    3156:	2100      	movs	r1, #0
    3158:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    315c:	f007 fd82 	bl	ac64 <nrf_clock_is_running>
	while (!(nrfx_clock_is_running(d, (void *)&type)
    3160:	2800      	cmp	r0, #0
    3162:	d0eb      	beq.n	313c <lfclk_spinwait+0x4c>
		 && ((type == target_type)
    3164:	f89d 3007 	ldrb.w	r3, [sp, #7]
	while (!(nrfx_clock_is_running(d, (void *)&type)
    3168:	2b02      	cmp	r3, #2
    316a:	d001      	beq.n	3170 <lfclk_spinwait+0x80>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    316c:	2d01      	cmp	r5, #1
    316e:	d1e5      	bne.n	313c <lfclk_spinwait+0x4c>
	if (isr_mode) {
    3170:	b304      	cbz	r4, 31b4 <lfclk_spinwait+0xc4>
	__asm__ volatile(
    3172:	f386 8811 	msr	BASEPRI, r6
    3176:	f3bf 8f6f 	isb	sy
}
    317a:	b002      	add	sp, #8
    317c:	bd70      	pop	{r4, r5, r6, pc}
				k_msleep(1);
    317e:	2001      	movs	r0, #1
    3180:	f007 fe8f 	bl	aea2 <k_msleep>
    3184:	e7de      	b.n	3144 <lfclk_spinwait+0x54>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    3186:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    318a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
    318e:	2b00      	cmp	r3, #0
    3190:	d0df      	beq.n	3152 <lfclk_spinwait+0x62>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3192:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    3196:	2200      	movs	r2, #0
    3198:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    319c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
    31a0:	2202      	movs	r2, #2
    31a2:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    31a6:	4a07      	ldr	r2, [pc, #28]	; (31c4 <lfclk_spinwait+0xd4>)
    31a8:	2120      	movs	r1, #32
    31aa:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    31ae:	2201      	movs	r2, #1
    31b0:	609a      	str	r2, [r3, #8]
}
    31b2:	e7ce      	b.n	3152 <lfclk_spinwait+0x62>
    p_reg->INTENSET = mask;
    31b4:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    31b8:	2202      	movs	r2, #2
    31ba:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    31be:	e7dc      	b.n	317a <lfclk_spinwait+0x8a>
    31c0:	200015f3 	.word	0x200015f3
    31c4:	e000e100 	.word	0xe000e100

000031c8 <api_blocking_start>:
{
    31c8:	b500      	push	{lr}
    31ca:	b085      	sub	sp, #20
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    31cc:	f8cd d000 	str.w	sp, [sp]
    31d0:	f8cd d004 	str.w	sp, [sp, #4]
    31d4:	2300      	movs	r3, #0
    31d6:	9302      	str	r3, [sp, #8]
    31d8:	2301      	movs	r3, #1
    31da:	9303      	str	r3, [sp, #12]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    31dc:	466b      	mov	r3, sp
    31de:	4a07      	ldr	r2, [pc, #28]	; (31fc <api_blocking_start+0x34>)
    31e0:	f007 fe27 	bl	ae32 <api_start>
	if (err < 0) {
    31e4:	2800      	cmp	r0, #0
    31e6:	db05      	blt.n	31f4 <api_blocking_start+0x2c>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    31e8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    31ec:	2300      	movs	r3, #0
    31ee:	4668      	mov	r0, sp
    31f0:	f005 fa0a 	bl	8608 <z_impl_k_sem_take>
}
    31f4:	b005      	add	sp, #20
    31f6:	f85d fb04 	ldr.w	pc, [sp], #4
    31fa:	bf00      	nop
    31fc:	0000aecf 	.word	0x0000aecf

00003200 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
    3200:	b570      	push	{r4, r5, r6, lr}
    3202:	4606      	mov	r6, r0
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    3204:	2200      	movs	r2, #0
    3206:	2101      	movs	r1, #1
    3208:	2005      	movs	r0, #5
    320a:	f007 f93d 	bl	a488 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
    320e:	4811      	ldr	r0, [pc, #68]	; (3254 <clk_init+0x54>)
    3210:	f001 f9b8 	bl	4584 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    3214:	4b10      	ldr	r3, [pc, #64]	; (3258 <clk_init+0x58>)
    3216:	4298      	cmp	r0, r3
    3218:	d119      	bne.n	324e <clk_init+0x4e>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    321a:	f008 fd35 	bl	bc88 <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
    321e:	2400      	movs	r4, #0
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    3220:	2c03      	cmp	r4, #3
    3222:	d812      	bhi.n	324a <clk_init+0x4a>
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
    3224:	4621      	mov	r1, r4
    3226:	4630      	mov	r0, r6
    3228:	f007 fd56 	bl	acd8 <get_sub_data>
    322c:	4605      	mov	r5, r0

		err = onoff_manager_init(get_onoff_manager(dev, i),
    322e:	4621      	mov	r1, r4
    3230:	4630      	mov	r0, r6
    3232:	f007 fd5e 	bl	acf2 <get_onoff_manager>
    3236:	4909      	ldr	r1, [pc, #36]	; (325c <clk_init+0x5c>)
    3238:	f006 fda0 	bl	9d7c <onoff_manager_init>
					 &transitions);
		if (err < 0) {
    323c:	2800      	cmp	r0, #0
    323e:	db05      	blt.n	324c <clk_init+0x4c>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    3240:	2301      	movs	r3, #1
    3242:	60ab      	str	r3, [r5, #8]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    3244:	441c      	add	r4, r3
    3246:	b2e4      	uxtb	r4, r4
    3248:	e7ea      	b.n	3220 <clk_init+0x20>
	}

	return 0;
    324a:	2000      	movs	r0, #0
}
    324c:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    324e:	f06f 0004 	mvn.w	r0, #4
    3252:	e7fb      	b.n	324c <clk_init+0x4c>
    3254:	00002ffd 	.word	0x00002ffd
    3258:	0bad0000 	.word	0x0bad0000
    325c:	0000efe8 	.word	0x0000efe8

00003260 <z_nrf_clock_control_lf_on>:
{
    3260:	b510      	push	{r4, lr}
    3262:	4604      	mov	r4, r0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    3264:	4b0e      	ldr	r3, [pc, #56]	; (32a0 <z_nrf_clock_control_lf_on+0x40>)
    3266:	2101      	movs	r1, #1
    3268:	e8d3 2fef 	ldaex	r2, [r3]
    326c:	e8c3 1fe0 	stlex	r0, r1, [r3]
    3270:	2800      	cmp	r0, #0
    3272:	d1f9      	bne.n	3268 <z_nrf_clock_control_lf_on+0x8>
	if (atomic_set(&on, 1) == 0) {
    3274:	b11a      	cbz	r2, 327e <z_nrf_clock_control_lf_on+0x1e>
	switch (start_mode) {
    3276:	1e63      	subs	r3, r4, #1
    3278:	2b01      	cmp	r3, #1
    327a:	d90d      	bls.n	3298 <z_nrf_clock_control_lf_on+0x38>
}
    327c:	bd10      	pop	{r4, pc}
				get_onoff_manager(CLOCK_DEVICE,
    327e:	4809      	ldr	r0, [pc, #36]	; (32a4 <z_nrf_clock_control_lf_on+0x44>)
    3280:	f007 fd37 	bl	acf2 <get_onoff_manager>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    3284:	4908      	ldr	r1, [pc, #32]	; (32a8 <z_nrf_clock_control_lf_on+0x48>)
    3286:	2300      	movs	r3, #0
    3288:	604b      	str	r3, [r1, #4]
    328a:	608b      	str	r3, [r1, #8]
    328c:	60cb      	str	r3, [r1, #12]
    328e:	2301      	movs	r3, #1
    3290:	608b      	str	r3, [r1, #8]
		err = onoff_request(mgr, &cli);
    3292:	f006 fd90 	bl	9db6 <onoff_request>
    3296:	e7ee      	b.n	3276 <z_nrf_clock_control_lf_on+0x16>
		lfclk_spinwait(start_mode);
    3298:	4620      	mov	r0, r4
    329a:	f7ff ff29 	bl	30f0 <lfclk_spinwait>
		break;
    329e:	e7ed      	b.n	327c <z_nrf_clock_control_lf_on+0x1c>
    32a0:	20000dfc 	.word	0x20000dfc
    32a4:	0000dd24 	.word	0x0000dd24
    32a8:	20000dec 	.word	0x20000dec

000032ac <rtt_console_init>:

	return character;
}

static int rtt_console_init(void)
{
    32ac:	b510      	push	{r4, lr}

#ifdef CONFIG_PRINTK
	__printk_hook_install(rtt_console_out);
    32ae:	4c04      	ldr	r4, [pc, #16]	; (32c0 <rtt_console_init+0x14>)
    32b0:	4620      	mov	r0, r4
    32b2:	f7fd fb2d 	bl	910 <__printk_hook_install>
#endif
	__stdout_hook_install(rtt_console_out);
    32b6:	4620      	mov	r0, r4
    32b8:	f7ff f83c 	bl	2334 <__stdout_hook_install>

	return 0;
}
    32bc:	2000      	movs	r0, #0
    32be:	bd10      	pop	{r4, pc}
    32c0:	000032c5 	.word	0x000032c5

000032c4 <rtt_console_out>:
{
    32c4:	b570      	push	{r4, r5, r6, lr}
    32c6:	b082      	sub	sp, #8
    32c8:	4606      	mov	r6, r0
	char c = (char)character;
    32ca:	f88d 0007 	strb.w	r0, [sp, #7]
	int max_cnt = CONFIG_RTT_TX_RETRY_CNT;
    32ce:	2402      	movs	r4, #2
		SEGGER_RTT_LOCK();
    32d0:	f3ef 8511 	mrs	r5, BASEPRI
    32d4:	f04f 0120 	mov.w	r1, #32
    32d8:	f381 8811 	msr	BASEPRI, r1
		cnt = SEGGER_RTT_WriteNoLock(0, &c, 1);
    32dc:	2201      	movs	r2, #1
    32de:	f10d 0107 	add.w	r1, sp, #7
    32e2:	2000      	movs	r0, #0
    32e4:	f004 fdd0 	bl	7e88 <SEGGER_RTT_WriteNoLock>
		SEGGER_RTT_UNLOCK();
    32e8:	f385 8811 	msr	BASEPRI, r5
		if (cnt) {
    32ec:	b938      	cbnz	r0, 32fe <rtt_console_out+0x3a>
		} else if (host_present) {
    32ee:	4b09      	ldr	r3, [pc, #36]	; (3314 <rtt_console_out+0x50>)
    32f0:	781b      	ldrb	r3, [r3, #0]
    32f2:	b15b      	cbz	r3, 330c <rtt_console_out+0x48>
			if (max_cnt) {
    32f4:	b13c      	cbz	r4, 3306 <rtt_console_out+0x42>
				wait();
    32f6:	f007 fe05 	bl	af04 <wait>
				max_cnt--;
    32fa:	3c01      	subs	r4, #1
		SEGGER_RTT_LOCK();
    32fc:	e7e8      	b.n	32d0 <rtt_console_out+0xc>
			host_present = true;
    32fe:	4b05      	ldr	r3, [pc, #20]	; (3314 <rtt_console_out+0x50>)
    3300:	2201      	movs	r2, #1
    3302:	701a      	strb	r2, [r3, #0]
    3304:	e002      	b.n	330c <rtt_console_out+0x48>
				host_present = false;
    3306:	4b03      	ldr	r3, [pc, #12]	; (3314 <rtt_console_out+0x50>)
    3308:	2200      	movs	r2, #0
    330a:	701a      	strb	r2, [r3, #0]
}
    330c:	4630      	mov	r0, r6
    330e:	b002      	add	sp, #8
    3310:	bd70      	pop	{r4, r5, r6, pc}
    3312:	bf00      	nop
    3314:	200015f1 	.word	0x200015f1

00003318 <flash_nor_get_parameters>:
flash_nor_get_parameters(const struct device *dev)
{
	ARG_UNUSED(dev);

	return &flash_nor_parameters;
}
    3318:	4800      	ldr	r0, [pc, #0]	; (331c <flash_nor_get_parameters+0x4>)
    331a:	4770      	bx	lr
    331c:	0000f19c 	.word	0x0000f19c

00003320 <spi_nor_erase>:
{
    3320:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3324:	b083      	sub	sp, #12
	const struct spi_nor_config *cfg = dev->config;
    3326:	6843      	ldr	r3, [r0, #4]
	return cfg->flash_size;
    3328:	f8d3 9010 	ldr.w	r9, [r3, #16]
	if ((addr < 0) || ((size + addr) > flash_size)) {
    332c:	1e0e      	subs	r6, r1, #0
    332e:	db72      	blt.n	3416 <spi_nor_erase+0xf6>
    3330:	4605      	mov	r5, r0
    3332:	4614      	mov	r4, r2
    3334:	18b3      	adds	r3, r6, r2
    3336:	454b      	cmp	r3, r9
    3338:	d870      	bhi.n	341c <spi_nor_erase+0xfc>
	if (!SPI_NOR_IS_SECTOR_ALIGNED(addr)) {
    333a:	f3c6 030b 	ubfx	r3, r6, #0, #12
    333e:	2b00      	cmp	r3, #0
    3340:	d16f      	bne.n	3422 <spi_nor_erase+0x102>
	if ((size % SPI_NOR_SECTOR_SIZE) != 0) {
    3342:	f3c2 030b 	ubfx	r3, r2, #0, #12
    3346:	2b00      	cmp	r3, #0
    3348:	d16e      	bne.n	3428 <spi_nor_erase+0x108>
	acquire_device(dev);
    334a:	f007 fdff 	bl	af4c <acquire_device>
	ret = spi_nor_write_protection_set(dev, false);
    334e:	2100      	movs	r1, #0
    3350:	4628      	mov	r0, r5
    3352:	f007 fe7e 	bl	b052 <spi_nor_write_protection_set>
    3356:	4680      	mov	r8, r0
	while ((size > 0) && (ret == 0)) {
    3358:	e00c      	b.n	3374 <spi_nor_erase+0x54>
			spi_nor_cmd_write(dev, SPI_NOR_CMD_CE);
    335a:	2300      	movs	r3, #0
    335c:	9301      	str	r3, [sp, #4]
    335e:	9300      	str	r3, [sp, #0]
    3360:	2280      	movs	r2, #128	; 0x80
    3362:	21c7      	movs	r1, #199	; 0xc7
    3364:	4628      	mov	r0, r5
    3366:	f007 fdfa 	bl	af5e <spi_nor_access>
			size -= flash_size;
    336a:	eba4 0409 	sub.w	r4, r4, r9
		spi_nor_wait_until_ready(dev);
    336e:	4628      	mov	r0, r5
    3370:	f007 fe57 	bl	b022 <spi_nor_wait_until_ready>
	while ((size > 0) && (ret == 0)) {
    3374:	2c00      	cmp	r4, #0
    3376:	d03e      	beq.n	33f6 <spi_nor_erase+0xd6>
    3378:	f1b8 0f00 	cmp.w	r8, #0
    337c:	d13b      	bne.n	33f6 <spi_nor_erase+0xd6>
		spi_nor_cmd_write(dev, SPI_NOR_CMD_WREN);
    337e:	2300      	movs	r3, #0
    3380:	9301      	str	r3, [sp, #4]
    3382:	9300      	str	r3, [sp, #0]
    3384:	2280      	movs	r2, #128	; 0x80
    3386:	2106      	movs	r1, #6
    3388:	4628      	mov	r0, r5
    338a:	f007 fde8 	bl	af5e <spi_nor_access>
		if (size == flash_size) {
    338e:	45a1      	cmp	r9, r4
    3390:	d0e3      	beq.n	335a <spi_nor_erase+0x3a>
			for (uint8_t ei = 0; ei < JESD216_NUM_ERASE_TYPES; ++ei) {
    3392:	2300      	movs	r3, #0
			const struct jesd216_erase_type *bet = NULL;
    3394:	461f      	mov	r7, r3
    3396:	e002      	b.n	339e <spi_nor_erase+0x7e>
					bet = etp;
    3398:	4667      	mov	r7, ip
			for (uint8_t ei = 0; ei < JESD216_NUM_ERASE_TYPES; ++ei) {
    339a:	3301      	adds	r3, #1
    339c:	b2db      	uxtb	r3, r3
    339e:	2b03      	cmp	r3, #3
    33a0:	d816      	bhi.n	33d0 <spi_nor_erase+0xb0>
				const struct jesd216_erase_type *etp =
    33a2:	4a23      	ldr	r2, [pc, #140]	; (3430 <spi_nor_erase+0x110>)
    33a4:	eb02 0c43 	add.w	ip, r2, r3, lsl #1
				if ((etp->exp != 0)
    33a8:	f89c 1001 	ldrb.w	r1, [ip, #1]
    33ac:	2900      	cmp	r1, #0
    33ae:	d0f4      	beq.n	339a <spi_nor_erase+0x7a>
				    && SPI_NOR_IS_ALIGNED(addr, etp->exp)
    33b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    33b4:	408a      	lsls	r2, r1
    33b6:	43d0      	mvns	r0, r2
    33b8:	ea36 0202 	bics.w	r2, r6, r2
    33bc:	d1ed      	bne.n	339a <spi_nor_erase+0x7a>
				    && SPI_NOR_IS_ALIGNED(size, etp->exp)
    33be:	4220      	tst	r0, r4
    33c0:	d1eb      	bne.n	339a <spi_nor_erase+0x7a>
				    && ((bet == NULL)
    33c2:	2f00      	cmp	r7, #0
    33c4:	d0e8      	beq.n	3398 <spi_nor_erase+0x78>
					|| (etp->exp > bet->exp))) {
    33c6:	787a      	ldrb	r2, [r7, #1]
    33c8:	4291      	cmp	r1, r2
    33ca:	d9e6      	bls.n	339a <spi_nor_erase+0x7a>
					bet = etp;
    33cc:	4667      	mov	r7, ip
    33ce:	e7e4      	b.n	339a <spi_nor_erase+0x7a>
			if (bet != NULL) {
    33d0:	b177      	cbz	r7, 33f0 <spi_nor_erase+0xd0>
				spi_nor_cmd_addr_write(dev, bet->cmd, addr, NULL, 0);
    33d2:	7839      	ldrb	r1, [r7, #0]
    33d4:	2300      	movs	r3, #0
    33d6:	9301      	str	r3, [sp, #4]
    33d8:	9300      	str	r3, [sp, #0]
    33da:	4633      	mov	r3, r6
    33dc:	2281      	movs	r2, #129	; 0x81
    33de:	4628      	mov	r0, r5
    33e0:	f007 fdbd 	bl	af5e <spi_nor_access>
				addr += BIT(bet->exp);
    33e4:	787a      	ldrb	r2, [r7, #1]
    33e6:	2301      	movs	r3, #1
    33e8:	4093      	lsls	r3, r2
    33ea:	441e      	add	r6, r3
				size -= BIT(bet->exp);
    33ec:	1ae4      	subs	r4, r4, r3
    33ee:	e7be      	b.n	336e <spi_nor_erase+0x4e>
				ret = -EINVAL;
    33f0:	f06f 0815 	mvn.w	r8, #21
    33f4:	e7bb      	b.n	336e <spi_nor_erase+0x4e>
	int ret2 = spi_nor_write_protection_set(dev, true);
    33f6:	2101      	movs	r1, #1
    33f8:	4628      	mov	r0, r5
    33fa:	f007 fe2a 	bl	b052 <spi_nor_write_protection_set>
    33fe:	4604      	mov	r4, r0
	if (!ret) {
    3400:	f1b8 0f00 	cmp.w	r8, #0
    3404:	d000      	beq.n	3408 <spi_nor_erase+0xe8>
    3406:	4644      	mov	r4, r8
	release_device(dev);
    3408:	4628      	mov	r0, r5
    340a:	f007 fe63 	bl	b0d4 <release_device>
}
    340e:	4620      	mov	r0, r4
    3410:	b003      	add	sp, #12
    3412:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return -EINVAL;
    3416:	f06f 0415 	mvn.w	r4, #21
    341a:	e7f8      	b.n	340e <spi_nor_erase+0xee>
    341c:	f06f 0415 	mvn.w	r4, #21
    3420:	e7f5      	b.n	340e <spi_nor_erase+0xee>
		return -EINVAL;
    3422:	f06f 0415 	mvn.w	r4, #21
    3426:	e7f2      	b.n	340e <spi_nor_erase+0xee>
		return -EINVAL;
    3428:	f06f 0415 	mvn.w	r4, #21
    342c:	e7ef      	b.n	340e <spi_nor_erase+0xee>
    342e:	bf00      	nop
    3430:	0000f1a4 	.word	0x0000f1a4

00003434 <spi_nor_configure>:
{
    3434:	b570      	push	{r4, r5, r6, lr}
    3436:	b086      	sub	sp, #24
    3438:	4604      	mov	r4, r0
	const struct spi_nor_config *cfg = dev->config;
    343a:	6845      	ldr	r5, [r0, #4]
	if (!spi_is_ready_dt(&cfg->spi)) {
    343c:	4628      	mov	r0, r5
    343e:	f007 ff22 	bl	b286 <spi_is_ready_dt>
    3442:	2800      	cmp	r0, #0
    3444:	d073      	beq.n	352e <spi_nor_configure+0xfa>
	acquire_device(dev);
    3446:	4620      	mov	r0, r4
    3448:	f007 fd80 	bl	af4c <acquire_device>
	rc = spi_nor_rdsr(dev);
    344c:	4620      	mov	r0, r4
    344e:	f007 fe0f 	bl	b070 <spi_nor_rdsr>
	if (rc > 0 && (rc & SPI_NOR_WIP_BIT)) {
    3452:	2800      	cmp	r0, #0
    3454:	dd02      	ble.n	345c <spi_nor_configure+0x28>
    3456:	f010 0f01 	tst.w	r0, #1
    345a:	d119      	bne.n	3490 <spi_nor_configure+0x5c>
	release_device(dev);
    345c:	4620      	mov	r0, r4
    345e:	f007 fe39 	bl	b0d4 <release_device>
	rc = spi_nor_read_jedec_id(dev, jedec_id);
    3462:	a905      	add	r1, sp, #20
    3464:	4620      	mov	r0, r4
    3466:	f007 fec0 	bl	b1ea <spi_nor_read_jedec_id>
	if (rc != 0) {
    346a:	4602      	mov	r2, r0
    346c:	b9c0      	cbnz	r0, 34a0 <spi_nor_configure+0x6c>
	if (memcmp(jedec_id, cfg->jedec_id, sizeof(jedec_id)) != 0) {
    346e:	2203      	movs	r2, #3
    3470:	f105 011c 	add.w	r1, r5, #28
    3474:	a805      	add	r0, sp, #20
    3476:	f007 f90f 	bl	a698 <memcmp>
    347a:	4606      	mov	r6, r0
    347c:	b9b8      	cbnz	r0, 34ae <spi_nor_configure+0x7a>
	if (cfg->has_lock != 0) {
    347e:	f895 3020 	ldrb.w	r3, [r5, #32]
    3482:	bb43      	cbnz	r3, 34d6 <spi_nor_configure+0xa2>
	if (cfg->enter_4byte_addr != 0) {
    3484:	7fe9      	ldrb	r1, [r5, #31]
    3486:	2900      	cmp	r1, #0
    3488:	d143      	bne.n	3512 <spi_nor_configure+0xde>
}
    348a:	4630      	mov	r0, r6
    348c:	b006      	add	sp, #24
    348e:	bd70      	pop	{r4, r5, r6, pc}
		LOG_WRN("Waiting until flash is ready");
    3490:	2157      	movs	r1, #87	; 0x57
    3492:	4828      	ldr	r0, [pc, #160]	; (3534 <spi_nor_configure+0x100>)
    3494:	f006 ff52 	bl	a33c <z_log_minimal_printk>
		spi_nor_wait_until_ready(dev);
    3498:	4620      	mov	r0, r4
    349a:	f007 fdc2 	bl	b022 <spi_nor_wait_until_ready>
    349e:	e7dd      	b.n	345c <spi_nor_configure+0x28>
		LOG_ERR("JEDEC ID read failed: %d", rc);
    34a0:	2145      	movs	r1, #69	; 0x45
    34a2:	4825      	ldr	r0, [pc, #148]	; (3538 <spi_nor_configure+0x104>)
    34a4:	f006 ff4a 	bl	a33c <z_log_minimal_printk>
		return -ENODEV;
    34a8:	f06f 0612 	mvn.w	r6, #18
    34ac:	e7ed      	b.n	348a <spi_nor_configure+0x56>
		LOG_ERR("Device id %02x %02x %02x does not match config %02x %02x %02x",
    34ae:	f89d 3016 	ldrb.w	r3, [sp, #22]
    34b2:	7f2a      	ldrb	r2, [r5, #28]
    34b4:	7f69      	ldrb	r1, [r5, #29]
    34b6:	7fa8      	ldrb	r0, [r5, #30]
    34b8:	9003      	str	r0, [sp, #12]
    34ba:	9102      	str	r1, [sp, #8]
    34bc:	9201      	str	r2, [sp, #4]
    34be:	9300      	str	r3, [sp, #0]
    34c0:	f89d 3015 	ldrb.w	r3, [sp, #21]
    34c4:	f89d 2014 	ldrb.w	r2, [sp, #20]
    34c8:	2145      	movs	r1, #69	; 0x45
    34ca:	481c      	ldr	r0, [pc, #112]	; (353c <spi_nor_configure+0x108>)
    34cc:	f006 ff36 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    34d0:	f06f 0615 	mvn.w	r6, #21
    34d4:	e7d9      	b.n	348a <spi_nor_configure+0x56>
		acquire_device(dev);
    34d6:	4620      	mov	r0, r4
    34d8:	f007 fd38 	bl	af4c <acquire_device>
		rc = spi_nor_rdsr(dev);
    34dc:	4620      	mov	r0, r4
    34de:	f007 fdc7 	bl	b070 <spi_nor_rdsr>
		if (rc > 0) {
    34e2:	2800      	cmp	r0, #0
    34e4:	dc04      	bgt.n	34f0 <spi_nor_configure+0xbc>
		if (rc != 0) {
    34e6:	b960      	cbnz	r0, 3502 <spi_nor_configure+0xce>
		release_device(dev);
    34e8:	4620      	mov	r0, r4
    34ea:	f007 fdf3 	bl	b0d4 <release_device>
    34ee:	e7c9      	b.n	3484 <spi_nor_configure+0x50>
			rc = spi_nor_wrsr(dev, rc & ~cfg->has_lock);
    34f0:	f895 3020 	ldrb.w	r3, [r5, #32]
    34f4:	ea20 0003 	bic.w	r0, r0, r3
    34f8:	b2c1      	uxtb	r1, r0
    34fa:	4620      	mov	r0, r4
    34fc:	f007 fdca 	bl	b094 <spi_nor_wrsr>
    3500:	e7f1      	b.n	34e6 <spi_nor_configure+0xb2>
			LOG_ERR("BP clear failed: %d\n", rc);
    3502:	4602      	mov	r2, r0
    3504:	2145      	movs	r1, #69	; 0x45
    3506:	480e      	ldr	r0, [pc, #56]	; (3540 <spi_nor_configure+0x10c>)
    3508:	f006 ff18 	bl	a33c <z_log_minimal_printk>
			return -ENODEV;
    350c:	f06f 0612 	mvn.w	r6, #18
    3510:	e7bb      	b.n	348a <spi_nor_configure+0x56>
		rc = spi_nor_set_address_mode(dev, cfg->enter_4byte_addr);
    3512:	4620      	mov	r0, r4
    3514:	f007 fe83 	bl	b21e <spi_nor_set_address_mode>
		if (rc != 0) {
    3518:	4606      	mov	r6, r0
    351a:	2800      	cmp	r0, #0
    351c:	d0b5      	beq.n	348a <spi_nor_configure+0x56>
			LOG_ERR("Unable to enter 4-byte mode: %d\n", rc);
    351e:	4602      	mov	r2, r0
    3520:	2145      	movs	r1, #69	; 0x45
    3522:	4808      	ldr	r0, [pc, #32]	; (3544 <spi_nor_configure+0x110>)
    3524:	f006 ff0a 	bl	a33c <z_log_minimal_printk>
			return -ENODEV;
    3528:	f06f 0612 	mvn.w	r6, #18
    352c:	e7ad      	b.n	348a <spi_nor_configure+0x56>
		return -ENODEV;
    352e:	f06f 0612 	mvn.w	r6, #18
    3532:	e7aa      	b.n	348a <spi_nor_configure+0x56>
    3534:	0000f084 	.word	0x0000f084
    3538:	0000f0a8 	.word	0x0000f0a8
    353c:	0000f0c8 	.word	0x0000f0c8
    3540:	0000f10c 	.word	0x0000f10c
    3544:	0000f128 	.word	0x0000f128

00003548 <nvmc_wait_ready>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    3548:	4b03      	ldr	r3, [pc, #12]	; (3558 <nvmc_wait_ready+0x10>)
    354a:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
#endif /* CONFIG_SOC_FLASH_NRF_UICR */
}

static void nvmc_wait_ready(void)
{
	while (!nrfx_nvmc_write_done_check()) {
    354e:	f013 0f01 	tst.w	r3, #1
    3552:	d0f9      	beq.n	3548 <nvmc_wait_ready>
	}
}
    3554:	4770      	bx	lr
    3556:	bf00      	nop
    3558:	50039000 	.word	0x50039000

0000355c <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(const struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
    355c:	4b02      	ldr	r3, [pc, #8]	; (3568 <flash_nrf_pages_layout+0xc>)
    355e:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
    3560:	2301      	movs	r3, #1
    3562:	6013      	str	r3, [r2, #0]
}
    3564:	4770      	bx	lr
    3566:	bf00      	nop
    3568:	20000ebc 	.word	0x20000ebc

0000356c <flash_nrf_get_parameters>:
flash_nrf_get_parameters(const struct device *dev)
{
	ARG_UNUSED(dev);

	return &flash_nrf_parameters;
}
    356c:	4800      	ldr	r0, [pc, #0]	; (3570 <flash_nrf_get_parameters+0x4>)
    356e:	4770      	bx	lr
    3570:	0000f250 	.word	0x0000f250

00003574 <flash_nrf_erase>:
{
    3574:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3576:	460e      	mov	r6, r1
    3578:	4615      	mov	r5, r2
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
    357a:	f008 fcb0 	bl	bede <nrfx_nvmc_flash_page_size_get>
    357e:	4604      	mov	r4, r0
	if (is_regular_addr_valid(addr, size)) {
    3580:	4629      	mov	r1, r5
    3582:	4630      	mov	r0, r6
    3584:	f007 fea1 	bl	b2ca <is_regular_addr_valid>
    3588:	b340      	cbz	r0, 35dc <flash_nrf_erase+0x68>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
    358a:	fbb6 f3f4 	udiv	r3, r6, r4
    358e:	fb04 6313 	mls	r3, r4, r3, r6
    3592:	b94b      	cbnz	r3, 35a8 <flash_nrf_erase+0x34>
    3594:	fbb5 f3f4 	udiv	r3, r5, r4
    3598:	fb04 5313 	mls	r3, r4, r3, r5
    359c:	b923      	cbnz	r3, 35a8 <flash_nrf_erase+0x34>
		if (!n_pages) {
    359e:	42ac      	cmp	r4, r5
    35a0:	d90b      	bls.n	35ba <flash_nrf_erase+0x46>
			return 0;
    35a2:	2400      	movs	r4, #0
}
    35a4:	4620      	mov	r0, r4
    35a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			LOG_ERR("unaligned address: 0x%08lx:%zu",
    35a8:	462b      	mov	r3, r5
    35aa:	4632      	mov	r2, r6
    35ac:	2145      	movs	r1, #69	; 0x45
    35ae:	4810      	ldr	r0, [pc, #64]	; (35f0 <flash_nrf_erase+0x7c>)
    35b0:	f006 fec4 	bl	a33c <z_log_minimal_printk>
			return -EINVAL;
    35b4:	f06f 0415 	mvn.w	r4, #21
    35b8:	e7f4      	b.n	35a4 <flash_nrf_erase+0x30>
    35ba:	4f0e      	ldr	r7, [pc, #56]	; (35f4 <flash_nrf_erase+0x80>)
    35bc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    35c0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    35c4:	4638      	mov	r0, r7
    35c6:	f005 f81f 	bl	8608 <z_impl_k_sem_take>
		ret = erase(addr, size);
    35ca:	4629      	mov	r1, r5
    35cc:	4630      	mov	r0, r6
    35ce:	f007 fea2 	bl	b316 <erase>
    35d2:	4604      	mov	r4, r0
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    35d4:	4638      	mov	r0, r7
    35d6:	f004 fff5 	bl	85c4 <z_impl_k_sem_give>
	return ret;
    35da:	e7e3      	b.n	35a4 <flash_nrf_erase+0x30>
		LOG_ERR("invalid address: 0x%08lx:%zu",
    35dc:	462b      	mov	r3, r5
    35de:	4632      	mov	r2, r6
    35e0:	2145      	movs	r1, #69	; 0x45
    35e2:	4805      	ldr	r0, [pc, #20]	; (35f8 <flash_nrf_erase+0x84>)
    35e4:	f006 feaa 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    35e8:	f06f 0415 	mvn.w	r4, #21
    35ec:	e7da      	b.n	35a4 <flash_nrf_erase+0x30>
    35ee:	bf00      	nop
    35f0:	0000f1ac 	.word	0x0000f1ac
    35f4:	20000ec4 	.word	0x20000ec4
    35f8:	0000f1d0 	.word	0x0000f1d0

000035fc <flash_nrf_write>:
{
    35fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3600:	460c      	mov	r4, r1
    3602:	4616      	mov	r6, r2
    3604:	461d      	mov	r5, r3
	if (is_regular_addr_valid(addr, len)) {
    3606:	4619      	mov	r1, r3
    3608:	4620      	mov	r0, r4
    360a:	f007 fe5e 	bl	b2ca <is_regular_addr_valid>
    360e:	b148      	cbz	r0, 3624 <flash_nrf_write+0x28>
	if (!is_aligned_32(addr) || (len % sizeof(uint32_t))) {
    3610:	f014 0703 	ands.w	r7, r4, #3
    3614:	d10f      	bne.n	3636 <flash_nrf_write+0x3a>
    3616:	f015 0f03 	tst.w	r5, #3
    361a:	d10c      	bne.n	3636 <flash_nrf_write+0x3a>
	if (!len) {
    361c:	b9a5      	cbnz	r5, 3648 <flash_nrf_write+0x4c>
}
    361e:	4638      	mov	r0, r7
    3620:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LOG_ERR("invalid address: 0x%08lx:%zu",
    3624:	462b      	mov	r3, r5
    3626:	4622      	mov	r2, r4
    3628:	2145      	movs	r1, #69	; 0x45
    362a:	4811      	ldr	r0, [pc, #68]	; (3670 <flash_nrf_write+0x74>)
    362c:	f006 fe86 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    3630:	f06f 0715 	mvn.w	r7, #21
    3634:	e7f3      	b.n	361e <flash_nrf_write+0x22>
		LOG_ERR("not word-aligned: 0x%08lx:%zu",
    3636:	462b      	mov	r3, r5
    3638:	4622      	mov	r2, r4
    363a:	2145      	movs	r1, #69	; 0x45
    363c:	480d      	ldr	r0, [pc, #52]	; (3674 <flash_nrf_write+0x78>)
    363e:	f006 fe7d 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    3642:	f06f 0715 	mvn.w	r7, #21
    3646:	e7ea      	b.n	361e <flash_nrf_write+0x22>
	return z_impl_k_sem_take(sem, timeout);
    3648:	f8df 802c 	ldr.w	r8, [pc, #44]	; 3678 <flash_nrf_write+0x7c>
    364c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    3650:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3654:	4640      	mov	r0, r8
    3656:	f004 ffd7 	bl	8608 <z_impl_k_sem_take>
		ret = write(addr, data, len);
    365a:	462a      	mov	r2, r5
    365c:	4631      	mov	r1, r6
    365e:	4620      	mov	r0, r4
    3660:	f007 fe7a 	bl	b358 <write>
    3664:	4607      	mov	r7, r0
	z_impl_k_sem_give(sem);
    3666:	4640      	mov	r0, r8
    3668:	f004 ffac 	bl	85c4 <z_impl_k_sem_give>
	return ret;
    366c:	e7d7      	b.n	361e <flash_nrf_write+0x22>
    366e:	bf00      	nop
    3670:	0000f1d0 	.word	0x0000f1d0
    3674:	0000f1f4 	.word	0x0000f1f4
    3678:	20000ec4 	.word	0x20000ec4

0000367c <flash_nrf_read>:
{
    367c:	b570      	push	{r4, r5, r6, lr}
    367e:	460d      	mov	r5, r1
    3680:	4616      	mov	r6, r2
    3682:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
    3684:	4619      	mov	r1, r3
    3686:	4628      	mov	r0, r5
    3688:	f007 fe1f 	bl	b2ca <is_regular_addr_valid>
    368c:	b110      	cbz	r0, 3694 <flash_nrf_read+0x18>
	if (!len) {
    368e:	b954      	cbnz	r4, 36a6 <flash_nrf_read+0x2a>
		return 0;
    3690:	2000      	movs	r0, #0
}
    3692:	bd70      	pop	{r4, r5, r6, pc}
		LOG_ERR("invalid address: 0x%08lx:%zu",
    3694:	4623      	mov	r3, r4
    3696:	462a      	mov	r2, r5
    3698:	2145      	movs	r1, #69	; 0x45
    369a:	4806      	ldr	r0, [pc, #24]	; (36b4 <flash_nrf_read+0x38>)
    369c:	f006 fe4e 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    36a0:	f06f 0015 	mvn.w	r0, #21
    36a4:	e7f5      	b.n	3692 <flash_nrf_read+0x16>
	memcpy(data, (void *)addr, len);
    36a6:	4622      	mov	r2, r4
    36a8:	4629      	mov	r1, r5
    36aa:	4630      	mov	r0, r6
    36ac:	f007 f806 	bl	a6bc <memcpy>
	return 0;
    36b0:	2000      	movs	r0, #0
    36b2:	e7ee      	b.n	3692 <flash_nrf_read+0x16>
    36b4:	0000f1d0 	.word	0x0000f1d0

000036b8 <nrf_flash_init>:
	.page_layout = flash_nrf_pages_layout,
#endif
};

static int nrf_flash_init(const struct device *dev)
{
    36b8:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
    36ba:	2201      	movs	r2, #1
    36bc:	4611      	mov	r1, r2
    36be:	4806      	ldr	r0, [pc, #24]	; (36d8 <nrf_flash_init+0x20>)
    36c0:	f00a f90c 	bl	d8dc <z_impl_k_sem_init>
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	nrf_flash_sync_init();
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

#if defined(CONFIG_FLASH_PAGE_LAYOUT)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
    36c4:	f008 fc0f 	bl	bee6 <nrfx_nvmc_flash_page_count_get>
    36c8:	4c04      	ldr	r4, [pc, #16]	; (36dc <nrf_flash_init+0x24>)
    36ca:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
    36cc:	f008 fc07 	bl	bede <nrfx_nvmc_flash_page_size_get>
    36d0:	6060      	str	r0, [r4, #4]
#endif

	return 0;
}
    36d2:	2000      	movs	r0, #0
    36d4:	bd10      	pop	{r4, pc}
    36d6:	bf00      	nop
    36d8:	20000ec4 	.word	0x20000ec4
    36dc:	20000ebc 	.word	0x20000ebc

000036e0 <get_dev>:
			dev = DEVICE_DT_INST_GET(i); \
		}

	if (0) {
	} /* Followed by else if from FOREACH macro. Done to avoid return statement in macro.  */
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    36e0:	b128      	cbz	r0, 36ee <get_dev+0xe>
    36e2:	2801      	cmp	r0, #1
    36e4:	d101      	bne.n	36ea <get_dev+0xa>
    36e6:	4803      	ldr	r0, [pc, #12]	; (36f4 <get_dev+0x14>)
	#undef GPIO_NRF_GET_DEV

	return dev;
}
    36e8:	4770      	bx	lr
	const struct device *dev = NULL;
    36ea:	2000      	movs	r0, #0
    36ec:	4770      	bx	lr
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    36ee:	4802      	ldr	r0, [pc, #8]	; (36f8 <get_dev+0x18>)
    36f0:	4770      	bx	lr
    36f2:	bf00      	nop
    36f4:	0000dd3c 	.word	0x0000dd3c
    36f8:	0000dd54 	.word	0x0000dd54

000036fc <gpio_nrfx_pin_interrupt_configure>:
{
    36fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    36fe:	b085      	sub	sp, #20
    3700:	460e      	mov	r6, r1
    3702:	4619      	mov	r1, r3
	return port->config;
    3704:	6843      	ldr	r3, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    3706:	7b1b      	ldrb	r3, [r3, #12]
    3708:	f006 051f 	and.w	r5, r6, #31
    370c:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
    3710:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    3714:	d022      	beq.n	375c <gpio_nrfx_pin_interrupt_configure+0x60>
    3716:	4607      	mov	r7, r0
    3718:	4614      	mov	r4, r2
	nrfx_gpiote_trigger_config_t trigger_config = {
    371a:	2300      	movs	r3, #0
    371c:	9301      	str	r3, [sp, #4]
    371e:	9302      	str	r3, [sp, #8]
		.trigger = get_trigger(mode, trig),
    3720:	4610      	mov	r0, r2
    3722:	f007 ff24 	bl	b56e <get_trigger>
	nrfx_gpiote_trigger_config_t trigger_config = {
    3726:	f88d 0004 	strb.w	r0, [sp, #4]
	return port->config;
    372a:	687b      	ldr	r3, [r7, #4]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
    372c:	6899      	ldr	r1, [r3, #8]
    372e:	40f1      	lsrs	r1, r6
    3730:	f011 0f01 	tst.w	r1, #1
    3734:	d102      	bne.n	373c <gpio_nrfx_pin_interrupt_configure+0x40>
    3736:	f1b4 7fa0 	cmp.w	r4, #20971520	; 0x1400000
    373a:	d014      	beq.n	3766 <gpio_nrfx_pin_interrupt_configure+0x6a>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    373c:	2300      	movs	r3, #0
    373e:	aa01      	add	r2, sp, #4
    3740:	4619      	mov	r1, r3
    3742:	4628      	mov	r0, r5
    3744:	f001 fa02 	bl	4b4c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    3748:	4b1a      	ldr	r3, [pc, #104]	; (37b4 <gpio_nrfx_pin_interrupt_configure+0xb8>)
    374a:	4298      	cmp	r0, r3
    374c:	d12f      	bne.n	37ae <gpio_nrfx_pin_interrupt_configure+0xb2>
	nrfx_gpiote_trigger_enable(abs_pin, true);
    374e:	2101      	movs	r1, #1
    3750:	4628      	mov	r0, r5
    3752:	f001 fb5f 	bl	4e14 <nrfx_gpiote_trigger_enable>
	return 0;
    3756:	2000      	movs	r0, #0
}
    3758:	b005      	add	sp, #20
    375a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrfx_gpiote_trigger_disable(abs_pin);
    375c:	4628      	mov	r0, r5
    375e:	f001 fb8b 	bl	4e78 <nrfx_gpiote_trigger_disable>
		return 0;
    3762:	2000      	movs	r0, #0
    3764:	e7f8      	b.n	3758 <gpio_nrfx_pin_interrupt_configure+0x5c>
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    3766:	f005 031f 	and.w	r3, r5, #31

    return pin_number >> 5;
    376a:	096a      	lsrs	r2, r5, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    376c:	2a01      	cmp	r2, #1
    376e:	d012      	beq.n	3796 <gpio_nrfx_pin_interrupt_configure+0x9a>
        case 0: return NRF_P0;
    3770:	4a11      	ldr	r2, [pc, #68]	; (37b8 <gpio_nrfx_pin_interrupt_configure+0xbc>)
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    3772:	3380      	adds	r3, #128	; 0x80
    3774:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
    3778:	f013 0f01 	tst.w	r3, #1
    377c:	d1de      	bne.n	373c <gpio_nrfx_pin_interrupt_configure+0x40>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
    377e:	f10d 010f 	add.w	r1, sp, #15
    3782:	4628      	mov	r0, r5
    3784:	f001 faea 	bl	4d5c <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
    3788:	4b0c      	ldr	r3, [pc, #48]	; (37bc <gpio_nrfx_pin_interrupt_configure+0xc0>)
    378a:	4298      	cmp	r0, r3
    378c:	d005      	beq.n	379a <gpio_nrfx_pin_interrupt_configure+0x9e>
		trigger_config.p_in_channel = &ch;
    378e:	f10d 030f 	add.w	r3, sp, #15
    3792:	9302      	str	r3, [sp, #8]
    3794:	e7d2      	b.n	373c <gpio_nrfx_pin_interrupt_configure+0x40>
        case 1: return NRF_P1;
    3796:	4a0a      	ldr	r2, [pc, #40]	; (37c0 <gpio_nrfx_pin_interrupt_configure+0xc4>)
    3798:	e7eb      	b.n	3772 <gpio_nrfx_pin_interrupt_configure+0x76>
			err = nrfx_gpiote_channel_alloc(&ch);
    379a:	f10d 000f 	add.w	r0, sp, #15
    379e:	f001 fb31 	bl	4e04 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
    37a2:	4b04      	ldr	r3, [pc, #16]	; (37b4 <gpio_nrfx_pin_interrupt_configure+0xb8>)
    37a4:	4298      	cmp	r0, r3
    37a6:	d0f2      	beq.n	378e <gpio_nrfx_pin_interrupt_configure+0x92>
				return -ENOMEM;
    37a8:	f06f 000b 	mvn.w	r0, #11
    37ac:	e7d4      	b.n	3758 <gpio_nrfx_pin_interrupt_configure+0x5c>
		return -EINVAL;
    37ae:	f06f 0015 	mvn.w	r0, #21
    37b2:	e7d1      	b.n	3758 <gpio_nrfx_pin_interrupt_configure+0x5c>
    37b4:	0bad0000 	.word	0x0bad0000
    37b8:	50842500 	.word	0x50842500
    37bc:	0bad0004 	.word	0x0bad0004
    37c0:	50842800 	.word	0x50842800

000037c4 <gpio_nrfx_pin_configure>:
{
    37c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    37c8:	b086      	sub	sp, #24
    37ca:	460e      	mov	r6, r1
    37cc:	4614      	mov	r4, r2
	return port->config;
    37ce:	f8d0 8004 	ldr.w	r8, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    37d2:	f898 300c 	ldrb.w	r3, [r8, #12]
    37d6:	f001 051f 	and.w	r5, r1, #31
    37da:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
    37de:	f10d 0117 	add.w	r1, sp, #23
    37e2:	4628      	mov	r0, r5
    37e4:	f001 faba 	bl	4d5c <nrfx_gpiote_channel_get>
    37e8:	4607      	mov	r7, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
    37ea:	f414 3f40 	tst.w	r4, #196608	; 0x30000
    37ee:	d039      	beq.n	3864 <gpio_nrfx_pin_configure+0xa0>
	nrfx_gpiote_trigger_config_t trigger_config = {
    37f0:	2100      	movs	r1, #0
    37f2:	9103      	str	r1, [sp, #12]
    37f4:	9104      	str	r1, [sp, #16]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    37f6:	460b      	mov	r3, r1
    37f8:	aa03      	add	r2, sp, #12
    37fa:	4628      	mov	r0, r5
    37fc:	f001 f9a6 	bl	4b4c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    3800:	4b32      	ldr	r3, [pc, #200]	; (38cc <gpio_nrfx_pin_configure+0x108>)
    3802:	4298      	cmp	r0, r3
    3804:	d15f      	bne.n	38c6 <gpio_nrfx_pin_configure+0x102>
	if (free_ch) {
    3806:	429f      	cmp	r7, r3
    3808:	d03c      	beq.n	3884 <gpio_nrfx_pin_configure+0xc0>
	if (flags & GPIO_OUTPUT) {
    380a:	f414 3f00 	tst.w	r4, #131072	; 0x20000
    380e:	d047      	beq.n	38a0 <gpio_nrfx_pin_configure+0xdc>
		int rv = get_drive(flags, &drive);
    3810:	f10d 0103 	add.w	r1, sp, #3
    3814:	4620      	mov	r0, r4
    3816:	f007 fe37 	bl	b488 <get_drive>
		if (rv != 0) {
    381a:	4607      	mov	r7, r0
    381c:	bb48      	cbnz	r0, 3872 <gpio_nrfx_pin_configure+0xae>
		nrfx_gpiote_output_config_t output_config = {
    381e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3822:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
    3826:	f414 3f80 	tst.w	r4, #65536	; 0x10000
    382a:	bf0c      	ite	eq
    382c:	2301      	moveq	r3, #1
    382e:	2300      	movne	r3, #0
		nrfx_gpiote_output_config_t output_config = {
    3830:	f88d 3005 	strb.w	r3, [sp, #5]
			.pull = get_pull(flags)
    3834:	4620      	mov	r0, r4
    3836:	f007 fe6a 	bl	b50e <get_pull>
		nrfx_gpiote_output_config_t output_config = {
    383a:	f88d 0006 	strb.w	r0, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    383e:	f414 2f00 	tst.w	r4, #524288	; 0x80000
    3842:	d024      	beq.n	388e <gpio_nrfx_pin_configure+0xca>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
    3844:	f8d8 2004 	ldr.w	r2, [r8, #4]
    3848:	2301      	movs	r3, #1
    384a:	40b3      	lsls	r3, r6
    p_reg->OUTSET = set_mask;
    384c:	6093      	str	r3, [r2, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
    384e:	2200      	movs	r2, #0
    3850:	a901      	add	r1, sp, #4
    3852:	4628      	mov	r0, r5
    3854:	f001 fa10 	bl	4c78 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    3858:	4b1c      	ldr	r3, [pc, #112]	; (38cc <gpio_nrfx_pin_configure+0x108>)
    385a:	4298      	cmp	r0, r3
    385c:	d009      	beq.n	3872 <gpio_nrfx_pin_configure+0xae>
    385e:	f06f 0715 	mvn.w	r7, #21
    3862:	e006      	b.n	3872 <gpio_nrfx_pin_configure+0xae>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
    3864:	4628      	mov	r0, r5
    3866:	f001 fb29 	bl	4ebc <nrfx_gpiote_pin_uninit>
		if (free_ch) {
    386a:	4b18      	ldr	r3, [pc, #96]	; (38cc <gpio_nrfx_pin_configure+0x108>)
    386c:	429f      	cmp	r7, r3
    386e:	d004      	beq.n	387a <gpio_nrfx_pin_configure+0xb6>
		return 0;
    3870:	2700      	movs	r7, #0
}
    3872:	4638      	mov	r0, r7
    3874:	b006      	add	sp, #24
    3876:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			err = nrfx_gpiote_channel_free(ch);
    387a:	f89d 0017 	ldrb.w	r0, [sp, #23]
    387e:	f001 fab9 	bl	4df4 <nrfx_gpiote_channel_free>
    3882:	e7f5      	b.n	3870 <gpio_nrfx_pin_configure+0xac>
		err = nrfx_gpiote_channel_free(ch);
    3884:	f89d 0017 	ldrb.w	r0, [sp, #23]
    3888:	f001 fab4 	bl	4df4 <nrfx_gpiote_channel_free>
    388c:	e7bd      	b.n	380a <gpio_nrfx_pin_configure+0x46>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
    388e:	f414 2f80 	tst.w	r4, #262144	; 0x40000
    3892:	d0dc      	beq.n	384e <gpio_nrfx_pin_configure+0x8a>
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
    3894:	f8d8 2004 	ldr.w	r2, [r8, #4]
    3898:	2301      	movs	r3, #1
    389a:	40b3      	lsls	r3, r6
    p_reg->OUTCLR = clr_mask;
    389c:	60d3      	str	r3, [r2, #12]
}
    389e:	e7d6      	b.n	384e <gpio_nrfx_pin_configure+0x8a>
		.pull = get_pull(flags)
    38a0:	4620      	mov	r0, r4
    38a2:	f007 fe34 	bl	b50e <get_pull>
	nrfx_gpiote_input_config_t input_config = {
    38a6:	f88d 0008 	strb.w	r0, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    38aa:	2300      	movs	r3, #0
    38ac:	461a      	mov	r2, r3
    38ae:	a902      	add	r1, sp, #8
    38b0:	4628      	mov	r0, r5
    38b2:	f001 f94b 	bl	4b4c <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    38b6:	4b05      	ldr	r3, [pc, #20]	; (38cc <gpio_nrfx_pin_configure+0x108>)
    38b8:	4298      	cmp	r0, r3
    38ba:	d101      	bne.n	38c0 <gpio_nrfx_pin_configure+0xfc>
    38bc:	2700      	movs	r7, #0
    38be:	e7d8      	b.n	3872 <gpio_nrfx_pin_configure+0xae>
    38c0:	f06f 0715 	mvn.w	r7, #21
    38c4:	e7d5      	b.n	3872 <gpio_nrfx_pin_configure+0xae>
		return -EINVAL;
    38c6:	f06f 0715 	mvn.w	r7, #21
    38ca:	e7d2      	b.n	3872 <gpio_nrfx_pin_configure+0xae>
    38cc:	0bad0000 	.word	0x0bad0000

000038d0 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    38d0:	b508      	push	{r3, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
    38d2:	f001 fa85 	bl	4de0 <nrfx_gpiote_is_init>
    38d6:	b108      	cbz	r0, 38dc <gpio_nrfx_init+0xc>
		return 0;
    38d8:	2000      	movs	r0, #0

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
    38da:	bd08      	pop	{r3, pc}
	err = nrfx_gpiote_init(0/*not used*/);
    38dc:	f001 fa56 	bl	4d8c <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
    38e0:	4b08      	ldr	r3, [pc, #32]	; (3904 <gpio_nrfx_init+0x34>)
    38e2:	4298      	cmp	r0, r3
    38e4:	d10a      	bne.n	38fc <gpio_nrfx_init+0x2c>
	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
    38e6:	2100      	movs	r1, #0
    38e8:	4807      	ldr	r0, [pc, #28]	; (3908 <gpio_nrfx_init+0x38>)
    38ea:	f001 fa31 	bl	4d50 <nrfx_gpiote_global_callback_set>
	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    38ee:	2200      	movs	r2, #0
    38f0:	2105      	movs	r1, #5
    38f2:	200d      	movs	r0, #13
    38f4:	f006 fdc8 	bl	a488 <z_arm_irq_priority_set>
	return 0;
    38f8:	2000      	movs	r0, #0
    38fa:	e7ee      	b.n	38da <gpio_nrfx_init+0xa>
		return -EIO;
    38fc:	f06f 0004 	mvn.w	r0, #4
    3900:	e7eb      	b.n	38da <gpio_nrfx_init+0xa>
    3902:	bf00      	nop
    3904:	0bad0000 	.word	0x0bad0000
    3908:	0000b5a7 	.word	0x0000b5a7

0000390c <nrf_gpio_cfg>:
{
    390c:	b430      	push	{r4, r5}
    *p_pin = pin_number & 0x1F;
    390e:	f000 0c1f 	and.w	ip, r0, #31
    return pin_number >> 5;
    3912:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    3914:	2801      	cmp	r0, #1
    3916:	d018      	beq.n	394a <nrf_gpio_cfg+0x3e>
        case 0: return NRF_P0;
    3918:	4d0d      	ldr	r5, [pc, #52]	; (3950 <nrf_gpio_cfg+0x44>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    391a:	f10c 0080 	add.w	r0, ip, #128	; 0x80
    391e:	f855 4020 	ldr.w	r4, [r5, r0, lsl #2]
    3922:	f004 4ce0 	and.w	ip, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    3926:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos) |
    392a:	ea41 0383 	orr.w	r3, r1, r3, lsl #2
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    392e:	f89d 2008 	ldrb.w	r2, [sp, #8]
    3932:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
    3936:	f89d 200c 	ldrb.w	r2, [sp, #12]
    393a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    393e:	ea43 030c 	orr.w	r3, r3, ip
    reg->PIN_CNF[pin_number] = cnf;
    3942:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
}
    3946:	bc30      	pop	{r4, r5}
    3948:	4770      	bx	lr
        case 1: return NRF_P1;
    394a:	4d02      	ldr	r5, [pc, #8]	; (3954 <nrf_gpio_cfg+0x48>)
    394c:	e7e5      	b.n	391a <nrf_gpio_cfg+0xe>
    394e:	bf00      	nop
    3950:	50842500 	.word	0x50842500
    3954:	50842800 	.word	0x50842800

00003958 <nrf_gpio_pin_write>:
    if (value == 0)
    3958:	b959      	cbnz	r1, 3972 <nrf_gpio_pin_write+0x1a>
    *p_pin = pin_number & 0x1F;
    395a:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
    395e:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    3960:	2801      	cmp	r0, #1
    3962:	d004      	beq.n	396e <nrf_gpio_pin_write+0x16>
        case 0: return NRF_P0;
    3964:	4a09      	ldr	r2, [pc, #36]	; (398c <nrf_gpio_pin_write+0x34>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    3966:	2301      	movs	r3, #1
    3968:	408b      	lsls	r3, r1
    p_reg->OUTCLR = clr_mask;
    396a:	60d3      	str	r3, [r2, #12]
}
    396c:	4770      	bx	lr
        case 1: return NRF_P1;
    396e:	4a08      	ldr	r2, [pc, #32]	; (3990 <nrf_gpio_pin_write+0x38>)
    3970:	e7f9      	b.n	3966 <nrf_gpio_pin_write+0xe>
    *p_pin = pin_number & 0x1F;
    3972:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
    3976:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    3978:	2801      	cmp	r0, #1
    397a:	d004      	beq.n	3986 <nrf_gpio_pin_write+0x2e>
        case 0: return NRF_P0;
    397c:	4a03      	ldr	r2, [pc, #12]	; (398c <nrf_gpio_pin_write+0x34>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    397e:	2301      	movs	r3, #1
    3980:	408b      	lsls	r3, r1
    p_reg->OUTSET = set_mask;
    3982:	6093      	str	r3, [r2, #8]
}
    3984:	4770      	bx	lr
        case 1: return NRF_P1;
    3986:	4a02      	ldr	r2, [pc, #8]	; (3990 <nrf_gpio_pin_write+0x38>)
    3988:	e7f9      	b.n	397e <nrf_gpio_pin_write+0x26>
    398a:	bf00      	nop
    398c:	50842500 	.word	0x50842500
    3990:	50842800 	.word	0x50842800

00003994 <pinctrl_configure_pins>:
#define NRF_PSEL_QSPI(reg, line) ((NRF_QSPI_Type *)reg)->PSEL.line
#endif

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
    3994:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3998:	b085      	sub	sp, #20
    399a:	4607      	mov	r7, r0
    399c:	4689      	mov	r9, r1
    399e:	4690      	mov	r8, r2
	for (uint8_t i = 0U; i < pin_cnt; i++) {
    39a0:	2400      	movs	r4, #0
    39a2:	e021      	b.n	39e8 <pinctrl_configure_pins+0x54>
		uint32_t write = NO_WRITE;
		nrf_gpio_pin_dir_t dir;
		nrf_gpio_pin_input_t input;

		if (pin == NRF_PIN_DISCONNECTED) {
			pin = 0xFFFFFFFFU;
    39a4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    39a8:	e02a      	b.n	3a00 <pinctrl_configure_pins+0x6c>
		}

		switch (NRF_GET_FUN(pins[i])) {
#if defined(NRF_PSEL_UART)
		case NRF_FUN_UART_TX:
			NRF_PSEL_UART(reg, TXD) = pin;
    39aa:	f8c8 550c 	str.w	r5, [r8, #1292]	; 0x50c
			write = 1U;
			dir = NRF_GPIO_PIN_DIR_OUTPUT;
			input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    39ae:	2601      	movs	r6, #1
			dir = NRF_GPIO_PIN_DIR_OUTPUT;
    39b0:	9603      	str	r6, [sp, #12]
			write = 1U;
    39b2:	4631      	mov	r1, r6
		default:
			return -ENOTSUP;
		}

		/* configure GPIO properties */
		if (pin != NRF_PIN_DISCONNECTED) {
    39b4:	2d7f      	cmp	r5, #127	; 0x7f
    39b6:	d015      	beq.n	39e4 <pinctrl_configure_pins+0x50>
			if (write != NO_WRITE) {
    39b8:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    39bc:	d15c      	bne.n	3a78 <pinctrl_configure_pins+0xe4>
				nrf_gpio_pin_write(pin, write);
			}

			/* force input and disconnected buffer for low power */
			if (NRF_GET_LP(pins[i]) == NRF_LP_ENABLE) {
    39be:	f857 300b 	ldr.w	r3, [r7, fp]
    39c2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    39c6:	d002      	beq.n	39ce <pinctrl_configure_pins+0x3a>
				dir = NRF_GPIO_PIN_DIR_INPUT;
				input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    39c8:	2601      	movs	r6, #1
				dir = NRF_GPIO_PIN_DIR_INPUT;
    39ca:	2200      	movs	r2, #0
    39cc:	9203      	str	r2, [sp, #12]
			}

			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
    39ce:	2200      	movs	r2, #0
    39d0:	9201      	str	r2, [sp, #4]
    39d2:	f8cd a000 	str.w	sl, [sp]
    39d6:	f3c3 13c1 	ubfx	r3, r3, #7, #2
    39da:	4632      	mov	r2, r6
    39dc:	9903      	ldr	r1, [sp, #12]
    39de:	4628      	mov	r0, r5
    39e0:	f7ff ff94 	bl	390c <nrf_gpio_cfg>
	for (uint8_t i = 0U; i < pin_cnt; i++) {
    39e4:	3401      	adds	r4, #1
    39e6:	b2e4      	uxtb	r4, r4
    39e8:	454c      	cmp	r4, r9
    39ea:	d249      	bcs.n	3a80 <pinctrl_configure_pins+0xec>
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
    39ec:	ea4f 0b84 	mov.w	fp, r4, lsl #2
    39f0:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
    39f4:	f3c3 2a43 	ubfx	sl, r3, #9, #4
		uint32_t pin = NRF_GET_PIN(pins[i]);
    39f8:	f003 057f 	and.w	r5, r3, #127	; 0x7f
		if (pin == NRF_PIN_DISCONNECTED) {
    39fc:	2d7f      	cmp	r5, #127	; 0x7f
    39fe:	d0d1      	beq.n	39a4 <pinctrl_configure_pins+0x10>
		switch (NRF_GET_FUN(pins[i])) {
    3a00:	0c1b      	lsrs	r3, r3, #16
    3a02:	2b06      	cmp	r3, #6
    3a04:	d840      	bhi.n	3a88 <pinctrl_configure_pins+0xf4>
    3a06:	a201      	add	r2, pc, #4	; (adr r2, 3a0c <pinctrl_configure_pins+0x78>)
    3a08:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    3a0c:	000039ab 	.word	0x000039ab
    3a10:	00003a29 	.word	0x00003a29
    3a14:	00003a37 	.word	0x00003a37
    3a18:	00003a43 	.word	0x00003a43
    3a1c:	00003a51 	.word	0x00003a51
    3a20:	00003a5f 	.word	0x00003a5f
    3a24:	00003a6b 	.word	0x00003a6b
			NRF_PSEL_UART(reg, RXD) = pin;
    3a28:	f8c8 5514 	str.w	r5, [r8, #1300]	; 0x514
			input = NRF_GPIO_PIN_INPUT_CONNECT;
    3a2c:	2600      	movs	r6, #0
			dir = NRF_GPIO_PIN_DIR_INPUT;
    3a2e:	9603      	str	r6, [sp, #12]
		uint32_t write = NO_WRITE;
    3a30:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
			break;
    3a34:	e7be      	b.n	39b4 <pinctrl_configure_pins+0x20>
			NRF_PSEL_UART(reg, RTS) = pin;
    3a36:	f8c8 5508 	str.w	r5, [r8, #1288]	; 0x508
			input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    3a3a:	2601      	movs	r6, #1
			dir = NRF_GPIO_PIN_DIR_OUTPUT;
    3a3c:	9603      	str	r6, [sp, #12]
			write = 1U;
    3a3e:	4631      	mov	r1, r6
			break;
    3a40:	e7b8      	b.n	39b4 <pinctrl_configure_pins+0x20>
			NRF_PSEL_UART(reg, CTS) = pin;
    3a42:	f8c8 5510 	str.w	r5, [r8, #1296]	; 0x510
			input = NRF_GPIO_PIN_INPUT_CONNECT;
    3a46:	2600      	movs	r6, #0
			dir = NRF_GPIO_PIN_DIR_INPUT;
    3a48:	9603      	str	r6, [sp, #12]
		uint32_t write = NO_WRITE;
    3a4a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
			break;
    3a4e:	e7b1      	b.n	39b4 <pinctrl_configure_pins+0x20>
			NRF_PSEL_SPIM(reg, SCK) = pin;
    3a50:	f8c8 5508 	str.w	r5, [r8, #1288]	; 0x508
			input = NRF_GPIO_PIN_INPUT_CONNECT;
    3a54:	2600      	movs	r6, #0
			dir = NRF_GPIO_PIN_DIR_OUTPUT;
    3a56:	2301      	movs	r3, #1
    3a58:	9303      	str	r3, [sp, #12]
			write = 0U;
    3a5a:	4631      	mov	r1, r6
			break;
    3a5c:	e7aa      	b.n	39b4 <pinctrl_configure_pins+0x20>
			NRF_PSEL_SPIM(reg, MOSI) = pin;
    3a5e:	f8c8 550c 	str.w	r5, [r8, #1292]	; 0x50c
			input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    3a62:	2601      	movs	r6, #1
			dir = NRF_GPIO_PIN_DIR_OUTPUT;
    3a64:	9603      	str	r6, [sp, #12]
			write = 0U;
    3a66:	2100      	movs	r1, #0
			break;
    3a68:	e7a4      	b.n	39b4 <pinctrl_configure_pins+0x20>
			NRF_PSEL_SPIM(reg, MISO) = pin;
    3a6a:	f8c8 5510 	str.w	r5, [r8, #1296]	; 0x510
			input = NRF_GPIO_PIN_INPUT_CONNECT;
    3a6e:	2600      	movs	r6, #0
			dir = NRF_GPIO_PIN_DIR_INPUT;
    3a70:	9603      	str	r6, [sp, #12]
		uint32_t write = NO_WRITE;
    3a72:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
			break;
    3a76:	e79d      	b.n	39b4 <pinctrl_configure_pins+0x20>
				nrf_gpio_pin_write(pin, write);
    3a78:	4628      	mov	r0, r5
    3a7a:	f7ff ff6d 	bl	3958 <nrf_gpio_pin_write>
    3a7e:	e79e      	b.n	39be <pinctrl_configure_pins+0x2a>
				     drive, NRF_GPIO_PIN_NOSENSE);
		}
	}

	return 0;
    3a80:	2000      	movs	r0, #0
}
    3a82:	b005      	add	sp, #20
    3a84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch (NRF_GET_FUN(pins[i])) {
    3a88:	f06f 0085 	mvn.w	r0, #133	; 0x85
    3a8c:	e7f9      	b.n	3a82 <pinctrl_configure_pins+0xee>
    3a8e:	bf00      	nop

00003a90 <get_nrf_spim_frequency>:

static inline nrf_spim_frequency_t get_nrf_spim_frequency(uint32_t frequency)
{
	/* Get the highest supported frequency not exceeding the requested one.
	 */
	if (frequency < 250000) {
    3a90:	4b19      	ldr	r3, [pc, #100]	; (3af8 <get_nrf_spim_frequency+0x68>)
    3a92:	4298      	cmp	r0, r3
    3a94:	d917      	bls.n	3ac6 <get_nrf_spim_frequency+0x36>
		return NRF_SPIM_FREQ_125K;
	} else if (frequency < 500000) {
    3a96:	4b19      	ldr	r3, [pc, #100]	; (3afc <get_nrf_spim_frequency+0x6c>)
    3a98:	4298      	cmp	r0, r3
    3a9a:	d917      	bls.n	3acc <get_nrf_spim_frequency+0x3c>
		return NRF_SPIM_FREQ_250K;
	} else if (frequency < 1000000) {
    3a9c:	4b18      	ldr	r3, [pc, #96]	; (3b00 <get_nrf_spim_frequency+0x70>)
    3a9e:	4298      	cmp	r0, r3
    3aa0:	d917      	bls.n	3ad2 <get_nrf_spim_frequency+0x42>
		return NRF_SPIM_FREQ_500K;
	} else if (frequency < 2000000) {
    3aa2:	4b18      	ldr	r3, [pc, #96]	; (3b04 <get_nrf_spim_frequency+0x74>)
    3aa4:	4298      	cmp	r0, r3
    3aa6:	d917      	bls.n	3ad8 <get_nrf_spim_frequency+0x48>
		return NRF_SPIM_FREQ_1M;
	} else if (frequency < 4000000) {
    3aa8:	4b17      	ldr	r3, [pc, #92]	; (3b08 <get_nrf_spim_frequency+0x78>)
    3aaa:	4298      	cmp	r0, r3
    3aac:	d917      	bls.n	3ade <get_nrf_spim_frequency+0x4e>
		return NRF_SPIM_FREQ_2M;
	} else if (frequency < 8000000) {
    3aae:	4b17      	ldr	r3, [pc, #92]	; (3b0c <get_nrf_spim_frequency+0x7c>)
    3ab0:	4298      	cmp	r0, r3
    3ab2:	d317      	bcc.n	3ae4 <get_nrf_spim_frequency+0x54>
		return NRF_SPIM_FREQ_4M;
/* Only the devices with HS-SPI can use SPI clock higher than 8 MHz and
 * have SPIM_FREQUENCY_FREQUENCY_M32 defined in their own bitfields.h
 */
#if defined(SPIM_FREQUENCY_FREQUENCY_M32)
	} else if (frequency < 16000000) {
    3ab4:	4b16      	ldr	r3, [pc, #88]	; (3b10 <get_nrf_spim_frequency+0x80>)
    3ab6:	4298      	cmp	r0, r3
    3ab8:	d317      	bcc.n	3aea <get_nrf_spim_frequency+0x5a>
		return NRF_SPIM_FREQ_8M;
	} else if (frequency < 32000000) {
    3aba:	4b16      	ldr	r3, [pc, #88]	; (3b14 <get_nrf_spim_frequency+0x84>)
    3abc:	4298      	cmp	r0, r3
    3abe:	d217      	bcs.n	3af0 <get_nrf_spim_frequency+0x60>
		return NRF_SPIM_FREQ_16M;
    3ac0:	f04f 6020 	mov.w	r0, #167772160	; 0xa000000
    3ac4:	4770      	bx	lr
		return NRF_SPIM_FREQ_125K;
    3ac6:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
    3aca:	4770      	bx	lr
		return NRF_SPIM_FREQ_250K;
    3acc:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
    3ad0:	4770      	bx	lr
		return NRF_SPIM_FREQ_500K;
    3ad2:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    3ad6:	4770      	bx	lr
		return NRF_SPIM_FREQ_1M;
    3ad8:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    3adc:	4770      	bx	lr
		return NRF_SPIM_FREQ_2M;
    3ade:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
    3ae2:	4770      	bx	lr
		return NRF_SPIM_FREQ_4M;
    3ae4:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    3ae8:	4770      	bx	lr
		return NRF_SPIM_FREQ_8M;
    3aea:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    3aee:	4770      	bx	lr
	} else {
		return NRF_SPIM_FREQ_32M;
    3af0:	f04f 50a0 	mov.w	r0, #335544320	; 0x14000000
#else
	} else {
		return NRF_SPIM_FREQ_8M;
#endif
	}
}
    3af4:	4770      	bx	lr
    3af6:	bf00      	nop
    3af8:	0003d08f 	.word	0x0003d08f
    3afc:	0007a11f 	.word	0x0007a11f
    3b00:	000f423f 	.word	0x000f423f
    3b04:	001e847f 	.word	0x001e847f
    3b08:	003d08ff 	.word	0x003d08ff
    3b0c:	007a1200 	.word	0x007a1200
    3b10:	00f42400 	.word	0x00f42400
    3b14:	01e84800 	.word	0x01e84800

00003b18 <spi_context_wait_for_completion>:

static inline size_t spi_context_total_tx_len(struct spi_context *ctx);
static inline size_t spi_context_total_rx_len(struct spi_context *ctx);

static inline int spi_context_wait_for_completion(struct spi_context *ctx)
{
    3b18:	b538      	push	{r3, r4, r5, lr}
    3b1a:	4604      	mov	r4, r0
}

static inline size_t spi_context_total_tx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
    3b1c:	2200      	movs	r2, #0

	for (n = 0; n < ctx->tx_count; ++n) {
    3b1e:	4613      	mov	r3, r2
    3b20:	e005      	b.n	3b2e <spi_context_wait_for_completion+0x16>
		total_len += ctx->current_tx[n].len;
    3b22:	6b61      	ldr	r1, [r4, #52]	; 0x34
    3b24:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    3b28:	6849      	ldr	r1, [r1, #4]
    3b2a:	440a      	add	r2, r1
	for (n = 0; n < ctx->tx_count; ++n) {
    3b2c:	3301      	adds	r3, #1
    3b2e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3b30:	4299      	cmp	r1, r3
    3b32:	d8f6      	bhi.n	3b22 <spi_context_wait_for_completion+0xa>
}

static inline size_t spi_context_total_rx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
    3b34:	2000      	movs	r0, #0

	for (n = 0; n < ctx->rx_count; ++n) {
    3b36:	4603      	mov	r3, r0
    3b38:	e005      	b.n	3b46 <spi_context_wait_for_completion+0x2e>
		total_len += ctx->current_rx[n].len;
    3b3a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    3b3c:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    3b40:	6849      	ldr	r1, [r1, #4]
    3b42:	4408      	add	r0, r1
	for (n = 0; n < ctx->rx_count; ++n) {
    3b44:	3301      	adds	r3, #1
    3b46:	6c21      	ldr	r1, [r4, #64]	; 0x40
    3b48:	4299      	cmp	r1, r3
    3b4a:	d8f6      	bhi.n	3b3a <spi_context_wait_for_completion+0x22>
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
    3b4c:	4282      	cmp	r2, r0
    3b4e:	bf38      	it	cc
    3b50:	4602      	movcc	r2, r0
    3b52:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
    3b56:	fb03 f002 	mul.w	r0, r3, r2
				     ctx->config->frequency;
    3b5a:	4625      	mov	r5, r4
    3b5c:	f855 3b20 	ldr.w	r3, [r5], #32
    3b60:	681b      	ldr	r3, [r3, #0]
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
    3b62:	fbb0 f0f3 	udiv	r0, r0, r3
			timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
    3b66:	30c8      	adds	r0, #200	; 0xc8
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
    3b68:	0c41      	lsrs	r1, r0, #17
    3b6a:	03c0      	lsls	r0, r0, #15
    3b6c:	f240 33e7 	movw	r3, #999	; 0x3e7
    3b70:	18c0      	adds	r0, r0, r3
    3b72:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    3b76:	f04f 0300 	mov.w	r3, #0
    3b7a:	f141 0100 	adc.w	r1, r1, #0
    3b7e:	f7fc fae9 	bl	154 <__aeabi_uldivmod>
    3b82:	4602      	mov	r2, r0
    3b84:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
    3b86:	4628      	mov	r0, r5
    3b88:	f004 fd3e 	bl	8608 <z_impl_k_sem_take>
		if (k_sem_take(&ctx->sync, timeout)) {
    3b8c:	b908      	cbnz	r0, 3b92 <spi_context_wait_for_completion+0x7a>
		status = ctx->sync_status;
    3b8e:	6b20      	ldr	r0, [r4, #48]	; 0x30
}
    3b90:	bd38      	pop	{r3, r4, r5, pc}
			LOG_ERR("Timeout waiting for transfer complete");
    3b92:	2145      	movs	r1, #69	; 0x45
    3b94:	4802      	ldr	r0, [pc, #8]	; (3ba0 <spi_context_wait_for_completion+0x88>)
    3b96:	f006 fbd1 	bl	a33c <z_log_minimal_printk>
			return -ETIMEDOUT;
    3b9a:	f06f 0073 	mvn.w	r0, #115	; 0x73
    3b9e:	e7f7      	b.n	3b90 <spi_context_wait_for_completion+0x78>
    3ba0:	0000f2b4 	.word	0x0000f2b4

00003ba4 <configure>:
	}
}

static int configure(const struct device *dev,
		     const struct spi_config *spi_cfg)
{
    3ba4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3ba8:	b086      	sub	sp, #24
    3baa:	460c      	mov	r4, r1
	struct spi_nrfx_data *dev_data = dev->data;
    3bac:	6905      	ldr	r5, [r0, #16]
	const struct spi_nrfx_config *dev_config = dev->config;
    3bae:	6846      	ldr	r6, [r0, #4]
	struct spi_context *ctx = &dev_data->ctx;
	uint32_t max_freq = dev_config->max_freq;
    3bb0:	f8d6 8008 	ldr.w	r8, [r6, #8]
	nrfx_spim_config_t config;
	nrfx_err_t result;

	if (dev_data->initialized && spi_context_configured(ctx, spi_cfg)) {
    3bb4:	f895 705d 	ldrb.w	r7, [r5, #93]	; 0x5d
    3bb8:	b11f      	cbz	r7, 3bc2 <configure+0x1e>
	return !!(ctx->config == config);
    3bba:	682b      	ldr	r3, [r5, #0]
    3bbc:	428b      	cmp	r3, r1
    3bbe:	f000 8092 	beq.w	3ce6 <configure+0x142>
		/* Already configured. No need to do it again. */
		return 0;
	}

	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
    3bc2:	88a3      	ldrh	r3, [r4, #4]
    3bc4:	f413 6f00 	tst.w	r3, #2048	; 0x800
    3bc8:	d14f      	bne.n	3c6a <configure+0xc6>
		LOG_ERR("Half-duplex not supported");
		return -ENOTSUP;
	}

	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    3bca:	f013 0f01 	tst.w	r3, #1
    3bce:	d153      	bne.n	3c78 <configure+0xd4>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
		return -EINVAL;
	}

	if (spi_cfg->operation & SPI_MODE_LOOP) {
    3bd0:	f013 0f08 	tst.w	r3, #8
    3bd4:	d158      	bne.n	3c88 <configure+0xe4>
	    (spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
		LOG_ERR("Only single line mode is supported");
		return -EINVAL;
	}

	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    3bd6:	f3c3 1345 	ubfx	r3, r3, #5, #6
    3bda:	2b08      	cmp	r3, #8
    3bdc:	d15b      	bne.n	3c96 <configure+0xf2>
		LOG_ERR("Word sizes other than 8 bits are not supported");
		return -EINVAL;
	}

	if (spi_cfg->frequency < 125000) {
    3bde:	6822      	ldr	r2, [r4, #0]
    3be0:	4b42      	ldr	r3, [pc, #264]	; (3cec <configure+0x148>)
    3be2:	429a      	cmp	r2, r3
    3be4:	d95e      	bls.n	3ca4 <configure+0x100>
#if defined(CONFIG_SOC_NRF5340_CPUAPP)
	/* On nRF5340, the 32 Mbps speed is supported by the application core
	 * when it is running at 128 MHz (see the Timing specifications section
	 * in the nRF5340 PS).
	 */
	if (max_freq > 16000000 &&
    3be6:	4b42      	ldr	r3, [pc, #264]	; (3cf0 <configure+0x14c>)
    3be8:	4598      	cmp	r8, r3
    3bea:	d908      	bls.n	3bfe <configure+0x5a>
                        CLOCK_HFCLKCTRL_HCLK_Msk);
}

NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_hfclk_div_t)((p_reg->HFCLKCTRL & CLOCK_HFCLKCTRL_HCLK_Msk)
    3bec:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    3bf0:	f8d3 3558 	ldr.w	r3, [r3, #1368]	; 0x558
    3bf4:	f013 0f03 	tst.w	r3, #3
    3bf8:	d001      	beq.n	3bfe <configure+0x5a>
	    nrf_clock_hfclk_div_get(NRF_CLOCK) != NRF_CLOCK_HFCLK_DIV_1) {
		max_freq = 16000000;
    3bfa:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 3cf0 <configure+0x14c>
	}
#endif

	config = dev_config->def_config;
    3bfe:	46ec      	mov	ip, sp
    3c00:	f106 0e0c 	add.w	lr, r6, #12
    3c04:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    3c08:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3c0c:	e89e 0003 	ldmia.w	lr, {r0, r1}
    3c10:	e88c 0003 	stmia.w	ip, {r0, r1}

	/* Limit the frequency to that supported by the SPIM instance. */
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
    3c14:	6820      	ldr	r0, [r4, #0]
    3c16:	4540      	cmp	r0, r8
    3c18:	bf28      	it	cs
    3c1a:	4640      	movcs	r0, r8
    3c1c:	f7ff ff38 	bl	3a90 <get_nrf_spim_frequency>
    3c20:	9002      	str	r0, [sp, #8]
						      max_freq));
	config.mode      = get_nrf_spim_mode(spi_cfg->operation);
    3c22:	88a3      	ldrh	r3, [r4, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    3c24:	f013 0f02 	tst.w	r3, #2
    3c28:	d043      	beq.n	3cb2 <configure+0x10e>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
    3c2a:	f013 0f04 	tst.w	r3, #4
    3c2e:	d045      	beq.n	3cbc <configure+0x118>
			return NRF_SPIM_MODE_3;
    3c30:	2303      	movs	r3, #3
	config.mode      = get_nrf_spim_mode(spi_cfg->operation);
    3c32:	f88d 300c 	strb.w	r3, [sp, #12]
	config.bit_order = get_nrf_spim_bit_order(spi_cfg->operation);
    3c36:	88a3      	ldrh	r3, [r4, #4]
	if (operation & SPI_TRANSFER_LSB) {
    3c38:	f013 0f10 	tst.w	r3, #16
    3c3c:	d042      	beq.n	3cc4 <configure+0x120>
		return NRF_SPIM_BIT_ORDER_LSB_FIRST;
    3c3e:	2301      	movs	r3, #1
	config.bit_order = get_nrf_spim_bit_order(spi_cfg->operation);
    3c40:	f88d 300d 	strb.w	r3, [sp, #13]

	if (dev_data->initialized) {
    3c44:	2f00      	cmp	r7, #0
    3c46:	d13f      	bne.n	3cc8 <configure+0x124>
		nrfx_spim_uninit(&dev_config->spim);
		dev_data->initialized = false;
	}

	result = nrfx_spim_init(&dev_config->spim, &config,
    3c48:	462b      	mov	r3, r5
    3c4a:	4a2a      	ldr	r2, [pc, #168]	; (3cf4 <configure+0x150>)
    3c4c:	4669      	mov	r1, sp
    3c4e:	4630      	mov	r0, r6
    3c50:	f001 fb40 	bl	52d4 <nrfx_spim_init>
				event_handler, dev_data);
	if (result != NRFX_SUCCESS) {
    3c54:	4b28      	ldr	r3, [pc, #160]	; (3cf8 <configure+0x154>)
    3c56:	4298      	cmp	r0, r3
    3c58:	d13d      	bne.n	3cd6 <configure+0x132>
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
		return -EIO;
	}

	dev_data->initialized = true;
    3c5a:	2301      	movs	r3, #1
    3c5c:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d

	ctx->config = spi_cfg;
    3c60:	602c      	str	r4, [r5, #0]

	return 0;
    3c62:	2000      	movs	r0, #0
}
    3c64:	b006      	add	sp, #24
    3c66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LOG_ERR("Half-duplex not supported");
    3c6a:	2145      	movs	r1, #69	; 0x45
    3c6c:	4823      	ldr	r0, [pc, #140]	; (3cfc <configure+0x158>)
    3c6e:	f006 fb65 	bl	a33c <z_log_minimal_printk>
		return -ENOTSUP;
    3c72:	f06f 0085 	mvn.w	r0, #133	; 0x85
    3c76:	e7f5      	b.n	3c64 <configure+0xc0>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
    3c78:	6802      	ldr	r2, [r0, #0]
    3c7a:	2145      	movs	r1, #69	; 0x45
    3c7c:	4820      	ldr	r0, [pc, #128]	; (3d00 <configure+0x15c>)
    3c7e:	f006 fb5d 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    3c82:	f06f 0015 	mvn.w	r0, #21
    3c86:	e7ed      	b.n	3c64 <configure+0xc0>
		LOG_ERR("Loopback mode is not supported");
    3c88:	2145      	movs	r1, #69	; 0x45
    3c8a:	481e      	ldr	r0, [pc, #120]	; (3d04 <configure+0x160>)
    3c8c:	f006 fb56 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    3c90:	f06f 0015 	mvn.w	r0, #21
    3c94:	e7e6      	b.n	3c64 <configure+0xc0>
		LOG_ERR("Word sizes other than 8 bits are not supported");
    3c96:	2145      	movs	r1, #69	; 0x45
    3c98:	481b      	ldr	r0, [pc, #108]	; (3d08 <configure+0x164>)
    3c9a:	f006 fb4f 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    3c9e:	f06f 0015 	mvn.w	r0, #21
    3ca2:	e7df      	b.n	3c64 <configure+0xc0>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
    3ca4:	2145      	movs	r1, #69	; 0x45
    3ca6:	4819      	ldr	r0, [pc, #100]	; (3d0c <configure+0x168>)
    3ca8:	f006 fb48 	bl	a33c <z_log_minimal_printk>
		return -EINVAL;
    3cac:	f06f 0015 	mvn.w	r0, #21
    3cb0:	e7d8      	b.n	3c64 <configure+0xc0>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
    3cb2:	f013 0f04 	tst.w	r3, #4
    3cb6:	d003      	beq.n	3cc0 <configure+0x11c>
			return NRF_SPIM_MODE_1;
    3cb8:	2301      	movs	r3, #1
    3cba:	e7ba      	b.n	3c32 <configure+0x8e>
			return NRF_SPIM_MODE_2;
    3cbc:	2302      	movs	r3, #2
    3cbe:	e7b8      	b.n	3c32 <configure+0x8e>
			return NRF_SPIM_MODE_0;
    3cc0:	2300      	movs	r3, #0
    3cc2:	e7b6      	b.n	3c32 <configure+0x8e>
		return NRF_SPIM_BIT_ORDER_MSB_FIRST;
    3cc4:	2300      	movs	r3, #0
    3cc6:	e7bb      	b.n	3c40 <configure+0x9c>
		nrfx_spim_uninit(&dev_config->spim);
    3cc8:	4630      	mov	r0, r6
    3cca:	f001 fba1 	bl	5410 <nrfx_spim_uninit>
		dev_data->initialized = false;
    3cce:	2300      	movs	r3, #0
    3cd0:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    3cd4:	e7b8      	b.n	3c48 <configure+0xa4>
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
    3cd6:	4602      	mov	r2, r0
    3cd8:	2145      	movs	r1, #69	; 0x45
    3cda:	480d      	ldr	r0, [pc, #52]	; (3d10 <configure+0x16c>)
    3cdc:	f006 fb2e 	bl	a33c <z_log_minimal_printk>
		return -EIO;
    3ce0:	f06f 0004 	mvn.w	r0, #4
    3ce4:	e7be      	b.n	3c64 <configure+0xc0>
		return 0;
    3ce6:	2000      	movs	r0, #0
    3ce8:	e7bc      	b.n	3c64 <configure+0xc0>
    3cea:	bf00      	nop
    3cec:	0001e847 	.word	0x0001e847
    3cf0:	00f42400 	.word	0x00f42400
    3cf4:	00003db5 	.word	0x00003db5
    3cf8:	0bad0000 	.word	0x0bad0000
    3cfc:	0000f2e0 	.word	0x0000f2e0
    3d00:	0000f300 	.word	0x0000f300
    3d04:	0000f328 	.word	0x0000f328
    3d08:	0000f34c 	.word	0x0000f34c
    3d0c:	0000f380 	.word	0x0000f380
    3d10:	0000f3b8 	.word	0x0000f3b8

00003d14 <transfer_next_chunk>:
	spi_context_complete(ctx, dev, error);
	dev_data->busy = false;
}

static void transfer_next_chunk(const struct device *dev)
{
    3d14:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d16:	b085      	sub	sp, #20
    3d18:	4605      	mov	r5, r0
	struct spi_nrfx_data *dev_data = dev->data;
    3d1a:	6904      	ldr	r4, [r0, #16]
	const struct spi_nrfx_config *dev_config = dev->config;
    3d1c:	6847      	ldr	r7, [r0, #4]
	if (!ctx->tx_len) {
    3d1e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    3d20:	2b00      	cmp	r3, #0
    3d22:	d038      	beq.n	3d96 <transfer_next_chunk+0x82>
	} else if (!ctx->rx_len) {
    3d24:	6d26      	ldr	r6, [r4, #80]	; 0x50
    3d26:	2e00      	cmp	r6, #0
    3d28:	d037      	beq.n	3d9a <transfer_next_chunk+0x86>
	return MIN(ctx->tx_len, ctx->rx_len);
    3d2a:	429e      	cmp	r6, r3
    3d2c:	bf28      	it	cs
    3d2e:	461e      	movcs	r6, r3
	struct spi_context *ctx = &dev_data->ctx;
	int error = 0;

	size_t chunk_len = spi_context_max_continuous_chunk(ctx);

	if (chunk_len > 0) {
    3d30:	2e00      	cmp	r6, #0
    3d32:	d03a      	beq.n	3daa <transfer_next_chunk+0x96>
		nrfx_spim_xfer_desc_t xfer;
		nrfx_err_t result;
		const uint8_t *tx_buf = ctx->tx_buf;
    3d34:	6c61      	ldr	r1, [r4, #68]	; 0x44
	return !!(ctx->tx_buf && ctx->tx_len);
    3d36:	b169      	cbz	r1, 3d54 <transfer_next_chunk+0x40>
    3d38:	b163      	cbz	r3, 3d54 <transfer_next_chunk+0x40>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    3d3a:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
#if (CONFIG_SPI_NRFX_RAM_BUFFER_SIZE > 0)
		if (spi_context_tx_buf_on(ctx) && !nrfx_is_in_ram(tx_buf)) {
    3d3e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    3d42:	d007      	beq.n	3d54 <transfer_next_chunk+0x40>
			if (chunk_len > CONFIG_SPI_NRFX_RAM_BUFFER_SIZE) {
    3d44:	2e08      	cmp	r6, #8
    3d46:	d900      	bls.n	3d4a <transfer_next_chunk+0x36>
				chunk_len = CONFIG_SPI_NRFX_RAM_BUFFER_SIZE;
    3d48:	2608      	movs	r6, #8
			}

			memcpy(dev_data->buffer, tx_buf, chunk_len);
    3d4a:	4632      	mov	r2, r6
    3d4c:	6e20      	ldr	r0, [r4, #96]	; 0x60
    3d4e:	f006 fcb5 	bl	a6bc <memcpy>
			tx_buf = dev_data->buffer;
    3d52:	6e21      	ldr	r1, [r4, #96]	; 0x60
		}
#endif
		if (chunk_len > dev_config->max_chunk_len) {
    3d54:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    3d56:	42b3      	cmp	r3, r6
    3d58:	d300      	bcc.n	3d5c <transfer_next_chunk+0x48>
    3d5a:	4633      	mov	r3, r6
			chunk_len = dev_config->max_chunk_len;
		}

		dev_data->chunk_len = chunk_len;
    3d5c:	65a3      	str	r3, [r4, #88]	; 0x58

		xfer.p_tx_buffer = tx_buf;
    3d5e:	9100      	str	r1, [sp, #0]
    3d60:	6c62      	ldr	r2, [r4, #68]	; 0x44
    3d62:	b1e2      	cbz	r2, 3d9e <transfer_next_chunk+0x8a>
    3d64:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    3d66:	b9e2      	cbnz	r2, 3da2 <transfer_next_chunk+0x8e>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    3d68:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    3d6a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    3d6c:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    3d6e:	b1d2      	cbz	r2, 3da6 <transfer_next_chunk+0x92>
    3d70:	6d22      	ldr	r2, [r4, #80]	; 0x50
    3d72:	b902      	cbnz	r2, 3d76 <transfer_next_chunk+0x62>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    3d74:	4613      	mov	r3, r2
    3d76:	9303      	str	r3, [sp, #12]
				error = -EIO;
			}
		}
#endif
		if (error == 0) {
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    3d78:	2200      	movs	r2, #0
    3d7a:	4669      	mov	r1, sp
    3d7c:	4638      	mov	r0, r7
    3d7e:	f001 fb8f 	bl	54a0 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
    3d82:	4b0b      	ldr	r3, [pc, #44]	; (3db0 <transfer_next_chunk+0x9c>)
    3d84:	4298      	cmp	r0, r3
    3d86:	d004      	beq.n	3d92 <transfer_next_chunk+0x7e>
				return;
			}
			error = -EIO;
    3d88:	f06f 0104 	mvn.w	r1, #4
			anomaly_58_workaround_clear(dev_data);
#endif
		}
	}

	finish_transaction(dev, error);
    3d8c:	4628      	mov	r0, r5
    3d8e:	f007 fd0d 	bl	b7ac <finish_transaction>
}
    3d92:	b005      	add	sp, #20
    3d94:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ctx->rx_len;
    3d96:	6d26      	ldr	r6, [r4, #80]	; 0x50
    3d98:	e7ca      	b.n	3d30 <transfer_next_chunk+0x1c>
		return ctx->tx_len;
    3d9a:	461e      	mov	r6, r3
    3d9c:	e7c8      	b.n	3d30 <transfer_next_chunk+0x1c>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    3d9e:	2200      	movs	r2, #0
    3da0:	e7e2      	b.n	3d68 <transfer_next_chunk+0x54>
    3da2:	461a      	mov	r2, r3
    3da4:	e7e0      	b.n	3d68 <transfer_next_chunk+0x54>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    3da6:	2300      	movs	r3, #0
    3da8:	e7e5      	b.n	3d76 <transfer_next_chunk+0x62>
	int error = 0;
    3daa:	2100      	movs	r1, #0
    3dac:	e7ee      	b.n	3d8c <transfer_next_chunk+0x78>
    3dae:	bf00      	nop
    3db0:	0bad0000 	.word	0x0bad0000

00003db4 <event_handler>:

static void event_handler(const nrfx_spim_evt_t *p_event, void *p_context)
{
	struct spi_nrfx_data *dev_data = p_context;

	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
    3db4:	7803      	ldrb	r3, [r0, #0]
    3db6:	2b00      	cmp	r3, #0
    3db8:	d14f      	bne.n	3e5a <event_handler+0xa6>
{
    3dba:	b510      	push	{r4, lr}
    3dbc:	460c      	mov	r4, r1
		/* Chunk length is set to 0 when a transaction is aborted
		 * due to a timeout.
		 */
		if (dev_data->chunk_len == 0) {
    3dbe:	6d8a      	ldr	r2, [r1, #88]	; 0x58
    3dc0:	b1d2      	cbz	r2, 3df8 <event_handler+0x44>
	if (!ctx->tx_len) {
    3dc2:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    3dc4:	b143      	cbz	r3, 3dd8 <event_handler+0x24>
	if (len > ctx->tx_len) {
    3dc6:	429a      	cmp	r2, r3
    3dc8:	d81c      	bhi.n	3e04 <event_handler+0x50>
	ctx->tx_len -= len;
    3dca:	1a9b      	subs	r3, r3, r2
    3dcc:	648b      	str	r3, [r1, #72]	; 0x48
	if (!ctx->tx_len) {
    3dce:	b1f3      	cbz	r3, 3e0e <event_handler+0x5a>
	} else if (ctx->tx_buf) {
    3dd0:	6c4b      	ldr	r3, [r1, #68]	; 0x44
    3dd2:	b10b      	cbz	r3, 3dd8 <event_handler+0x24>
		ctx->tx_buf += dfs * len;
    3dd4:	4413      	add	r3, r2
    3dd6:	644b      	str	r3, [r1, #68]	; 0x44

#ifdef CONFIG_SOC_NRF52832_ALLOW_SPIM_DESPITE_PAN_58
		anomaly_58_workaround_clear(dev_data);
#endif
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
    3dd8:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (!ctx->rx_len) {
    3dda:	6d23      	ldr	r3, [r4, #80]	; 0x50
    3ddc:	b143      	cbz	r3, 3df0 <event_handler+0x3c>
	if (len > ctx->rx_len) {
    3dde:	429a      	cmp	r2, r3
    3de0:	d825      	bhi.n	3e2e <event_handler+0x7a>
	ctx->rx_len -= len;
    3de2:	1a9b      	subs	r3, r3, r2
    3de4:	6523      	str	r3, [r4, #80]	; 0x50
	if (!ctx->rx_len) {
    3de6:	b33b      	cbz	r3, 3e38 <event_handler+0x84>
	} else if (ctx->rx_buf) {
    3de8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    3dea:	b10b      	cbz	r3, 3df0 <event_handler+0x3c>
		ctx->rx_buf += dfs * len;
    3dec:	4413      	add	r3, r2
    3dee:	64e3      	str	r3, [r4, #76]	; 0x4c

		transfer_next_chunk(dev_data->dev);
    3df0:	6d60      	ldr	r0, [r4, #84]	; 0x54
    3df2:	f7ff ff8f 	bl	3d14 <transfer_next_chunk>
	}
}
    3df6:	bd10      	pop	{r4, pc}
			finish_transaction(dev_data->dev, -ETIMEDOUT);
    3df8:	f06f 0173 	mvn.w	r1, #115	; 0x73
    3dfc:	6d60      	ldr	r0, [r4, #84]	; 0x54
    3dfe:	f007 fcd5 	bl	b7ac <finish_transaction>
			return;
    3e02:	e7f8      	b.n	3df6 <event_handler+0x42>
		LOG_ERR("Update exceeds current buffer");
    3e04:	2145      	movs	r1, #69	; 0x45
    3e06:	4815      	ldr	r0, [pc, #84]	; (3e5c <event_handler+0xa8>)
    3e08:	f006 fa98 	bl	a33c <z_log_minimal_printk>
		return;
    3e0c:	e7e4      	b.n	3dd8 <event_handler+0x24>
		++ctx->current_tx;
    3e0e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    3e10:	3308      	adds	r3, #8
    3e12:	634b      	str	r3, [r1, #52]	; 0x34
		--ctx->tx_count;
    3e14:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    3e16:	3b01      	subs	r3, #1
    3e18:	638b      	str	r3, [r1, #56]	; 0x38
			spi_context_get_next_buf(&ctx->current_tx,
    3e1a:	2301      	movs	r3, #1
    3e1c:	f101 0248 	add.w	r2, r1, #72	; 0x48
    3e20:	3138      	adds	r1, #56	; 0x38
    3e22:	f104 0034 	add.w	r0, r4, #52	; 0x34
    3e26:	f007 fc36 	bl	b696 <spi_context_get_next_buf>
		ctx->tx_buf = (const uint8_t *)
    3e2a:	6460      	str	r0, [r4, #68]	; 0x44
    3e2c:	e7d4      	b.n	3dd8 <event_handler+0x24>
		LOG_ERR("Update exceeds current buffer");
    3e2e:	2145      	movs	r1, #69	; 0x45
    3e30:	480a      	ldr	r0, [pc, #40]	; (3e5c <event_handler+0xa8>)
    3e32:	f006 fa83 	bl	a33c <z_log_minimal_printk>
		return;
    3e36:	e7db      	b.n	3df0 <event_handler+0x3c>
		++ctx->current_rx;
    3e38:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    3e3a:	3308      	adds	r3, #8
    3e3c:	63e3      	str	r3, [r4, #60]	; 0x3c
		--ctx->rx_count;
    3e3e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3e40:	3b01      	subs	r3, #1
    3e42:	6423      	str	r3, [r4, #64]	; 0x40
			spi_context_get_next_buf(&ctx->current_rx,
    3e44:	2301      	movs	r3, #1
    3e46:	f104 0250 	add.w	r2, r4, #80	; 0x50
    3e4a:	f104 0140 	add.w	r1, r4, #64	; 0x40
    3e4e:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    3e52:	f007 fc20 	bl	b696 <spi_context_get_next_buf>
		ctx->rx_buf = (uint8_t *)
    3e56:	64e0      	str	r0, [r4, #76]	; 0x4c
    3e58:	e7ca      	b.n	3df0 <event_handler+0x3c>
    3e5a:	4770      	bx	lr
    3e5c:	0000f3e4 	.word	0x0000f3e4

00003e60 <spi_context_cs_configure_all>:
{
    3e60:	b538      	push	{r3, r4, r5, lr}
    3e62:	4605      	mov	r5, r0
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
    3e64:	6884      	ldr	r4, [r0, #8]
    3e66:	e00a      	b.n	3e7e <spi_context_cs_configure_all+0x1e>
			LOG_ERR("CS GPIO port %s pin %d is not ready",
    3e68:	6822      	ldr	r2, [r4, #0]
    3e6a:	7923      	ldrb	r3, [r4, #4]
    3e6c:	6812      	ldr	r2, [r2, #0]
    3e6e:	2145      	movs	r1, #69	; 0x45
    3e70:	480d      	ldr	r0, [pc, #52]	; (3ea8 <spi_context_cs_configure_all+0x48>)
    3e72:	f006 fa63 	bl	a33c <z_log_minimal_printk>
			return -ENODEV;
    3e76:	f06f 0012 	mvn.w	r0, #18
    3e7a:	e014      	b.n	3ea6 <spi_context_cs_configure_all+0x46>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
    3e7c:	3408      	adds	r4, #8
    3e7e:	68ab      	ldr	r3, [r5, #8]
    3e80:	68ea      	ldr	r2, [r5, #12]
    3e82:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    3e86:	429c      	cmp	r4, r3
    3e88:	d20c      	bcs.n	3ea4 <spi_context_cs_configure_all+0x44>
		if (!device_is_ready(cs_gpio->port)) {
    3e8a:	6820      	ldr	r0, [r4, #0]
    3e8c:	f009 fbe9 	bl	d662 <z_device_is_ready>
    3e90:	2800      	cmp	r0, #0
    3e92:	d0e9      	beq.n	3e68 <spi_context_cs_configure_all+0x8>
		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
    3e94:	f44f 11b0 	mov.w	r1, #1441792	; 0x160000
    3e98:	4620      	mov	r0, r4
    3e9a:	f007 fbd4 	bl	b646 <gpio_pin_configure_dt>
		if (ret < 0) {
    3e9e:	2800      	cmp	r0, #0
    3ea0:	daec      	bge.n	3e7c <spi_context_cs_configure_all+0x1c>
    3ea2:	e000      	b.n	3ea6 <spi_context_cs_configure_all+0x46>
	return 0;
    3ea4:	2000      	movs	r0, #0
}
    3ea6:	bd38      	pop	{r3, r4, r5, pc}
    3ea8:	0000f408 	.word	0x0000f408

00003eac <set_comparator>:
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(int32_t chan, uint32_t cyc)
{
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    3eac:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
    3eb0:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    3eb4:	4b01      	ldr	r3, [pc, #4]	; (3ebc <set_comparator+0x10>)
    3eb6:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
}
    3eba:	4770      	bx	lr
    3ebc:	50015000 	.word	0x50015000

00003ec0 <event_enable>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
}

static void event_enable(int32_t chan)
{
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    3ec0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    3ec4:	4083      	lsls	r3, r0
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    3ec6:	4a02      	ldr	r2, [pc, #8]	; (3ed0 <event_enable+0x10>)
    3ec8:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
}
    3ecc:	4770      	bx	lr
    3ece:	bf00      	nop
    3ed0:	50015000 	.word	0x50015000

00003ed4 <event_disable>:

static void event_disable(int32_t chan)
{
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    3ed4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    3ed8:	4083      	lsls	r3, r0
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    3eda:	4a02      	ldr	r2, [pc, #8]	; (3ee4 <event_disable+0x10>)
    3edc:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
}
    3ee0:	4770      	bx	lr
    3ee2:	bf00      	nop
    3ee4:	50015000 	.word	0x50015000

00003ee8 <counter>:
     return p_reg->COUNTER;
    3ee8:	4b01      	ldr	r3, [pc, #4]	; (3ef0 <counter+0x8>)
    3eea:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

static uint32_t counter(void)
{
	return nrf_rtc_counter_get(RTC);
}
    3eee:	4770      	bx	lr
    3ef0:	50015000 	.word	0x50015000

00003ef4 <set_alarm>:
 * @param[in] chan A channel for which a new CC value is to be set.
 *
 * @param[in] req_cc Requested CC register value to be set.
 */
static void set_alarm(int32_t chan, uint32_t req_cc)
{
    3ef4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3ef8:	4606      	mov	r6, r0
    3efa:	4688      	mov	r8, r1
	 * (however, even if such spurious event was generated, it would be
	 * properly filtered out in process_channel(), where the target time
	 * is checked).
	 * Clear also the event as it may already be generated at this point.
	 */
	event_disable(chan);
    3efc:	f7ff ffea 	bl	3ed4 <event_disable>
	event_clear(chan);
    3f00:	4630      	mov	r0, r6
    3f02:	f007 fd18 	bl	b936 <event_clear>
	uint32_t cc_val = req_cc;
    3f06:	4645      	mov	r5, r8
	uint32_t cc_inc = MIN_CYCLES_FROM_NOW;
    3f08:	2703      	movs	r7, #3
    3f0a:	e001      	b.n	3f10 <set_alarm+0x1c>
				} else {
					break;
				}
			}

			cc_val = now + cc_inc;
    3f0c:	193d      	adds	r5, r7, r4
			cc_inc++;
    3f0e:	3701      	adds	r7, #1
		set_comparator(chan, cc_val);
    3f10:	4629      	mov	r1, r5
    3f12:	4630      	mov	r0, r6
    3f14:	f7ff ffca 	bl	3eac <set_comparator>
		event_enable(chan);
    3f18:	4630      	mov	r0, r6
    3f1a:	f7ff ffd1 	bl	3ec0 <event_enable>
		now = counter();
    3f1e:	f7ff ffe3 	bl	3ee8 <counter>
    3f22:	4604      	mov	r4, r0
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
    3f24:	1cc1      	adds	r1, r0, #3
    3f26:	4628      	mov	r0, r5
    3f28:	f007 fcf4 	bl	b914 <counter_sub>
    3f2c:	4b0b      	ldr	r3, [pc, #44]	; (3f5c <set_alarm+0x68>)
    3f2e:	4298      	cmp	r0, r3
    3f30:	d911      	bls.n	3f56 <set_alarm+0x62>
			if (event_check(chan)) {
    3f32:	4630      	mov	r0, r6
    3f34:	f007 fcf2 	bl	b91c <event_check>
    3f38:	2800      	cmp	r0, #0
    3f3a:	d0e7      	beq.n	3f0c <set_alarm+0x18>
				now = counter();
    3f3c:	f7ff ffd4 	bl	3ee8 <counter>
    3f40:	4604      	mov	r4, r0
				if (counter_sub(now, req_cc) > COUNTER_HALF_SPAN) {
    3f42:	4641      	mov	r1, r8
    3f44:	f007 fce6 	bl	b914 <counter_sub>
    3f48:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    3f4c:	d903      	bls.n	3f56 <set_alarm+0x62>
					event_clear(chan);
    3f4e:	4630      	mov	r0, r6
    3f50:	f007 fcf1 	bl	b936 <event_clear>
    3f54:	e7da      	b.n	3f0c <set_alarm+0x18>
		} else {
			break;
		}
	}
}
    3f56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3f5a:	bf00      	nop
    3f5c:	007ffffd 	.word	0x007ffffd

00003f60 <int_event_disable_rtc>:
    p_reg->INTENCLR = mask;
    3f60:	4b03      	ldr	r3, [pc, #12]	; (3f70 <int_event_disable_rtc+0x10>)
    3f62:	4a04      	ldr	r2, [pc, #16]	; (3f74 <int_event_disable_rtc+0x14>)
    3f64:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->EVTENCLR = mask;
    3f68:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	/* Reset interrupt enabling to expected reset values */
	nrf_rtc_int_disable(RTC, mask);

	/* Reset event routing enabling to expected reset values */
	nrf_rtc_event_disable(RTC, mask);
}
    3f6c:	4770      	bx	lr
    3f6e:	bf00      	nop
    3f70:	50015000 	.word	0x50015000
    3f74:	000f0003 	.word	0x000f0003

00003f78 <compare_int_lock>:
{
    3f78:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
    3f7a:	2301      	movs	r3, #1
    3f7c:	4083      	lsls	r3, r0
    3f7e:	ea6f 0c03 	mvn.w	ip, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    3f82:	4a0c      	ldr	r2, [pc, #48]	; (3fb4 <compare_int_lock+0x3c>)
    3f84:	e8d2 1fef 	ldaex	r1, [r2]
    3f88:	ea01 0e0c 	and.w	lr, r1, ip
    3f8c:	e8c2 efe4 	stlex	r4, lr, [r2]
    3f90:	2c00      	cmp	r4, #0
    3f92:	d1f7      	bne.n	3f84 <compare_int_lock+0xc>
	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    3f94:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    3f98:	4082      	lsls	r2, r0
    p_reg->INTENCLR = mask;
    3f9a:	4807      	ldr	r0, [pc, #28]	; (3fb8 <compare_int_lock+0x40>)
    3f9c:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
    3fa0:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3fa4:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
    3fa8:	420b      	tst	r3, r1
}
    3faa:	bf14      	ite	ne
    3fac:	2001      	movne	r0, #1
    3fae:	2000      	moveq	r0, #0
    3fb0:	bd10      	pop	{r4, pc}
    3fb2:	bf00      	nop
    3fb4:	20000ef8 	.word	0x20000ef8
    3fb8:	50015000 	.word	0x50015000

00003fbc <channel_processing_check_and_clear>:
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
    3fbc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    3fc0:	4083      	lsls	r3, r0
    return p_reg->INTENSET & mask;
    3fc2:	4a12      	ldr	r2, [pc, #72]	; (400c <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0xc>)
    3fc4:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
    3fc8:	4213      	tst	r3, r2
    3fca:	d101      	bne.n	3fd0 <channel_processing_check_and_clear+0x14>
	return false;
    3fcc:	2000      	movs	r0, #0
}
    3fce:	4770      	bx	lr
{
    3fd0:	b510      	push	{r4, lr}
    3fd2:	4604      	mov	r4, r0
		if ((atomic_and(&force_isr_mask, ~BIT(chan)) & BIT(chan)) ||
    3fd4:	2301      	movs	r3, #1
    3fd6:	4083      	lsls	r3, r0
    3fd8:	43db      	mvns	r3, r3
    3fda:	490d      	ldr	r1, [pc, #52]	; (4010 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x10>)
    3fdc:	e8d1 2fef 	ldaex	r2, [r1]
    3fe0:	ea02 0003 	and.w	r0, r2, r3
    3fe4:	e8c1 0fec 	stlex	ip, r0, [r1]
    3fe8:	f1bc 0f00 	cmp.w	ip, #0
    3fec:	d1f6      	bne.n	3fdc <channel_processing_check_and_clear+0x20>
    3fee:	fa22 f304 	lsr.w	r3, r2, r4
    3ff2:	f013 0f01 	tst.w	r3, #1
    3ff6:	d103      	bne.n	4000 <CONFIG_COVERAGE_GCOV_HEAP_SIZE>
		    event_check(chan)) {
    3ff8:	4620      	mov	r0, r4
    3ffa:	f007 fc8f 	bl	b91c <event_check>
		if ((atomic_and(&force_isr_mask, ~BIT(chan)) & BIT(chan)) ||
    3ffe:	b118      	cbz	r0, 4008 <CONFIG_COVERAGE_GCOV_HEAP_SIZE+0x8>
			event_clear(chan);
    4000:	4620      	mov	r0, r4
    4002:	f007 fc98 	bl	b936 <event_clear>
			return true;
    4006:	2001      	movs	r0, #1
}
    4008:	bd10      	pop	{r4, pc}
    400a:	bf00      	nop
    400c:	50015000 	.word	0x50015000
    4010:	20000ef4 	.word	0x20000ef4

00004014 <compare_int_unlock>:
	if (key) {
    4014:	b901      	cbnz	r1, 4018 <compare_int_unlock+0x4>
}
    4016:	4770      	bx	lr
		atomic_or(&int_mask, BIT(chan));
    4018:	2301      	movs	r3, #1
    401a:	4083      	lsls	r3, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    401c:	4a0d      	ldr	r2, [pc, #52]	; (4054 <compare_int_unlock+0x40>)
    401e:	e8d2 cfef 	ldaex	ip, [r2]
    4022:	ea4c 0c03 	orr.w	ip, ip, r3
    4026:	e8c2 cfe1 	stlex	r1, ip, [r2]
    402a:	2900      	cmp	r1, #0
    402c:	d1f7      	bne.n	401e <compare_int_unlock+0xa>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    402e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    4032:	4083      	lsls	r3, r0
    p_reg->INTENSET = mask;
    4034:	4a08      	ldr	r2, [pc, #32]	; (4058 <compare_int_unlock+0x44>)
    4036:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    403a:	4b08      	ldr	r3, [pc, #32]	; (405c <compare_int_unlock+0x48>)
    403c:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
    4040:	40c3      	lsrs	r3, r0
    4042:	f013 0f01 	tst.w	r3, #1
    4046:	d0e6      	beq.n	4016 <compare_int_unlock+0x2>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4048:	4b05      	ldr	r3, [pc, #20]	; (4060 <compare_int_unlock+0x4c>)
    404a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    404e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
    4052:	e7e0      	b.n	4016 <compare_int_unlock+0x2>
    4054:	20000ef8 	.word	0x20000ef8
    4058:	50015000 	.word	0x50015000
    405c:	20000ef4 	.word	0x20000ef4
    4060:	e000e100 	.word	0xe000e100

00004064 <sys_clock_timeout_handler>:
{
    4064:	b538      	push	{r3, r4, r5, lr}
    4066:	4614      	mov	r4, r2
	uint32_t cc_value = absolute_time_to_cc(expire_time);
    4068:	4610      	mov	r0, r2
    406a:	4619      	mov	r1, r3
    406c:	f007 fc6f 	bl	b94e <absolute_time_to_cc>
    4070:	4602      	mov	r2, r0
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
    4072:	490d      	ldr	r1, [pc, #52]	; (40a8 <sys_clock_timeout_handler+0x44>)
    4074:	680b      	ldr	r3, [r1, #0]
    4076:	1ae0      	subs	r0, r4, r3
	last_count += dticks * CYC_PER_TICK;
    4078:	181b      	adds	r3, r3, r0
    407a:	684c      	ldr	r4, [r1, #4]
    407c:	f144 0400 	adc.w	r4, r4, #0
    4080:	600b      	str	r3, [r1, #0]
    4082:	604c      	str	r4, [r1, #4]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
    4084:	f5a2 1300 	sub.w	r3, r2, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
    4088:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
    408c:	d209      	bcs.n	40a2 <sys_clock_timeout_handler+0x3e>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
    408e:	4b07      	ldr	r3, [pc, #28]	; (40ac <sys_clock_timeout_handler+0x48>)
    4090:	681b      	ldr	r3, [r3, #0]
    4092:	0a19      	lsrs	r1, r3, #8
    4094:	061b      	lsls	r3, r3, #24
    4096:	18d4      	adds	r4, r2, r3
    4098:	f141 0500 	adc.w	r5, r1, #0
    409c:	4b04      	ldr	r3, [pc, #16]	; (40b0 <sys_clock_timeout_handler+0x4c>)
    409e:	e9c3 4500 	strd	r4, r5, [r3]
	sys_clock_announce(dticks);
    40a2:	f004 ff75 	bl	8f90 <sys_clock_announce>
}
    40a6:	bd38      	pop	{r3, r4, r5, pc}
    40a8:	20000370 	.word	0x20000370
    40ac:	20000efc 	.word	0x20000efc
    40b0:	20000378 	.word	0x20000378

000040b4 <z_nrf_rtc_timer_read>:
{
    40b4:	b538      	push	{r3, r4, r5, lr}
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
    40b6:	4b0d      	ldr	r3, [pc, #52]	; (40ec <z_nrf_rtc_timer_read+0x38>)
    40b8:	681c      	ldr	r4, [r3, #0]
    40ba:	0a25      	lsrs	r5, r4, #8
    40bc:	0624      	lsls	r4, r4, #24
  __ASM volatile ("dmb 0xF":::"memory");
    40be:	f3bf 8f5f 	dmb	sy
	uint32_t cntr = counter();
    40c2:	f7ff ff11 	bl	3ee8 <counter>
    40c6:	4603      	mov	r3, r0
	val += cntr;
    40c8:	1900      	adds	r0, r0, r4
    40ca:	f145 0100 	adc.w	r1, r5, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
    40ce:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    40d2:	d20a      	bcs.n	40ea <z_nrf_rtc_timer_read+0x36>
		if (val < anchor) {
    40d4:	4b06      	ldr	r3, [pc, #24]	; (40f0 <z_nrf_rtc_timer_read+0x3c>)
    40d6:	e9d3 2300 	ldrd	r2, r3, [r3]
    40da:	4290      	cmp	r0, r2
    40dc:	eb71 0303 	sbcs.w	r3, r1, r3
    40e0:	d203      	bcs.n	40ea <z_nrf_rtc_timer_read+0x36>
			val += COUNTER_SPAN;
    40e2:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
    40e6:	f141 0100 	adc.w	r1, r1, #0
}
    40ea:	bd38      	pop	{r3, r4, r5, pc}
    40ec:	20000efc 	.word	0x20000efc
    40f0:	20000378 	.word	0x20000378

000040f4 <compare_set_nolocks>:
{
    40f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    40f6:	4606      	mov	r6, r0
    40f8:	4614      	mov	r4, r2
    40fa:	461d      	mov	r5, r3
	uint32_t cc_value = absolute_time_to_cc(target_time);
    40fc:	4610      	mov	r0, r2
    40fe:	4619      	mov	r1, r3
    4100:	f007 fc25 	bl	b94e <absolute_time_to_cc>
    4104:	4607      	mov	r7, r0
	uint64_t curr_time = z_nrf_rtc_timer_read();
    4106:	f7ff ffd5 	bl	40b4 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
    410a:	42a0      	cmp	r0, r4
    410c:	eb71 0305 	sbcs.w	r3, r1, r5
    4110:	d215      	bcs.n	413e <compare_set_nolocks+0x4a>
		if (target_time - curr_time > COUNTER_HALF_SPAN) {
    4112:	1a20      	subs	r0, r4, r0
    4114:	eb65 0101 	sbc.w	r1, r5, r1
    4118:	4b15      	ldr	r3, [pc, #84]	; (4170 <compare_set_nolocks+0x7c>)
    411a:	4298      	cmp	r0, r3
    411c:	f171 0100 	sbcs.w	r1, r1, #0
    4120:	d223      	bcs.n	416a <compare_set_nolocks+0x76>
		if (target_time != cc_data[chan].target_time) {
    4122:	4b14      	ldr	r3, [pc, #80]	; (4174 <compare_set_nolocks+0x80>)
    4124:	eb03 1306 	add.w	r3, r3, r6, lsl #4
    4128:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
    412c:	42ab      	cmp	r3, r5
    412e:	bf08      	it	eq
    4130:	42a2      	cmpeq	r2, r4
    4132:	d00e      	beq.n	4152 <compare_set_nolocks+0x5e>
			set_alarm(chan, cc_value);
    4134:	4639      	mov	r1, r7
    4136:	4630      	mov	r0, r6
    4138:	f7ff fedc 	bl	3ef4 <set_alarm>
    413c:	e009      	b.n	4152 <compare_set_nolocks+0x5e>
		atomic_or(&force_isr_mask, BIT(chan));
    413e:	2301      	movs	r3, #1
    4140:	40b3      	lsls	r3, r6
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4142:	4a0d      	ldr	r2, [pc, #52]	; (4178 <compare_set_nolocks+0x84>)
    4144:	e8d2 0fef 	ldaex	r0, [r2]
    4148:	4318      	orrs	r0, r3
    414a:	e8c2 0fe1 	stlex	r1, r0, [r2]
    414e:	2900      	cmp	r1, #0
    4150:	d1f8      	bne.n	4144 <compare_set_nolocks+0x50>
	cc_data[chan].target_time = target_time;
    4152:	4b08      	ldr	r3, [pc, #32]	; (4174 <compare_set_nolocks+0x80>)
    4154:	0132      	lsls	r2, r6, #4
    4156:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    415a:	e9c6 4502 	strd	r4, r5, [r6, #8]
	cc_data[chan].callback = handler;
    415e:	9906      	ldr	r1, [sp, #24]
    4160:	5099      	str	r1, [r3, r2]
	cc_data[chan].user_context = user_data;
    4162:	9b07      	ldr	r3, [sp, #28]
    4164:	6073      	str	r3, [r6, #4]
	return ret;
    4166:	2000      	movs	r0, #0
}
    4168:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return -EINVAL;
    416a:	f06f 0015 	mvn.w	r0, #21
    416e:	e7fb      	b.n	4168 <compare_set_nolocks+0x74>
    4170:	00800001 	.word	0x00800001
    4174:	20000360 	.word	0x20000360
    4178:	20000ef4 	.word	0x20000ef4

0000417c <sys_clock_driver_init>:
	int_event_disable_rtc();
	NVIC_ClearPendingIRQ(RTC_IRQn);
}

static int sys_clock_driver_init(void)
{
    417c:	b530      	push	{r4, r5, lr}
    417e:	b083      	sub	sp, #12
			CLOCK_CONTROL_NRF_LF_START_NOWAIT :
			(IS_ENABLED(CONFIG_SYSTEM_CLOCK_WAIT_FOR_AVAILABILITY) ?
			CLOCK_CONTROL_NRF_LF_START_AVAILABLE :
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	int_event_disable_rtc();
    4180:	f7ff feee 	bl	3f60 <int_event_disable_rtc>
    p_reg->PRESCALER = val;
    4184:	2300      	movs	r3, #0
    4186:	4a1d      	ldr	r2, [pc, #116]	; (41fc <sys_clock_driver_init+0x80>)
    4188:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    418c:	2b00      	cmp	r3, #0
    418e:	dd24      	ble.n	41da <sys_clock_driver_init+0x5e>
    p_reg->INTENSET = mask;
    4190:	4c1a      	ldr	r4, [pc, #104]	; (41fc <sys_clock_driver_init+0x80>)
    4192:	2502      	movs	r5, #2
    4194:	f8c4 5304 	str.w	r5, [r4, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4198:	4b19      	ldr	r3, [pc, #100]	; (4200 <sys_clock_driver_init+0x84>)
    419a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    419e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    41a2:	2200      	movs	r2, #0
    41a4:	2101      	movs	r1, #1
    41a6:	2015      	movs	r0, #21
    41a8:	f006 f96e 	bl	a488 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    41ac:	2015      	movs	r0, #21
    41ae:	f006 f961 	bl	a474 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    41b2:	2301      	movs	r3, #1
    41b4:	60a3      	str	r3, [r4, #8]
    41b6:	6023      	str	r3, [r4, #0]

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    41b8:	4a12      	ldr	r2, [pc, #72]	; (4204 <sys_clock_driver_init+0x88>)
    41ba:	6013      	str	r3, [r2, #0]
	}

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		MAX_CYCLES : CYC_PER_TICK;

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
    41bc:	2400      	movs	r4, #0
    41be:	9401      	str	r4, [sp, #4]
    41c0:	4b11      	ldr	r3, [pc, #68]	; (4208 <sys_clock_driver_init+0x8c>)
    41c2:	9300      	str	r3, [sp, #0]
    41c4:	4a11      	ldr	r2, [pc, #68]	; (420c <sys_clock_driver_init+0x90>)
    41c6:	2300      	movs	r3, #0
    41c8:	4620      	mov	r0, r4
    41ca:	f007 fbd1 	bl	b970 <compare_set>

	z_nrf_clock_control_lf_on(mode);
    41ce:	4628      	mov	r0, r5
    41d0:	f7ff f846 	bl	3260 <z_nrf_clock_control_lf_on>

	return 0;
}
    41d4:	4620      	mov	r0, r4
    41d6:	b003      	add	sp, #12
    41d8:	bd30      	pop	{r4, r5, pc}
		cc_data[chan].target_time = TARGET_TIME_INVALID;
    41da:	4a0d      	ldr	r2, [pc, #52]	; (4210 <sys_clock_driver_init+0x94>)
    41dc:	eb02 1203 	add.w	r2, r2, r3, lsl #4
    41e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    41e4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    41e8:	e9c2 0102 	strd	r0, r1, [r2, #8]
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    41ec:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    41f0:	409a      	lsls	r2, r3
    p_reg->INTENSET = mask;
    41f2:	4902      	ldr	r1, [pc, #8]	; (41fc <sys_clock_driver_init+0x80>)
    41f4:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    41f8:	3301      	adds	r3, #1
    41fa:	e7c7      	b.n	418c <sys_clock_driver_init+0x10>
    41fc:	50015000 	.word	0x50015000
    4200:	e000e100 	.word	0xe000e100
    4204:	20000ef8 	.word	0x20000ef8
    4208:	00004065 	.word	0x00004065
    420c:	007fffff 	.word	0x007fffff
    4210:	20000360 	.word	0x20000360

00004214 <process_channel>:
{
    4214:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4218:	b082      	sub	sp, #8
    421a:	4604      	mov	r4, r0
	if (channel_processing_check_and_clear(chan)) {
    421c:	f7ff fece 	bl	3fbc <channel_processing_check_and_clear>
    4220:	b910      	cbnz	r0, 4228 <process_channel+0x14>
}
    4222:	b002      	add	sp, #8
    4224:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_time = z_nrf_rtc_timer_read();
    4228:	f7ff ff44 	bl	40b4 <z_nrf_rtc_timer_read>
    422c:	4682      	mov	sl, r0
    422e:	460d      	mov	r5, r1
		mcu_critical_state = full_int_lock();
    4230:	f007 fb90 	bl	b954 <full_int_lock>
    4234:	4606      	mov	r6, r0
		expire_time = cc_data[chan].target_time;
    4236:	4b15      	ldr	r3, [pc, #84]	; (428c <process_channel+0x78>)
    4238:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    423c:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
    4240:	45c2      	cmp	sl, r8
    4242:	eb75 0509 	sbcs.w	r5, r5, r9
    4246:	d20b      	bcs.n	4260 <process_channel+0x4c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
    4248:	2500      	movs	r5, #0
		full_int_unlock(mcu_critical_state);
    424a:	4630      	mov	r0, r6
    424c:	f007 fb8b 	bl	b966 <full_int_unlock>
		if (handler) {
    4250:	2d00      	cmp	r5, #0
    4252:	d0e6      	beq.n	4222 <process_channel+0xe>
			handler(chan, expire_time, user_context);
    4254:	9700      	str	r7, [sp, #0]
    4256:	4642      	mov	r2, r8
    4258:	464b      	mov	r3, r9
    425a:	4620      	mov	r0, r4
    425c:	47a8      	blx	r5
}
    425e:	e7e0      	b.n	4222 <process_channel+0xe>
			handler = cc_data[chan].callback;
    4260:	4a0a      	ldr	r2, [pc, #40]	; (428c <process_channel+0x78>)
    4262:	0123      	lsls	r3, r4, #4
    4264:	eb02 1104 	add.w	r1, r2, r4, lsl #4
    4268:	58d5      	ldr	r5, [r2, r3]
			user_context = cc_data[chan].user_context;
    426a:	684f      	ldr	r7, [r1, #4]
			cc_data[chan].callback = NULL;
    426c:	2000      	movs	r0, #0
    426e:	50d0      	str	r0, [r2, r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
    4270:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4274:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4278:	e9c1 2302 	strd	r2, r3, [r1, #8]
			event_disable(chan);
    427c:	4620      	mov	r0, r4
    427e:	f7ff fe29 	bl	3ed4 <event_disable>
			event_clear(chan);
    4282:	4620      	mov	r0, r4
    4284:	f007 fb57 	bl	b936 <event_clear>
    4288:	e7df      	b.n	424a <process_channel+0x36>
    428a:	bf00      	nop
    428c:	20000360 	.word	0x20000360

00004290 <rtc_nrf_isr>:
{
    4290:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
    4292:	4b0e      	ldr	r3, [pc, #56]	; (42cc <rtc_nrf_isr+0x3c>)
    4294:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
    4298:	f013 0f02 	tst.w	r3, #2
    429c:	d00d      	beq.n	42ba <rtc_nrf_isr+0x2a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    429e:	4b0b      	ldr	r3, [pc, #44]	; (42cc <rtc_nrf_isr+0x3c>)
    42a0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    42a4:	b14b      	cbz	r3, 42ba <rtc_nrf_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    42a6:	4b09      	ldr	r3, [pc, #36]	; (42cc <rtc_nrf_isr+0x3c>)
    42a8:	2200      	movs	r2, #0
    42aa:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    42ae:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		overflow_cnt++;
    42b2:	4a07      	ldr	r2, [pc, #28]	; (42d0 <rtc_nrf_isr+0x40>)
    42b4:	6813      	ldr	r3, [r2, #0]
    42b6:	3301      	adds	r3, #1
    42b8:	6013      	str	r3, [r2, #0]
{
    42ba:	2400      	movs	r4, #0
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    42bc:	2c00      	cmp	r4, #0
    42be:	dd00      	ble.n	42c2 <rtc_nrf_isr+0x32>
}
    42c0:	bd10      	pop	{r4, pc}
		process_channel(chan);
    42c2:	4620      	mov	r0, r4
    42c4:	f7ff ffa6 	bl	4214 <process_channel>
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    42c8:	3401      	adds	r4, #1
    42ca:	e7f7      	b.n	42bc <rtc_nrf_isr+0x2c>
    42cc:	50015000 	.word	0x50015000
    42d0:	20000efc 	.word	0x20000efc

000042d4 <sys_clock_set_timeout>:
{
    42d4:	b510      	push	{r4, lr}
    42d6:	b082      	sub	sp, #8
	if (ticks == K_TICKS_FOREVER) {
    42d8:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    42dc:	d006      	beq.n	42ec <sys_clock_set_timeout+0x18>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
    42de:	2801      	cmp	r0, #1
    42e0:	dd09      	ble.n	42f6 <sys_clock_set_timeout+0x22>
    42e2:	4b15      	ldr	r3, [pc, #84]	; (4338 <sys_clock_set_timeout+0x64>)
    42e4:	4298      	cmp	r0, r3
    42e6:	dc24      	bgt.n	4332 <sys_clock_set_timeout+0x5e>
    42e8:	4604      	mov	r4, r0
    42ea:	e005      	b.n	42f8 <sys_clock_set_timeout+0x24>
		sys_busy = false;
    42ec:	4b13      	ldr	r3, [pc, #76]	; (433c <sys_clock_set_timeout+0x68>)
    42ee:	2200      	movs	r2, #0
    42f0:	701a      	strb	r2, [r3, #0]
		cyc = MAX_TICKS * CYC_PER_TICK;
    42f2:	4c13      	ldr	r4, [pc, #76]	; (4340 <sys_clock_set_timeout+0x6c>)
    42f4:	e003      	b.n	42fe <sys_clock_set_timeout+0x2a>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
    42f6:	2401      	movs	r4, #1
		sys_busy = true;
    42f8:	4b10      	ldr	r3, [pc, #64]	; (433c <sys_clock_set_timeout+0x68>)
    42fa:	2201      	movs	r2, #1
    42fc:	701a      	strb	r2, [r3, #0]
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
    42fe:	f7ff fed9 	bl	40b4 <z_nrf_rtc_timer_read>
    4302:	4b10      	ldr	r3, [pc, #64]	; (4344 <sys_clock_set_timeout+0x70>)
    4304:	681a      	ldr	r2, [r3, #0]
    4306:	685b      	ldr	r3, [r3, #4]
    4308:	1a80      	subs	r0, r0, r2
	if (unannounced >= COUNTER_HALF_SPAN) {
    430a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    430e:	d300      	bcc.n	4312 <sys_clock_set_timeout+0x3e>
		cyc = 0;
    4310:	2400      	movs	r4, #0
	cyc += unannounced;
    4312:	4404      	add	r4, r0
	if (cyc > MAX_CYCLES) {
    4314:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
    4318:	d300      	bcc.n	431c <sys_clock_set_timeout+0x48>
		cyc = MAX_CYCLES;
    431a:	4c09      	ldr	r4, [pc, #36]	; (4340 <sys_clock_set_timeout+0x6c>)
	uint64_t target_time = cyc + last_count;
    431c:	2000      	movs	r0, #0
    431e:	1912      	adds	r2, r2, r4
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
    4320:	9001      	str	r0, [sp, #4]
    4322:	4909      	ldr	r1, [pc, #36]	; (4348 <sys_clock_set_timeout+0x74>)
    4324:	9100      	str	r1, [sp, #0]
    4326:	f143 0300 	adc.w	r3, r3, #0
    432a:	f007 fb21 	bl	b970 <compare_set>
}
    432e:	b002      	add	sp, #8
    4330:	bd10      	pop	{r4, pc}
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
    4332:	4c03      	ldr	r4, [pc, #12]	; (4340 <sys_clock_set_timeout+0x6c>)
    4334:	e7e0      	b.n	42f8 <sys_clock_set_timeout+0x24>
    4336:	bf00      	nop
    4338:	007ffffe 	.word	0x007ffffe
    433c:	200015f2 	.word	0x200015f2
    4340:	007fffff 	.word	0x007fffff
    4344:	20000370 	.word	0x20000370
    4348:	00004065 	.word	0x00004065

0000434c <sys_clock_elapsed>:
{
    434c:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
    434e:	f7ff feb1 	bl	40b4 <z_nrf_rtc_timer_read>
    4352:	4b02      	ldr	r3, [pc, #8]	; (435c <sys_clock_elapsed+0x10>)
    4354:	681b      	ldr	r3, [r3, #0]
}
    4356:	1ac0      	subs	r0, r0, r3
    4358:	bd08      	pop	{r3, pc}
    435a:	bf00      	nop
    435c:	20000370 	.word	0x20000370

00004360 <SystemInit>:
    SystemCoreClock = __SYSTEM_CLOCK_MAX >> (NRF_CLOCK_S->HFCLKCTRL & (CLOCK_HFCLKCTRL_HCLK_Msk));
#endif
}

void SystemInit(void)
{
    4360:	b508      	push	{r3, lr}
            SAU->CTRL |= (1 << SAU_CTRL_ALLNS_Pos);
        #endif

        /* Workaround for Errata 97 "ERASEPROTECT, APPROTECT, or startup problems" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_97())
    4362:	f007 fb9e 	bl	baa2 <nrf53_errata_97>
    4366:	b168      	cbz	r0, 4384 <SystemInit+0x24>
        {
            if (*((volatile uint32_t *)0x50004A20ul) == 0)
    4368:	4b5d      	ldr	r3, [pc, #372]	; (44e0 <SystemInit+0x180>)
    436a:	f8d3 3a20 	ldr.w	r3, [r3, #2592]	; 0xa20
    436e:	b94b      	cbnz	r3, 4384 <SystemInit+0x24>
            {
                *((volatile uint32_t *)0x50004A20ul) = 0xDul;
    4370:	4b5b      	ldr	r3, [pc, #364]	; (44e0 <SystemInit+0x180>)
    4372:	220d      	movs	r2, #13
    4374:	f8c3 2a20 	str.w	r2, [r3, #2592]	; 0xa20
                *((volatile uint32_t *)0x5000491Cul) = 0x1ul;
    4378:	2201      	movs	r2, #1
    437a:	f8c3 291c 	str.w	r2, [r3, #2332]	; 0x91c
                *((volatile uint32_t *)0x5000491Cul) = 0x0ul;
    437e:	2200      	movs	r2, #0
    4380:	f8c3 291c 	str.w	r2, [r3, #2332]	; 0x91c
{
    4384:	2200      	movs	r2, #0
    4386:	e00b      	b.n	43a0 <SystemInit+0x40>
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
            #if defined ( __ICCARM__ )
                /* IAR will complain about the order of volatile pointer accesses. */
                #pragma diag_suppress=Pa082
            #endif
            *((volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR) = NRF_FICR_S->TRIMCNF[index].DATA;
    4388:	f102 0360 	add.w	r3, r2, #96	; 0x60
    438c:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
    4390:	f851 1033 	ldr.w	r1, [r1, r3, lsl #3]
    4394:	00db      	lsls	r3, r3, #3
    4396:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
    439a:	685b      	ldr	r3, [r3, #4]
    439c:	600b      	str	r3, [r1, #0]
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    439e:	3201      	adds	r2, #1
    43a0:	2a1f      	cmp	r2, #31
    43a2:	d808      	bhi.n	43b6 <SystemInit+0x56>
    43a4:	f102 0360 	add.w	r3, r2, #96	; 0x60
    43a8:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
    43ac:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    43b0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    43b4:	d1e8      	bne.n	4388 <SystemInit+0x28>
        }

        /* errata 64 must be before errata 42, as errata 42 is dependant on the changes in errata 64*/
        /* Workaround for Errata 64 "VREGMAIN has invalid configuration when CPU is running at 128 MHz" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_64())
    43b6:	f007 fb4c 	bl	ba52 <nrf53_errata_64>
    43ba:	b130      	cbz	r0, 43ca <SystemInit+0x6a>
        {
            *((volatile uint32_t *)0x5000470Cul) = 0x29ul;
    43bc:	4b48      	ldr	r3, [pc, #288]	; (44e0 <SystemInit+0x180>)
    43be:	2229      	movs	r2, #41	; 0x29
    43c0:	f8c3 270c 	str.w	r2, [r3, #1804]	; 0x70c
            *((volatile uint32_t *)0x5000473Cul) = 0x3ul;
    43c4:	2203      	movs	r2, #3
    43c6:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
        }

        /* Workaround for Errata 42 "Reset value of HFCLKCTRL is invalid" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_42())
    43ca:	f007 faf6 	bl	b9ba <nrf53_errata_42>
    43ce:	b140      	cbz	r0, 43e2 <SystemInit+0x82>
        {
            *((volatile uint32_t *)0x50039530ul) = 0xBEEF0044ul;
    43d0:	4b44      	ldr	r3, [pc, #272]	; (44e4 <SystemInit+0x184>)
    43d2:	4a45      	ldr	r2, [pc, #276]	; (44e8 <SystemInit+0x188>)
    43d4:	f8c3 2530 	str.w	r2, [r3, #1328]	; 0x530
            NRF_CLOCK_S->HFCLKCTRL = CLOCK_HFCLKCTRL_HCLK_Div2 << CLOCK_HFCLKCTRL_HCLK_Pos;
    43d8:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    43dc:	2201      	movs	r2, #1
    43de:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558
        }

        /* Workaround for Errata 46 "Higher power consumption of LFRC" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_46())
    43e2:	f007 fafe 	bl	b9e2 <nrf53_errata_46>
    43e6:	b118      	cbz	r0, 43f0 <SystemInit+0x90>
        {
            *((volatile uint32_t *)0x5003254Cul) = 0;
    43e8:	4b40      	ldr	r3, [pc, #256]	; (44ec <SystemInit+0x18c>)
    43ea:	2200      	movs	r2, #0
    43ec:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
        }

        /* Workaround for Errata 49 "SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_49())
    43f0:	f007 fb0f 	bl	ba12 <nrf53_errata_49>
    43f4:	b168      	cbz	r0, 4412 <SystemInit+0xb2>
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
    43f6:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    43fa:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    43fe:	f013 0f01 	tst.w	r3, #1
    4402:	d006      	beq.n	4412 <SystemInit+0xb2>
            {
                NRF_POWER_S->EVENTS_SLEEPENTER = 0;
    4404:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    4408:	2200      	movs	r2, #0
    440a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
                NRF_POWER_S->EVENTS_SLEEPEXIT = 0;
    440e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
            }
        }

        /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_55())
    4412:	f007 fb12 	bl	ba3a <nrf53_errata_55>
    4416:	b160      	cbz	r0, 4432 <SystemInit+0xd2>
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
    4418:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    441c:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    4420:	f013 0f01 	tst.w	r3, #1
    4424:	d005      	beq.n	4432 <SystemInit+0xd2>
                NRF_RESET_S->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
    4426:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    442a:	f06f 0201 	mvn.w	r2, #1
    442e:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
            }
        }

        /* Workaround for Errata 69 "VREGMAIN configuration is not retained in System OFF" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_69())
    4432:	f007 fb22 	bl	ba7a <nrf53_errata_69>
    4436:	b118      	cbz	r0, 4440 <SystemInit+0xe0>
        {
            *((volatile uint32_t *)0x5000470Cul) =0x65ul;
    4438:	4b29      	ldr	r3, [pc, #164]	; (44e0 <SystemInit+0x180>)
    443a:	2265      	movs	r2, #101	; 0x65
    443c:	f8c3 270c 	str.w	r2, [r3, #1804]	; 0x70c
        }

        if (nrf53_errata_140())
    4440:	f007 fb43 	bl	baca <nrf53_errata_140>
    4444:	b120      	cbz	r0, 4450 <SystemInit+0xf0>
        {
            if (*(volatile uint32_t *)0x50032420 & 0x80000000)
    4446:	4b29      	ldr	r3, [pc, #164]	; (44ec <SystemInit+0x18c>)
    4448:	f8d3 3420 	ldr.w	r3, [r3, #1056]	; 0x420
    444c:	2b00      	cmp	r3, #0
    444e:	db30      	blt.n	44b2 <SystemInit+0x152>
                NRF_CLOCK_S->TASKS_LFCLKSTOP = 1;
                NRF_CLOCK_S->LFCLKSRC = CLOCK_LFCLKSRC_SRC_LFRC;
            }
        }

        if (nrf53_errata_160())
    4450:	f007 fb47 	bl	bae2 <nrf53_errata_160>
    4454:	b1e8      	cbz	r0, 4492 <SystemInit+0x132>
        {
            *((volatile uint32_t *)0x5000470C) = 0x7Eul;
    4456:	4b22      	ldr	r3, [pc, #136]	; (44e0 <SystemInit+0x180>)
    4458:	227e      	movs	r2, #126	; 0x7e
    445a:	f8c3 270c 	str.w	r2, [r3, #1804]	; 0x70c
            *((volatile uint32_t *)0x5000493C) = 0x7Eul;
    445e:	f8c3 293c 	str.w	r2, [r3, #2364]	; 0x93c
            *((volatile uint32_t *)0x50002118) = 0x7Ful;
    4462:	4a23      	ldr	r2, [pc, #140]	; (44f0 <SystemInit+0x190>)
    4464:	237f      	movs	r3, #127	; 0x7f
    4466:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
            *((volatile uint32_t *)0x50039E04) = 0x0ul;
    446a:	491e      	ldr	r1, [pc, #120]	; (44e4 <SystemInit+0x184>)
    446c:	2300      	movs	r3, #0
    446e:	f8c1 3e04 	str.w	r3, [r1, #3588]	; 0xe04
            *((volatile uint32_t *)0x50039E08) = 0x0ul;
    4472:	f8c1 3e08 	str.w	r3, [r1, #3592]	; 0xe08
            *((volatile uint32_t *)0x50101110) = 0x0ul;
    4476:	f501 2148 	add.w	r1, r1, #819200	; 0xc8000
    447a:	f8c1 3110 	str.w	r3, [r1, #272]	; 0x110
            *((volatile uint32_t *)0x50002124) = 0x0ul;
    447e:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124
            *((volatile uint32_t *)0x5000212C) = 0x0ul;
    4482:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
            *((volatile uint32_t *)0x502012A0) = 0x0ul;
    4486:	f502 12ff 	add.w	r2, r2, #2088960	; 0x1fe000
    448a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    448e:	f8c2 32a0 	str.w	r3, [r2, #672]	; 0x2a0

        #endif

        /* Allow Non-Secure code to run FPU instructions.
         * If only the secure code should control FPU power state these registers should be configured accordingly in the secure application code. */
        SCB->NSACR |= (3UL << 10);
    4492:	4a18      	ldr	r2, [pc, #96]	; (44f4 <SystemInit+0x194>)
    4494:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    4498:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
    449c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                /* Do nothing, allow user code to handle APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load APPROTECT soft branch from UICR.
               If UICR->APPROTECT is disabled, CTRLAP->APPROTECT will be disabled. */
            NRF_CTRLAP_S->APPROTECT.DISABLE = NRF_UICR_S->APPROTECT;
    44a0:	4a15      	ldr	r2, [pc, #84]	; (44f8 <SystemInit+0x198>)
    44a2:	6811      	ldr	r1, [r2, #0]
    44a4:	4b15      	ldr	r3, [pc, #84]	; (44fc <SystemInit+0x19c>)
    44a6:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
                /* Do nothing, allow user code to handle SECURE APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load SECURE APPROTECT soft branch from UICR.
               If UICR->SECUREAPPROTECT is disabled, CTRLAP->SECUREAPPROTECT will be disabled. */
            NRF_CTRLAP_S->SECUREAPPROTECT.DISABLE = NRF_UICR_S->SECUREAPPROTECT;
    44aa:	69d2      	ldr	r2, [r2, #28]
    44ac:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
    #if (__FPU_USED == 1)
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
        __DSB();
        __ISB();
    #endif
}
    44b0:	bd08      	pop	{r3, pc}
                NRF_CLOCK_S->LFCLKSRC = CLOCK_LFCLKSRC_SRC_LFSYNT;
    44b2:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    44b6:	2203      	movs	r2, #3
    44b8:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
                NRF_CLOCK_S->TASKS_LFCLKSTART = 1;
    44bc:	2201      	movs	r2, #1
    44be:	609a      	str	r2, [r3, #8]
                while (NRF_CLOCK_S->EVENTS_LFCLKSTARTED == 0) {}
    44c0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    44c4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    44c8:	2b00      	cmp	r3, #0
    44ca:	d0f9      	beq.n	44c0 <SystemInit+0x160>
                NRF_CLOCK_S->EVENTS_LFCLKSTARTED = 0;
    44cc:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    44d0:	2200      	movs	r2, #0
    44d2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
                NRF_CLOCK_S->TASKS_LFCLKSTOP = 1;
    44d6:	2201      	movs	r2, #1
    44d8:	60da      	str	r2, [r3, #12]
                NRF_CLOCK_S->LFCLKSRC = CLOCK_LFCLKSRC_SRC_LFRC;
    44da:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    44de:	e7b7      	b.n	4450 <SystemInit+0xf0>
    44e0:	50004000 	.word	0x50004000
    44e4:	50039000 	.word	0x50039000
    44e8:	beef0044 	.word	0xbeef0044
    44ec:	50032000 	.word	0x50032000
    44f0:	50002000 	.word	0x50002000
    44f4:	e000ed00 	.word	0xe000ed00
    44f8:	00ff8000 	.word	0x00ff8000
    44fc:	50006000 	.word	0x50006000

00004500 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
    4500:	b510      	push	{r4, lr}
    int8_t idx;
    uint32_t new_mask, prev_mask;

    do {
        prev_mask = *p_mask;
    4502:	6804      	ldr	r4, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
    4504:	fab4 f384 	clz	r3, r4
    4508:	f1c3 031f 	rsb	r3, r3, #31
    450c:	fa5f fc83 	uxtb.w	ip, r3
        if (idx < 0) {
    4510:	2b00      	cmp	r3, #0
    4512:	db12      	blt.n	453a <nrfx_flag32_alloc+0x3a>
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
    4514:	2201      	movs	r2, #1
    4516:	fa02 f303 	lsl.w	r3, r2, r3
    451a:	ea24 0303 	bic.w	r3, r4, r3
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    451e:	e8d0 2fef 	ldaex	r2, [r0]
    4522:	42a2      	cmp	r2, r4
    4524:	d104      	bne.n	4530 <nrfx_flag32_alloc+0x30>
    4526:	e8c0 3fee 	stlex	lr, r3, [r0]
    452a:	f1be 0f00 	cmp.w	lr, #0
    452e:	d1f6      	bne.n	451e <nrfx_flag32_alloc+0x1e>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    4530:	d1e7      	bne.n	4502 <nrfx_flag32_alloc+0x2>

    *p_flag = idx;
    4532:	f881 c000 	strb.w	ip, [r1]

    return NRFX_SUCCESS;
    4536:	4802      	ldr	r0, [pc, #8]	; (4540 <nrfx_flag32_alloc+0x40>)
}
    4538:	bd10      	pop	{r4, pc}
            return NRFX_ERROR_NO_MEM;
    453a:	4802      	ldr	r0, [pc, #8]	; (4544 <nrfx_flag32_alloc+0x44>)
    453c:	e7fc      	b.n	4538 <nrfx_flag32_alloc+0x38>
    453e:	bf00      	nop
    4540:	0bad0000 	.word	0x0bad0000
    4544:	0bad0002 	.word	0x0bad0002

00004548 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
    4548:	6803      	ldr	r3, [r0, #0]
    454a:	40cb      	lsrs	r3, r1
    454c:	f013 0f01 	tst.w	r3, #1
    4550:	d111      	bne.n	4576 <nrfx_flag32_free+0x2e>
{
    4552:	b500      	push	{lr}
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
    4554:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
    4556:	2301      	movs	r3, #1
    4558:	408b      	lsls	r3, r1
    455a:	4313      	orrs	r3, r2
    455c:	e8d0 cfef 	ldaex	ip, [r0]
    4560:	4594      	cmp	ip, r2
    4562:	d104      	bne.n	456e <nrfx_flag32_free+0x26>
    4564:	e8c0 3fee 	stlex	lr, r3, [r0]
    4568:	f1be 0f00 	cmp.w	lr, #0
    456c:	d1f6      	bne.n	455c <nrfx_flag32_free+0x14>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    456e:	d1f1      	bne.n	4554 <nrfx_flag32_free+0xc>

    return NRFX_SUCCESS;
    4570:	4802      	ldr	r0, [pc, #8]	; (457c <nrfx_flag32_free+0x34>)
}
    4572:	f85d fb04 	ldr.w	pc, [sp], #4
        return NRFX_ERROR_INVALID_PARAM;
    4576:	4802      	ldr	r0, [pc, #8]	; (4580 <nrfx_flag32_free+0x38>)
}
    4578:	4770      	bx	lr
    457a:	bf00      	nop
    457c:	0bad0000 	.word	0x0bad0000
    4580:	0bad0004 	.word	0x0bad0004

00004584 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    4584:	4b05      	ldr	r3, [pc, #20]	; (459c <nrfx_clock_init+0x18>)
    4586:	791b      	ldrb	r3, [r3, #4]
    4588:	b92b      	cbnz	r3, 4596 <nrfx_clock_init+0x12>
    else
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
    458a:	4b04      	ldr	r3, [pc, #16]	; (459c <nrfx_clock_init+0x18>)
    458c:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    458e:	2201      	movs	r2, #1
    4590:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    4592:	4803      	ldr	r0, [pc, #12]	; (45a0 <nrfx_clock_init+0x1c>)
    4594:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    4596:	4803      	ldr	r0, [pc, #12]	; (45a4 <nrfx_clock_init+0x20>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    4598:	4770      	bx	lr
    459a:	bf00      	nop
    459c:	20000f00 	.word	0x20000f00
    45a0:	0bad0000 	.word	0x0bad0000
    45a4:	0bad000c 	.word	0x0bad000c

000045a8 <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    45a8:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    45aa:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    45ae:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    45b2:	b163      	cbz	r3, 45ce <nrfx_power_clock_irq_handler+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    45b4:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    45b8:	2000      	movs	r0, #0
    45ba:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
    45be:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
    45c2:	2201      	movs	r2, #1
    45c4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    45c8:	4b28      	ldr	r3, [pc, #160]	; (466c <nrfx_power_clock_irq_handler+0xc4>)
    45ca:	681b      	ldr	r3, [r3, #0]
    45cc:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    45ce:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    45d2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    45d6:	b1bb      	cbz	r3, 4608 <nrfx_power_clock_irq_handler+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    45d8:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    45dc:	2200      	movs	r2, #0
    45de:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    45e2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    45e6:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
    45ea:	f002 0203 	and.w	r2, r2, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    45ee:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    45f2:	2a01      	cmp	r2, #1
    45f4:	d031      	beq.n	465a <nrfx_power_clock_irq_handler+0xb2>
    p_reg->INTENCLR = mask;
    45f6:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    45fa:	2202      	movs	r2, #2
    45fc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        else
#endif
        {
            // After the LF clock external source start invoke user callback.
            nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_LF_STARTED_MASK);
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    4600:	4b1a      	ldr	r3, [pc, #104]	; (466c <nrfx_power_clock_irq_handler+0xc4>)
    4602:	681b      	ldr	r3, [r3, #0]
    4604:	2001      	movs	r0, #1
    4606:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    4608:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    460c:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)

#if NRF_CLOCK_HAS_HFCLKAUDIO
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED))
    4610:	b173      	cbz	r3, 4630 <nrfx_power_clock_irq_handler+0x88>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4612:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    4616:	2200      	movs	r2, #0
    4618:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    461c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENCLR = mask;
    4620:	f44f 7280 	mov.w	r2, #256	; 0x100
    4624:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLKAUDIO_STARTED);
    4628:	4b10      	ldr	r3, [pc, #64]	; (466c <nrfx_power_clock_irq_handler+0xc4>)
    462a:	681b      	ldr	r3, [r3, #0]
    462c:	2004      	movs	r0, #4
    462e:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    4630:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    4634:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
    }
#endif

#if NRF_CLOCK_HAS_HFCLK192M
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED))
    4638:	b173      	cbz	r3, 4658 <nrfx_power_clock_irq_handler+0xb0>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    463a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    463e:	2200      	movs	r2, #0
    4640:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    4644:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENCLR = mask;
    4648:	f44f 7200 	mov.w	r2, #512	; 0x200
    464c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLK192MSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    4650:	4b06      	ldr	r3, [pc, #24]	; (466c <nrfx_power_clock_irq_handler+0xc4>)
    4652:	681b      	ldr	r3, [r3, #0]
    4654:	2005      	movs	r0, #5
    4656:	4798      	blx	r3
    }
#endif
}
    4658:	bd08      	pop	{r3, pc}
    p_reg->LFCLKSRC = (uint32_t)(source);
    465a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    465e:	2202      	movs	r2, #2
    4660:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4664:	2201      	movs	r2, #1
    4666:	609a      	str	r2, [r3, #8]
}
    4668:	e7ce      	b.n	4608 <nrfx_power_clock_irq_handler+0x60>
    466a:	bf00      	nop
    466c:	20000f00 	.word	0x20000f00

00004670 <nrf_gpio_reconfigure>:
{
    4670:	b5f0      	push	{r4, r5, r6, r7, lr}
    4672:	461c      	mov	r4, r3
    4674:	9f05      	ldr	r7, [sp, #20]
    4676:	9e06      	ldr	r6, [sp, #24]
    *p_pin = pin_number & 0x1F;
    4678:	f000 0c1f 	and.w	ip, r0, #31
    return pin_number >> 5;
    467c:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    467e:	2801      	cmp	r0, #1
    4680:	d034      	beq.n	46ec <nrf_gpio_reconfigure+0x7c>
        case 0: return NRF_P0;
    4682:	4d27      	ldr	r5, [pc, #156]	; (4720 <nrf_gpio_reconfigure+0xb0>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
    4684:	f10c 0380 	add.w	r3, ip, #128	; 0x80
    4688:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
    468c:	b381      	cbz	r1, 46f0 <nrf_gpio_reconfigure+0x80>
    468e:	2001      	movs	r0, #1
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    4690:	b382      	cbz	r2, 46f4 <nrf_gpio_reconfigure+0x84>
    4692:	f04f 0e02 	mov.w	lr, #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
    4696:	ea40 000e 	orr.w	r0, r0, lr
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    469a:	b374      	cbz	r4, 46fa <nrf_gpio_reconfigure+0x8a>
    469c:	f04f 0e0c 	mov.w	lr, #12
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    46a0:	ea40 000e 	orr.w	r0, r0, lr
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
    46a4:	b367      	cbz	r7, 4700 <nrf_gpio_reconfigure+0x90>
    46a6:	f44f 6e70 	mov.w	lr, #3840	; 0xf00
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    46aa:	ea40 000e 	orr.w	r0, r0, lr
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
    46ae:	b356      	cbz	r6, 4706 <nrf_gpio_reconfigure+0x96>
    46b0:	f44f 3e40 	mov.w	lr, #196608	; 0x30000
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
    46b4:	ea40 000e 	orr.w	r0, r0, lr
    cnf &= ~to_update;
    46b8:	ea23 0000 	bic.w	r0, r3, r0
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    46bc:	b331      	cbz	r1, 470c <nrf_gpio_reconfigure+0x9c>
    46be:	780b      	ldrb	r3, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    46c0:	b332      	cbz	r2, 4710 <nrf_gpio_reconfigure+0xa0>
    46c2:	7812      	ldrb	r2, [r2, #0]
    46c4:	0052      	lsls	r2, r2, #1
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    46c6:	4313      	orrs	r3, r2
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    46c8:	b324      	cbz	r4, 4714 <nrf_gpio_reconfigure+0xa4>
    46ca:	7822      	ldrb	r2, [r4, #0]
    46cc:	0092      	lsls	r2, r2, #2
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    46ce:	4313      	orrs	r3, r2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
    46d0:	b317      	cbz	r7, 4718 <nrf_gpio_reconfigure+0xa8>
    46d2:	783a      	ldrb	r2, [r7, #0]
    46d4:	0212      	lsls	r2, r2, #8
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    46d6:	4313      	orrs	r3, r2
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
    46d8:	b306      	cbz	r6, 471c <nrf_gpio_reconfigure+0xac>
    46da:	7832      	ldrb	r2, [r6, #0]
    46dc:	0412      	lsls	r2, r2, #16
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
    46de:	4313      	orrs	r3, r2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    46e0:	4303      	orrs	r3, r0
    reg->PIN_CNF[pin_number] = cnf;
    46e2:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
    46e6:	f845 302c 	str.w	r3, [r5, ip, lsl #2]
}
    46ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
        case 1: return NRF_P1;
    46ec:	4d0d      	ldr	r5, [pc, #52]	; (4724 <nrf_gpio_reconfigure+0xb4>)
    46ee:	e7c9      	b.n	4684 <nrf_gpio_reconfigure+0x14>
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
    46f0:	2000      	movs	r0, #0
    46f2:	e7cd      	b.n	4690 <nrf_gpio_reconfigure+0x20>
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    46f4:	f04f 0e00 	mov.w	lr, #0
    46f8:	e7cd      	b.n	4696 <nrf_gpio_reconfigure+0x26>
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    46fa:	f04f 0e00 	mov.w	lr, #0
    46fe:	e7cf      	b.n	46a0 <nrf_gpio_reconfigure+0x30>
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
    4700:	f04f 0e00 	mov.w	lr, #0
    4704:	e7d1      	b.n	46aa <nrf_gpio_reconfigure+0x3a>
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
    4706:	f04f 0e00 	mov.w	lr, #0
    470a:	e7d3      	b.n	46b4 <nrf_gpio_reconfigure+0x44>
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    470c:	2300      	movs	r3, #0
    470e:	e7d7      	b.n	46c0 <nrf_gpio_reconfigure+0x50>
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    4710:	2200      	movs	r2, #0
    4712:	e7d8      	b.n	46c6 <nrf_gpio_reconfigure+0x56>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    4714:	2200      	movs	r2, #0
    4716:	e7da      	b.n	46ce <nrf_gpio_reconfigure+0x5e>
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
    4718:	2200      	movs	r2, #0
    471a:	e7dc      	b.n	46d6 <nrf_gpio_reconfigure+0x66>
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
    471c:	2200      	movs	r2, #0
    471e:	e7de      	b.n	46de <nrf_gpio_reconfigure+0x6e>
    4720:	50842500 	.word	0x50842500
    4724:	50842800 	.word	0x50842800

00004728 <nrf_gpio_cfg_default>:
    *p_pin = pin_number & 0x1F;
    4728:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    472c:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    472e:	2801      	cmp	r0, #1
    4730:	d00a      	beq.n	4748 <nrf_gpio_cfg_default+0x20>
        case 0: return NRF_P0;
    4732:	4906      	ldr	r1, [pc, #24]	; (474c <nrf_gpio_cfg_default+0x24>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    4734:	3280      	adds	r2, #128	; 0x80
    4736:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    473a:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    473e:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
    4742:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    4746:	4770      	bx	lr
        case 1: return NRF_P1;
    4748:	4901      	ldr	r1, [pc, #4]	; (4750 <nrf_gpio_cfg_default+0x28>)
    474a:	e7f3      	b.n	4734 <nrf_gpio_cfg_default+0xc>
    474c:	50842500 	.word	0x50842500
    4750:	50842800 	.word	0x50842800

00004754 <nrf_gpio_latches_read_and_clear>:
{
    4754:	b500      	push	{lr}
    4756:	b083      	sub	sp, #12
    4758:	4684      	mov	ip, r0
    475a:	468e      	mov	lr, r1
    NRF_GPIO_Type * gpio_regs[GPIO_COUNT] = GPIO_REG_LIST;
    475c:	4b0c      	ldr	r3, [pc, #48]	; (4790 <nrf_gpio_latches_read_and_clear+0x3c>)
    475e:	e893 0003 	ldmia.w	r3, {r0, r1}
    4762:	ab02      	add	r3, sp, #8
    4764:	e903 0003 	stmdb	r3, {r0, r1}
    for (i = start_port; i < (start_port + length); i++)
    4768:	4663      	mov	r3, ip
    476a:	e009      	b.n	4780 <nrf_gpio_latches_read_and_clear+0x2c>
        *p_masks = gpio_regs[i]->LATCH;
    476c:	a902      	add	r1, sp, #8
    476e:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    4772:	f851 1c08 	ldr.w	r1, [r1, #-8]
    4776:	6a08      	ldr	r0, [r1, #32]
    4778:	f842 0b04 	str.w	r0, [r2], #4
        gpio_regs[i]->LATCH = *p_masks;
    477c:	6208      	str	r0, [r1, #32]
    for (i = start_port; i < (start_port + length); i++)
    477e:	3301      	adds	r3, #1
    4780:	eb0c 000e 	add.w	r0, ip, lr
    4784:	4298      	cmp	r0, r3
    4786:	d8f1      	bhi.n	476c <nrf_gpio_latches_read_and_clear+0x18>
}
    4788:	b003      	add	sp, #12
    478a:	f85d fb04 	ldr.w	pc, [sp], #4
    478e:	bf00      	nop
    4790:	0000e080 	.word	0x0000e080

00004794 <pin_in_use>:
 *
 * @return True if pin is in use.
 */
static bool pin_in_use(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    4794:	3008      	adds	r0, #8
    4796:	4b03      	ldr	r3, [pc, #12]	; (47a4 <pin_in_use+0x10>)
    4798:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    479c:	f000 0001 	and.w	r0, r0, #1
    47a0:	4770      	bx	lr
    47a2:	bf00      	nop
    47a4:	200001d0 	.word	0x200001d0

000047a8 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
    47a8:	3008      	adds	r0, #8
    47aa:	4b03      	ldr	r3, [pc, #12]	; (47b8 <pin_in_use_by_te+0x10>)
    47ac:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    47b0:	f3c0 1040 	ubfx	r0, r0, #5, #1
    47b4:	4770      	bx	lr
    47b6:	bf00      	nop
    47b8:	200001d0 	.word	0x200001d0

000047bc <pin_has_trigger>:
 *
 * @return True if pin has trigger.
 */
static bool pin_has_trigger(uint32_t pin)
{
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
    47bc:	3008      	adds	r0, #8
    47be:	4b04      	ldr	r3, [pc, #16]	; (47d0 <pin_has_trigger+0x14>)
    47c0:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    47c4:	f010 001c 	ands.w	r0, r0, #28
    47c8:	bf18      	it	ne
    47ca:	2001      	movne	r0, #1
    47cc:	4770      	bx	lr
    47ce:	bf00      	nop
    47d0:	200001d0 	.word	0x200001d0

000047d4 <pin_is_output>:
 *
 * @return True if pin is output.
 */
static bool pin_is_output(uint32_t pin)
{
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    47d4:	3008      	adds	r0, #8
    47d6:	4b03      	ldr	r3, [pc, #12]	; (47e4 <pin_is_output+0x10>)
    47d8:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    47dc:	f3c0 0040 	ubfx	r0, r0, #1, #1
    47e0:	4770      	bx	lr
    47e2:	bf00      	nop
    47e4:	200001d0 	.word	0x200001d0

000047e8 <pin_te_get>:
}

/* Returns gpiote TE channel associated with the pin */
static uint8_t pin_te_get(nrfx_gpiote_pin_t pin)
{
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    47e8:	3008      	adds	r0, #8
    47ea:	4b02      	ldr	r3, [pc, #8]	; (47f4 <pin_te_get+0xc>)
    47ec:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    47f0:	0b40      	lsrs	r0, r0, #13
    47f2:	4770      	bx	lr
    47f4:	200001d0 	.word	0x200001d0

000047f8 <handler_in_use>:
}

static bool handler_in_use(int32_t handler_id)
{

    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    47f8:	2200      	movs	r2, #0
    47fa:	e004      	b.n	4806 <handler_in_use+0xe>
    {
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    47fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4800:	4283      	cmp	r3, r0
    4802:	d00f      	beq.n	4824 <handler_in_use+0x2c>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    4804:	3201      	adds	r2, #1
    4806:	2a2f      	cmp	r2, #47	; 0x2f
    4808:	d80a      	bhi.n	4820 <handler_in_use+0x28>
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    480a:	f102 0308 	add.w	r3, r2, #8
    480e:	4906      	ldr	r1, [pc, #24]	; (4828 <handler_in_use+0x30>)
    4810:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    4814:	f413 7f80 	tst.w	r3, #256	; 0x100
    4818:	d0f0      	beq.n	47fc <handler_in_use+0x4>
    481a:	f3c3 2343 	ubfx	r3, r3, #9, #4
    481e:	e7ef      	b.n	4800 <handler_in_use+0x8>
        {
            return true;
        }
    }

    return false;
    4820:	2000      	movs	r0, #0
    4822:	4770      	bx	lr
            return true;
    4824:	2001      	movs	r0, #1
}
    4826:	4770      	bx	lr
    4828:	200001d0 	.word	0x200001d0

0000482c <find_handler>:
    return NRFX_SUCCESS;
}

static int32_t find_handler(nrfx_gpiote_interrupt_handler_t handler, void * p_context)
{
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
    482c:	2300      	movs	r3, #0
    482e:	b113      	cbz	r3, 4836 <find_handler+0xa>
        {
            return i;
        }
    }

    return -1;
    4830:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    4834:	4770      	bx	lr
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    4836:	4a07      	ldr	r2, [pc, #28]	; (4854 <find_handler+0x28>)
    4838:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
    483c:	4282      	cmp	r2, r0
    483e:	d001      	beq.n	4844 <find_handler+0x18>
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
    4840:	3301      	adds	r3, #1
    4842:	e7f4      	b.n	482e <find_handler+0x2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    4844:	4a03      	ldr	r2, [pc, #12]	; (4854 <find_handler+0x28>)
    4846:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    484a:	6852      	ldr	r2, [r2, #4]
    484c:	428a      	cmp	r2, r1
    484e:	d1f7      	bne.n	4840 <find_handler+0x14>
            return i;
    4850:	4618      	mov	r0, r3
    4852:	4770      	bx	lr
    4854:	200001d0 	.word	0x200001d0

00004858 <get_initial_sense>:
    return NRFX_SUCCESS;
}

static inline nrf_gpio_pin_sense_t get_initial_sense(nrfx_gpiote_pin_t pin)
{
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    4858:	f100 0208 	add.w	r2, r0, #8
    485c:	4b0e      	ldr	r3, [pc, #56]	; (4898 <get_initial_sense+0x40>)
    485e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    4862:	f3c3 0382 	ubfx	r3, r3, #2, #3
    nrf_gpio_pin_sense_t sense;

    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
    4866:	2b04      	cmp	r3, #4
    4868:	d010      	beq.n	488c <get_initial_sense+0x34>
    {
        sense = NRF_GPIO_PIN_SENSE_LOW;
    }
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
    486a:	2b05      	cmp	r3, #5
    486c:	d010      	beq.n	4890 <get_initial_sense+0x38>
    *p_pin = pin_number & 0x1F;
    486e:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    4872:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    4874:	2801      	cmp	r0, #1
    4876:	d007      	beq.n	4888 <get_initial_sense+0x30>
        case 0: return NRF_P0;
    4878:	4b08      	ldr	r3, [pc, #32]	; (489c <get_initial_sense+0x44>)
    return p_reg->IN;
    487a:	691b      	ldr	r3, [r3, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    487c:	40d3      	lsrs	r3, r2
        sense = NRF_GPIO_PIN_SENSE_HIGH;
    }
    else
    {
        /* If edge detection start with sensing opposite state. */
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    487e:	f013 0f01 	tst.w	r3, #1
    4882:	d007      	beq.n	4894 <get_initial_sense+0x3c>
    4884:	2003      	movs	r0, #3
    4886:	4770      	bx	lr
        case 1: return NRF_P1;
    4888:	4b05      	ldr	r3, [pc, #20]	; (48a0 <get_initial_sense+0x48>)
    488a:	e7f6      	b.n	487a <get_initial_sense+0x22>
        sense = NRF_GPIO_PIN_SENSE_LOW;
    488c:	2003      	movs	r0, #3
    488e:	4770      	bx	lr
        sense = NRF_GPIO_PIN_SENSE_HIGH;
    4890:	2002      	movs	r0, #2
    4892:	4770      	bx	lr
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    4894:	2002      	movs	r0, #2
    }

    return sense;
}
    4896:	4770      	bx	lr
    4898:	200001d0 	.word	0x200001d0
    489c:	50842500 	.word	0x50842500
    48a0:	50842800 	.word	0x50842800

000048a4 <channel_handler_get>:
}

/* Return handler associated with given pin or null. */
static nrfx_gpiote_handler_config_t const * channel_handler_get(nrfx_gpiote_pin_t pin)
{
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    48a4:	3008      	adds	r0, #8
    48a6:	4b06      	ldr	r3, [pc, #24]	; (48c0 <channel_handler_get+0x1c>)
    48a8:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
    48ac:	f410 7f80 	tst.w	r0, #256	; 0x100
    48b0:	d004      	beq.n	48bc <channel_handler_get+0x18>
    48b2:	f3c0 2043 	ubfx	r0, r0, #9, #4
    if (handler_id == PIN_FLAG_NO_HANDLER)
    {
        return NULL;
    }

    return &m_cb.handlers[handler_id];
    48b6:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    48ba:	4770      	bx	lr
        return NULL;
    48bc:	2000      	movs	r0, #0
}
    48be:	4770      	bx	lr
    48c0:	200001d0 	.word	0x200001d0

000048c4 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
    48c4:	b570      	push	{r4, r5, r6, lr}
    48c6:	4604      	mov	r4, r0
    48c8:	460d      	mov	r5, r1
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);
    48ca:	f7ff ffeb 	bl	48a4 <channel_handler_get>

    if (handler)
    48ce:	b120      	cbz	r0, 48da <call_handler+0x16>
    {
        handler->handler(pin, trigger, handler->p_context);
    48d0:	6806      	ldr	r6, [r0, #0]
    48d2:	6842      	ldr	r2, [r0, #4]
    48d4:	4629      	mov	r1, r5
    48d6:	4620      	mov	r0, r4
    48d8:	47b0      	blx	r6
    }
    if (m_cb.global_handler.handler)
    48da:	4b04      	ldr	r3, [pc, #16]	; (48ec <call_handler+0x28>)
    48dc:	689b      	ldr	r3, [r3, #8]
    48de:	b123      	cbz	r3, 48ea <call_handler+0x26>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    48e0:	4a02      	ldr	r2, [pc, #8]	; (48ec <call_handler+0x28>)
    48e2:	68d2      	ldr	r2, [r2, #12]
    48e4:	4629      	mov	r1, r5
    48e6:	4620      	mov	r0, r4
    48e8:	4798      	blx	r3
    }
}
    48ea:	bd70      	pop	{r4, r5, r6, pc}
    48ec:	200001d0 	.word	0x200001d0

000048f0 <next_sense_cond_call_handler>:

static void next_sense_cond_call_handler(nrfx_gpiote_pin_t     pin,
                                         nrfx_gpiote_trigger_t trigger,
                                         nrf_gpio_pin_sense_t  sense)
{
    48f0:	b570      	push	{r4, r5, r6, lr}
    48f2:	4606      	mov	r6, r0
    48f4:	460c      	mov	r4, r1
    48f6:	4615      	mov	r5, r2
    if (is_level(trigger))
    48f8:	4608      	mov	r0, r1
    48fa:	f007 faad 	bl	be58 <is_level>
    48fe:	b960      	cbnz	r0, 491a <next_sense_cond_call_handler+0x2a>
    {
        /* Reconfigure sense to the opposite level, so the internal PINx.DETECT signal
         * can be deasserted. Therefore PORT event can be generated again,
         * unless some other PINx.DETECT signal is still active. */
        nrf_gpio_pin_sense_t next_sense = (sense == NRF_GPIO_PIN_SENSE_HIGH) ?
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    4900:	2d02      	cmp	r5, #2
    4902:	d026      	beq.n	4952 <next_sense_cond_call_handler+0x62>
    4904:	2102      	movs	r1, #2

        nrf_gpio_cfg_sense_set(pin, next_sense);
    4906:	4630      	mov	r0, r6
    4908:	f007 fa7e 	bl	be08 <nrf_gpio_cfg_sense_set>

        /* Invoke user handler only if the sensed pin level matches its polarity
         * configuration. Call handler unconditionally in case of toggle trigger or
         * level trigger. */
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
    490c:	2c03      	cmp	r4, #3
    490e:	d024      	beq.n	495a <next_sense_cond_call_handler+0x6a>
    4910:	2d02      	cmp	r5, #2
    4912:	d020      	beq.n	4956 <next_sense_cond_call_handler+0x66>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    4914:	2d03      	cmp	r5, #3
    4916:	d025      	beq.n	4964 <next_sense_cond_call_handler+0x74>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
        {
            call_handler(pin, trigger);
        }
    }
}
    4918:	bd70      	pop	{r4, r5, r6, pc}
        call_handler(pin, trigger);
    491a:	4621      	mov	r1, r4
    491c:	4630      	mov	r0, r6
    491e:	f7ff ffd1 	bl	48c4 <call_handler>
    *p_pin = pin_number & 0x1F;
    4922:	f006 031f 	and.w	r3, r6, #31
    return pin_number >> 5;
    4926:	0972      	lsrs	r2, r6, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    4928:	2a01      	cmp	r2, #1
    492a:	d010      	beq.n	494e <next_sense_cond_call_handler+0x5e>
        case 0: return NRF_P0;
    492c:	4a0f      	ldr	r2, [pc, #60]	; (496c <next_sense_cond_call_handler+0x7c>)
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    492e:	3380      	adds	r3, #128	; 0x80
    4930:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4934:	f3c3 4301 	ubfx	r3, r3, #16, #2
        if (nrf_gpio_pin_sense_get(pin) == sense)
    4938:	429d      	cmp	r5, r3
    493a:	d1ed      	bne.n	4918 <next_sense_cond_call_handler+0x28>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    493c:	2100      	movs	r1, #0
    493e:	4630      	mov	r0, r6
    4940:	f007 fa62 	bl	be08 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
    4944:	4629      	mov	r1, r5
    4946:	4630      	mov	r0, r6
    4948:	f007 fa5e 	bl	be08 <nrf_gpio_cfg_sense_set>
    494c:	e7e4      	b.n	4918 <next_sense_cond_call_handler+0x28>
        case 1: return NRF_P1;
    494e:	4a08      	ldr	r2, [pc, #32]	; (4970 <next_sense_cond_call_handler+0x80>)
    4950:	e7ed      	b.n	492e <next_sense_cond_call_handler+0x3e>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    4952:	2103      	movs	r1, #3
    4954:	e7d7      	b.n	4906 <next_sense_cond_call_handler+0x16>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    4956:	2c01      	cmp	r4, #1
    4958:	d1dc      	bne.n	4914 <next_sense_cond_call_handler+0x24>
            call_handler(pin, trigger);
    495a:	4621      	mov	r1, r4
    495c:	4630      	mov	r0, r6
    495e:	f7ff ffb1 	bl	48c4 <call_handler>
}
    4962:	e7d9      	b.n	4918 <next_sense_cond_call_handler+0x28>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    4964:	2c02      	cmp	r4, #2
    4966:	d1d7      	bne.n	4918 <next_sense_cond_call_handler+0x28>
    4968:	e7f7      	b.n	495a <next_sense_cond_call_handler+0x6a>
    496a:	bf00      	nop
    496c:	50842500 	.word	0x50842500
    4970:	50842800 	.word	0x50842800

00004974 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    4974:	f100 0208 	add.w	r2, r0, #8
    4978:	4b0e      	ldr	r3, [pc, #56]	; (49b4 <release_handler+0x40>)
    497a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    497e:	f413 7f80 	tst.w	r3, #256	; 0x100
    4982:	d016      	beq.n	49b2 <release_handler+0x3e>
{
    4984:	b510      	push	{r4, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    4986:	f3c3 2443 	ubfx	r4, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
    498a:	4610      	mov	r0, r2
    498c:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    4990:	4a08      	ldr	r2, [pc, #32]	; (49b4 <release_handler+0x40>)
    4992:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    if (!handler_in_use(handler_id))
    4996:	4620      	mov	r0, r4
    4998:	f7ff ff2e 	bl	47f8 <handler_in_use>
    499c:	b100      	cbz	r0, 49a0 <release_handler+0x2c>
}
    499e:	bd10      	pop	{r4, pc}
        m_cb.handlers[handler_id].handler = NULL;
    49a0:	4804      	ldr	r0, [pc, #16]	; (49b4 <release_handler+0x40>)
    49a2:	2300      	movs	r3, #0
    49a4:	f840 3034 	str.w	r3, [r0, r4, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    49a8:	4621      	mov	r1, r4
    49aa:	3074      	adds	r0, #116	; 0x74
    49ac:	f7ff fdcc 	bl	4548 <nrfx_flag32_free>
        NRFX_ASSERT(err == NRFX_SUCCESS);
    49b0:	e7f5      	b.n	499e <release_handler+0x2a>
    49b2:	4770      	bx	lr
    49b4:	200001d0 	.word	0x200001d0

000049b8 <pin_handler_trigger_uninit>:
{
    49b8:	b510      	push	{r4, lr}
    49ba:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin))
    49bc:	f7ff fef4 	bl	47a8 <pin_in_use_by_te>
    49c0:	b150      	cbz	r0, 49d8 <pin_handler_trigger_uninit+0x20>
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
    49c2:	4620      	mov	r0, r4
    49c4:	f7ff ff10 	bl	47e8 <pin_te_get>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
    49c8:	4b08      	ldr	r3, [pc, #32]	; (49ec <pin_handler_trigger_uninit+0x34>)
    49ca:	f500 70a2 	add.w	r0, r0, #324	; 0x144
    49ce:	2200      	movs	r2, #0
    49d0:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
#if defined(NRF53_SERIES) || defined(NRF91_SERIES)
    p_reg->CONFIG[idx] = 0;
    49d4:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
    release_handler(pin);
    49d8:	4620      	mov	r0, r4
    49da:	f7ff ffcb 	bl	4974 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
    49de:	3408      	adds	r4, #8
    49e0:	4b03      	ldr	r3, [pc, #12]	; (49f0 <pin_handler_trigger_uninit+0x38>)
    49e2:	2200      	movs	r2, #0
    49e4:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
}
    49e8:	bd10      	pop	{r4, pc}
    49ea:	bf00      	nop
    49ec:	5000d000 	.word	0x5000d000
    49f0:	200001d0 	.word	0x200001d0

000049f4 <pin_handler_set>:
{
    49f4:	b570      	push	{r4, r5, r6, lr}
    49f6:	b082      	sub	sp, #8
    49f8:	4605      	mov	r5, r0
    49fa:	460e      	mov	r6, r1
    49fc:	4614      	mov	r4, r2
    release_handler(pin);
    49fe:	f7ff ffb9 	bl	4974 <release_handler>
    if (!handler)
    4a02:	b326      	cbz	r6, 4a4e <pin_handler_set+0x5a>
    handler_id = find_handler(handler, p_context);
    4a04:	4621      	mov	r1, r4
    4a06:	4630      	mov	r0, r6
    4a08:	f7ff ff10 	bl	482c <find_handler>
    if (handler_id < 0)
    4a0c:	1e03      	subs	r3, r0, #0
    4a0e:	db13      	blt.n	4a38 <pin_handler_set+0x44>
    m_cb.handlers[handler_id].handler = handler;
    4a10:	4910      	ldr	r1, [pc, #64]	; (4a54 <pin_handler_set+0x60>)
    4a12:	f841 6033 	str.w	r6, [r1, r3, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
    4a16:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
    4a1a:	6054      	str	r4, [r2, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    4a1c:	f105 0008 	add.w	r0, r5, #8
    4a20:	f831 2010 	ldrh.w	r2, [r1, r0, lsl #1]
    4a24:	025b      	lsls	r3, r3, #9
    4a26:	b29b      	uxth	r3, r3
    4a28:	4313      	orrs	r3, r2
    4a2a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    4a2e:	f821 3010 	strh.w	r3, [r1, r0, lsl #1]
    return NRFX_SUCCESS;
    4a32:	4809      	ldr	r0, [pc, #36]	; (4a58 <pin_handler_set+0x64>)
}
    4a34:	b002      	add	sp, #8
    4a36:	bd70      	pop	{r4, r5, r6, pc}
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
    4a38:	f10d 0107 	add.w	r1, sp, #7
    4a3c:	4807      	ldr	r0, [pc, #28]	; (4a5c <pin_handler_set+0x68>)
    4a3e:	f7ff fd5f 	bl	4500 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
    4a42:	4b05      	ldr	r3, [pc, #20]	; (4a58 <pin_handler_set+0x64>)
    4a44:	4298      	cmp	r0, r3
    4a46:	d1f5      	bne.n	4a34 <pin_handler_set+0x40>
        handler_id = (int32_t)id;
    4a48:	f89d 3007 	ldrb.w	r3, [sp, #7]
    4a4c:	e7e0      	b.n	4a10 <pin_handler_set+0x1c>
        return NRFX_SUCCESS;
    4a4e:	4802      	ldr	r0, [pc, #8]	; (4a58 <pin_handler_set+0x64>)
    4a50:	e7f0      	b.n	4a34 <pin_handler_set+0x40>
    4a52:	bf00      	nop
    4a54:	200001d0 	.word	0x200001d0
    4a58:	0bad0000 	.word	0x0bad0000
    4a5c:	20000244 	.word	0x20000244

00004a60 <port_event_handle>:
    }
    return false;
}

static void port_event_handle(void)
{
    4a60:	b570      	push	{r4, r5, r6, lr}
    4a62:	b082      	sub	sp, #8
    uint32_t latch[GPIO_COUNT];

    nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, latch);
    4a64:	466a      	mov	r2, sp
    4a66:	2102      	movs	r1, #2
    4a68:	2000      	movs	r0, #0
    4a6a:	f7ff fe73 	bl	4754 <nrf_gpio_latches_read_and_clear>
    4a6e:	e03e      	b.n	4aee <port_event_handle+0x8e>
    4a70:	4e21      	ldr	r6, [pc, #132]	; (4af8 <port_event_handle+0x98>)
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    4a72:	f105 0380 	add.w	r3, r5, #128	; 0x80
    4a76:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);

                nrf_bitmask_bit_clear(pin, latch);
                sense = nrf_gpio_pin_sense_get(pin);

                next_sense_cond_call_handler(pin, trigger, sense);
    4a7a:	f3c2 4201 	ubfx	r2, r2, #16, #2
    4a7e:	f7ff ff37 	bl	48f0 <next_sense_cond_call_handler>
    reg->LATCH = (1 << pin_number);
    4a82:	2301      	movs	r3, #1
    4a84:	40ab      	lsls	r3, r5
    4a86:	6233      	str	r3, [r6, #32]
            while (latch[i])
    4a88:	ab02      	add	r3, sp, #8
    4a8a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    4a8e:	f853 0c08 	ldr.w	r0, [r3, #-8]
    4a92:	b1f8      	cbz	r0, 4ad4 <port_event_handle+0x74>
                uint32_t pin = NRF_CTZ(latch[i]);
    4a94:	fa90 f0a0 	rbit	r0, r0
    4a98:	fab0 f080 	clz	r0, r0
                pin += 32 * i;
    4a9c:	eb00 1044 	add.w	r0, r0, r4, lsl #5
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    4aa0:	f100 0208 	add.w	r2, r0, #8
    4aa4:	4b15      	ldr	r3, [pc, #84]	; (4afc <port_event_handle+0x9c>)
    4aa6:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
    4aaa:	f3c1 0182 	ubfx	r1, r1, #2, #3
 * @param[in,out] p_mask Pointer to mask with bit fields.
 */
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    4aae:	08c5      	lsrs	r5, r0, #3
    bit = BITMASK_RELBIT_GET(bit);
    4ab0:	f000 0607 	and.w	r6, r0, #7
    p_mask8[byte_idx] &= ~(1 << bit);
    4ab4:	f81d 2005 	ldrb.w	r2, [sp, r5]
    4ab8:	2301      	movs	r3, #1
    4aba:	40b3      	lsls	r3, r6
    4abc:	43db      	mvns	r3, r3
    4abe:	b25b      	sxtb	r3, r3
    4ac0:	4013      	ands	r3, r2
    4ac2:	f80d 3005 	strb.w	r3, [sp, r5]
    *p_pin = pin_number & 0x1F;
    4ac6:	f000 051f 	and.w	r5, r0, #31
    return pin_number >> 5;
    4aca:	0943      	lsrs	r3, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    4acc:	2b01      	cmp	r3, #1
    4ace:	d0cf      	beq.n	4a70 <port_event_handle+0x10>
        case 0: return NRF_P0;
    4ad0:	4e0b      	ldr	r6, [pc, #44]	; (4b00 <port_event_handle+0xa0>)
    4ad2:	e7ce      	b.n	4a72 <port_event_handle+0x12>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    4ad4:	3401      	adds	r4, #1
    4ad6:	2c01      	cmp	r4, #1
    4ad8:	d9d6      	bls.n	4a88 <port_event_handle+0x28>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    4ada:	4b0a      	ldr	r3, [pc, #40]	; (4b04 <port_event_handle+0xa4>)
    4adc:	2200      	movs	r2, #0
    4ade:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
    4ae2:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
        }

        /* All pins have been handled, clear PORT, check latch again in case
         * something came between deciding to exit and clearing PORT event. */
        nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
    } while (latch_pending_read_and_check(latch));
    4ae6:	4668      	mov	r0, sp
    4ae8:	f007 f9bb 	bl	be62 <latch_pending_read_and_check>
    4aec:	b108      	cbz	r0, 4af2 <port_event_handle+0x92>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    4aee:	2400      	movs	r4, #0
    4af0:	e7f1      	b.n	4ad6 <port_event_handle+0x76>
}
    4af2:	b002      	add	sp, #8
    4af4:	bd70      	pop	{r4, r5, r6, pc}
    4af6:	bf00      	nop
    4af8:	50842800 	.word	0x50842800
    4afc:	200001d0 	.word	0x200001d0
    4b00:	50842500 	.word	0x50842500
    4b04:	5000d000 	.word	0x5000d000

00004b08 <gpiote_evt_handle>:
    } while (input_read_and_check(input, pins_to_check));
}
#endif // defined(NRF_GPIO_LATCH_PRESENT)

static void gpiote_evt_handle(uint32_t mask)
{
    4b08:	b538      	push	{r3, r4, r5, lr}
    4b0a:	4604      	mov	r4, r0
    while (mask)
    4b0c:	e018      	b.n	4b40 <gpiote_evt_handle+0x38>
    {
        uint32_t ch = NRF_CTZ(mask);
    4b0e:	fa94 f3a4 	rbit	r3, r4
    4b12:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
    4b16:	2201      	movs	r2, #1
    4b18:	409a      	lsls	r2, r3
    4b1a:	ea24 0402 	bic.w	r4, r4, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    4b1e:	4a0a      	ldr	r2, [pc, #40]	; (4b48 <gpiote_evt_handle+0x40>)
    4b20:	f503 73a2 	add.w	r3, r3, #324	; 0x144
    4b24:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
    4b28:	f3c5 2505 	ubfx	r5, r5, #8, #6
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
    4b2c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
        nrfx_gpiote_pin_t pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, ch);
        nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(NRF_GPIOTE, ch);

        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    4b30:	f3c0 4001 	ubfx	r0, r0, #16, #2
    4b34:	f007 f98e 	bl	be54 <gpiote_polarity_to_trigger>
    4b38:	4601      	mov	r1, r0
    4b3a:	4628      	mov	r0, r5
    4b3c:	f7ff fec2 	bl	48c4 <call_handler>
    while (mask)
    4b40:	2c00      	cmp	r4, #0
    4b42:	d1e4      	bne.n	4b0e <gpiote_evt_handle+0x6>
    }
}
    4b44:	bd38      	pop	{r3, r4, r5, pc}
    4b46:	bf00      	nop
    4b48:	5000d000 	.word	0x5000d000

00004b4c <nrfx_gpiote_input_configure>:
{
    4b4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4b50:	b084      	sub	sp, #16
    4b52:	4604      	mov	r4, r0
    4b54:	4615      	mov	r5, r2
    4b56:	461e      	mov	r6, r3
    if (p_input_config)
    4b58:	b309      	cbz	r1, 4b9e <nrfx_gpiote_input_configure+0x52>
    4b5a:	460f      	mov	r7, r1
        if (pin_is_task_output(pin))
    4b5c:	f007 f964 	bl	be28 <pin_is_task_output>
    4b60:	2800      	cmp	r0, #0
    4b62:	d13f      	bne.n	4be4 <nrfx_gpiote_input_configure+0x98>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
    4b64:	2300      	movs	r3, #0
    4b66:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
    4b6a:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
    4b6e:	9301      	str	r3, [sp, #4]
    4b70:	9300      	str	r3, [sp, #0]
    4b72:	463b      	mov	r3, r7
    4b74:	f10d 020f 	add.w	r2, sp, #15
    4b78:	f10d 010e 	add.w	r1, sp, #14
    4b7c:	4620      	mov	r0, r4
    4b7e:	f7ff fd77 	bl	4670 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
    4b82:	4a39      	ldr	r2, [pc, #228]	; (4c68 <nrfx_gpiote_input_configure+0x11c>)
    4b84:	f104 0108 	add.w	r1, r4, #8
    4b88:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    4b8c:	f023 0302 	bic.w	r3, r3, #2
    4b90:	b29b      	uxth	r3, r3
    4b92:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    4b96:	f043 0301 	orr.w	r3, r3, #1
    4b9a:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_trigger_config)
    4b9e:	b1bd      	cbz	r5, 4bd0 <nrfx_gpiote_input_configure+0x84>
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
    4ba0:	782f      	ldrb	r7, [r5, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
    4ba2:	f8d5 8004 	ldr.w	r8, [r5, #4]
        if (pin_is_output(pin))
    4ba6:	4620      	mov	r0, r4
    4ba8:	f7ff fe14 	bl	47d4 <pin_is_output>
    4bac:	b1e0      	cbz	r0, 4be8 <nrfx_gpiote_input_configure+0x9c>
            if (use_evt)
    4bae:	f1b8 0f00 	cmp.w	r8, #0
    4bb2:	d153      	bne.n	4c5c <nrfx_gpiote_input_configure+0x110>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    4bb4:	4a2c      	ldr	r2, [pc, #176]	; (4c68 <nrfx_gpiote_input_configure+0x11c>)
    4bb6:	f104 0108 	add.w	r1, r4, #8
    4bba:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    4bbe:	f023 031c 	bic.w	r3, r3, #28
    4bc2:	b29b      	uxth	r3, r3
    4bc4:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    4bc8:	ea43 0387 	orr.w	r3, r3, r7, lsl #2
    4bcc:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_handler_config)
    4bd0:	2e00      	cmp	r6, #0
    4bd2:	d047      	beq.n	4c64 <nrfx_gpiote_input_configure+0x118>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
    4bd4:	6872      	ldr	r2, [r6, #4]
    4bd6:	6831      	ldr	r1, [r6, #0]
    4bd8:	4620      	mov	r0, r4
    4bda:	f7ff ff0b 	bl	49f4 <pin_handler_set>
}
    4bde:	b004      	add	sp, #16
    4be0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return NRFX_ERROR_INVALID_PARAM;
    4be4:	4821      	ldr	r0, [pc, #132]	; (4c6c <nrfx_gpiote_input_configure+0x120>)
    4be6:	e7fa      	b.n	4bde <nrfx_gpiote_input_configure+0x92>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
    4be8:	4a1f      	ldr	r2, [pc, #124]	; (4c68 <nrfx_gpiote_input_configure+0x11c>)
    4bea:	f104 0108 	add.w	r1, r4, #8
    4bee:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    4bf2:	f023 0320 	bic.w	r3, r3, #32
    4bf6:	04db      	lsls	r3, r3, #19
    4bf8:	0cdb      	lsrs	r3, r3, #19
    4bfa:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
            if (use_evt)
    4bfe:	f1b8 0f00 	cmp.w	r8, #0
    4c02:	d0d7      	beq.n	4bb4 <nrfx_gpiote_input_configure+0x68>
                if (!edge)
    4c04:	2f03      	cmp	r7, #3
    4c06:	d82b      	bhi.n	4c60 <nrfx_gpiote_input_configure+0x114>
                uint8_t ch = *p_trigger_config->p_in_channel;
    4c08:	686b      	ldr	r3, [r5, #4]
    4c0a:	781d      	ldrb	r5, [r3, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
    4c0c:	b947      	cbnz	r7, 4c20 <nrfx_gpiote_input_configure+0xd4>
    p_reg->CONFIG[idx] = 0;
    4c0e:	4b18      	ldr	r3, [pc, #96]	; (4c70 <nrfx_gpiote_input_configure+0x124>)
    4c10:	f505 75a2 	add.w	r5, r5, #324	; 0x144
    4c14:	2200      	movs	r2, #0
    4c16:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
    p_reg->CONFIG[idx] = 0;
    4c1a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
#endif
}
    4c1e:	e7c9      	b.n	4bb4 <nrfx_gpiote_input_configure+0x68>
                    nrf_gpiote_polarity_t polarity = gpiote_trigger_to_polarity(trigger);
    4c20:	4638      	mov	r0, r7
    4c22:	f007 f918 	bl	be56 <gpiote_trigger_to_polarity>
    4c26:	4603      	mov	r3, r0
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    4c28:	4811      	ldr	r0, [pc, #68]	; (4c70 <nrfx_gpiote_input_configure+0x124>)
    4c2a:	f505 71a2 	add.w	r1, r5, #324	; 0x144
    4c2e:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
    4c32:	f022 0203 	bic.w	r2, r2, #3
    4c36:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
                    nrf_gpiote_event_configure(NRF_GPIOTE, ch, pin, polarity);
    4c3a:	4622      	mov	r2, r4
    4c3c:	4629      	mov	r1, r5
    4c3e:	f007 f8ab 	bl	bd98 <nrf_gpiote_event_configure>
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    4c42:	4a09      	ldr	r2, [pc, #36]	; (4c68 <nrfx_gpiote_input_configure+0x11c>)
    4c44:	f104 0108 	add.w	r1, r4, #8
    4c48:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    4c4c:	036d      	lsls	r5, r5, #13
    4c4e:	b2ad      	uxth	r5, r5
    4c50:	432b      	orrs	r3, r5
    4c52:	f043 0320 	orr.w	r3, r3, #32
    4c56:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    4c5a:	e7ab      	b.n	4bb4 <nrfx_gpiote_input_configure+0x68>
                return NRFX_ERROR_INVALID_PARAM;
    4c5c:	4803      	ldr	r0, [pc, #12]	; (4c6c <nrfx_gpiote_input_configure+0x120>)
    4c5e:	e7be      	b.n	4bde <nrfx_gpiote_input_configure+0x92>
                    return NRFX_ERROR_INVALID_PARAM;
    4c60:	4802      	ldr	r0, [pc, #8]	; (4c6c <nrfx_gpiote_input_configure+0x120>)
    4c62:	e7bc      	b.n	4bde <nrfx_gpiote_input_configure+0x92>
        err = NRFX_SUCCESS;
    4c64:	4803      	ldr	r0, [pc, #12]	; (4c74 <nrfx_gpiote_input_configure+0x128>)
    4c66:	e7ba      	b.n	4bde <nrfx_gpiote_input_configure+0x92>
    4c68:	200001d0 	.word	0x200001d0
    4c6c:	0bad0004 	.word	0x0bad0004
    4c70:	5000d000 	.word	0x5000d000
    4c74:	0bad0000 	.word	0x0bad0000

00004c78 <nrfx_gpiote_output_configure>:
{
    4c78:	b570      	push	{r4, r5, r6, lr}
    4c7a:	b084      	sub	sp, #16
    4c7c:	4604      	mov	r4, r0
    4c7e:	4615      	mov	r5, r2
    if (p_config)
    4c80:	b329      	cbz	r1, 4cce <nrfx_gpiote_output_configure+0x56>
    4c82:	460e      	mov	r6, r1
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
    4c84:	f007 f8df 	bl	be46 <pin_is_input>
    4c88:	b120      	cbz	r0, 4c94 <nrfx_gpiote_output_configure+0x1c>
    4c8a:	4620      	mov	r0, r4
    4c8c:	f7ff fd8c 	bl	47a8 <pin_in_use_by_te>
    4c90:	2800      	cmp	r0, #0
    4c92:	d13a      	bne.n	4d0a <nrfx_gpiote_output_configure+0x92>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
    4c94:	4620      	mov	r0, r4
    4c96:	f7ff fd91 	bl	47bc <pin_has_trigger>
    4c9a:	b110      	cbz	r0, 4ca2 <nrfx_gpiote_output_configure+0x2a>
    4c9c:	7873      	ldrb	r3, [r6, #1]
    4c9e:	2b01      	cmp	r3, #1
    4ca0:	d033      	beq.n	4d0a <nrfx_gpiote_output_configure+0x92>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
    4ca2:	2301      	movs	r3, #1
    4ca4:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
    4ca8:	2300      	movs	r3, #0
    4caa:	9301      	str	r3, [sp, #4]
    4cac:	9600      	str	r6, [sp, #0]
    4cae:	1cb3      	adds	r3, r6, #2
    4cb0:	1c72      	adds	r2, r6, #1
    4cb2:	f10d 010f 	add.w	r1, sp, #15
    4cb6:	4620      	mov	r0, r4
    4cb8:	f7ff fcda 	bl	4670 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
    4cbc:	4a20      	ldr	r2, [pc, #128]	; (4d40 <nrfx_gpiote_output_configure+0xc8>)
    4cbe:	f104 0108 	add.w	r1, r4, #8
    4cc2:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    4cc6:	f043 0303 	orr.w	r3, r3, #3
    4cca:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_task_config)
    4cce:	b395      	cbz	r5, 4d36 <nrfx_gpiote_output_configure+0xbe>
        if (pin_is_input(pin))
    4cd0:	4620      	mov	r0, r4
    4cd2:	f007 f8b8 	bl	be46 <pin_is_input>
    4cd6:	bb80      	cbnz	r0, 4d3a <nrfx_gpiote_output_configure+0xc2>
        uint32_t ch = p_task_config->task_ch;
    4cd8:	782e      	ldrb	r6, [r5, #0]
    p_reg->CONFIG[idx] = 0;
    4cda:	4b1a      	ldr	r3, [pc, #104]	; (4d44 <nrfx_gpiote_output_configure+0xcc>)
    4cdc:	f506 72a2 	add.w	r2, r6, #324	; 0x144
    4ce0:	2100      	movs	r1, #0
    4ce2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    p_reg->CONFIG[idx] = 0;
    4ce6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
    4cea:	4a15      	ldr	r2, [pc, #84]	; (4d40 <nrfx_gpiote_output_configure+0xc8>)
    4cec:	f104 0108 	add.w	r1, r4, #8
    4cf0:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    4cf4:	f023 0320 	bic.w	r3, r3, #32
    4cf8:	04db      	lsls	r3, r3, #19
    4cfa:	0cdb      	lsrs	r3, r3, #19
    4cfc:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
    4d00:	786b      	ldrb	r3, [r5, #1]
    4d02:	b923      	cbnz	r3, 4d0e <nrfx_gpiote_output_configure+0x96>
    return NRFX_SUCCESS;
    4d04:	4810      	ldr	r0, [pc, #64]	; (4d48 <nrfx_gpiote_output_configure+0xd0>)
}
    4d06:	b004      	add	sp, #16
    4d08:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_INVALID_PARAM;
    4d0a:	4810      	ldr	r0, [pc, #64]	; (4d4c <nrfx_gpiote_output_configure+0xd4>)
    4d0c:	e7fb      	b.n	4d06 <nrfx_gpiote_output_configure+0x8e>
                                      p_task_config->init_val);
    4d0e:	78aa      	ldrb	r2, [r5, #2]
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
    4d10:	9200      	str	r2, [sp, #0]
    4d12:	4622      	mov	r2, r4
    4d14:	4631      	mov	r1, r6
    4d16:	480b      	ldr	r0, [pc, #44]	; (4d44 <nrfx_gpiote_output_configure+0xcc>)
    4d18:	f007 f857 	bl	bdca <nrf_gpiote_task_configure>
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    4d1c:	4a08      	ldr	r2, [pc, #32]	; (4d40 <nrfx_gpiote_output_configure+0xc8>)
    4d1e:	3408      	adds	r4, #8
    4d20:	f832 3014 	ldrh.w	r3, [r2, r4, lsl #1]
    4d24:	0376      	lsls	r6, r6, #13
    4d26:	b2b6      	uxth	r6, r6
    4d28:	4333      	orrs	r3, r6
    4d2a:	f043 0320 	orr.w	r3, r3, #32
    4d2e:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]
    return NRFX_SUCCESS;
    4d32:	4805      	ldr	r0, [pc, #20]	; (4d48 <nrfx_gpiote_output_configure+0xd0>)
    4d34:	e7e7      	b.n	4d06 <nrfx_gpiote_output_configure+0x8e>
    4d36:	4804      	ldr	r0, [pc, #16]	; (4d48 <nrfx_gpiote_output_configure+0xd0>)
    4d38:	e7e5      	b.n	4d06 <nrfx_gpiote_output_configure+0x8e>
            return NRFX_ERROR_INVALID_PARAM;
    4d3a:	4804      	ldr	r0, [pc, #16]	; (4d4c <nrfx_gpiote_output_configure+0xd4>)
    4d3c:	e7e3      	b.n	4d06 <nrfx_gpiote_output_configure+0x8e>
    4d3e:	bf00      	nop
    4d40:	200001d0 	.word	0x200001d0
    4d44:	5000d000 	.word	0x5000d000
    4d48:	0bad0000 	.word	0x0bad0000
    4d4c:	0bad0004 	.word	0x0bad0004

00004d50 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
    4d50:	4b01      	ldr	r3, [pc, #4]	; (4d58 <nrfx_gpiote_global_callback_set+0x8>)
    4d52:	6098      	str	r0, [r3, #8]
    m_cb.global_handler.p_context = p_context;
    4d54:	60d9      	str	r1, [r3, #12]
}
    4d56:	4770      	bx	lr
    4d58:	200001d0 	.word	0x200001d0

00004d5c <nrfx_gpiote_channel_get>:
{
    4d5c:	b538      	push	{r3, r4, r5, lr}
    4d5e:	4604      	mov	r4, r0
    4d60:	460d      	mov	r5, r1
    if (pin_in_use_by_te(pin))
    4d62:	f7ff fd21 	bl	47a8 <pin_in_use_by_te>
    4d66:	b140      	cbz	r0, 4d7a <nrfx_gpiote_channel_get+0x1e>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    4d68:	f104 0008 	add.w	r0, r4, #8
    4d6c:	4b04      	ldr	r3, [pc, #16]	; (4d80 <nrfx_gpiote_channel_get+0x24>)
    4d6e:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    4d72:	0b5b      	lsrs	r3, r3, #13
    4d74:	702b      	strb	r3, [r5, #0]
        return NRFX_SUCCESS;
    4d76:	4803      	ldr	r0, [pc, #12]	; (4d84 <nrfx_gpiote_channel_get+0x28>)
}
    4d78:	bd38      	pop	{r3, r4, r5, pc}
        return NRFX_ERROR_INVALID_PARAM;
    4d7a:	4803      	ldr	r0, [pc, #12]	; (4d88 <nrfx_gpiote_channel_get+0x2c>)
    4d7c:	e7fc      	b.n	4d78 <nrfx_gpiote_channel_get+0x1c>
    4d7e:	bf00      	nop
    4d80:	200001d0 	.word	0x200001d0
    4d84:	0bad0000 	.word	0x0bad0000
    4d88:	0bad0004 	.word	0x0bad0004

00004d8c <nrfx_gpiote_init>:
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    4d8c:	4b0f      	ldr	r3, [pc, #60]	; (4dcc <nrfx_gpiote_init+0x40>)
    4d8e:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
    4d92:	b10b      	cbz	r3, 4d98 <nrfx_gpiote_init+0xc>
        return err_code;
    4d94:	480e      	ldr	r0, [pc, #56]	; (4dd0 <nrfx_gpiote_init+0x44>)
}
    4d96:	4770      	bx	lr
{
    4d98:	b510      	push	{r4, lr}
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
    4d9a:	4c0e      	ldr	r4, [pc, #56]	; (4dd4 <nrfx_gpiote_init+0x48>)
    4d9c:	2260      	movs	r2, #96	; 0x60
    4d9e:	2100      	movs	r1, #0
    4da0:	4620      	mov	r0, r4
    4da2:	f005 fcba 	bl	a71a <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
    4da6:	200d      	movs	r0, #13
    4da8:	f005 fb64 	bl	a474 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    4dac:	4b0a      	ldr	r3, [pc, #40]	; (4dd8 <nrfx_gpiote_init+0x4c>)
    4dae:	2200      	movs	r2, #0
    4db0:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
    4db4:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
    4db8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    4dbc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    4dc0:	2301      	movs	r3, #1
    4dc2:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
    4dc6:	6663      	str	r3, [r4, #100]	; 0x64
    return err_code;
    4dc8:	4804      	ldr	r0, [pc, #16]	; (4ddc <nrfx_gpiote_init+0x50>)
}
    4dca:	bd10      	pop	{r4, pc}
    4dcc:	200001d0 	.word	0x200001d0
    4dd0:	0bad0005 	.word	0x0bad0005
    4dd4:	200001e0 	.word	0x200001e0
    4dd8:	5000d000 	.word	0x5000d000
    4ddc:	0bad0000 	.word	0x0bad0000

00004de0 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
    4de0:	4b03      	ldr	r3, [pc, #12]	; (4df0 <nrfx_gpiote_is_init+0x10>)
    4de2:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
    4de6:	3800      	subs	r0, #0
    4de8:	bf18      	it	ne
    4dea:	2001      	movne	r0, #1
    4dec:	4770      	bx	lr
    4dee:	bf00      	nop
    4df0:	200001d0 	.word	0x200001d0

00004df4 <nrfx_gpiote_channel_free>:
{
    4df4:	b508      	push	{r3, lr}
    4df6:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
    4df8:	4801      	ldr	r0, [pc, #4]	; (4e00 <nrfx_gpiote_channel_free+0xc>)
    4dfa:	f7ff fba5 	bl	4548 <nrfx_flag32_free>
}
    4dfe:	bd08      	pop	{r3, pc}
    4e00:	20000240 	.word	0x20000240

00004e04 <nrfx_gpiote_channel_alloc>:
{
    4e04:	b508      	push	{r3, lr}
    4e06:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
    4e08:	4801      	ldr	r0, [pc, #4]	; (4e10 <nrfx_gpiote_channel_alloc+0xc>)
    4e0a:	f7ff fb79 	bl	4500 <nrfx_flag32_alloc>
}
    4e0e:	bd08      	pop	{r3, pc}
    4e10:	20000240 	.word	0x20000240

00004e14 <nrfx_gpiote_trigger_enable>:
{
    4e14:	b538      	push	{r3, r4, r5, lr}
    4e16:	4604      	mov	r4, r0
    4e18:	460d      	mov	r5, r1
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    4e1a:	f7ff fcc5 	bl	47a8 <pin_in_use_by_te>
    4e1e:	b300      	cbz	r0, 4e62 <nrfx_gpiote_trigger_enable+0x4e>
    4e20:	4620      	mov	r0, r4
    4e22:	f007 f810 	bl	be46 <pin_is_input>
    4e26:	b1e0      	cbz	r0, 4e62 <nrfx_gpiote_trigger_enable+0x4e>
        uint8_t ch = pin_te_get(pin);
    4e28:	4620      	mov	r0, r4
    4e2a:	f7ff fcdd 	bl	47e8 <pin_te_get>
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
    4e2e:	0083      	lsls	r3, r0, #2
    4e30:	f503 7380 	add.w	r3, r3, #256	; 0x100
    return ((uint32_t)p_reg + event);
    4e34:	b29b      	uxth	r3, r3
    4e36:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    4e3a:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    4e3e:	2200      	movs	r2, #0
    4e40:	601a      	str	r2, [r3, #0]
    4e42:	681b      	ldr	r3, [r3, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    4e44:	4a0b      	ldr	r2, [pc, #44]	; (4e74 <nrfx_gpiote_trigger_enable+0x60>)
    4e46:	f500 71a2 	add.w	r1, r0, #324	; 0x144
    4e4a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    4e4e:	f043 0301 	orr.w	r3, r3, #1
    4e52:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        if (int_enable)
    4e56:	b15d      	cbz	r5, 4e70 <nrfx_gpiote_trigger_enable+0x5c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
    4e58:	2301      	movs	r3, #1
    4e5a:	4083      	lsls	r3, r0
    p_reg->INTENSET = mask;
    4e5c:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    4e60:	e006      	b.n	4e70 <nrfx_gpiote_trigger_enable+0x5c>
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
    4e62:	4620      	mov	r0, r4
    4e64:	f7ff fcf8 	bl	4858 <get_initial_sense>
    4e68:	4601      	mov	r1, r0
    4e6a:	4620      	mov	r0, r4
    4e6c:	f006 ffcc 	bl	be08 <nrf_gpio_cfg_sense_set>
}
    4e70:	bd38      	pop	{r3, r4, r5, pc}
    4e72:	bf00      	nop
    4e74:	5000d000 	.word	0x5000d000

00004e78 <nrfx_gpiote_trigger_disable>:
{
    4e78:	b510      	push	{r4, lr}
    4e7a:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    4e7c:	f7ff fc94 	bl	47a8 <pin_in_use_by_te>
    4e80:	b1a0      	cbz	r0, 4eac <nrfx_gpiote_trigger_disable+0x34>
    4e82:	4620      	mov	r0, r4
    4e84:	f006 ffdf 	bl	be46 <pin_is_input>
    4e88:	b180      	cbz	r0, 4eac <nrfx_gpiote_trigger_disable+0x34>
        uint8_t ch = pin_te_get(pin);
    4e8a:	4620      	mov	r0, r4
    4e8c:	f7ff fcac 	bl	47e8 <pin_te_get>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
    4e90:	2201      	movs	r2, #1
    4e92:	4082      	lsls	r2, r0
    p_reg->INTENCLR = mask;
    4e94:	4b08      	ldr	r3, [pc, #32]	; (4eb8 <nrfx_gpiote_trigger_disable+0x40>)
    4e96:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    4e9a:	f500 70a2 	add.w	r0, r0, #324	; 0x144
    4e9e:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    4ea2:	f022 0203 	bic.w	r2, r2, #3
    4ea6:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
}
    4eaa:	e003      	b.n	4eb4 <nrfx_gpiote_trigger_disable+0x3c>
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
    4eac:	2100      	movs	r1, #0
    4eae:	4620      	mov	r0, r4
    4eb0:	f006 ffaa 	bl	be08 <nrf_gpio_cfg_sense_set>
}
    4eb4:	bd10      	pop	{r4, pc}
    4eb6:	bf00      	nop
    4eb8:	5000d000 	.word	0x5000d000

00004ebc <nrfx_gpiote_pin_uninit>:
{
    4ebc:	b510      	push	{r4, lr}
    4ebe:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
    4ec0:	f7ff fc68 	bl	4794 <pin_in_use>
    4ec4:	b908      	cbnz	r0, 4eca <nrfx_gpiote_pin_uninit+0xe>
        return NRFX_ERROR_INVALID_PARAM;
    4ec6:	4806      	ldr	r0, [pc, #24]	; (4ee0 <nrfx_gpiote_pin_uninit+0x24>)
}
    4ec8:	bd10      	pop	{r4, pc}
    nrfx_gpiote_trigger_disable(pin);
    4eca:	4620      	mov	r0, r4
    4ecc:	f7ff ffd4 	bl	4e78 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
    4ed0:	4620      	mov	r0, r4
    4ed2:	f7ff fd71 	bl	49b8 <pin_handler_trigger_uninit>
    nrf_gpio_cfg_default(pin);
    4ed6:	4620      	mov	r0, r4
    4ed8:	f7ff fc26 	bl	4728 <nrf_gpio_cfg_default>
    return NRFX_SUCCESS;
    4edc:	4801      	ldr	r0, [pc, #4]	; (4ee4 <nrfx_gpiote_pin_uninit+0x28>)
    4ede:	e7f3      	b.n	4ec8 <nrfx_gpiote_pin_uninit+0xc>
    4ee0:	0bad0004 	.word	0x0bad0004
    4ee4:	0bad0000 	.word	0x0bad0000

00004ee8 <nrfx_gpiote_irq_handler>:

void nrfx_gpiote_irq_handler(void)
{
    4ee8:	b538      	push	{r3, r4, r5, lr}
    uint32_t status = 0;
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    4eea:	2001      	movs	r0, #1
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    4eec:	f44f 7380 	mov.w	r3, #256	; 0x100

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    4ef0:	2100      	movs	r1, #0
    uint32_t status = 0;
    4ef2:	460c      	mov	r4, r1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    4ef4:	e003      	b.n	4efe <nrfx_gpiote_irq_handler+0x16>
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
        }
        mask <<= 1;
    4ef6:	0040      	lsls	r0, r0, #1
        /* Incrementing to next event, utilizing the fact that events are grouped together
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    4ef8:	3304      	adds	r3, #4
    4efa:	b29b      	uxth	r3, r3
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    4efc:	3101      	adds	r1, #1
    4efe:	2907      	cmp	r1, #7
    4f00:	d814      	bhi.n	4f2c <nrfx_gpiote_irq_handler+0x44>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    4f02:	f103 42a0 	add.w	r2, r3, #1342177280	; 0x50000000
    4f06:	f502 4250 	add.w	r2, r2, #53248	; 0xd000
    4f0a:	6812      	ldr	r2, [r2, #0]
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
    4f0c:	2a00      	cmp	r2, #0
    4f0e:	d0f2      	beq.n	4ef6 <nrfx_gpiote_irq_handler+0xe>
    return p_reg->INTENSET & mask;
    4f10:	4a0c      	ldr	r2, [pc, #48]	; (4f44 <nrfx_gpiote_irq_handler+0x5c>)
    4f12:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
    4f16:	4210      	tst	r0, r2
    4f18:	d0ed      	beq.n	4ef6 <nrfx_gpiote_irq_handler+0xe>
    return ((uint32_t)p_reg + event);
    4f1a:	f103 42a0 	add.w	r2, r3, #1342177280	; 0x50000000
    4f1e:	f502 4250 	add.w	r2, r2, #53248	; 0xd000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    4f22:	2500      	movs	r5, #0
    4f24:	6015      	str	r5, [r2, #0]
    4f26:	6812      	ldr	r2, [r2, #0]
            status |= mask;
    4f28:	4304      	orrs	r4, r0
    4f2a:	e7e4      	b.n	4ef6 <nrfx_gpiote_irq_handler+0xe>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    4f2c:	4b05      	ldr	r3, [pc, #20]	; (4f44 <nrfx_gpiote_irq_handler+0x5c>)
    4f2e:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
    4f32:	b91b      	cbnz	r3, 4f3c <nrfx_gpiote_irq_handler+0x54>
    {
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
    4f34:	4620      	mov	r0, r4
    4f36:	f7ff fde7 	bl	4b08 <gpiote_evt_handle>
}
    4f3a:	bd38      	pop	{r3, r4, r5, pc}
        port_event_handle();
    4f3c:	f7ff fd90 	bl	4a60 <port_event_handle>
    4f40:	e7f8      	b.n	4f34 <nrfx_gpiote_irq_handler+0x4c>
    4f42:	bf00      	nop
    4f44:	5000d000 	.word	0x5000d000

00004f48 <nvmc_readonly_mode_set>:

#if defined(NVMC_CONFIGNS_WEN_Msk)
NRF_STATIC_INLINE void nrf_nvmc_nonsecure_mode_set(NRF_NVMC_Type *    p_reg,
                                                   nrf_nvmc_ns_mode_t mode)
{
    p_reg->CONFIGNS = (uint32_t)mode;
    4f48:	4b03      	ldr	r3, [pc, #12]	; (4f58 <nvmc_readonly_mode_set+0x10>)
    4f4a:	2200      	movs	r2, #0
    4f4c:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
    p_reg->CONFIG = (uint32_t)mode;
    4f50:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    nrf_nvmc_nonsecure_mode_set(NRF_NVMC, NRF_NVMC_NS_MODE_READONLY);
#endif
#if !defined(NRF_TRUSTZONE_NONSECURE)
    nrf_nvmc_mode_set(NRF_NVMC, NRF_NVMC_MODE_READONLY);
#endif
}
    4f54:	4770      	bx	lr
    4f56:	bf00      	nop
    4f58:	50039000 	.word	0x50039000

00004f5c <nvmc_write_mode_set>:
    p_reg->CONFIGNS = (uint32_t)mode;
    4f5c:	4b03      	ldr	r3, [pc, #12]	; (4f6c <nvmc_write_mode_set+0x10>)
    4f5e:	2201      	movs	r2, #1
    4f60:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
    p_reg->CONFIG = (uint32_t)mode;
    4f64:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    nrf_nvmc_nonsecure_mode_set(NRF_NVMC, NRF_NVMC_NS_MODE_WRITE);
#endif
#if !defined(NRF_TRUSTZONE_NONSECURE)
    nrf_nvmc_mode_set(NRF_NVMC, NRF_NVMC_MODE_WRITE);
#endif
}
    4f68:	4770      	bx	lr
    4f6a:	bf00      	nop
    4f6c:	50039000 	.word	0x50039000

00004f70 <nvmc_erase_mode_set>:
    p_reg->CONFIGNS = (uint32_t)mode;
    4f70:	4b03      	ldr	r3, [pc, #12]	; (4f80 <nvmc_erase_mode_set+0x10>)
    4f72:	2202      	movs	r2, #2
    4f74:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
    p_reg->CONFIG = (uint32_t)mode;
    4f78:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    nrf_nvmc_nonsecure_mode_set(NRF_NVMC, NRF_NVMC_NS_MODE_ERASE);
#endif
#if !defined(NRF_TRUSTZONE_NONSECURE)
    nrf_nvmc_mode_set(NRF_NVMC, NRF_NVMC_MODE_ERASE);
#endif
}
    4f7c:	4770      	bx	lr
    4f7e:	bf00      	nop
    4f80:	50039000 	.word	0x50039000

00004f84 <nvmc_word_write>:
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    4f84:	4b04      	ldr	r3, [pc, #16]	; (4f98 <nvmc_word_write+0x14>)
    4f86:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
{
#if defined(NRF91_SERIES)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    4f8a:	f013 0f01 	tst.w	r3, #1
    4f8e:	d0f9      	beq.n	4f84 <nvmc_word_write>
    {}
#endif

    *(volatile uint32_t *)addr = value;
    4f90:	6001      	str	r1, [r0, #0]
    4f92:	f3bf 8f5f 	dmb	sy
    __DMB();
}
    4f96:	4770      	bx	lr
    4f98:	50039000 	.word	0x50039000

00004f9c <nrfx_nvmc_page_erase>:
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    4f9c:	b510      	push	{r4, lr}
    4f9e:	4604      	mov	r4, r0
    NRFX_ASSERT(is_valid_address(addr, false));

    if (!is_page_aligned_check(addr))
    4fa0:	f006 ff81 	bl	bea6 <is_page_aligned_check>
    4fa4:	b908      	cbnz	r0, 4faa <nrfx_nvmc_page_erase+0xe>
    {
        return NRFX_ERROR_INVALID_ADDR;
    4fa6:	4808      	ldr	r0, [pc, #32]	; (4fc8 <nrfx_nvmc_page_erase+0x2c>)
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
}
    4fa8:	bd10      	pop	{r4, pc}
    nvmc_erase_mode_set();
    4faa:	f7ff ffe1 	bl	4f70 <nvmc_erase_mode_set>
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
#elif defined(NRF53_SERIES) || defined(NRF91_SERIES)
    *(volatile uint32_t *)page_addr = 0xFFFFFFFF;
    4fae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4fb2:	6023      	str	r3, [r4, #0]
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    4fb4:	4b05      	ldr	r3, [pc, #20]	; (4fcc <nrfx_nvmc_page_erase+0x30>)
    4fb6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    4fba:	f013 0f01 	tst.w	r3, #1
    4fbe:	d0f9      	beq.n	4fb4 <nrfx_nvmc_page_erase+0x18>
    nvmc_readonly_mode_set();
    4fc0:	f7ff ffc2 	bl	4f48 <nvmc_readonly_mode_set>
    return NRFX_SUCCESS;
    4fc4:	4802      	ldr	r0, [pc, #8]	; (4fd0 <nrfx_nvmc_page_erase+0x34>)
    4fc6:	e7ef      	b.n	4fa8 <nrfx_nvmc_page_erase+0xc>
    4fc8:	0bad000a 	.word	0x0bad000a
    4fcc:	50039000 	.word	0x50039000
    4fd0:	0bad0000 	.word	0x0bad0000

00004fd4 <nrf_gpio_cfg>:
{
    4fd4:	b430      	push	{r4, r5}
    *p_pin = pin_number & 0x1F;
    4fd6:	f000 0c1f 	and.w	ip, r0, #31
    return pin_number >> 5;
    4fda:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    4fdc:	2801      	cmp	r0, #1
    4fde:	d018      	beq.n	5012 <nrf_gpio_cfg+0x3e>
        case 0: return NRF_P0;
    4fe0:	4d0d      	ldr	r5, [pc, #52]	; (5018 <nrf_gpio_cfg+0x44>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    4fe2:	f10c 0080 	add.w	r0, ip, #128	; 0x80
    4fe6:	f855 4020 	ldr.w	r4, [r5, r0, lsl #2]
    4fea:	f004 4ce0 	and.w	ip, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    4fee:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos) |
    4ff2:	ea41 0383 	orr.w	r3, r1, r3, lsl #2
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    4ff6:	f89d 2008 	ldrb.w	r2, [sp, #8]
    4ffa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
    4ffe:	f89d 200c 	ldrb.w	r2, [sp, #12]
    5002:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    5006:	ea43 030c 	orr.w	r3, r3, ip
    reg->PIN_CNF[pin_number] = cnf;
    500a:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
}
    500e:	bc30      	pop	{r4, r5}
    5010:	4770      	bx	lr
        case 1: return NRF_P1;
    5012:	4d02      	ldr	r5, [pc, #8]	; (501c <nrf_gpio_cfg+0x48>)
    5014:	e7e5      	b.n	4fe2 <nrf_gpio_cfg+0xe>
    5016:	bf00      	nop
    5018:	50842500 	.word	0x50842500
    501c:	50842800 	.word	0x50842800

00005020 <nrf_gpio_cfg_default>:
    *p_pin = pin_number & 0x1F;
    5020:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    5024:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    5026:	2801      	cmp	r0, #1
    5028:	d00a      	beq.n	5040 <nrf_gpio_cfg_default+0x20>
        case 0: return NRF_P0;
    502a:	4906      	ldr	r1, [pc, #24]	; (5044 <nrf_gpio_cfg_default+0x24>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    502c:	3280      	adds	r2, #128	; 0x80
    502e:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    5032:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    5036:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
    503a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    503e:	4770      	bx	lr
        case 1: return NRF_P1;
    5040:	4901      	ldr	r1, [pc, #4]	; (5048 <nrf_gpio_cfg_default+0x28>)
    5042:	e7f3      	b.n	502c <nrf_gpio_cfg_default+0xc>
    5044:	50842500 	.word	0x50842500
    5048:	50842800 	.word	0x50842800

0000504c <nrf_gpio_pin_write>:
    if (value == 0)
    504c:	b959      	cbnz	r1, 5066 <nrf_gpio_pin_write+0x1a>
    *p_pin = pin_number & 0x1F;
    504e:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
    5052:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    5054:	2801      	cmp	r0, #1
    5056:	d004      	beq.n	5062 <nrf_gpio_pin_write+0x16>
        case 0: return NRF_P0;
    5058:	4a09      	ldr	r2, [pc, #36]	; (5080 <nrf_gpio_pin_write+0x34>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    505a:	2301      	movs	r3, #1
    505c:	408b      	lsls	r3, r1
    p_reg->OUTCLR = clr_mask;
    505e:	60d3      	str	r3, [r2, #12]
}
    5060:	4770      	bx	lr
        case 1: return NRF_P1;
    5062:	4a08      	ldr	r2, [pc, #32]	; (5084 <nrf_gpio_pin_write+0x38>)
    5064:	e7f9      	b.n	505a <nrf_gpio_pin_write+0xe>
    *p_pin = pin_number & 0x1F;
    5066:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
    506a:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    506c:	2801      	cmp	r0, #1
    506e:	d004      	beq.n	507a <nrf_gpio_pin_write+0x2e>
        case 0: return NRF_P0;
    5070:	4a03      	ldr	r2, [pc, #12]	; (5080 <nrf_gpio_pin_write+0x34>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    5072:	2301      	movs	r3, #1
    5074:	408b      	lsls	r3, r1
    p_reg->OUTSET = set_mask;
    5076:	6093      	str	r3, [r2, #8]
}
    5078:	4770      	bx	lr
        case 1: return NRF_P1;
    507a:	4a02      	ldr	r2, [pc, #8]	; (5084 <nrf_gpio_pin_write+0x38>)
    507c:	e7f9      	b.n	5072 <nrf_gpio_pin_write+0x26>
    507e:	bf00      	nop
    5080:	50842500 	.word	0x50842500
    5084:	50842800 	.word	0x50842800

00005088 <configure_pins>:
    p_cb->transfer_in_progress = false;
}

static void configure_pins(nrfx_spim_t const *        p_instance,
                           nrfx_spim_config_t const * p_config)
{
    5088:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    508c:	b082      	sub	sp, #8
    508e:	4605      	mov	r5, r0
    5090:	460c      	mov	r4, r1
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    5092:	6806      	ldr	r6, [r0, #0]

    if (!p_config->skip_gpio_cfg)
    5094:	7ccb      	ldrb	r3, [r1, #19]
    5096:	2b00      	cmp	r3, #0
    5098:	d160      	bne.n	515c <configure_pins+0xd4>
    {
        // Configure pin drive - high drive for 32 MHz clock frequency.
        nrf_gpio_pin_drive_t pin_drive;
#if NRF_SPIM_HAS_32_MHZ_FREQ
        pin_drive = (p_config->frequency == NRF_SPIM_FREQ_32M)
    509a:	688b      	ldr	r3, [r1, #8]
                    ? NRF_GPIO_PIN_H0H1
                    : NRF_GPIO_PIN_S0S1;
    509c:	f1b3 5fa0 	cmp.w	r3, #335544320	; 0x14000000
    50a0:	d07f      	beq.n	51a2 <configure_pins+0x11a>
    50a2:	f04f 0800 	mov.w	r8, #0
        //   used: 0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3
        //   (CPOL = 1);
        //   according to the reference manual guidelines, this pin and its
        //   input buffer must always be connected for the SPI to work
        nrf_gpio_pin_write(p_config->sck_pin,
                           p_config->mode <= NRF_SPIM_MODE_1 ? 0 : 1);
    50a6:	7b21      	ldrb	r1, [r4, #12]
        nrf_gpio_pin_write(p_config->sck_pin,
    50a8:	2901      	cmp	r1, #1
    50aa:	bf94      	ite	ls
    50ac:	2100      	movls	r1, #0
    50ae:	2101      	movhi	r1, #1
    50b0:	7820      	ldrb	r0, [r4, #0]
    50b2:	f7ff ffcb 	bl	504c <nrf_gpio_pin_write>
        nrf_gpio_cfg(p_config->sck_pin,
    50b6:	7823      	ldrb	r3, [r4, #0]
    *p_pin = pin_number & 0x1F;
    50b8:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    50bc:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    50be:	2b01      	cmp	r3, #1
    50c0:	d072      	beq.n	51a8 <configure_pins+0x120>
        case 0: return NRF_P0;
    50c2:	495d      	ldr	r1, [pc, #372]	; (5238 <configure_pins+0x1b0>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    50c4:	3280      	adds	r2, #128	; 0x80
    50c6:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    50ca:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
    50ce:	ea4f 2708 	mov.w	r7, r8, lsl #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    50d2:	f047 0001 	orr.w	r0, r7, #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    50d6:	4303      	orrs	r3, r0
    reg->PIN_CNF[pin_number] = cnf;
    50d8:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
                     NRF_GPIO_PIN_INPUT_CONNECT,
                     NRF_GPIO_PIN_NOPULL,
                     pin_drive,
                     NRF_GPIO_PIN_NOSENSE);
        // - MOSI (optional) - output with initial value 0
        if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
    50dc:	7863      	ldrb	r3, [r4, #1]
    50de:	2bff      	cmp	r3, #255	; 0xff
    50e0:	d019      	beq.n	5116 <configure_pins+0x8e>
    *p_pin = pin_number & 0x1F;
    50e2:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    50e6:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    50e8:	2b01      	cmp	r3, #1
    50ea:	d05f      	beq.n	51ac <configure_pins+0x124>
        case 0: return NRF_P0;
    50ec:	4952      	ldr	r1, [pc, #328]	; (5238 <configure_pins+0x1b0>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    50ee:	2301      	movs	r3, #1
    50f0:	4093      	lsls	r3, r2
    p_reg->OUTCLR = clr_mask;
    50f2:	60cb      	str	r3, [r1, #12]
        {
            nrf_gpio_pin_write(p_config->mosi_pin, 0);
            nrf_gpio_cfg(p_config->mosi_pin,
    50f4:	7863      	ldrb	r3, [r4, #1]
    *p_pin = pin_number & 0x1F;
    50f6:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    50fa:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    50fc:	2b01      	cmp	r3, #1
    50fe:	d057      	beq.n	51b0 <configure_pins+0x128>
        case 0: return NRF_P0;
    5100:	494d      	ldr	r1, [pc, #308]	; (5238 <configure_pins+0x1b0>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    5102:	3280      	adds	r2, #128	; 0x80
    5104:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    5108:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    510c:	f047 0003 	orr.w	r0, r7, #3
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    5110:	4303      	orrs	r3, r0
    reg->PIN_CNF[pin_number] = cnf;
    5112:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
                         NRF_GPIO_PIN_NOPULL,
                         pin_drive,
                         NRF_GPIO_PIN_NOSENSE);
        }
        // - MISO (optional) - input
        if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
    5116:	78a0      	ldrb	r0, [r4, #2]
    5118:	28ff      	cmp	r0, #255	; 0xff
    511a:	d14b      	bne.n	51b4 <configure_pins+0x12c>
                         p_config->miso_pull,
                         pin_drive,
                         NRF_GPIO_PIN_NOSENSE);
        }
        // - Slave Select (optional) - output, initially inactive
        if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    511c:	78e0      	ldrb	r0, [r4, #3]
    511e:	28ff      	cmp	r0, #255	; 0xff
    5120:	d151      	bne.n	51c6 <configure_pins+0x13e>
                         pin_drive,
                         NRF_GPIO_PIN_NOSENSE);
        }
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        // - DCX (optional) - output.
        if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
    5122:	7be3      	ldrb	r3, [r4, #15]
    5124:	2bff      	cmp	r3, #255	; 0xff
    5126:	d019      	beq.n	515c <configure_pins+0xd4>
    *p_pin = pin_number & 0x1F;
    5128:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    512c:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    512e:	2b01      	cmp	r3, #1
    5130:	d062      	beq.n	51f8 <configure_pins+0x170>
        case 0: return NRF_P0;
    5132:	4941      	ldr	r1, [pc, #260]	; (5238 <configure_pins+0x1b0>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    5134:	2301      	movs	r3, #1
    5136:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    5138:	608b      	str	r3, [r1, #8]
        {
            nrf_gpio_pin_write(p_config->dcx_pin, 1);
            nrf_gpio_cfg(p_config->dcx_pin,
    513a:	7be3      	ldrb	r3, [r4, #15]
    *p_pin = pin_number & 0x1F;
    513c:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    5140:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    5142:	2b01      	cmp	r3, #1
    5144:	d05a      	beq.n	51fc <configure_pins+0x174>
        case 0: return NRF_P0;
    5146:	493c      	ldr	r1, [pc, #240]	; (5238 <configure_pins+0x1b0>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    5148:	3280      	adds	r2, #128	; 0x80
    514a:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    514e:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    5152:	f047 0703 	orr.w	r7, r7, #3
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    5156:	433b      	orrs	r3, r7
    reg->PIN_CNF[pin_number] = cnf;
    5158:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
                         NRF_GPIO_PIN_NOSENSE);
        }
#endif
    }

    if (!p_config->skip_psel_cfg)
    515c:	7d23      	ldrb	r3, [r4, #20]
    515e:	2b00      	cmp	r3, #0
    5160:	d164      	bne.n	522c <configure_pins+0x1a4>
    {
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
    5162:	7863      	ldrb	r3, [r4, #1]
                            ? p_config->mosi_pin
                            : NRF_SPIM_PIN_NOT_CONNECTED;
    5164:	2bff      	cmp	r3, #255	; 0xff
    5166:	d04b      	beq.n	5200 <configure_pins+0x178>
    5168:	461a      	mov	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
    516a:	78a3      	ldrb	r3, [r4, #2]
                            ? p_config->miso_pin
                            : NRF_SPIM_PIN_NOT_CONNECTED;
    516c:	2bff      	cmp	r3, #255	; 0xff
    516e:	d04a      	beq.n	5206 <configure_pins+0x17e>

        nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
    5170:	7821      	ldrb	r1, [r4, #0]
NRF_STATIC_INLINE void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
                                         uint32_t        sck_pin,
                                         uint32_t        mosi_pin,
                                         uint32_t        miso_pin)
{
    p_reg->PSEL.SCK  = sck_pin;
    5172:	f8c6 1508 	str.w	r1, [r6, #1288]	; 0x508
    p_reg->PSEL.MOSI = mosi_pin;
    5176:	f8c6 250c 	str.w	r2, [r6, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
    517a:	f8c6 3510 	str.w	r3, [r6, #1296]	; 0x510

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx))
    517e:	792b      	ldrb	r3, [r5, #4]
    5180:	2b00      	cmp	r3, #0
    5182:	d14c      	bne.n	521e <configure_pins+0x196>
        {
            if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED &&
    5184:	78e3      	ldrb	r3, [r4, #3]
    5186:	2bff      	cmp	r3, #255	; 0xff
    5188:	d040      	beq.n	520c <configure_pins+0x184>
                p_config->use_hw_ss)
    518a:	7c62      	ldrb	r2, [r4, #17]
            if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED &&
    518c:	2a00      	cmp	r2, #0
    518e:	d03d      	beq.n	520c <configure_pins+0x184>
            {
                nrf_spim_csn_configure(p_spim,
                                    p_config->ss_pin,
                                    (p_config->ss_active_high == true
    5190:	7921      	ldrb	r1, [r4, #4]
                                        ? NRF_SPIM_CSN_POL_HIGH
                                        : NRF_SPIM_CSN_POL_LOW),
                                    p_config->ss_duration);
    5192:	7ca2      	ldrb	r2, [r4, #18]
NRF_STATIC_INLINE void nrf_spim_csn_configure(NRF_SPIM_Type *    p_reg,
                                              uint32_t           pin,
                                              nrf_spim_csn_pol_t polarity,
                                              uint32_t           duration)
{
    p_reg->PSEL.CSN = pin;
    5194:	f8c6 3514 	str.w	r3, [r6, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
    5198:	f8c6 1568 	str.w	r1, [r6, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
    519c:	f8c6 2564 	str.w	r2, [r6, #1380]	; 0x564
}
    51a0:	e03d      	b.n	521e <configure_pins+0x196>
                    : NRF_GPIO_PIN_S0S1;
    51a2:	f04f 0803 	mov.w	r8, #3
    51a6:	e77e      	b.n	50a6 <configure_pins+0x1e>
        case 1: return NRF_P1;
    51a8:	4924      	ldr	r1, [pc, #144]	; (523c <configure_pins+0x1b4>)
    51aa:	e78b      	b.n	50c4 <configure_pins+0x3c>
    51ac:	4923      	ldr	r1, [pc, #140]	; (523c <configure_pins+0x1b4>)
    51ae:	e79e      	b.n	50ee <configure_pins+0x66>
    51b0:	4922      	ldr	r1, [pc, #136]	; (523c <configure_pins+0x1b4>)
    51b2:	e7a6      	b.n	5102 <configure_pins+0x7a>
            nrf_gpio_cfg(p_config->miso_pin,
    51b4:	2100      	movs	r1, #0
    51b6:	9101      	str	r1, [sp, #4]
    51b8:	f8cd 8000 	str.w	r8, [sp]
    51bc:	7ba3      	ldrb	r3, [r4, #14]
    51be:	460a      	mov	r2, r1
    51c0:	f7ff ff08 	bl	4fd4 <nrf_gpio_cfg>
    51c4:	e7aa      	b.n	511c <configure_pins+0x94>
                               p_config->ss_active_high ? 0 : 1);
    51c6:	7921      	ldrb	r1, [r4, #4]
            nrf_gpio_pin_write(p_config->ss_pin,
    51c8:	f081 0101 	eor.w	r1, r1, #1
    51cc:	f7ff ff3e 	bl	504c <nrf_gpio_pin_write>
            nrf_gpio_cfg(p_config->ss_pin,
    51d0:	78e3      	ldrb	r3, [r4, #3]
    *p_pin = pin_number & 0x1F;
    51d2:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    51d6:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    51d8:	2b01      	cmp	r3, #1
    51da:	d00b      	beq.n	51f4 <configure_pins+0x16c>
        case 0: return NRF_P0;
    51dc:	4916      	ldr	r1, [pc, #88]	; (5238 <configure_pins+0x1b0>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
    51de:	3280      	adds	r2, #128	; 0x80
    51e0:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    51e4:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    51e8:	f047 0003 	orr.w	r0, r7, #3
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    51ec:	4303      	orrs	r3, r0
    reg->PIN_CNF[pin_number] = cnf;
    51ee:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    51f2:	e796      	b.n	5122 <configure_pins+0x9a>
        case 1: return NRF_P1;
    51f4:	4911      	ldr	r1, [pc, #68]	; (523c <configure_pins+0x1b4>)
    51f6:	e7f2      	b.n	51de <configure_pins+0x156>
    51f8:	4910      	ldr	r1, [pc, #64]	; (523c <configure_pins+0x1b4>)
    51fa:	e79b      	b.n	5134 <configure_pins+0xac>
    51fc:	490f      	ldr	r1, [pc, #60]	; (523c <configure_pins+0x1b4>)
    51fe:	e7a3      	b.n	5148 <configure_pins+0xc0>
                            : NRF_SPIM_PIN_NOT_CONNECTED;
    5200:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    5204:	e7b1      	b.n	516a <configure_pins+0xe2>
                            : NRF_SPIM_PIN_NOT_CONNECTED;
    5206:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    520a:	e7b1      	b.n	5170 <configure_pins+0xe8>
    p_reg->PSEL.CSN = pin;
    520c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5210:	f8c6 3514 	str.w	r3, [r6, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
    5214:	2300      	movs	r3, #0
    5216:	f8c6 3568 	str.w	r3, [r6, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
    521a:	f8c6 3564 	str.w	r3, [r6, #1380]	; 0x564
                                       NRF_SPIM_CSN_POL_LOW,
                                       0);
            }
        }

        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
    521e:	792b      	ldrb	r3, [r5, #4]
    5220:	b923      	cbnz	r3, 522c <configure_pins+0x1a4>
        {
            uint32_t dcx_pin = (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
    5222:	7be3      	ldrb	r3, [r4, #15]
                               ? p_config->dcx_pin
                               : NRF_SPIM_PIN_NOT_CONNECTED;
    5224:	2bff      	cmp	r3, #255	; 0xff
    5226:	d004      	beq.n	5232 <configure_pins+0x1aa>

#if NRF_SPIM_DCX_PRESENT
NRF_STATIC_INLINE void nrf_spim_dcx_pin_set(NRF_SPIM_Type * p_reg,
                                            uint32_t        dcx_pin)
{
    p_reg->PSELDCX = dcx_pin;
    5228:	f8c6 356c 	str.w	r3, [r6, #1388]	; 0x56c
            nrf_spim_dcx_pin_set(p_spim, dcx_pin);
        }
#endif
    }
}
    522c:	b002      	add	sp, #8
    522e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                               : NRF_SPIM_PIN_NOT_CONNECTED;
    5232:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5236:	e7f7      	b.n	5228 <configure_pins+0x1a0>
    5238:	50842500 	.word	0x50842500
    523c:	50842800 	.word	0x50842800

00005240 <spim_xfer>:

static nrfx_err_t spim_xfer(NRF_SPIM_Type               * p_spim,
                            spim_control_block_t        * p_cb,
                            nrfx_spim_xfer_desc_t const * p_xfer_desc,
                            uint32_t                      flags)
{
    5240:	b570      	push	{r4, r5, r6, lr}
    5242:	4604      	mov	r4, r0
    5244:	460e      	mov	r6, r1
    5246:	461d      	mov	r5, r3
    nrfx_err_t err_code;
    // EasyDMA requires that transfer buffers are placed in Data RAM region;
    // signal error if they are not.
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
    5248:	6813      	ldr	r3, [r2, #0]
    524a:	b123      	cbz	r3, 5256 <spim_xfer+0x16>
    524c:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
    5250:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    5254:	d106      	bne.n	5264 <spim_xfer+0x24>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
    5256:	6891      	ldr	r1, [r2, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
    5258:	b141      	cbz	r1, 526c <spim_xfer+0x2c>
    525a:	f001 4160 	and.w	r1, r1, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
    525e:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
    5262:	d003      	beq.n	526c <spim_xfer+0x2c>
    {
        p_cb->transfer_in_progress = false;
    5264:	2300      	movs	r3, #0
    5266:	7773      	strb	r3, [r6, #29]
        err_code = NRFX_ERROR_INVALID_ADDR;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    5268:	4818      	ldr	r0, [pc, #96]	; (52cc <spim_xfer+0x8c>)
        spim_int_enable(p_spim, !(flags & NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER));
    }
    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    526a:	bd70      	pop	{r4, r5, r6, pc}
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
    526c:	6851      	ldr	r1, [r2, #4]

NRF_STATIC_INLINE void nrf_spim_tx_buffer_set(NRF_SPIM_Type * p_reg,
                                              uint8_t const * p_buffer,
                                              size_t          length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    526e:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    5272:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
    5276:	6891      	ldr	r1, [r2, #8]
    5278:	68d3      	ldr	r3, [r2, #12]

NRF_STATIC_INLINE void nrf_spim_rx_buffer_set(NRF_SPIM_Type * p_reg,
                                              uint8_t * p_buffer,
                                              size_t    length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    527a:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    527e:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    5282:	2300      	movs	r3, #0
    5284:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
    5288:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
    spim_list_enable_handle(p_spim, flags);
    528c:	4629      	mov	r1, r5
    528e:	4620      	mov	r0, r4
    5290:	f006 fe71 	bl	bf76 <spim_list_enable_handle>
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
    5294:	f015 0208 	ands.w	r2, r5, #8
    5298:	d101      	bne.n	529e <spim_xfer+0x5e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    529a:	2301      	movs	r3, #1
    529c:	6123      	str	r3, [r4, #16]
    if (!p_cb->handler)
    529e:	6833      	ldr	r3, [r6, #0]
    52a0:	b14b      	cbz	r3, 52b6 <spim_xfer+0x76>
        spim_int_enable(p_spim, !(flags & NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER));
    52a2:	f015 0f04 	tst.w	r5, #4
    52a6:	bf0c      	ite	eq
    52a8:	2101      	moveq	r1, #1
    52aa:	2100      	movne	r1, #0
    52ac:	4620      	mov	r0, r4
    52ae:	f006 fe59 	bl	bf64 <spim_int_enable>
    return err_code;
    52b2:	4807      	ldr	r0, [pc, #28]	; (52d0 <spim_xfer+0x90>)
    52b4:	e7d9      	b.n	526a <spim_xfer+0x2a>
        if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
    52b6:	b91a      	cbnz	r2, 52c0 <spim_xfer+0x80>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    52b8:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
    52bc:	2b00      	cmp	r3, #0
    52be:	d0fb      	beq.n	52b8 <spim_xfer+0x78>
        set_ss_pin_state(p_cb, false);
    52c0:	2100      	movs	r1, #0
    52c2:	4630      	mov	r0, r6
    52c4:	f006 fe30 	bl	bf28 <set_ss_pin_state>
    return err_code;
    52c8:	4801      	ldr	r0, [pc, #4]	; (52d0 <spim_xfer+0x90>)
    52ca:	e7ce      	b.n	526a <spim_xfer+0x2a>
    52cc:	0bad000a 	.word	0x0bad000a
    52d0:	0bad0000 	.word	0x0bad0000

000052d4 <nrfx_spim_init>:
{
    52d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    52d8:	460c      	mov	r4, r1
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    52da:	7906      	ldrb	r6, [r0, #4]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    52dc:	6807      	ldr	r7, [r0, #0]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    52de:	4946      	ldr	r1, [pc, #280]	; (53f8 <nrfx_spim_init+0x124>)
    52e0:	eb01 1146 	add.w	r1, r1, r6, lsl #5
    52e4:	7f09      	ldrb	r1, [r1, #28]
    52e6:	2900      	cmp	r1, #0
    52e8:	d179      	bne.n	53de <nrfx_spim_init+0x10a>
    52ea:	4605      	mov	r5, r0
    if (
    52ec:	2e00      	cmp	r6, #0
    52ee:	d179      	bne.n	53e4 <nrfx_spim_init+0x110>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
    52f0:	68a1      	ldr	r1, [r4, #8]
    52f2:	f1b1 6f20 	cmp.w	r1, #167772160	; 0xa000000
    52f6:	d04b      	beq.n	5390 <nrfx_spim_init+0xbc>
    52f8:	f1b1 5fa0 	cmp.w	r1, #335544320	; 0x14000000
    52fc:	d048      	beq.n	5390 <nrfx_spim_init+0xbc>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
    52fe:	f894 c00f 	ldrb.w	ip, [r4, #15]
    if (!(p_config->skip_gpio_cfg && p_config->skip_psel_cfg) &&
    5302:	7ce0      	ldrb	r0, [r4, #19]
    5304:	b108      	cbz	r0, 530a <nrfx_spim_init+0x36>
    5306:	7d20      	ldrb	r0, [r4, #20]
    5308:	b910      	cbnz	r0, 5310 <nrfx_spim_init+0x3c>
    530a:	483c      	ldr	r0, [pc, #240]	; (53fc <nrfx_spim_init+0x128>)
    530c:	4287      	cmp	r7, r0
    530e:	d047      	beq.n	53a0 <nrfx_spim_init+0xcc>
    p_cb->handler = handler;
    5310:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 53f8 <nrfx_spim_init+0x124>
    5314:	ea4f 1846 	mov.w	r8, r6, lsl #5
    5318:	eb09 1146 	add.w	r1, r9, r6, lsl #5
    531c:	f849 2008 	str.w	r2, [r9, r8]
    p_cb->p_context = p_context;
    5320:	604b      	str	r3, [r1, #4]
    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
    5322:	7ce0      	ldrb	r0, [r4, #19]
    5324:	7f8a      	ldrb	r2, [r1, #30]
    5326:	f360 0200 	bfi	r2, r0, #0, #1
    532a:	778a      	strb	r2, [r1, #30]
    p_cb->ss_active_high = p_config->ss_active_high;
    532c:	7920      	ldrb	r0, [r4, #4]
    532e:	b2d2      	uxtb	r2, r2
    5330:	f360 0241 	bfi	r2, r0, #1, #1
    5334:	778a      	strb	r2, [r1, #30]
    p_cb->use_hw_ss = p_config->use_hw_ss;
    5336:	7c60      	ldrb	r0, [r4, #17]
    5338:	b2d2      	uxtb	r2, r2
    533a:	f360 0282 	bfi	r2, r0, #2, #1
    533e:	778a      	strb	r2, [r1, #30]
    p_cb->ss_pin = p_config->ss_pin;
    5340:	78e3      	ldrb	r3, [r4, #3]
    5342:	77cb      	strb	r3, [r1, #31]
    configure_pins(p_instance, p_config);
    5344:	4621      	mov	r1, r4
    5346:	4628      	mov	r0, r5
    5348:	f7ff fe9e 	bl	5088 <configure_pins>
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
    534c:	7c23      	ldrb	r3, [r4, #16]
    p_reg->IFTIMING.RXDELAY = rxdelay;
    534e:	f8c7 3560 	str.w	r3, [r7, #1376]	; 0x560
    nrf_spim_frequency_set(p_spim, p_config->frequency);
    5352:	68a3      	ldr	r3, [r4, #8]
    p_reg->FREQUENCY = (uint32_t)frequency;
    5354:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
    5358:	7b62      	ldrb	r2, [r4, #13]
    535a:	7b21      	ldrb	r1, [r4, #12]
    535c:	4638      	mov	r0, r7
    535e:	f006 fdc6 	bl	beee <nrf_spim_configure>
    nrf_spim_orc_set(p_spim, p_config->orc);
    5362:	79a3      	ldrb	r3, [r4, #6]
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
    5364:	f8c7 35c0 	str.w	r3, [r7, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
    5368:	2307      	movs	r3, #7
    536a:	f8c7 3500 	str.w	r3, [r7, #1280]	; 0x500
    if (p_cb->handler)
    536e:	f859 3008 	ldr.w	r3, [r9, r8]
    5372:	b123      	cbz	r3, 537e <nrfx_spim_init+0xaa>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    5374:	6828      	ldr	r0, [r5, #0]
    5376:	f340 3007 	sbfx	r0, r0, #12, #8
    537a:	f005 f87b 	bl	a474 <arch_irq_enable>
    p_cb->transfer_in_progress = false;
    537e:	4b1e      	ldr	r3, [pc, #120]	; (53f8 <nrfx_spim_init+0x124>)
    5380:	eb03 1346 	add.w	r3, r3, r6, lsl #5
    5384:	2200      	movs	r2, #0
    5386:	775a      	strb	r2, [r3, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    5388:	2201      	movs	r2, #1
    538a:	771a      	strb	r2, [r3, #28]
    return err_code;
    538c:	481c      	ldr	r0, [pc, #112]	; (5400 <nrfx_spim_init+0x12c>)
    538e:	e027      	b.n	53e0 <nrfx_spim_init+0x10c>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
    5390:	f1b1 6f20 	cmp.w	r1, #167772160	; 0xa000000
    5394:	d0b3      	beq.n	52fe <nrfx_spim_init+0x2a>
    5396:	f1b1 5fa0 	cmp.w	r1, #335544320	; 0x14000000
    539a:	d0b0      	beq.n	52fe <nrfx_spim_init+0x2a>
        return err_code;
    539c:	4819      	ldr	r0, [pc, #100]	; (5404 <nrfx_spim_init+0x130>)
    539e:	e01f      	b.n	53e0 <nrfx_spim_init+0x10c>
        (p_spim == NRF_SPIM4) && (p_config->frequency == NRF_SPIM_FREQ_32M))
    53a0:	f1b1 5fa0 	cmp.w	r1, #335544320	; 0x14000000
    53a4:	d1b4      	bne.n	5310 <nrfx_spim_init+0x3c>
        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
    53a6:	7821      	ldrb	r1, [r4, #0]
    53a8:	29ff      	cmp	r1, #255	; 0xff
    53aa:	d001      	beq.n	53b0 <nrfx_spim_init+0xdc>
    53ac:	2908      	cmp	r1, #8
    53ae:	d11b      	bne.n	53e8 <nrfx_spim_init+0x114>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
    53b0:	78e1      	ldrb	r1, [r4, #3]
        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
    53b2:	29ff      	cmp	r1, #255	; 0xff
    53b4:	d001      	beq.n	53ba <nrfx_spim_init+0xe6>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
    53b6:	290b      	cmp	r1, #11
    53b8:	d118      	bne.n	53ec <nrfx_spim_init+0x118>
    53ba:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    53be:	d002      	beq.n	53c6 <nrfx_spim_init+0xf2>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
    53c0:	f1bc 0f0c 	cmp.w	ip, #12
    53c4:	d114      	bne.n	53f0 <nrfx_spim_init+0x11c>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
    53c6:	7861      	ldrb	r1, [r4, #1]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
    53c8:	29ff      	cmp	r1, #255	; 0xff
    53ca:	d001      	beq.n	53d0 <nrfx_spim_init+0xfc>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
    53cc:	2909      	cmp	r1, #9
    53ce:	d111      	bne.n	53f4 <nrfx_spim_init+0x120>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
    53d0:	78a1      	ldrb	r1, [r4, #2]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
    53d2:	29ff      	cmp	r1, #255	; 0xff
    53d4:	d09c      	beq.n	5310 <nrfx_spim_init+0x3c>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
    53d6:	290a      	cmp	r1, #10
    53d8:	d09a      	beq.n	5310 <nrfx_spim_init+0x3c>
            return err_code;
    53da:	480b      	ldr	r0, [pc, #44]	; (5408 <nrfx_spim_init+0x134>)
    53dc:	e000      	b.n	53e0 <nrfx_spim_init+0x10c>
        return err_code;
    53de:	480b      	ldr	r0, [pc, #44]	; (540c <nrfx_spim_init+0x138>)
}
    53e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return err_code;
    53e4:	4807      	ldr	r0, [pc, #28]	; (5404 <nrfx_spim_init+0x130>)
    53e6:	e7fb      	b.n	53e0 <nrfx_spim_init+0x10c>
            return err_code;
    53e8:	4807      	ldr	r0, [pc, #28]	; (5408 <nrfx_spim_init+0x134>)
    53ea:	e7f9      	b.n	53e0 <nrfx_spim_init+0x10c>
    53ec:	4806      	ldr	r0, [pc, #24]	; (5408 <nrfx_spim_init+0x134>)
    53ee:	e7f7      	b.n	53e0 <nrfx_spim_init+0x10c>
    53f0:	4805      	ldr	r0, [pc, #20]	; (5408 <nrfx_spim_init+0x134>)
    53f2:	e7f5      	b.n	53e0 <nrfx_spim_init+0x10c>
    53f4:	4804      	ldr	r0, [pc, #16]	; (5408 <nrfx_spim_init+0x134>)
    53f6:	e7f3      	b.n	53e0 <nrfx_spim_init+0x10c>
    53f8:	20000f08 	.word	0x20000f08
    53fc:	5000a000 	.word	0x5000a000
    5400:	0bad0000 	.word	0x0bad0000
    5404:	0bad0003 	.word	0x0bad0003
    5408:	0bad0004 	.word	0x0bad0004
    540c:	0bad0005 	.word	0x0bad0005

00005410 <nrfx_spim_uninit>:
{
    5410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5412:	4605      	mov	r5, r0
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    5414:	7904      	ldrb	r4, [r0, #4]
    5416:	0162      	lsls	r2, r4, #5
    5418:	4b1f      	ldr	r3, [pc, #124]	; (5498 <nrfx_spim_uninit+0x88>)
    541a:	eb03 1744 	add.w	r7, r3, r4, lsl #5
    NRF_SPIM_Type * p_spim = p_instance->p_reg;
    541e:	6806      	ldr	r6, [r0, #0]
    if (p_cb->handler)
    5420:	589b      	ldr	r3, [r3, r2]
    5422:	b143      	cbz	r3, 5436 <nrfx_spim_uninit+0x26>
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
    5424:	f346 3007 	sbfx	r0, r6, #12, #8
    5428:	f005 f829 	bl	a47e <arch_irq_disable>
    p_reg->INTENCLR = mask;
    542c:	4b1b      	ldr	r3, [pc, #108]	; (549c <nrfx_spim_uninit+0x8c>)
    542e:	f8c6 3308 	str.w	r3, [r6, #776]	; 0x308
        if (p_cb->transfer_in_progress)
    5432:	7f7b      	ldrb	r3, [r7, #29]
    5434:	b97b      	cbnz	r3, 5456 <nrfx_spim_uninit+0x46>
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Disabled << SPIM_ENABLE_ENABLE_Pos);
    5436:	2300      	movs	r3, #0
    5438:	f8c6 3500 	str.w	r3, [r6, #1280]	; 0x500
    if (!p_cb->skip_gpio_cfg)
    543c:	4b16      	ldr	r3, [pc, #88]	; (5498 <nrfx_spim_uninit+0x88>)
    543e:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    5442:	7f9b      	ldrb	r3, [r3, #30]
    5444:	f013 0f01 	tst.w	r3, #1
    5448:	d00a      	beq.n	5460 <nrfx_spim_uninit+0x50>
    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
    544a:	4b13      	ldr	r3, [pc, #76]	; (5498 <nrfx_spim_uninit+0x88>)
    544c:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    5450:	2200      	movs	r2, #0
    5452:	771a      	strb	r2, [r3, #28]
}
    5454:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            spim_abort(p_spim, p_cb);
    5456:	4639      	mov	r1, r7
    5458:	4630      	mov	r0, r6
    545a:	f006 fdb0 	bl	bfbe <spim_abort>
    545e:	e7ea      	b.n	5436 <nrfx_spim_uninit+0x26>
    return p_reg->PSEL.SCK;
    5460:	f8d6 0508 	ldr.w	r0, [r6, #1288]	; 0x508
        spim_pin_uninit(nrf_spim_sck_pin_get(p_spim));
    5464:	f006 fd58 	bl	bf18 <spim_pin_uninit>
    return p_reg->PSEL.MISO;
    5468:	f8d6 0510 	ldr.w	r0, [r6, #1296]	; 0x510
        spim_pin_uninit(nrf_spim_miso_pin_get(p_spim));
    546c:	f006 fd54 	bl	bf18 <spim_pin_uninit>
    return p_reg->PSEL.MOSI;
    5470:	f8d6 050c 	ldr.w	r0, [r6, #1292]	; 0x50c
        spim_pin_uninit(nrf_spim_mosi_pin_get(p_spim));
    5474:	f006 fd50 	bl	bf18 <spim_pin_uninit>
        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
    5478:	792b      	ldrb	r3, [r5, #4]
    547a:	b143      	cbz	r3, 548e <nrfx_spim_uninit+0x7e>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    547c:	4b06      	ldr	r3, [pc, #24]	; (5498 <nrfx_spim_uninit+0x88>)
    547e:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    5482:	7fd8      	ldrb	r0, [r3, #31]
    5484:	28ff      	cmp	r0, #255	; 0xff
    5486:	d0e0      	beq.n	544a <nrfx_spim_uninit+0x3a>
            nrf_gpio_cfg_default(p_cb->ss_pin);
    5488:	f7ff fdca 	bl	5020 <nrf_gpio_cfg_default>
    548c:	e7dd      	b.n	544a <nrfx_spim_uninit+0x3a>
    return p_reg->PSELDCX;
    548e:	f8d6 056c 	ldr.w	r0, [r6, #1388]	; 0x56c
            spim_pin_uninit(nrf_spim_dcx_pin_get(p_spim));
    5492:	f006 fd41 	bl	bf18 <spim_pin_uninit>
    5496:	e7f1      	b.n	547c <nrfx_spim_uninit+0x6c>
    5498:	20000f08 	.word	0x20000f08
    549c:	00080152 	.word	0x00080152

000054a0 <nrfx_spim_xfer>:

nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
                          nrfx_spim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
    54a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    54a4:	4690      	mov	r8, r2
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    54a6:	7903      	ldrb	r3, [r0, #4]
    54a8:	4e13      	ldr	r6, [pc, #76]	; (54f8 <nrfx_spim_xfer+0x58>)
    54aa:	eb06 1643 	add.w	r6, r6, r3, lsl #5
#endif
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
    54ae:	7f72      	ldrb	r2, [r6, #29]
    54b0:	b9fa      	cbnz	r2, 54f2 <nrfx_spim_xfer+0x52>
    54b2:	4607      	mov	r7, r0
    54b4:	460d      	mov	r5, r1
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
    54b6:	015a      	lsls	r2, r3, #5
    54b8:	490f      	ldr	r1, [pc, #60]	; (54f8 <nrfx_spim_xfer+0x58>)
    54ba:	588a      	ldr	r2, [r1, r2]
    54bc:	b122      	cbz	r2, 54c8 <nrfx_spim_xfer+0x28>
    54be:	f018 0f14 	tst.w	r8, #20
    54c2:	d101      	bne.n	54c8 <nrfx_spim_xfer+0x28>
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
    54c4:	2101      	movs	r1, #1
    54c6:	7771      	strb	r1, [r6, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
    54c8:	4c0b      	ldr	r4, [pc, #44]	; (54f8 <nrfx_spim_xfer+0x58>)
    54ca:	eb04 1c43 	add.w	ip, r4, r3, lsl #5
    54ce:	f10c 0c0c 	add.w	ip, ip, #12
    54d2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    54d6:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    set_ss_pin_state(p_cb, true);
    54da:	2101      	movs	r1, #1
    54dc:	4630      	mov	r0, r6
    54de:	f006 fd23 	bl	bf28 <set_ss_pin_state>

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
    54e2:	4643      	mov	r3, r8
    54e4:	462a      	mov	r2, r5
    54e6:	4631      	mov	r1, r6
    54e8:	6838      	ldr	r0, [r7, #0]
    54ea:	f7ff fea9 	bl	5240 <spim_xfer>
}
    54ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return err_code;
    54f2:	4802      	ldr	r0, [pc, #8]	; (54fc <nrfx_spim_xfer+0x5c>)
    54f4:	e7fb      	b.n	54ee <nrfx_spim_xfer+0x4e>
    54f6:	bf00      	nop
    54f8:	20000f08 	.word	0x20000f08
    54fc:	0bad000b 	.word	0x0bad000b

00005500 <nrfx_spim_4_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_SPIM4_ENABLED)
void nrfx_spim_4_irq_handler(void)
{
    5500:	b508      	push	{r3, lr}
    irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
    5502:	4902      	ldr	r1, [pc, #8]	; (550c <nrfx_spim_4_irq_handler+0xc>)
    5504:	4802      	ldr	r0, [pc, #8]	; (5510 <nrfx_spim_4_irq_handler+0x10>)
    5506:	f006 fd4b 	bl	bfa0 <irq_handler>
}
    550a:	bd08      	pop	{r3, pc}
    550c:	20000f08 	.word	0x20000f08
    5510:	5000a000 	.word	0x5000a000

00005514 <lfs_dir_traverse_filter>:
    return 0;
}

#ifndef LFS_READONLY
static int lfs_dir_traverse_filter(void *p,
        lfs_tag_t tag, const void *buffer) {
    5514:	b410      	push	{r4}
    (void)buffer;

    // which mask depends on unique bit in tag structure
    uint32_t mask = (tag & LFS_MKTAG(0x100, 0, 0))
            ? LFS_MKTAG(0x7ff, 0x3ff, 0)
            : LFS_MKTAG(0x700, 0x3ff, 0);
    5516:	f011 5f80 	tst.w	r1, #268435456	; 0x10000000
    551a:	d01c      	beq.n	5556 <lfs_dir_traverse_filter+0x42>
    551c:	4a18      	ldr	r2, [pc, #96]	; (5580 <lfs_dir_traverse_filter+0x6c>)

    // check for redundancy
    if ((mask & tag) == (mask & *filtertag) ||
    551e:	6803      	ldr	r3, [r0, #0]
    5520:	ea83 0401 	eor.w	r4, r3, r1
    5524:	4214      	tst	r4, r2
    5526:	d018      	beq.n	555a <lfs_dir_traverse_filter+0x46>
    return ((int32_t)(tag << 22) >> 22) == -1;
    5528:	f343 0209 	sbfx	r2, r3, #0, #10
    if ((mask & tag) == (mask & *filtertag) ||
    552c:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    5530:	d013      	beq.n	555a <lfs_dir_traverse_filter+0x46>
            lfs_tag_isdelete(*filtertag) ||
            (LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) == (
    5532:	4c13      	ldr	r4, [pc, #76]	; (5580 <lfs_dir_traverse_filter+0x6c>)
    5534:	400c      	ands	r4, r1
                LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
                    (LFS_MKTAG(0, 0x3ff, 0) & *filtertag))) {
    5536:	4a13      	ldr	r2, [pc, #76]	; (5584 <lfs_dir_traverse_filter+0x70>)
    5538:	401a      	ands	r2, r3
                LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
    553a:	f042 429f 	orr.w	r2, r2, #1333788672	; 0x4f800000
    553e:	f442 02e0 	orr.w	r2, r2, #7340032	; 0x700000
            lfs_tag_isdelete(*filtertag) ||
    5542:	4294      	cmp	r4, r2
    5544:	d009      	beq.n	555a <lfs_dir_traverse_filter+0x46>
    return (tag & 0x70000000) >> 20;
    5546:	0d0a      	lsrs	r2, r1, #20
    5548:	f402 64e0 	and.w	r4, r2, #1792	; 0x700
        *filtertag = LFS_MKTAG(LFS_FROM_NOOP, 0, 0);
        return true;
    }

    // check if we need to adjust for created/deleted tags
    if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&
    554c:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
    5550:	d008      	beq.n	5564 <lfs_dir_traverse_filter+0x50>
            lfs_tag_id(tag) <= lfs_tag_id(*filtertag)) {
        *filtertag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);
    }

    return false;
    5552:	2000      	movs	r0, #0
    5554:	e004      	b.n	5560 <lfs_dir_traverse_filter+0x4c>
            : LFS_MKTAG(0x700, 0x3ff, 0);
    5556:	4a0c      	ldr	r2, [pc, #48]	; (5588 <lfs_dir_traverse_filter+0x74>)
    5558:	e7e1      	b.n	551e <lfs_dir_traverse_filter+0xa>
        *filtertag = LFS_MKTAG(LFS_FROM_NOOP, 0, 0);
    555a:	2300      	movs	r3, #0
    555c:	6003      	str	r3, [r0, #0]
        return true;
    555e:	2001      	movs	r0, #1
}
    5560:	bc10      	pop	{r4}
    5562:	4770      	bx	lr
    return (tag & 0x000ffc00) >> 10;
    5564:	f3c1 2189 	ubfx	r1, r1, #10, #10
    5568:	f3c3 2489 	ubfx	r4, r3, #10, #10
    if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&
    556c:	428c      	cmp	r4, r1
    556e:	d305      	bcc.n	557c <lfs_dir_traverse_filter+0x68>
    return (int8_t)lfs_tag_chunk(tag);
    5570:	b252      	sxtb	r2, r2
        *filtertag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);
    5572:	eb03 2382 	add.w	r3, r3, r2, lsl #10
    5576:	6003      	str	r3, [r0, #0]
    return false;
    5578:	2000      	movs	r0, #0
    557a:	e7f1      	b.n	5560 <lfs_dir_traverse_filter+0x4c>
    557c:	2000      	movs	r0, #0
    557e:	e7ef      	b.n	5560 <lfs_dir_traverse_filter+0x4c>
    5580:	7ffffc00 	.word	0x7ffffc00
    5584:	000ffc00 	.word	0x000ffc00
    5588:	700ffc00 	.word	0x700ffc00

0000558c <lfs_fs_prepmove>:
}
#endif

#ifndef LFS_READONLY
static void lfs_fs_prepmove(lfs_t *lfs,
        uint16_t id, const lfs_block_t pair[2]) {
    558c:	b410      	push	{r4}
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
    558e:	4b12      	ldr	r3, [pc, #72]	; (55d8 <lfs_fs_prepmove+0x4c>)
    5590:	6b04      	ldr	r4, [r0, #48]	; 0x30
    5592:	4023      	ands	r3, r4
            ((id != 0x3ff) ? LFS_MKTAG(LFS_TYPE_DELETE, id, 0) : 0));
    5594:	f240 3cff 	movw	ip, #1023	; 0x3ff
    5598:	4561      	cmp	r1, ip
    559a:	d016      	beq.n	55ca <lfs_fs_prepmove+0x3e>
    559c:	ea4f 2c81 	mov.w	ip, r1, lsl #10
    55a0:	f04c 4c9f 	orr.w	ip, ip, #1333788672	; 0x4f800000
    55a4:	f44c 0ce0 	orr.w	ip, ip, #7340032	; 0x700000
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
    55a8:	ea43 030c 	orr.w	r3, r3, ip
    55ac:	6303      	str	r3, [r0, #48]	; 0x30
    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
    55ae:	f240 33ff 	movw	r3, #1023	; 0x3ff
    55b2:	4299      	cmp	r1, r3
    55b4:	d00c      	beq.n	55d0 <lfs_fs_prepmove+0x44>
    55b6:	6813      	ldr	r3, [r2, #0]
    55b8:	6343      	str	r3, [r0, #52]	; 0x34
    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
    55ba:	f240 33ff 	movw	r3, #1023	; 0x3ff
    55be:	4299      	cmp	r1, r3
    55c0:	d008      	beq.n	55d4 <lfs_fs_prepmove+0x48>
    55c2:	6853      	ldr	r3, [r2, #4]
    55c4:	6383      	str	r3, [r0, #56]	; 0x38
}
    55c6:	bc10      	pop	{r4}
    55c8:	4770      	bx	lr
            ((id != 0x3ff) ? LFS_MKTAG(LFS_TYPE_DELETE, id, 0) : 0));
    55ca:	f04f 0c00 	mov.w	ip, #0
    55ce:	e7eb      	b.n	55a8 <lfs_fs_prepmove+0x1c>
    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
    55d0:	2300      	movs	r3, #0
    55d2:	e7f1      	b.n	55b8 <lfs_fs_prepmove+0x2c>
    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
    55d4:	2300      	movs	r3, #0
    55d6:	e7f5      	b.n	55c4 <lfs_fs_prepmove+0x38>
    55d8:	800003ff 	.word	0x800003ff

000055dc <lfs_dir_getslice>:
        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {
    55dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    55e0:	b089      	sub	sp, #36	; 0x24
    55e2:	4607      	mov	r7, r0
    55e4:	468a      	mov	sl, r1
    55e6:	4690      	mov	r8, r2
    55e8:	469b      	mov	fp, r3
    lfs_off_t off = dir->off;
    55ea:	68cd      	ldr	r5, [r1, #12]
    lfs_tag_t ntag = dir->etag;
    55ec:	690b      	ldr	r3, [r1, #16]
    55ee:	9307      	str	r3, [sp, #28]
    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&
    55f0:	303c      	adds	r0, #60	; 0x3c
    55f2:	f006 fd31 	bl	c058 <lfs_gstate_hasmovehere>
    55f6:	2800      	cmp	r0, #0
    55f8:	f000 8082 	beq.w	5700 <lfs_dir_getslice+0x124>
    return (tag & 0x000ffc00) >> 10;
    55fc:	f3c8 2389 	ubfx	r3, r8, #10, #10
    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&
    5600:	2b00      	cmp	r3, #0
    5602:	d07f      	beq.n	5704 <lfs_dir_getslice+0x128>
            lfs_tag_id(lfs->gdisk.tag) <= lfs_tag_id(gtag)) {
    5604:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    return (tag & 0x000ffc00) >> 10;
    5606:	f3c3 2389 	ubfx	r3, r3, #10, #10
    560a:	f3cb 2289 	ubfx	r2, fp, #10, #10
            lfs_tag_id(gmask) != 0 &&
    560e:	4293      	cmp	r3, r2
    5610:	d97a      	bls.n	5708 <lfs_dir_getslice+0x12c>
    lfs_stag_t gdiff = 0;
    5612:	2600      	movs	r6, #0
    5614:	e006      	b.n	5624 <lfs_dir_getslice+0x48>
        if ((gmask & tag) == (gmask & (gtag - gdiff))) {
    5616:	9605      	str	r6, [sp, #20]
    5618:	ebab 0306 	sub.w	r3, fp, r6
    561c:	4063      	eors	r3, r4
    561e:	ea13 0f08 	tst.w	r3, r8
    5622:	d048      	beq.n	56b6 <lfs_dir_getslice+0xda>
    while (off >= sizeof(lfs_tag_t) + lfs_tag_dsize(ntag)) {
    5624:	9c07      	ldr	r4, [sp, #28]
    return ((int32_t)(tag << 22) >> 22) == -1;
    5626:	f344 0909 	sbfx	r9, r4, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    562a:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
    562e:	bf14      	ite	ne
    5630:	4623      	movne	r3, r4
    5632:	1c63      	addeq	r3, r4, #1
    return tag & 0x000003ff;
    5634:	f3c3 0309 	ubfx	r3, r3, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5638:	1d1a      	adds	r2, r3, #4
    while (off >= sizeof(lfs_tag_t) + lfs_tag_dsize(ntag)) {
    563a:	3308      	adds	r3, #8
    563c:	42ab      	cmp	r3, r5
    563e:	d865      	bhi.n	570c <lfs_dir_getslice+0x130>
        off -= lfs_tag_dsize(ntag);
    5640:	1aad      	subs	r5, r5, r2
                dir->pair[0], off, &ntag, sizeof(ntag));
    5642:	f8da 2000 	ldr.w	r2, [sl]
        int err = lfs_bd_read(lfs,
    5646:	2304      	movs	r3, #4
    5648:	9303      	str	r3, [sp, #12]
    564a:	a907      	add	r1, sp, #28
    564c:	9102      	str	r1, [sp, #8]
    564e:	9501      	str	r5, [sp, #4]
    5650:	9200      	str	r2, [sp, #0]
    5652:	463a      	mov	r2, r7
    5654:	2100      	movs	r1, #0
    5656:	4638      	mov	r0, r7
    5658:	f006 fdc2 	bl	c1e0 <lfs_bd_read>
        if (err) {
    565c:	4603      	mov	r3, r0
    565e:	2800      	cmp	r0, #0
    5660:	d156      	bne.n	5710 <lfs_dir_getslice+0x134>
        ntag = (lfs_frombe32(ntag) ^ tag) & 0x7fffffff;
    5662:	9b07      	ldr	r3, [sp, #28]
static inline uint32_t lfs_frombe32(uint32_t a)
{
#if defined(CONFIG_BIG_ENDIAN)
	return a;
#elif !defined(LFS_NO_INTRINSICS)
	return __builtin_bswap32(a);
    5664:	ba1b      	rev	r3, r3
    5666:	4063      	eors	r3, r4
    5668:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    566c:	9307      	str	r3, [sp, #28]
    return (tag & 0x000ffc00) >> 10;
    566e:	f3c8 2389 	ubfx	r3, r8, #10, #10
        if (lfs_tag_id(gmask) != 0 &&
    5672:	2b00      	cmp	r3, #0
    5674:	d0cf      	beq.n	5616 <lfs_dir_getslice+0x3a>
    return (tag & 0x70000000) >> 20;
    5676:	0d23      	lsrs	r3, r4, #20
    5678:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
        if (lfs_tag_id(gmask) != 0 &&
    567c:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    5680:	d1c9      	bne.n	5616 <lfs_dir_getslice+0x3a>
    return (tag & 0x000ffc00) >> 10;
    5682:	f3c4 2089 	ubfx	r0, r4, #10, #10
                lfs_tag_id(tag) <= lfs_tag_id(gtag - gdiff)) {
    5686:	ebab 0206 	sub.w	r2, fp, r6
    return (tag & 0x000ffc00) >> 10;
    568a:	f3c2 2c89 	ubfx	ip, r2, #10, #10
                lfs_tag_type1(tag) == LFS_TYPE_SPLICE &&
    568e:	4584      	cmp	ip, r0
    5690:	d3c1      	bcc.n	5616 <lfs_dir_getslice+0x3a>
                    (LFS_MKTAG(0, 0x3ff, 0) & (gtag - gdiff)))) {
    5692:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    5696:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    569a:	f422 727f 	bic.w	r2, r2, #1020	; 0x3fc
    569e:	f022 0203 	bic.w	r2, r2, #3
            if (tag == (LFS_MKTAG(LFS_TYPE_CREATE, 0, 0) |
    56a2:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    56a6:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    56aa:	42a2      	cmp	r2, r4
    56ac:	d034      	beq.n	5718 <lfs_dir_getslice+0x13c>
    return (int8_t)lfs_tag_chunk(tag);
    56ae:	b25b      	sxtb	r3, r3
            gdiff += LFS_MKTAG(0, lfs_tag_splice(tag), 0);
    56b0:	eb06 2683 	add.w	r6, r6, r3, lsl #10
    56b4:	e7af      	b.n	5616 <lfs_dir_getslice+0x3a>
            if (lfs_tag_isdelete(tag)) {
    56b6:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
    56ba:	d030      	beq.n	571e <lfs_dir_getslice+0x142>
    return tag & 0x000003ff;
    56bc:	f3c4 0609 	ubfx	r6, r4, #0, #10
	return (a < b) ? a : b;
    56c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
    56c2:	429e      	cmp	r6, r3
    56c4:	bf28      	it	cs
    56c6:	461e      	movcs	r6, r3
                    dir->pair[0], off+sizeof(tag)+goff, gbuffer, diff);
    56c8:	f8da 2000 	ldr.w	r2, [sl]
    56cc:	9b12      	ldr	r3, [sp, #72]	; 0x48
    56ce:	442b      	add	r3, r5
            err = lfs_bd_read(lfs,
    56d0:	9603      	str	r6, [sp, #12]
    56d2:	9913      	ldr	r1, [sp, #76]	; 0x4c
    56d4:	9102      	str	r1, [sp, #8]
    56d6:	3304      	adds	r3, #4
    56d8:	9301      	str	r3, [sp, #4]
    56da:	9200      	str	r2, [sp, #0]
    56dc:	4633      	mov	r3, r6
    56de:	463a      	mov	r2, r7
    56e0:	2100      	movs	r1, #0
    56e2:	4638      	mov	r0, r7
    56e4:	f006 fd7c 	bl	c1e0 <lfs_bd_read>
            if (err) {
    56e8:	4603      	mov	r3, r0
    56ea:	b988      	cbnz	r0, 5710 <lfs_dir_getslice+0x134>
            memset((uint8_t*)gbuffer + diff, 0, gsize - diff);
    56ec:	9b14      	ldr	r3, [sp, #80]	; 0x50
    56ee:	1b9a      	subs	r2, r3, r6
    56f0:	2100      	movs	r1, #0
    56f2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    56f4:	1998      	adds	r0, r3, r6
    56f6:	f005 f810 	bl	a71a <memset>
            return tag + gdiff;
    56fa:	9b05      	ldr	r3, [sp, #20]
    56fc:	4423      	add	r3, r4
    56fe:	e007      	b.n	5710 <lfs_dir_getslice+0x134>
    lfs_stag_t gdiff = 0;
    5700:	2600      	movs	r6, #0
    5702:	e78f      	b.n	5624 <lfs_dir_getslice+0x48>
    5704:	2600      	movs	r6, #0
    5706:	e78d      	b.n	5624 <lfs_dir_getslice+0x48>
        gdiff -= LFS_MKTAG(0, 1, 0);
    5708:	4e06      	ldr	r6, [pc, #24]	; (5724 <lfs_dir_getslice+0x148>)
    570a:	e78b      	b.n	5624 <lfs_dir_getslice+0x48>
    return LFS_ERR_NOENT;
    570c:	f06f 0301 	mvn.w	r3, #1
}
    5710:	4618      	mov	r0, r3
    5712:	b009      	add	sp, #36	; 0x24
    5714:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                return LFS_ERR_NOENT;
    5718:	f06f 0301 	mvn.w	r3, #1
    571c:	e7f8      	b.n	5710 <lfs_dir_getslice+0x134>
                return LFS_ERR_NOENT;
    571e:	f06f 0301 	mvn.w	r3, #1
    5722:	e7f5      	b.n	5710 <lfs_dir_getslice+0x134>
    5724:	fffffc00 	.word	0xfffffc00

00005728 <lfs_dir_getgstate>:
        lfs_gstate_t *gstate) {
    5728:	b510      	push	{r4, lr}
    572a:	b086      	sub	sp, #24
    572c:	4614      	mov	r4, r2
    lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x7ff, 0, 0),
    572e:	ab03      	add	r3, sp, #12
    5730:	9300      	str	r3, [sp, #0]
    5732:	4b09      	ldr	r3, [pc, #36]	; (5758 <lfs_dir_getgstate+0x30>)
    5734:	4a09      	ldr	r2, [pc, #36]	; (575c <lfs_dir_getgstate+0x34>)
    5736:	f006 fe1e 	bl	c376 <lfs_dir_get>
    if (res < 0 && res != LFS_ERR_NOENT) {
    573a:	2800      	cmp	r0, #0
    573c:	da04      	bge.n	5748 <lfs_dir_getgstate+0x20>
    573e:	f110 0f02 	cmn.w	r0, #2
    5742:	d106      	bne.n	5752 <lfs_dir_getgstate+0x2a>
    return 0;
    5744:	2000      	movs	r0, #0
    5746:	e004      	b.n	5752 <lfs_dir_getgstate+0x2a>
        lfs_gstate_xor(gstate, &temp);
    5748:	a903      	add	r1, sp, #12
    574a:	4620      	mov	r0, r4
    574c:	f006 fc73 	bl	c036 <lfs_gstate_xor>
    return 0;
    5750:	2000      	movs	r0, #0
}
    5752:	b006      	add	sp, #24
    5754:	bd10      	pop	{r4, pc}
    5756:	bf00      	nop
    5758:	7ff0000c 	.word	0x7ff0000c
    575c:	7ff00000 	.word	0x7ff00000

00005760 <lfs_dir_traverse>:
        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
    5760:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5764:	b0af      	sub	sp, #188	; 0xbc
    5766:	9007      	str	r0, [sp, #28]
    5768:	460d      	mov	r5, r1
    576a:	4617      	mov	r7, r2
    576c:	461c      	mov	r4, r3
    576e:	f8dd 80e0 	ldr.w	r8, [sp, #224]	; 0xe0
    5772:	f8dd b0e4 	ldr.w	fp, [sp, #228]	; 0xe4
    5776:	f8dd a0e8 	ldr.w	sl, [sp, #232]	; 0xe8
    577a:	f8bd 30f0 	ldrh.w	r3, [sp, #240]	; 0xf0
    577e:	9304      	str	r3, [sp, #16]
    5780:	f8bd 30f4 	ldrh.w	r3, [sp, #244]	; 0xf4
    5784:	9305      	str	r3, [sp, #20]
    5786:	f9bd 30f8 	ldrsh.w	r3, [sp, #248]	; 0xf8
    578a:	9306      	str	r3, [sp, #24]
    unsigned sp = 0;
    578c:	2600      	movs	r6, #0
    return ((int32_t)(tag << 22) >> 22) == -1;
    578e:	f344 0309 	sbfx	r3, r4, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5792:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    5796:	bf14      	ite	ne
    5798:	46a1      	movne	r9, r4
    579a:	f104 0901 	addeq.w	r9, r4, #1
    return tag & 0x000003ff;
    579e:	f3c9 0909 	ubfx	r9, r9, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    57a2:	f109 0904 	add.w	r9, r9, #4
            if (off+lfs_tag_dsize(ptag) < dir->off) {
    57a6:	44b9      	add	r9, r7
    57a8:	68eb      	ldr	r3, [r5, #12]
    57aa:	4599      	cmp	r9, r3
    57ac:	d345      	bcc.n	583a <lfs_dir_traverse+0xda>
            } else if (attrcount > 0) {
    57ae:	f1bb 0f00 	cmp.w	fp, #0
    57b2:	f340 8118 	ble.w	59e6 <lfs_dir_traverse+0x286>
                tag = attrs[0].tag;
    57b6:	f8d8 3000 	ldr.w	r3, [r8]
    57ba:	930f      	str	r3, [sp, #60]	; 0x3c
                buffer = attrs[0].buffer;
    57bc:	f8d8 9004 	ldr.w	r9, [r8, #4]
                attrs += 1;
    57c0:	f108 0808 	add.w	r8, r8, #8
                attrcount -= 1;
    57c4:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
            if ((mask & tmask & tag) != (mask & tmask & ttag)) {
    57c8:	990f      	ldr	r1, [sp, #60]	; 0x3c
    57ca:	4ba2      	ldr	r3, [pc, #648]	; (5a54 <lfs_dir_traverse+0x2f4>)
    57cc:	ea0a 0303 	and.w	r3, sl, r3
    57d0:	9a3b      	ldr	r2, [sp, #236]	; 0xec
    57d2:	404a      	eors	r2, r1
    57d4:	401a      	ands	r2, r3
    57d6:	d1da      	bne.n	578e <lfs_dir_traverse+0x2e>
    return (tag & 0x000ffc00) >> 10;
    57d8:	f3ca 2389 	ubfx	r3, sl, #10, #10
            if (lfs_tag_id(tmask) != 0) {
    57dc:	2b00      	cmp	r3, #0
    57de:	d14c      	bne.n	587a <lfs_dir_traverse+0x11a>
    return (tag & 0x000ffc00) >> 10;
    57e0:	f3ca 2389 	ubfx	r3, sl, #10, #10
        if (lfs_tag_id(tmask) != 0 &&
    57e4:	b143      	cbz	r3, 57f8 <lfs_dir_traverse+0x98>
    return (tag & 0x000ffc00) >> 10;
    57e6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    57e8:	f3c3 2389 	ubfx	r3, r3, #10, #10
        if (lfs_tag_id(tmask) != 0 &&
    57ec:	9a04      	ldr	r2, [sp, #16]
    57ee:	429a      	cmp	r2, r3
    57f0:	d8cd      	bhi.n	578e <lfs_dir_traverse+0x2e>
                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {
    57f2:	9a05      	ldr	r2, [sp, #20]
    57f4:	429a      	cmp	r2, r3
    57f6:	d9ca      	bls.n	578e <lfs_dir_traverse+0x2e>
        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {
    57f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    57fa:	9308      	str	r3, [sp, #32]
    return (tag & 0x7ff00000) >> 20;
    57fc:	f3c3 530a 	ubfx	r3, r3, #20, #11
        if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {
    5800:	2b00      	cmp	r3, #0
    5802:	d0c4      	beq.n	578e <lfs_dir_traverse+0x2e>
        } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {
    5804:	f240 1201 	movw	r2, #257	; 0x101
    5808:	4293      	cmp	r3, r2
    580a:	d074      	beq.n	58f6 <lfs_dir_traverse+0x196>
        } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {
    580c:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    5810:	f000 80bc 	beq.w	598c <lfs_dir_traverse+0x22c>
            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
    5814:	464a      	mov	r2, r9
    5816:	9b08      	ldr	r3, [sp, #32]
    5818:	9906      	ldr	r1, [sp, #24]
    581a:	eb03 2181 	add.w	r1, r3, r1, lsl #10
    581e:	9840      	ldr	r0, [sp, #256]	; 0x100
    5820:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
    5822:	4798      	blx	r3
            if (res < 0) {
    5824:	1e03      	subs	r3, r0, #0
    5826:	f2c0 8111 	blt.w	5a4c <lfs_dir_traverse+0x2ec>
            if (res) {
    582a:	2b00      	cmp	r3, #0
    582c:	d0af      	beq.n	578e <lfs_dir_traverse+0x2e>
    582e:	e0db      	b.n	59e8 <lfs_dir_traverse+0x288>
    5830:	9e08      	ldr	r6, [sp, #32]
    5832:	9d09      	ldr	r5, [sp, #36]	; 0x24
    5834:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    5836:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    5838:	e7a9      	b.n	578e <lfs_dir_traverse+0x2e>
                        dir->pair[0], off, &tag, sizeof(tag));
    583a:	682a      	ldr	r2, [r5, #0]
                int err = lfs_bd_read(lfs,
    583c:	2304      	movs	r3, #4
    583e:	9303      	str	r3, [sp, #12]
    5840:	a90f      	add	r1, sp, #60	; 0x3c
    5842:	9102      	str	r1, [sp, #8]
    5844:	f8cd 9004 	str.w	r9, [sp, #4]
    5848:	9200      	str	r2, [sp, #0]
    584a:	9a07      	ldr	r2, [sp, #28]
    584c:	2100      	movs	r1, #0
    584e:	4610      	mov	r0, r2
    5850:	f006 fcc6 	bl	c1e0 <lfs_bd_read>
                if (err) {
    5854:	4603      	mov	r3, r0
    5856:	2800      	cmp	r0, #0
    5858:	f040 80f8 	bne.w	5a4c <lfs_dir_traverse+0x2ec>
                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
    585c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	return __builtin_bswap32(a);
    585e:	ba1b      	rev	r3, r3
    5860:	4063      	eors	r3, r4
    5862:	f043 4400 	orr.w	r4, r3, #2147483648	; 0x80000000
    5866:	940f      	str	r4, [sp, #60]	; 0x3c
                disk.block = dir->pair[0];
    5868:	682b      	ldr	r3, [r5, #0]
    586a:	930d      	str	r3, [sp, #52]	; 0x34
                disk.off = off+sizeof(lfs_tag_t);
    586c:	f109 0304 	add.w	r3, r9, #4
    5870:	930e      	str	r3, [sp, #56]	; 0x38
                off += lfs_tag_dsize(ptag);
    5872:	464f      	mov	r7, r9
                buffer = &disk;
    5874:	f10d 0934 	add.w	r9, sp, #52	; 0x34
    5878:	e7a6      	b.n	57c8 <lfs_dir_traverse+0x68>
                stack[sp] = (struct lfs_dir_traverse){
    587a:	ebc6 1306 	rsb	r3, r6, r6, lsl #4
    587e:	a82e      	add	r0, sp, #184	; 0xb8
    5880:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    5884:	f843 5c78 	str.w	r5, [r3, #-120]
    5888:	f843 7c74 	str.w	r7, [r3, #-116]
    588c:	f843 4c70 	str.w	r4, [r3, #-112]
    5890:	f843 8c6c 	str.w	r8, [r3, #-108]
    5894:	f843 bc68 	str.w	fp, [r3, #-104]
    5898:	f843 ac64 	str.w	sl, [r3, #-100]
    589c:	983b      	ldr	r0, [sp, #236]	; 0xec
    589e:	f843 0c60 	str.w	r0, [r3, #-96]
    58a2:	9804      	ldr	r0, [sp, #16]
    58a4:	f823 0c5c 	strh.w	r0, [r3, #-92]
    58a8:	9805      	ldr	r0, [sp, #20]
    58aa:	f823 0c5a 	strh.w	r0, [r3, #-90]
    58ae:	9806      	ldr	r0, [sp, #24]
    58b0:	f823 0c58 	strh.w	r0, [r3, #-88]
    58b4:	983f      	ldr	r0, [sp, #252]	; 0xfc
    58b6:	f843 0c54 	str.w	r0, [r3, #-84]
    58ba:	9840      	ldr	r0, [sp, #256]	; 0x100
    58bc:	f843 0c50 	str.w	r0, [r3, #-80]
    58c0:	f843 1c4c 	str.w	r1, [r3, #-76]
    58c4:	f843 9c48 	str.w	r9, [r3, #-72]
    58c8:	3b44      	subs	r3, #68	; 0x44
    58ca:	a90d      	add	r1, sp, #52	; 0x34
    58cc:	c903      	ldmia	r1, {r0, r1}
    58ce:	e883 0003 	stmia.w	r3, {r0, r1}
                data = &stack[sp-1].tag;
    58d2:	ebc6 1306 	rsb	r3, r6, r6, lsl #4
    58d6:	009b      	lsls	r3, r3, #2
    58d8:	3328      	adds	r3, #40	; 0x28
    58da:	a910      	add	r1, sp, #64	; 0x40
    58dc:	440b      	add	r3, r1
    58de:	3304      	adds	r3, #4
    58e0:	9340      	str	r3, [sp, #256]	; 0x100
                sp += 1;
    58e2:	3601      	adds	r6, #1
                ttag = 0;
    58e4:	923b      	str	r2, [sp, #236]	; 0xec
                tmask = 0;
    58e6:	4692      	mov	sl, r2
                cb = lfs_dir_traverse_filter;
    58e8:	4b5b      	ldr	r3, [pc, #364]	; (5a58 <lfs_dir_traverse+0x2f8>)
    58ea:	933f      	str	r3, [sp, #252]	; 0xfc
                diff = 0;
    58ec:	2300      	movs	r3, #0
    58ee:	9306      	str	r3, [sp, #24]
                end = 0;
    58f0:	9305      	str	r3, [sp, #20]
                begin = 0;
    58f2:	9304      	str	r3, [sp, #16]
    58f4:	e74b      	b.n	578e <lfs_dir_traverse+0x2e>
            if (cb == lfs_dir_traverse_filter) {
    58f6:	4b58      	ldr	r3, [pc, #352]	; (5a58 <lfs_dir_traverse+0x2f8>)
    58f8:	9a3f      	ldr	r2, [sp, #252]	; 0xfc
    58fa:	429a      	cmp	r2, r3
    58fc:	f43f af47 	beq.w	578e <lfs_dir_traverse+0x2e>
            stack[sp] = (struct lfs_dir_traverse){
    5900:	ebc6 1306 	rsb	r3, r6, r6, lsl #4
    5904:	aa2e      	add	r2, sp, #184	; 0xb8
    5906:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    590a:	223c      	movs	r2, #60	; 0x3c
    590c:	2100      	movs	r1, #0
    590e:	9309      	str	r3, [sp, #36]	; 0x24
    5910:	f1a3 0078 	sub.w	r0, r3, #120	; 0x78
    5914:	f004 ff01 	bl	a71a <memset>
    5918:	9b09      	ldr	r3, [sp, #36]	; 0x24
    591a:	f843 5c78 	str.w	r5, [r3, #-120]
    591e:	f843 7c74 	str.w	r7, [r3, #-116]
    5922:	f843 4c70 	str.w	r4, [r3, #-112]
    5926:	f843 8c6c 	str.w	r8, [r3, #-108]
    592a:	f843 bc68 	str.w	fp, [r3, #-104]
    592e:	f843 ac64 	str.w	sl, [r3, #-100]
    5932:	9a3b      	ldr	r2, [sp, #236]	; 0xec
    5934:	f843 2c60 	str.w	r2, [r3, #-96]
    5938:	9a04      	ldr	r2, [sp, #16]
    593a:	f823 2c5c 	strh.w	r2, [r3, #-92]
    593e:	9a05      	ldr	r2, [sp, #20]
    5940:	f823 2c5a 	strh.w	r2, [r3, #-90]
    5944:	9806      	ldr	r0, [sp, #24]
    5946:	f823 0c58 	strh.w	r0, [r3, #-88]
    594a:	9a3f      	ldr	r2, [sp, #252]	; 0xfc
    594c:	f843 2c54 	str.w	r2, [r3, #-84]
    5950:	9a40      	ldr	r2, [sp, #256]	; 0x100
    5952:	f843 2c50 	str.w	r2, [r3, #-80]
            sp += 1;
    5956:	3601      	adds	r6, #1
            uint16_t fromid = lfs_tag_size(tag);
    5958:	9b08      	ldr	r3, [sp, #32]
    595a:	f3c3 0209 	ubfx	r2, r3, #0, #10
    595e:	9204      	str	r2, [sp, #16]
    return (tag & 0x000ffc00) >> 10;
    5960:	f3c3 2389 	ubfx	r3, r3, #10, #10
            end = fromid+1;
    5964:	1c51      	adds	r1, r2, #1
    5966:	9105      	str	r1, [sp, #20]
            diff = toid-fromid+diff;
    5968:	1a9b      	subs	r3, r3, r2
    596a:	fa10 f383 	uxtah	r3, r0, r3
    596e:	b21b      	sxth	r3, r3
    5970:	9306      	str	r3, [sp, #24]
            dir = buffer;
    5972:	464d      	mov	r5, r9
            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);
    5974:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    5978:	933b      	str	r3, [sp, #236]	; 0xec
            tmask = LFS_MKTAG(0x600, 0x3ff, 0);
    597a:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 5a5c <lfs_dir_traverse+0x2fc>
            attrcount = 0;
    597e:	f04f 0b00 	mov.w	fp, #0
            attrs = NULL;
    5982:	46d8      	mov	r8, fp
            ptag = 0xffffffff;
    5984:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
            off = 0;
    5988:	465f      	mov	r7, fp
    598a:	e700      	b.n	578e <lfs_dir_traverse+0x2e>
            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
    598c:	2300      	movs	r3, #0
    598e:	9608      	str	r6, [sp, #32]
    5990:	9509      	str	r5, [sp, #36]	; 0x24
    5992:	970a      	str	r7, [sp, #40]	; 0x28
    5994:	940b      	str	r4, [sp, #44]	; 0x2c
    5996:	461c      	mov	r4, r3
    5998:	9d06      	ldr	r5, [sp, #24]
    599a:	9e3f      	ldr	r6, [sp, #252]	; 0xfc
    599c:	9f40      	ldr	r7, [sp, #256]	; 0x100
    599e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    return tag & 0x000003ff;
    59a0:	f3c3 0209 	ubfx	r2, r3, #0, #10
            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
    59a4:	4294      	cmp	r4, r2
    59a6:	d219      	bcs.n	59dc <lfs_dir_traverse+0x27c>
                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,
    59a8:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    59ac:	eb09 0281 	add.w	r2, r9, r1, lsl #2
    59b0:	f819 1021 	ldrb.w	r1, [r9, r1, lsl #2]
    59b4:	f501 7140 	add.w	r1, r1, #768	; 0x300
    return (tag & 0x000ffc00) >> 10;
    59b8:	f3c3 2389 	ubfx	r3, r3, #10, #10
                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,
    59bc:	442b      	add	r3, r5
    59be:	029b      	lsls	r3, r3, #10
    59c0:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
    59c4:	6891      	ldr	r1, [r2, #8]
    59c6:	6852      	ldr	r2, [r2, #4]
    59c8:	4319      	orrs	r1, r3
    59ca:	4638      	mov	r0, r7
    59cc:	47b0      	blx	r6
                if (res < 0) {
    59ce:	2800      	cmp	r0, #0
    59d0:	db3b      	blt.n	5a4a <lfs_dir_traverse+0x2ea>
                if (res) {
    59d2:	2800      	cmp	r0, #0
    59d4:	f47f af2c 	bne.w	5830 <lfs_dir_traverse+0xd0>
            for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
    59d8:	3401      	adds	r4, #1
    59da:	e7e0      	b.n	599e <lfs_dir_traverse+0x23e>
    59dc:	9e08      	ldr	r6, [sp, #32]
    59de:	9d09      	ldr	r5, [sp, #36]	; 0x24
    59e0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    59e2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    59e4:	e6d3      	b.n	578e <lfs_dir_traverse+0x2e>
                res = 0;
    59e6:	2300      	movs	r3, #0
    if (sp > 0) {
    59e8:	b386      	cbz	r6, 5a4c <lfs_dir_traverse+0x2ec>
        dir         = stack[sp-1].dir;
    59ea:	3e01      	subs	r6, #1
    59ec:	ebc6 1306 	rsb	r3, r6, r6, lsl #4
    59f0:	aa2e      	add	r2, sp, #184	; 0xb8
    59f2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    59f6:	f853 5c78 	ldr.w	r5, [r3, #-120]
        off         = stack[sp-1].off;
    59fa:	f853 7c74 	ldr.w	r7, [r3, #-116]
        ptag        = stack[sp-1].ptag;
    59fe:	f853 4c70 	ldr.w	r4, [r3, #-112]
        attrs       = stack[sp-1].attrs;
    5a02:	f853 8c6c 	ldr.w	r8, [r3, #-108]
        attrcount   = stack[sp-1].attrcount;
    5a06:	f853 bc68 	ldr.w	fp, [r3, #-104]
        tmask       = stack[sp-1].tmask;
    5a0a:	f853 ac64 	ldr.w	sl, [r3, #-100]
        ttag        = stack[sp-1].ttag;
    5a0e:	f853 2c60 	ldr.w	r2, [r3, #-96]
    5a12:	923b      	str	r2, [sp, #236]	; 0xec
        begin       = stack[sp-1].begin;
    5a14:	f833 2c5c 	ldrh.w	r2, [r3, #-92]
    5a18:	9204      	str	r2, [sp, #16]
        end         = stack[sp-1].end;
    5a1a:	f833 2c5a 	ldrh.w	r2, [r3, #-90]
    5a1e:	9205      	str	r2, [sp, #20]
        diff        = stack[sp-1].diff;
    5a20:	f933 2c58 	ldrsh.w	r2, [r3, #-88]
    5a24:	9206      	str	r2, [sp, #24]
        cb          = stack[sp-1].cb;
    5a26:	f853 2c54 	ldr.w	r2, [r3, #-84]
    5a2a:	923f      	str	r2, [sp, #252]	; 0xfc
        data        = stack[sp-1].data;
    5a2c:	f853 2c50 	ldr.w	r2, [r3, #-80]
    5a30:	9240      	str	r2, [sp, #256]	; 0x100
        tag         = stack[sp-1].tag;
    5a32:	f853 2c4c 	ldr.w	r2, [r3, #-76]
    5a36:	920f      	str	r2, [sp, #60]	; 0x3c
        buffer      = stack[sp-1].buffer;
    5a38:	f853 9c48 	ldr.w	r9, [r3, #-72]
        disk        = stack[sp-1].disk;
    5a3c:	aa0d      	add	r2, sp, #52	; 0x34
    5a3e:	3b44      	subs	r3, #68	; 0x44
    5a40:	e893 0003 	ldmia.w	r3, {r0, r1}
    5a44:	e882 0003 	stmia.w	r2, {r0, r1}
        goto popped;
    5a48:	e6ca      	b.n	57e0 <lfs_dir_traverse+0x80>
    5a4a:	4603      	mov	r3, r0
}
    5a4c:	4618      	mov	r0, r3
    5a4e:	b02f      	add	sp, #188	; 0xbc
    5a50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5a54:	7ff00000 	.word	0x7ff00000
    5a58:	00005515 	.word	0x00005515
    5a5c:	600ffc00 	.word	0x600ffc00

00005a60 <lfs_file_flushedread>:
        void *buffer, lfs_size_t size) {
    5a60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5a64:	b087      	sub	sp, #28
    5a66:	460c      	mov	r4, r1
    5a68:	4617      	mov	r7, r2
    if (file->pos >= file->ctz.size) {
    5a6a:	6b49      	ldr	r1, [r1, #52]	; 0x34
    5a6c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    5a6e:	4291      	cmp	r1, r2
    5a70:	d272      	bcs.n	5b58 <lfs_file_flushedread+0xf8>
    5a72:	4680      	mov	r8, r0
    size = lfs_min(size, file->ctz.size - file->pos);
    5a74:	eba2 0901 	sub.w	r9, r2, r1
	return (a < b) ? a : b;
    5a78:	4599      	cmp	r9, r3
    5a7a:	bf28      	it	cs
    5a7c:	4699      	movcs	r9, r3
    nsize = size;
    5a7e:	464e      	mov	r6, r9
    while (nsize > 0) {
    5a80:	e037      	b.n	5af2 <lfs_file_flushedread+0x92>
            if (!(file->flags & LFS_F_INLINE)) {
    5a82:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    5a86:	d041      	beq.n	5b0c <lfs_file_flushedread+0xac>
                file->block = LFS_BLOCK_INLINE;
    5a88:	f06f 0301 	mvn.w	r3, #1
    5a8c:	63a3      	str	r3, [r4, #56]	; 0x38
                file->off = file->pos;
    5a8e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    5a90:	63e3      	str	r3, [r4, #60]	; 0x3c
            file->flags |= LFS_F_READING;
    5a92:	6b23      	ldr	r3, [r4, #48]	; 0x30
    5a94:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    5a98:	6323      	str	r3, [r4, #48]	; 0x30
        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
    5a9a:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
    5a9e:	69db      	ldr	r3, [r3, #28]
    5aa0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    5aa2:	1a9d      	subs	r5, r3, r2
    5aa4:	42b5      	cmp	r5, r6
    5aa6:	bf28      	it	cs
    5aa8:	4635      	movcs	r5, r6
        if (file->flags & LFS_F_INLINE) {
    5aaa:	6b21      	ldr	r1, [r4, #48]	; 0x30
    5aac:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    5ab0:	d041      	beq.n	5b36 <lfs_file_flushedread+0xd6>
                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),
    5ab2:	88a1      	ldrh	r1, [r4, #4]
    5ab4:	0289      	lsls	r1, r1, #10
            int err = lfs_dir_getread(lfs, &file->m,
    5ab6:	9505      	str	r5, [sp, #20]
    5ab8:	9704      	str	r7, [sp, #16]
    5aba:	9203      	str	r2, [sp, #12]
    5abc:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
    5ac0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    5ac4:	9102      	str	r1, [sp, #8]
    5ac6:	4a27      	ldr	r2, [pc, #156]	; (5b64 <lfs_file_flushedread+0x104>)
    5ac8:	9201      	str	r2, [sp, #4]
    5aca:	9300      	str	r3, [sp, #0]
    5acc:	f104 0340 	add.w	r3, r4, #64	; 0x40
    5ad0:	2200      	movs	r2, #0
    5ad2:	f104 0108 	add.w	r1, r4, #8
    5ad6:	4640      	mov	r0, r8
    5ad8:	f006 fcce 	bl	c478 <lfs_dir_getread>
            if (err) {
    5adc:	4603      	mov	r3, r0
    5ade:	2800      	cmp	r0, #0
    5ae0:	d13b      	bne.n	5b5a <lfs_file_flushedread+0xfa>
        file->pos += diff;
    5ae2:	6b63      	ldr	r3, [r4, #52]	; 0x34
    5ae4:	442b      	add	r3, r5
    5ae6:	6363      	str	r3, [r4, #52]	; 0x34
        file->off += diff;
    5ae8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    5aea:	442b      	add	r3, r5
    5aec:	63e3      	str	r3, [r4, #60]	; 0x3c
        data += diff;
    5aee:	442f      	add	r7, r5
        nsize -= diff;
    5af0:	1b76      	subs	r6, r6, r5
    while (nsize > 0) {
    5af2:	2e00      	cmp	r6, #0
    5af4:	d02e      	beq.n	5b54 <lfs_file_flushedread+0xf4>
        if (!(file->flags & LFS_F_READING) ||
    5af6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    5af8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    5afc:	d0c1      	beq.n	5a82 <lfs_file_flushedread+0x22>
                file->off == lfs->cfg->block_size) {
    5afe:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    5b00:	f8d8 2068 	ldr.w	r2, [r8, #104]	; 0x68
    5b04:	69d2      	ldr	r2, [r2, #28]
        if (!(file->flags & LFS_F_READING) ||
    5b06:	4291      	cmp	r1, r2
    5b08:	d1c7      	bne.n	5a9a <lfs_file_flushedread+0x3a>
    5b0a:	e7ba      	b.n	5a82 <lfs_file_flushedread+0x22>
                int err = lfs_ctz_find(lfs, NULL, &file->cache,
    5b0c:	f104 033c 	add.w	r3, r4, #60	; 0x3c
    5b10:	9303      	str	r3, [sp, #12]
    5b12:	f104 0338 	add.w	r3, r4, #56	; 0x38
    5b16:	9302      	str	r3, [sp, #8]
    5b18:	6b63      	ldr	r3, [r4, #52]	; 0x34
    5b1a:	9301      	str	r3, [sp, #4]
    5b1c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5b1e:	9300      	str	r3, [sp, #0]
    5b20:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    5b22:	f104 0240 	add.w	r2, r4, #64	; 0x40
    5b26:	2100      	movs	r1, #0
    5b28:	4640      	mov	r0, r8
    5b2a:	f006 fe31 	bl	c790 <lfs_ctz_find>
                if (err) {
    5b2e:	4603      	mov	r3, r0
    5b30:	2800      	cmp	r0, #0
    5b32:	d0ae      	beq.n	5a92 <lfs_file_flushedread+0x32>
    5b34:	e011      	b.n	5b5a <lfs_file_flushedread+0xfa>
            int err = lfs_bd_read(lfs,
    5b36:	9503      	str	r5, [sp, #12]
    5b38:	9702      	str	r7, [sp, #8]
    5b3a:	9201      	str	r2, [sp, #4]
    5b3c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    5b3e:	9200      	str	r2, [sp, #0]
    5b40:	f104 0240 	add.w	r2, r4, #64	; 0x40
    5b44:	2100      	movs	r1, #0
    5b46:	4640      	mov	r0, r8
    5b48:	f006 fb4a 	bl	c1e0 <lfs_bd_read>
            if (err) {
    5b4c:	4603      	mov	r3, r0
    5b4e:	2800      	cmp	r0, #0
    5b50:	d0c7      	beq.n	5ae2 <lfs_file_flushedread+0x82>
    5b52:	e002      	b.n	5b5a <lfs_file_flushedread+0xfa>
    return size;
    5b54:	464b      	mov	r3, r9
    5b56:	e000      	b.n	5b5a <lfs_file_flushedread+0xfa>
        return 0;
    5b58:	2300      	movs	r3, #0
}
    5b5a:	4618      	mov	r0, r3
    5b5c:	b007      	add	sp, #28
    5b5e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5b62:	bf00      	nop
    5b64:	fff7fc00 	.word	0xfff7fc00

00005b68 <lfs_dir_fetchmatch>:
        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
    5b68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5b6c:	b095      	sub	sp, #84	; 0x54
    5b6e:	4615      	mov	r5, r2
    5b70:	9307      	str	r3, [sp, #28]
    if (pair[0] >= lfs->cfg->block_count || pair[1] >= lfs->cfg->block_count) {
    5b72:	6812      	ldr	r2, [r2, #0]
    5b74:	6e83      	ldr	r3, [r0, #104]	; 0x68
    5b76:	6a1b      	ldr	r3, [r3, #32]
    5b78:	429a      	cmp	r2, r3
    5b7a:	f080 823a 	bcs.w	5ff2 <lfs_dir_fetchmatch+0x48a>
    5b7e:	4604      	mov	r4, r0
    5b80:	460e      	mov	r6, r1
    5b82:	686a      	ldr	r2, [r5, #4]
    5b84:	4293      	cmp	r3, r2
    5b86:	f240 8237 	bls.w	5ff8 <lfs_dir_fetchmatch+0x490>
    uint32_t revs[2] = {0, 0};
    5b8a:	2300      	movs	r3, #0
    5b8c:	9310      	str	r3, [sp, #64]	; 0x40
    5b8e:	9311      	str	r3, [sp, #68]	; 0x44
    for (int i = 0; i < 2; i++) {
    5b90:	461f      	mov	r7, r3
    int r = 0;
    5b92:	4699      	mov	r9, r3
    for (int i = 0; i < 2; i++) {
    5b94:	e00e      	b.n	5bb4 <lfs_dir_fetchmatch+0x4c>
                lfs_scmp(revs[i], revs[(i+1)%2]) > 0) {
    5b96:	1c7b      	adds	r3, r7, #1
    5b98:	f003 0301 	and.w	r3, r3, #1
    5b9c:	bf48      	it	mi
    5b9e:	425b      	negmi	r3, r3
    5ba0:	a914      	add	r1, sp, #80	; 0x50
    5ba2:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    5ba6:	f853 3c10 	ldr.w	r3, [r3, #-16]
	return (int)(unsigned int)(a - b);
    5baa:	1ad2      	subs	r2, r2, r3
        if (err != LFS_ERR_CORRUPT &&
    5bac:	2a00      	cmp	r2, #0
    5bae:	dd00      	ble.n	5bb2 <lfs_dir_fetchmatch+0x4a>
            r = i;
    5bb0:	46b9      	mov	r9, r7
    for (int i = 0; i < 2; i++) {
    5bb2:	3701      	adds	r7, #1
    5bb4:	2f01      	cmp	r7, #1
    5bb6:	dc1d      	bgt.n	5bf4 <lfs_dir_fetchmatch+0x8c>
                pair[i], 0, &revs[i], sizeof(revs[i]));
    5bb8:	ea4f 0887 	mov.w	r8, r7, lsl #2
    5bbc:	ab10      	add	r3, sp, #64	; 0x40
    5bbe:	eb03 0287 	add.w	r2, r3, r7, lsl #2
        int err = lfs_bd_read(lfs,
    5bc2:	2304      	movs	r3, #4
    5bc4:	9303      	str	r3, [sp, #12]
    5bc6:	9202      	str	r2, [sp, #8]
    5bc8:	2100      	movs	r1, #0
    5bca:	9101      	str	r1, [sp, #4]
    5bcc:	f855 2027 	ldr.w	r2, [r5, r7, lsl #2]
    5bd0:	9200      	str	r2, [sp, #0]
    5bd2:	4622      	mov	r2, r4
    5bd4:	4620      	mov	r0, r4
    5bd6:	f006 fb03 	bl	c1e0 <lfs_bd_read>
        revs[i] = lfs_fromle32(revs[i]);
    5bda:	f108 0350 	add.w	r3, r8, #80	; 0x50
    5bde:	eb0d 0803 	add.w	r8, sp, r3
    5be2:	f858 2c10 	ldr.w	r2, [r8, #-16]
        if (err && err != LFS_ERR_CORRUPT) {
    5be6:	4682      	mov	sl, r0
    5be8:	2800      	cmp	r0, #0
    5bea:	d0d4      	beq.n	5b96 <lfs_dir_fetchmatch+0x2e>
    5bec:	f110 0f54 	cmn.w	r0, #84	; 0x54
    5bf0:	d0df      	beq.n	5bb2 <lfs_dir_fetchmatch+0x4a>
    5bf2:	e1fa      	b.n	5fea <lfs_dir_fetchmatch+0x482>
    dir->pair[0] = pair[(r+0)%2];
    5bf4:	f1b9 0f00 	cmp.w	r9, #0
    5bf8:	f009 0301 	and.w	r3, r9, #1
    5bfc:	bfb8      	it	lt
    5bfe:	425b      	neglt	r3, r3
    5c00:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
    5c04:	6032      	str	r2, [r6, #0]
    dir->pair[1] = pair[(r+1)%2];
    5c06:	f119 0c01 	adds.w	ip, r9, #1
    5c0a:	f00c 0c01 	and.w	ip, ip, #1
    5c0e:	bf48      	it	mi
    5c10:	f1cc 0c00 	rsbmi	ip, ip, #0
    5c14:	46e1      	mov	r9, ip
    5c16:	f855 202c 	ldr.w	r2, [r5, ip, lsl #2]
    5c1a:	6072      	str	r2, [r6, #4]
    dir->rev = revs[(r+0)%2];
    5c1c:	aa14      	add	r2, sp, #80	; 0x50
    5c1e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    5c22:	f853 3c10 	ldr.w	r3, [r3, #-16]
    5c26:	60b3      	str	r3, [r6, #8]
    dir->off = 0; // nonzero = found some commits
    5c28:	2700      	movs	r7, #0
    5c2a:	60f7      	str	r7, [r6, #12]
    lfs_stag_t besttag = -1;
    5c2c:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    5c30:	f8cd a020 	str.w	sl, [sp, #32]
    5c34:	46ba      	mov	sl, r7
    for (int i = 0; i < 2; i++) {
    5c36:	e046      	b.n	5cc6 <lfs_dir_fetchmatch+0x15e>
                if (err == LFS_ERR_CORRUPT) {
    5c38:	f110 0f54 	cmn.w	r0, #84	; 0x54
    5c3c:	f040 818f 	bne.w	5f5e <lfs_dir_fetchmatch+0x3f6>
                    dir->erased = false;
    5c40:	2300      	movs	r3, #0
    5c42:	75b3      	strb	r3, [r6, #22]
                    break;
    5c44:	e02f      	b.n	5ca6 <lfs_dir_fetchmatch+0x13e>
    return (tag & 0x70000000) >> 20;
    5c46:	ea4f 5318 	mov.w	r3, r8, lsr #20
    5c4a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
                dir->erased = (lfs_tag_type1(ptag) == LFS_TYPE_CRC &&
    5c4e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    5c52:	d004      	beq.n	5c5e <lfs_dir_fetchmatch+0xf6>
    5c54:	9b05      	ldr	r3, [sp, #20]
    5c56:	f003 0301 	and.w	r3, r3, #1
    5c5a:	75b3      	strb	r3, [r6, #22]
                break;
    5c5c:	e023      	b.n	5ca6 <lfs_dir_fetchmatch+0x13e>
                        dir->off % lfs->cfg->prog_size == 0);
    5c5e:	68f3      	ldr	r3, [r6, #12]
    5c60:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    5c62:	6992      	ldr	r2, [r2, #24]
    5c64:	fbb3 f1f2 	udiv	r1, r3, r2
    5c68:	fb02 3311 	mls	r3, r2, r1, r3
                dir->erased = (lfs_tag_type1(ptag) == LFS_TYPE_CRC &&
    5c6c:	2b00      	cmp	r3, #0
    5c6e:	d1f1      	bne.n	5c54 <lfs_dir_fetchmatch+0xec>
    5c70:	2301      	movs	r3, #1
    5c72:	9305      	str	r3, [sp, #20]
    5c74:	e7ee      	b.n	5c54 <lfs_dir_fetchmatch+0xec>
                dir->erased = false;
    5c76:	2300      	movs	r3, #0
    5c78:	75b3      	strb	r3, [r6, #22]
                break;
    5c7a:	e014      	b.n	5ca6 <lfs_dir_fetchmatch+0x13e>
                err = lfs_bd_read(lfs,
    5c7c:	2204      	movs	r2, #4
    5c7e:	9203      	str	r2, [sp, #12]
    5c80:	aa0d      	add	r2, sp, #52	; 0x34
    5c82:	9202      	str	r2, [sp, #8]
    5c84:	1d3a      	adds	r2, r7, #4
    5c86:	9201      	str	r2, [sp, #4]
    5c88:	6832      	ldr	r2, [r6, #0]
    5c8a:	9200      	str	r2, [sp, #0]
    5c8c:	4622      	mov	r2, r4
    5c8e:	2100      	movs	r1, #0
    5c90:	4620      	mov	r0, r4
    5c92:	f006 faa5 	bl	c1e0 <lfs_bd_read>
                if (err) {
    5c96:	2800      	cmp	r0, #0
    5c98:	d130      	bne.n	5cfc <lfs_dir_fetchmatch+0x194>
                if (crc != dcrc) {
    5c9a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    5c9c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5c9e:	429a      	cmp	r2, r3
    5ca0:	d034      	beq.n	5d0c <lfs_dir_fetchmatch+0x1a4>
                    dir->erased = false;
    5ca2:	2300      	movs	r3, #0
    5ca4:	75b3      	strb	r3, [r6, #22]
        if (dir->off > 0) {
    5ca6:	68f3      	ldr	r3, [r6, #12]
    5ca8:	2b00      	cmp	r3, #0
    5caa:	f040 815b 	bne.w	5f64 <lfs_dir_fetchmatch+0x3fc>
    lfs_block_t t = pair[0];
    5cae:	6833      	ldr	r3, [r6, #0]
    pair[0] = pair[1];
    5cb0:	6872      	ldr	r2, [r6, #4]
    5cb2:	6032      	str	r2, [r6, #0]
    pair[1] = t;
    5cb4:	6073      	str	r3, [r6, #4]
        dir->rev = revs[(r+1)%2];
    5cb6:	ab14      	add	r3, sp, #80	; 0x50
    5cb8:	eb03 0389 	add.w	r3, r3, r9, lsl #2
    5cbc:	f853 3c10 	ldr.w	r3, [r3, #-16]
    5cc0:	60b3      	str	r3, [r6, #8]
    for (int i = 0; i < 2; i++) {
    5cc2:	f10a 0a01 	add.w	sl, sl, #1
    5cc6:	f1ba 0f01 	cmp.w	sl, #1
    5cca:	f300 8181 	bgt.w	5fd0 <lfs_dir_fetchmatch+0x468>
        lfs_block_t temptail[2] = {LFS_BLOCK_NULL, LFS_BLOCK_NULL};
    5cce:	4ab1      	ldr	r2, [pc, #708]	; (5f94 <lfs_dir_fetchmatch+0x42c>)
    5cd0:	ab0e      	add	r3, sp, #56	; 0x38
    5cd2:	e892 0003 	ldmia.w	r2, {r0, r1}
    5cd6:	e883 0003 	stmia.w	r3, {r0, r1}
        uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));
    5cda:	2204      	movs	r2, #4
    5cdc:	f106 0108 	add.w	r1, r6, #8
    5ce0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5ce4:	f002 f87a 	bl	7ddc <lfs_crc>
    5ce8:	900b      	str	r0, [sp, #44]	; 0x2c
        lfs_stag_t tempbesttag = besttag;
    5cea:	9b08      	ldr	r3, [sp, #32]
    5cec:	9306      	str	r3, [sp, #24]
        bool tempsplit = false;
    5cee:	2300      	movs	r3, #0
    5cf0:	461f      	mov	r7, r3
    5cf2:	9309      	str	r3, [sp, #36]	; 0x24
        uint16_t tempcount = 0;
    5cf4:	469b      	mov	fp, r3
        lfs_tag_t ptag = 0xffffffff;
    5cf6:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    5cfa:	e085      	b.n	5e08 <lfs_dir_fetchmatch+0x2a0>
                    if (err == LFS_ERR_CORRUPT) {
    5cfc:	f110 0f54 	cmn.w	r0, #84	; 0x54
    5d00:	d102      	bne.n	5d08 <lfs_dir_fetchmatch+0x1a0>
                        dir->erased = false;
    5d02:	2300      	movs	r3, #0
    5d04:	75b3      	strb	r3, [r6, #22]
                        break;
    5d06:	e7ce      	b.n	5ca6 <lfs_dir_fetchmatch+0x13e>
                    return err;
    5d08:	4682      	mov	sl, r0
    5d0a:	e16e      	b.n	5fea <lfs_dir_fetchmatch+0x482>
                ptag ^= (lfs_tag_t)(lfs_tag_chunk(tag) & 1U) << 31;
    5d0c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5d0e:	f3c3 5307 	ubfx	r3, r3, #20, #8
    5d12:	ea85 78c3 	eor.w	r8, r5, r3, lsl #31
                lfs->seed = lfs_crc(lfs->seed, &crc, sizeof(crc));
    5d16:	2204      	movs	r2, #4
    5d18:	a90b      	add	r1, sp, #44	; 0x2c
    5d1a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    5d1c:	f002 f85e 	bl	7ddc <lfs_crc>
    5d20:	62e0      	str	r0, [r4, #44]	; 0x2c
                dir->off = off + lfs_tag_dsize(tag);
    5d22:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    return ((int32_t)(tag << 22) >> 22) == -1;
    5d24:	f343 0209 	sbfx	r2, r3, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5d28:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    5d2c:	bf08      	it	eq
    5d2e:	3301      	addeq	r3, #1
    return tag & 0x000003ff;
    5d30:	f3c3 0309 	ubfx	r3, r3, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5d34:	3304      	adds	r3, #4
                dir->off = off + lfs_tag_dsize(tag);
    5d36:	443b      	add	r3, r7
    5d38:	60f3      	str	r3, [r6, #12]
                dir->etag = ptag;
    5d3a:	f8c6 8010 	str.w	r8, [r6, #16]
                dir->count = tempcount;
    5d3e:	f8a6 b014 	strh.w	fp, [r6, #20]
                dir->tail[0] = temptail[0];
    5d42:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    5d44:	61b3      	str	r3, [r6, #24]
                dir->tail[1] = temptail[1];
    5d46:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    5d48:	61f3      	str	r3, [r6, #28]
                dir->split = tempsplit;
    5d4a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5d4c:	75f3      	strb	r3, [r6, #23]
                crc = 0xffffffff;
    5d4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5d52:	930b      	str	r3, [sp, #44]	; 0x2c
                besttag = tempbesttag;
    5d54:	9b06      	ldr	r3, [sp, #24]
    5d56:	9308      	str	r3, [sp, #32]
    5d58:	e056      	b.n	5e08 <lfs_dir_fetchmatch+0x2a0>
                    return err;
    5d5a:	4682      	mov	sl, r0
    5d5c:	e145      	b.n	5fea <lfs_dir_fetchmatch+0x482>
                crc = lfs_crc(crc, &dat, 1);
    5d5e:	2201      	movs	r2, #1
    5d60:	a90d      	add	r1, sp, #52	; 0x34
    5d62:	980b      	ldr	r0, [sp, #44]	; 0x2c
    5d64:	f002 f83a 	bl	7ddc <lfs_crc>
    5d68:	900b      	str	r0, [sp, #44]	; 0x2c
            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
    5d6a:	f108 0801 	add.w	r8, r8, #1
    5d6e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    return ((int32_t)(tag << 22) >> 22) == -1;
    5d70:	f343 0209 	sbfx	r2, r3, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5d74:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    5d78:	bf08      	it	eq
    5d7a:	3301      	addeq	r3, #1
    return tag & 0x000003ff;
    5d7c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5d80:	3304      	adds	r3, #4
            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
    5d82:	4543      	cmp	r3, r8
    5d84:	d916      	bls.n	5db4 <lfs_dir_fetchmatch+0x24c>
                        NULL, &lfs->rcache, lfs->cfg->block_size,
    5d86:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    5d88:	69db      	ldr	r3, [r3, #28]
                err = lfs_bd_read(lfs,
    5d8a:	2201      	movs	r2, #1
    5d8c:	9203      	str	r2, [sp, #12]
    5d8e:	aa0d      	add	r2, sp, #52	; 0x34
    5d90:	9202      	str	r2, [sp, #8]
    5d92:	eb07 0208 	add.w	r2, r7, r8
    5d96:	9201      	str	r2, [sp, #4]
    5d98:	6832      	ldr	r2, [r6, #0]
    5d9a:	9200      	str	r2, [sp, #0]
    5d9c:	4622      	mov	r2, r4
    5d9e:	2100      	movs	r1, #0
    5da0:	4620      	mov	r0, r4
    5da2:	f006 fa1d 	bl	c1e0 <lfs_bd_read>
                if (err) {
    5da6:	2800      	cmp	r0, #0
    5da8:	d0d9      	beq.n	5d5e <lfs_dir_fetchmatch+0x1f6>
                    if (err == LFS_ERR_CORRUPT) {
    5daa:	f110 0f54 	cmn.w	r0, #84	; 0x54
    5dae:	d1d4      	bne.n	5d5a <lfs_dir_fetchmatch+0x1f2>
                        dir->erased = false;
    5db0:	2300      	movs	r3, #0
    5db2:	75b3      	strb	r3, [r6, #22]
            if (lfs_tag_type1(tag) == LFS_TYPE_NAME) {
    5db4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    return (tag & 0x70000000) >> 20;
    5db6:	0d1a      	lsrs	r2, r3, #20
            if (lfs_tag_type1(tag) == LFS_TYPE_NAME) {
    5db8:	f412 61e0 	ands.w	r1, r2, #1792	; 0x700
    5dbc:	d106      	bne.n	5dcc <lfs_dir_fetchmatch+0x264>
    return (tag & 0x000ffc00) >> 10;
    5dbe:	f3c3 2389 	ubfx	r3, r3, #10, #10
                if (lfs_tag_id(tag) >= tempcount) {
    5dc2:	455b      	cmp	r3, fp
    5dc4:	d309      	bcc.n	5dda <lfs_dir_fetchmatch+0x272>
                    tempcount = lfs_tag_id(tag) + 1;
    5dc6:	f103 0b01 	add.w	fp, r3, #1
    5dca:	e006      	b.n	5dda <lfs_dir_fetchmatch+0x272>
            } else if (lfs_tag_type1(tag) == LFS_TYPE_SPLICE) {
    5dcc:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
    5dd0:	d060      	beq.n	5e94 <lfs_dir_fetchmatch+0x32c>
            } else if (lfs_tag_type1(tag) == LFS_TYPE_TAIL) {
    5dd2:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
    5dd6:	f000 8084 	beq.w	5ee2 <lfs_dir_fetchmatch+0x37a>
            if ((fmask & tag) == (fmask & ftag)) {
    5dda:	990c      	ldr	r1, [sp, #48]	; 0x30
    5ddc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    5dde:	404b      	eors	r3, r1
    5de0:	9a07      	ldr	r2, [sp, #28]
    5de2:	4213      	tst	r3, r2
    5de4:	d10f      	bne.n	5e06 <lfs_dir_fetchmatch+0x29e>
                        dir->pair[0], off+sizeof(tag)});
    5de6:	6833      	ldr	r3, [r6, #0]
                int res = cb(data, tag, &(struct lfs_diskoff){
    5de8:	9312      	str	r3, [sp, #72]	; 0x48
                        dir->pair[0], off+sizeof(tag)});
    5dea:	1d3b      	adds	r3, r7, #4
                int res = cb(data, tag, &(struct lfs_diskoff){
    5dec:	9313      	str	r3, [sp, #76]	; 0x4c
    5dee:	aa12      	add	r2, sp, #72	; 0x48
    5df0:	9821      	ldr	r0, [sp, #132]	; 0x84
    5df2:	9b20      	ldr	r3, [sp, #128]	; 0x80
    5df4:	4798      	blx	r3
                if (res < 0) {
    5df6:	2800      	cmp	r0, #0
    5df8:	f2c0 808f 	blt.w	5f1a <lfs_dir_fetchmatch+0x3b2>
                if (res == LFS_CMP_EQ) {
    5dfc:	2800      	cmp	r0, #0
    5dfe:	f040 8094 	bne.w	5f2a <lfs_dir_fetchmatch+0x3c2>
                    tempbesttag = tag;
    5e02:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5e04:	9306      	str	r3, [sp, #24]
            ptag = tag;
    5e06:	46a8      	mov	r8, r5
    return ((int32_t)(tag << 22) >> 22) == -1;
    5e08:	f348 0209 	sbfx	r2, r8, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5e0c:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    5e10:	bf14      	ite	ne
    5e12:	4643      	movne	r3, r8
    5e14:	f108 0301 	addeq.w	r3, r8, #1
    return tag & 0x000003ff;
    5e18:	f3c3 0309 	ubfx	r3, r3, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5e1c:	3304      	adds	r3, #4
            off += lfs_tag_dsize(ptag);
    5e1e:	441f      	add	r7, r3
                    NULL, &lfs->rcache, lfs->cfg->block_size,
    5e20:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    5e22:	69db      	ldr	r3, [r3, #28]
            int err = lfs_bd_read(lfs,
    5e24:	2204      	movs	r2, #4
    5e26:	9203      	str	r2, [sp, #12]
    5e28:	aa0c      	add	r2, sp, #48	; 0x30
    5e2a:	9202      	str	r2, [sp, #8]
    5e2c:	9701      	str	r7, [sp, #4]
    5e2e:	6832      	ldr	r2, [r6, #0]
    5e30:	9200      	str	r2, [sp, #0]
    5e32:	4622      	mov	r2, r4
    5e34:	2100      	movs	r1, #0
    5e36:	4620      	mov	r0, r4
    5e38:	f006 f9d2 	bl	c1e0 <lfs_bd_read>
            if (err) {
    5e3c:	9005      	str	r0, [sp, #20]
    5e3e:	2800      	cmp	r0, #0
    5e40:	f47f aefa 	bne.w	5c38 <lfs_dir_fetchmatch+0xd0>
            crc = lfs_crc(crc, &tag, sizeof(tag));
    5e44:	2204      	movs	r2, #4
    5e46:	a90c      	add	r1, sp, #48	; 0x30
    5e48:	980b      	ldr	r0, [sp, #44]	; 0x2c
    5e4a:	f001 ffc7 	bl	7ddc <lfs_crc>
    5e4e:	900b      	str	r0, [sp, #44]	; 0x2c
            tag = lfs_frombe32(tag) ^ ptag;
    5e50:	9d0c      	ldr	r5, [sp, #48]	; 0x30
	return __builtin_bswap32(a);
    5e52:	ba2d      	rev	r5, r5
    5e54:	ea85 0508 	eor.w	r5, r5, r8
    5e58:	950c      	str	r5, [sp, #48]	; 0x30
            if (!lfs_tag_isvalid(tag)) {
    5e5a:	2d00      	cmp	r5, #0
    5e5c:	f6ff aef3 	blt.w	5c46 <lfs_dir_fetchmatch+0xde>
    return ((int32_t)(tag << 22) >> 22) == -1;
    5e60:	f345 0309 	sbfx	r3, r5, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5e64:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    5e68:	bf14      	ite	ne
    5e6a:	462a      	movne	r2, r5
    5e6c:	1c6a      	addeq	r2, r5, #1
    return tag & 0x000003ff;
    5e6e:	f3c2 0209 	ubfx	r2, r2, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    5e72:	3204      	adds	r2, #4
            } else if (off + lfs_tag_dsize(tag) > lfs->cfg->block_size) {
    5e74:	443a      	add	r2, r7
    5e76:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    5e78:	69db      	ldr	r3, [r3, #28]
    5e7a:	429a      	cmp	r2, r3
    5e7c:	f63f aefb 	bhi.w	5c76 <lfs_dir_fetchmatch+0x10e>
    return (tag & 0x70000000) >> 20;
    5e80:	0d2a      	lsrs	r2, r5, #20
    5e82:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
            if (lfs_tag_type1(tag) == LFS_TYPE_CRC) {
    5e86:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    5e8a:	f43f aef7 	beq.w	5c7c <lfs_dir_fetchmatch+0x114>
            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
    5e8e:	f04f 0804 	mov.w	r8, #4
    5e92:	e76c      	b.n	5d6e <lfs_dir_fetchmatch+0x206>
    return (int8_t)lfs_tag_chunk(tag);
    5e94:	b252      	sxtb	r2, r2
                tempcount += lfs_tag_splice(tag);
    5e96:	fa1b fb82 	uxtah	fp, fp, r2
    5e9a:	fa1f fb8b 	uxth.w	fp, fp
                        (LFS_MKTAG(0, 0x3ff, 0) & tempbesttag))) {
    5e9e:	9906      	ldr	r1, [sp, #24]
    5ea0:	4608      	mov	r0, r1
                if (tag == (LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
    5ea2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    5ea6:	f421 0170 	bic.w	r1, r1, #15728640	; 0xf00000
    5eaa:	f421 717f 	bic.w	r1, r1, #1020	; 0x3fc
    5eae:	f021 0103 	bic.w	r1, r1, #3
    5eb2:	f041 419f 	orr.w	r1, r1, #1333788672	; 0x4f800000
    5eb6:	f441 01e0 	orr.w	r1, r1, #7340032	; 0x700000
    5eba:	428b      	cmp	r3, r1
    5ebc:	d00d      	beq.n	5eda <lfs_dir_fetchmatch+0x372>
                } else if (tempbesttag != -1 &&
    5ebe:	9906      	ldr	r1, [sp, #24]
    5ec0:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    5ec4:	d089      	beq.n	5dda <lfs_dir_fetchmatch+0x272>
    return (tag & 0x000ffc00) >> 10;
    5ec6:	f3c3 2389 	ubfx	r3, r3, #10, #10
    5eca:	f3c0 2189 	ubfx	r1, r0, #10, #10
                } else if (tempbesttag != -1 &&
    5ece:	428b      	cmp	r3, r1
    5ed0:	d883      	bhi.n	5dda <lfs_dir_fetchmatch+0x272>
                    tempbesttag += LFS_MKTAG(0, lfs_tag_splice(tag), 0);
    5ed2:	eb00 2382 	add.w	r3, r0, r2, lsl #10
    5ed6:	9306      	str	r3, [sp, #24]
    5ed8:	e77f      	b.n	5dda <lfs_dir_fetchmatch+0x272>
                    tempbesttag |= 0x80000000;
    5eda:	f040 4300 	orr.w	r3, r0, #2147483648	; 0x80000000
    5ede:	9306      	str	r3, [sp, #24]
    5ee0:	e77b      	b.n	5dda <lfs_dir_fetchmatch+0x272>
                tempsplit = (lfs_tag_chunk(tag) & 1);
    5ee2:	f002 0301 	and.w	r3, r2, #1
    5ee6:	9309      	str	r3, [sp, #36]	; 0x24
                        NULL, &lfs->rcache, lfs->cfg->block_size,
    5ee8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    5eea:	69db      	ldr	r3, [r3, #28]
                err = lfs_bd_read(lfs,
    5eec:	2208      	movs	r2, #8
    5eee:	9203      	str	r2, [sp, #12]
    5ef0:	aa0e      	add	r2, sp, #56	; 0x38
    5ef2:	9202      	str	r2, [sp, #8]
    5ef4:	1d3a      	adds	r2, r7, #4
    5ef6:	9201      	str	r2, [sp, #4]
    5ef8:	6832      	ldr	r2, [r6, #0]
    5efa:	9200      	str	r2, [sp, #0]
    5efc:	4622      	mov	r2, r4
    5efe:	2100      	movs	r1, #0
    5f00:	4620      	mov	r0, r4
    5f02:	f006 f96d 	bl	c1e0 <lfs_bd_read>
                if (err) {
    5f06:	2800      	cmp	r0, #0
    5f08:	f43f af67 	beq.w	5dda <lfs_dir_fetchmatch+0x272>
                    if (err == LFS_ERR_CORRUPT) {
    5f0c:	f110 0f54 	cmn.w	r0, #84	; 0x54
    5f10:	f47f af63 	bne.w	5dda <lfs_dir_fetchmatch+0x272>
                        dir->erased = false;
    5f14:	2300      	movs	r3, #0
    5f16:	75b3      	strb	r3, [r6, #22]
                        break;
    5f18:	e6c5      	b.n	5ca6 <lfs_dir_fetchmatch+0x13e>
                    if (res == LFS_ERR_CORRUPT) {
    5f1a:	f110 0f54 	cmn.w	r0, #84	; 0x54
    5f1e:	d102      	bne.n	5f26 <lfs_dir_fetchmatch+0x3be>
                        dir->erased = false;
    5f20:	2300      	movs	r3, #0
    5f22:	75b3      	strb	r3, [r6, #22]
                        break;
    5f24:	e6bf      	b.n	5ca6 <lfs_dir_fetchmatch+0x13e>
                    return res;
    5f26:	4682      	mov	sl, r0
    5f28:	e05f      	b.n	5fea <lfs_dir_fetchmatch+0x482>
                } else if ((LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) ==
    5f2a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    5f2c:	9b06      	ldr	r3, [sp, #24]
    5f2e:	469c      	mov	ip, r3
    5f30:	ea82 0103 	eor.w	r1, r2, r3
    5f34:	4b18      	ldr	r3, [pc, #96]	; (5f98 <lfs_dir_fetchmatch+0x430>)
    5f36:	400b      	ands	r3, r1
    5f38:	b16b      	cbz	r3, 5f56 <lfs_dir_fetchmatch+0x3ee>
                } else if (res == LFS_CMP_GT &&
    5f3a:	2802      	cmp	r0, #2
    5f3c:	f47f af63 	bne.w	5e06 <lfs_dir_fetchmatch+0x29e>
    return (tag & 0x000ffc00) >> 10;
    5f40:	f3c2 2389 	ubfx	r3, r2, #10, #10
    5f44:	f3cc 2c89 	ubfx	ip, ip, #10, #10
                } else if (res == LFS_CMP_GT &&
    5f48:	4563      	cmp	r3, ip
    5f4a:	f63f af5c 	bhi.w	5e06 <lfs_dir_fetchmatch+0x29e>
                    tempbesttag = tag | 0x80000000;
    5f4e:	f042 4300 	orr.w	r3, r2, #2147483648	; 0x80000000
    5f52:	9306      	str	r3, [sp, #24]
    5f54:	e757      	b.n	5e06 <lfs_dir_fetchmatch+0x29e>
                    tempbesttag = -1;
    5f56:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5f5a:	9306      	str	r3, [sp, #24]
    5f5c:	e753      	b.n	5e06 <lfs_dir_fetchmatch+0x29e>
                return err;
    5f5e:	f8dd a014 	ldr.w	sl, [sp, #20]
    5f62:	e042      	b.n	5fea <lfs_dir_fetchmatch+0x482>
    5f64:	f8dd a020 	ldr.w	sl, [sp, #32]
            if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair)) {
    5f68:	4631      	mov	r1, r6
    5f6a:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    5f6e:	f006 f873 	bl	c058 <lfs_gstate_hasmovehere>
    5f72:	b1a8      	cbz	r0, 5fa0 <lfs_dir_fetchmatch+0x438>
                if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {
    5f74:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    return (tag & 0x000ffc00) >> 10;
    5f76:	f3c3 2389 	ubfx	r3, r3, #10, #10
    5f7a:	f3ca 2289 	ubfx	r2, sl, #10, #10
                if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {
    5f7e:	4293      	cmp	r3, r2
    5f80:	d00c      	beq.n	5f9c <lfs_dir_fetchmatch+0x434>
                } else if (besttag != -1 &&
    5f82:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
    5f86:	d00b      	beq.n	5fa0 <lfs_dir_fetchmatch+0x438>
    5f88:	4293      	cmp	r3, r2
    5f8a:	d209      	bcs.n	5fa0 <lfs_dir_fetchmatch+0x438>
                    besttag -= LFS_MKTAG(0, 1, 0);
    5f8c:	f5aa 6a80 	sub.w	sl, sl, #1024	; 0x400
    5f90:	e006      	b.n	5fa0 <lfs_dir_fetchmatch+0x438>
    5f92:	bf00      	nop
    5f94:	0000e088 	.word	0x0000e088
    5f98:	7ffffc00 	.word	0x7ffffc00
                    besttag |= 0x80000000;
    5f9c:	f04a 4a00 	orr.w	sl, sl, #2147483648	; 0x80000000
            if (id) {
    5fa0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    5fa2:	b13b      	cbz	r3, 5fb4 <lfs_dir_fetchmatch+0x44c>
    return (tag & 0x000ffc00) >> 10;
    5fa4:	f3ca 2389 	ubfx	r3, sl, #10, #10
                *id = lfs_min(lfs_tag_id(besttag), dir->count);
    5fa8:	8ab2      	ldrh	r2, [r6, #20]
	return (a < b) ? a : b;
    5faa:	4293      	cmp	r3, r2
    5fac:	bf28      	it	cs
    5fae:	4613      	movcs	r3, r2
    5fb0:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    5fb2:	8013      	strh	r3, [r2, #0]
            if (lfs_tag_isvalid(besttag)) {
    5fb4:	f1ba 0f00 	cmp.w	sl, #0
    5fb8:	da17      	bge.n	5fea <lfs_dir_fetchmatch+0x482>
    return (tag & 0x000ffc00) >> 10;
    5fba:	f3ca 2389 	ubfx	r3, sl, #10, #10
            } else if (lfs_tag_id(besttag) < dir->count) {
    5fbe:	8ab2      	ldrh	r2, [r6, #20]
    5fc0:	429a      	cmp	r2, r3
    5fc2:	d902      	bls.n	5fca <lfs_dir_fetchmatch+0x462>
                return LFS_ERR_NOENT;
    5fc4:	f06f 0a01 	mvn.w	sl, #1
    5fc8:	e00f      	b.n	5fea <lfs_dir_fetchmatch+0x482>
                return 0;
    5fca:	f04f 0a00 	mov.w	sl, #0
    5fce:	e00c      	b.n	5fea <lfs_dir_fetchmatch+0x482>
    LFS_ERROR("Corrupted dir pair at {0x%"PRIx32", 0x%"PRIx32"}",
    5fd0:	6873      	ldr	r3, [r6, #4]
    5fd2:	9301      	str	r3, [sp, #4]
    5fd4:	6833      	ldr	r3, [r6, #0]
    5fd6:	9300      	str	r3, [sp, #0]
    5fd8:	f240 43d2 	movw	r3, #1234	; 0x4d2
    5fdc:	4a08      	ldr	r2, [pc, #32]	; (6000 <CONFIG_PM_PARTITION_SIZE_LITTLEFS>)
    5fde:	2145      	movs	r1, #69	; 0x45
    5fe0:	4808      	ldr	r0, [pc, #32]	; (6004 <CONFIG_PM_PARTITION_SIZE_LITTLEFS+0x4>)
    5fe2:	f004 f9ab 	bl	a33c <z_log_minimal_printk>
    return LFS_ERR_CORRUPT;
    5fe6:	f06f 0a53 	mvn.w	sl, #83	; 0x53
}
    5fea:	4650      	mov	r0, sl
    5fec:	b015      	add	sp, #84	; 0x54
    5fee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return LFS_ERR_CORRUPT;
    5ff2:	f06f 0a53 	mvn.w	sl, #83	; 0x53
    5ff6:	e7f8      	b.n	5fea <lfs_dir_fetchmatch+0x482>
    5ff8:	f06f 0a53 	mvn.w	sl, #83	; 0x53
    5ffc:	e7f5      	b.n	5fea <lfs_dir_fetchmatch+0x482>
    5ffe:	bf00      	nop
    6000:	0000f4d4 	.word	0x0000f4d4
    6004:	0000f4fc 	.word	0x0000f4fc

00006008 <lfs_fs_parent>:
        lfs_mdir_t *parent) {
    6008:	b5f0      	push	{r4, r5, r6, r7, lr}
    600a:	b089      	sub	sp, #36	; 0x24
    600c:	4606      	mov	r6, r0
    600e:	460f      	mov	r7, r1
    6010:	4614      	mov	r4, r2
    parent->tail[0] = 0;
    6012:	2500      	movs	r5, #0
    6014:	6195      	str	r5, [r2, #24]
    parent->tail[1] = 1;
    6016:	2301      	movs	r3, #1
    6018:	61d3      	str	r3, [r2, #28]
    while (!lfs_pair_isnull(parent->tail)) {
    601a:	e025      	b.n	6068 <lfs_fs_parent+0x60>
            return LFS_ERR_CORRUPT;
    601c:	f06f 0353 	mvn.w	r3, #83	; 0x53
    6020:	e02e      	b.n	6080 <lfs_fs_parent+0x78>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    6022:	2301      	movs	r3, #1
    6024:	e000      	b.n	6028 <lfs_fs_parent+0x20>
    6026:	2301      	movs	r3, #1
    while (!lfs_pair_isnull(parent->tail)) {
    6028:	bb43      	cbnz	r3, 607c <lfs_fs_parent+0x74>
        if (cycle >= lfs->cfg->block_count/2) {
    602a:	6eb3      	ldr	r3, [r6, #104]	; 0x68
    602c:	6a1b      	ldr	r3, [r3, #32]
    602e:	ebb5 0f53 	cmp.w	r5, r3, lsr #1
    6032:	d2f3      	bcs.n	601c <lfs_fs_parent+0x14>
        cycle += 1;
    6034:	3501      	adds	r5, #1
                lfs_fs_parent_match, &(struct lfs_fs_parent_match){
    6036:	9605      	str	r6, [sp, #20]
                    lfs, {pair[0], pair[1]}});
    6038:	683b      	ldr	r3, [r7, #0]
                lfs_fs_parent_match, &(struct lfs_fs_parent_match){
    603a:	9306      	str	r3, [sp, #24]
                    lfs, {pair[0], pair[1]}});
    603c:	687b      	ldr	r3, [r7, #4]
                lfs_fs_parent_match, &(struct lfs_fs_parent_match){
    603e:	9307      	str	r3, [sp, #28]
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,
    6040:	ab05      	add	r3, sp, #20
    6042:	9303      	str	r3, [sp, #12]
    6044:	4b10      	ldr	r3, [pc, #64]	; (6088 <lfs_fs_parent+0x80>)
    6046:	9302      	str	r3, [sp, #8]
    6048:	2300      	movs	r3, #0
    604a:	9301      	str	r3, [sp, #4]
    604c:	4b0f      	ldr	r3, [pc, #60]	; (608c <lfs_fs_parent+0x84>)
    604e:	9300      	str	r3, [sp, #0]
    6050:	4b0f      	ldr	r3, [pc, #60]	; (6090 <lfs_fs_parent+0x88>)
    6052:	f104 0218 	add.w	r2, r4, #24
    6056:	4621      	mov	r1, r4
    6058:	4630      	mov	r0, r6
    605a:	f7ff fd85 	bl	5b68 <lfs_dir_fetchmatch>
        if (tag && tag != LFS_ERR_NOENT) {
    605e:	4603      	mov	r3, r0
    6060:	b110      	cbz	r0, 6068 <lfs_fs_parent+0x60>
    6062:	f110 0f02 	cmn.w	r0, #2
    6066:	d10b      	bne.n	6080 <lfs_fs_parent+0x78>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    6068:	69a3      	ldr	r3, [r4, #24]
    606a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    606e:	d0da      	beq.n	6026 <lfs_fs_parent+0x1e>
    6070:	69e3      	ldr	r3, [r4, #28]
    6072:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    6076:	d0d4      	beq.n	6022 <lfs_fs_parent+0x1a>
    6078:	2300      	movs	r3, #0
    607a:	e7d5      	b.n	6028 <lfs_fs_parent+0x20>
    return LFS_ERR_NOENT;
    607c:	f06f 0301 	mvn.w	r3, #1
}
    6080:	4618      	mov	r0, r3
    6082:	b009      	add	sp, #36	; 0x24
    6084:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6086:	bf00      	nop
    6088:	0000c429 	.word	0x0000c429
    608c:	20000008 	.word	0x20000008
    6090:	7ff003ff 	.word	0x7ff003ff

00006094 <lfs_fs_rawtraverse>:
        bool includeorphans) {
    6094:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6098:	b08f      	sub	sp, #60	; 0x3c
    609a:	4605      	mov	r5, r0
    609c:	460e      	mov	r6, r1
    609e:	4617      	mov	r7, r2
    60a0:	4698      	mov	r8, r3
    lfs_mdir_t dir = {.tail = {0, 1}};
    60a2:	2220      	movs	r2, #32
    60a4:	2100      	movs	r1, #0
    60a6:	a806      	add	r0, sp, #24
    60a8:	f004 fb37 	bl	a71a <memset>
    60ac:	2301      	movs	r3, #1
    60ae:	930d      	str	r3, [sp, #52]	; 0x34
    lfs_block_t cycle = 0;
    60b0:	f04f 0900 	mov.w	r9, #0
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    60b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    60b6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    60ba:	d06d      	beq.n	6198 <lfs_fs_rawtraverse+0x104>
    60bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    60be:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    60c2:	d067      	beq.n	6194 <lfs_fs_rawtraverse+0x100>
    60c4:	2300      	movs	r3, #0
    while (!lfs_pair_isnull(dir.tail)) {
    60c6:	2b00      	cmp	r3, #0
    60c8:	d168      	bne.n	619c <lfs_fs_rawtraverse+0x108>
        if (cycle >= lfs->cfg->block_count/2) {
    60ca:	6eab      	ldr	r3, [r5, #104]	; 0x68
    60cc:	6a1b      	ldr	r3, [r3, #32]
    60ce:	ebb9 0f53 	cmp.w	r9, r3, lsr #1
    60d2:	f080 8095 	bcs.w	6200 <lfs_fs_rawtraverse+0x16c>
        cycle += 1;
    60d6:	f109 0901 	add.w	r9, r9, #1
        for (int i = 0; i < 2; i++) {
    60da:	2400      	movs	r4, #0
    60dc:	2c01      	cmp	r4, #1
    60de:	dc0b      	bgt.n	60f8 <lfs_fs_rawtraverse+0x64>
            int err = cb(data, dir.tail[i]);
    60e0:	1da3      	adds	r3, r4, #6
    60e2:	aa0e      	add	r2, sp, #56	; 0x38
    60e4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    60e8:	f853 1c20 	ldr.w	r1, [r3, #-32]
    60ec:	4638      	mov	r0, r7
    60ee:	47b0      	blx	r6
            if (err) {
    60f0:	4603      	mov	r3, r0
    60f2:	b970      	cbnz	r0, 6112 <lfs_fs_rawtraverse+0x7e>
        for (int i = 0; i < 2; i++) {
    60f4:	3401      	adds	r4, #1
    60f6:	e7f1      	b.n	60dc <lfs_fs_rawtraverse+0x48>
        int err = lfs_dir_fetch(lfs, &dir, dir.tail);
    60f8:	aa0c      	add	r2, sp, #48	; 0x30
    60fa:	a906      	add	r1, sp, #24
    60fc:	4628      	mov	r0, r5
    60fe:	f006 fb90 	bl	c822 <lfs_dir_fetch>
        if (err) {
    6102:	4682      	mov	sl, r0
    6104:	2800      	cmp	r0, #0
    6106:	d17e      	bne.n	6206 <lfs_fs_rawtraverse+0x172>
        for (uint16_t id = 0; id < dir.count; id++) {
    6108:	2400      	movs	r4, #0
    610a:	e015      	b.n	6138 <lfs_fs_rawtraverse+0xa4>
                if (tag == LFS_ERR_NOENT) {
    610c:	f113 0f02 	cmn.w	r3, #2
    6110:	d010      	beq.n	6134 <lfs_fs_rawtraverse+0xa0>
}
    6112:	4618      	mov	r0, r3
    6114:	b00f      	add	sp, #60	; 0x3c
    6116:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                err = lfs_ctz_traverse(lfs, NULL, &lfs->rcache,
    611a:	9702      	str	r7, [sp, #8]
    611c:	9601      	str	r6, [sp, #4]
    611e:	9b05      	ldr	r3, [sp, #20]
    6120:	9300      	str	r3, [sp, #0]
    6122:	9b04      	ldr	r3, [sp, #16]
    6124:	462a      	mov	r2, r5
    6126:	2100      	movs	r1, #0
    6128:	4628      	mov	r0, r5
    612a:	f006 f931 	bl	c390 <lfs_ctz_traverse>
                if (err) {
    612e:	4603      	mov	r3, r0
    6130:	2800      	cmp	r0, #0
    6132:	d1ee      	bne.n	6112 <lfs_fs_rawtraverse+0x7e>
        for (uint16_t id = 0; id < dir.count; id++) {
    6134:	3401      	adds	r4, #1
    6136:	b2a4      	uxth	r4, r4
    6138:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    613c:	42a3      	cmp	r3, r4
    613e:	d9b9      	bls.n	60b4 <lfs_fs_rawtraverse+0x20>
                    LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);
    6140:	02a3      	lsls	r3, r4, #10
            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),
    6142:	aa04      	add	r2, sp, #16
    6144:	9200      	str	r2, [sp, #0]
    6146:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    614a:	f043 0308 	orr.w	r3, r3, #8
    614e:	4a2f      	ldr	r2, [pc, #188]	; (620c <lfs_fs_rawtraverse+0x178>)
    6150:	a906      	add	r1, sp, #24
    6152:	4628      	mov	r0, r5
    6154:	f006 f90f 	bl	c376 <lfs_dir_get>
            if (tag < 0) {
    6158:	1e03      	subs	r3, r0, #0
    615a:	dbd7      	blt.n	610c <lfs_fs_rawtraverse+0x78>
    return (tag & 0x7ff00000) >> 20;
    615c:	f3c3 530a 	ubfx	r3, r3, #20, #11
            if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {
    6160:	f240 2202 	movw	r2, #514	; 0x202
    6164:	4293      	cmp	r3, r2
    6166:	d0d8      	beq.n	611a <lfs_fs_rawtraverse+0x86>
            } else if (includeorphans &&
    6168:	f1b8 0f00 	cmp.w	r8, #0
    616c:	d0e2      	beq.n	6134 <lfs_fs_rawtraverse+0xa0>
    616e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    6172:	d1df      	bne.n	6134 <lfs_fs_rawtraverse+0xa0>
                for (int i = 0; i < 2; i++) {
    6174:	46d3      	mov	fp, sl
    6176:	e001      	b.n	617c <lfs_fs_rawtraverse+0xe8>
    6178:	f10b 0b01 	add.w	fp, fp, #1
    617c:	f1bb 0f01 	cmp.w	fp, #1
    6180:	dcd8      	bgt.n	6134 <lfs_fs_rawtraverse+0xa0>
                    err = cb(data, (&ctz.head)[i]);
    6182:	ab04      	add	r3, sp, #16
    6184:	f853 102b 	ldr.w	r1, [r3, fp, lsl #2]
    6188:	4638      	mov	r0, r7
    618a:	47b0      	blx	r6
                    if (err) {
    618c:	4603      	mov	r3, r0
    618e:	2800      	cmp	r0, #0
    6190:	d0f2      	beq.n	6178 <lfs_fs_rawtraverse+0xe4>
    6192:	e7be      	b.n	6112 <lfs_fs_rawtraverse+0x7e>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    6194:	2301      	movs	r3, #1
    6196:	e796      	b.n	60c6 <lfs_fs_rawtraverse+0x32>
    6198:	2301      	movs	r3, #1
    619a:	e794      	b.n	60c6 <lfs_fs_rawtraverse+0x32>
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
    619c:	6aac      	ldr	r4, [r5, #40]	; 0x28
    619e:	e00e      	b.n	61be <lfs_fs_rawtraverse+0x12a>
            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,
    61a0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    61a2:	9702      	str	r7, [sp, #8]
    61a4:	9601      	str	r6, [sp, #4]
    61a6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    61a8:	9200      	str	r2, [sp, #0]
    61aa:	462a      	mov	r2, r5
    61ac:	f104 0140 	add.w	r1, r4, #64	; 0x40
    61b0:	4628      	mov	r0, r5
    61b2:	f006 f8ed 	bl	c390 <lfs_ctz_traverse>
            if (err) {
    61b6:	4603      	mov	r3, r0
    61b8:	b158      	cbz	r0, 61d2 <lfs_fs_rawtraverse+0x13e>
    61ba:	e7aa      	b.n	6112 <lfs_fs_rawtraverse+0x7e>
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
    61bc:	6824      	ldr	r4, [r4, #0]
    61be:	b1ec      	cbz	r4, 61fc <lfs_fs_rawtraverse+0x168>
        if (f->type != LFS_TYPE_REG) {
    61c0:	79a3      	ldrb	r3, [r4, #6]
    61c2:	2b01      	cmp	r3, #1
    61c4:	d1fa      	bne.n	61bc <lfs_fs_rawtraverse+0x128>
        if ((f->flags & LFS_F_DIRTY) && !(f->flags & LFS_F_INLINE)) {
    61c6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    61c8:	f403 1388 	and.w	r3, r3, #1114112	; 0x110000
    61cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    61d0:	d0e6      	beq.n	61a0 <lfs_fs_rawtraverse+0x10c>
        if ((f->flags & LFS_F_WRITING) && !(f->flags & LFS_F_INLINE)) {
    61d2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    61d4:	f403 1390 	and.w	r3, r3, #1179648	; 0x120000
    61d8:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
    61dc:	d1ee      	bne.n	61bc <lfs_fs_rawtraverse+0x128>
            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,
    61de:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    61e0:	9702      	str	r7, [sp, #8]
    61e2:	9601      	str	r6, [sp, #4]
    61e4:	6b62      	ldr	r2, [r4, #52]	; 0x34
    61e6:	9200      	str	r2, [sp, #0]
    61e8:	462a      	mov	r2, r5
    61ea:	f104 0140 	add.w	r1, r4, #64	; 0x40
    61ee:	4628      	mov	r0, r5
    61f0:	f006 f8ce 	bl	c390 <lfs_ctz_traverse>
            if (err) {
    61f4:	4603      	mov	r3, r0
    61f6:	2800      	cmp	r0, #0
    61f8:	d0e0      	beq.n	61bc <lfs_fs_rawtraverse+0x128>
    61fa:	e78a      	b.n	6112 <lfs_fs_rawtraverse+0x7e>
    return 0;
    61fc:	2300      	movs	r3, #0
    61fe:	e788      	b.n	6112 <lfs_fs_rawtraverse+0x7e>
            return LFS_ERR_CORRUPT;
    6200:	f06f 0353 	mvn.w	r3, #83	; 0x53
    6204:	e785      	b.n	6112 <lfs_fs_rawtraverse+0x7e>
            return err;
    6206:	4603      	mov	r3, r0
    6208:	e783      	b.n	6112 <lfs_fs_rawtraverse+0x7e>
    620a:	bf00      	nop
    620c:	700ffc00 	.word	0x700ffc00

00006210 <lfs_alloc>:
static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
    6210:	b570      	push	{r4, r5, r6, lr}
    6212:	b082      	sub	sp, #8
    6214:	4604      	mov	r4, r0
    6216:	460d      	mov	r5, r1
        while (lfs->free.i != lfs->free.size) {
    6218:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    621a:	6da2      	ldr	r2, [r4, #88]	; 0x58
    621c:	4293      	cmp	r3, r2
    621e:	d02d      	beq.n	627c <lfs_alloc+0x6c>
            lfs->free.i += 1;
    6220:	1c5a      	adds	r2, r3, #1
    6222:	65e2      	str	r2, [r4, #92]	; 0x5c
            lfs->free.ack -= 1;
    6224:	6e22      	ldr	r2, [r4, #96]	; 0x60
    6226:	3a01      	subs	r2, #1
    6228:	6622      	str	r2, [r4, #96]	; 0x60
            if (!(lfs->free.buffer[off / 32] & (1U << (off % 32)))) {
    622a:	6e62      	ldr	r2, [r4, #100]	; 0x64
    622c:	0959      	lsrs	r1, r3, #5
    622e:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    6232:	f003 001f 	and.w	r0, r3, #31
    6236:	2201      	movs	r2, #1
    6238:	4082      	lsls	r2, r0
    623a:	4211      	tst	r1, r2
    623c:	d1ec      	bne.n	6218 <lfs_alloc+0x8>
                *block = (lfs->free.off + off) % lfs->cfg->block_count;
    623e:	6d62      	ldr	r2, [r4, #84]	; 0x54
    6240:	4413      	add	r3, r2
    6242:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    6244:	6a12      	ldr	r2, [r2, #32]
    6246:	fbb3 f1f2 	udiv	r1, r3, r2
    624a:	fb02 3311 	mls	r3, r2, r1, r3
    624e:	602b      	str	r3, [r5, #0]
                while (lfs->free.i != lfs->free.size &&
    6250:	e004      	b.n	625c <lfs_alloc+0x4c>
                    lfs->free.i += 1;
    6252:	3301      	adds	r3, #1
    6254:	65e3      	str	r3, [r4, #92]	; 0x5c
                    lfs->free.ack -= 1;
    6256:	6e23      	ldr	r3, [r4, #96]	; 0x60
    6258:	3b01      	subs	r3, #1
    625a:	6623      	str	r3, [r4, #96]	; 0x60
                while (lfs->free.i != lfs->free.size &&
    625c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    625e:	6da2      	ldr	r2, [r4, #88]	; 0x58
    6260:	4293      	cmp	r3, r2
    6262:	d03c      	beq.n	62de <lfs_alloc+0xce>
                        (lfs->free.buffer[lfs->free.i / 32]
    6264:	6e62      	ldr	r2, [r4, #100]	; 0x64
    6266:	0959      	lsrs	r1, r3, #5
    6268:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
                            & (1U << (lfs->free.i % 32)))) {
    626c:	f003 001f 	and.w	r0, r3, #31
    6270:	2201      	movs	r2, #1
    6272:	4082      	lsls	r2, r0
                while (lfs->free.i != lfs->free.size &&
    6274:	4211      	tst	r1, r2
    6276:	d1ec      	bne.n	6252 <lfs_alloc+0x42>
                return 0;
    6278:	2600      	movs	r6, #0
    627a:	e031      	b.n	62e0 <lfs_alloc+0xd0>
        if (lfs->free.ack == 0) {
    627c:	6e21      	ldr	r1, [r4, #96]	; 0x60
    627e:	b309      	cbz	r1, 62c4 <lfs_alloc+0xb4>
        lfs->free.off = (lfs->free.off + lfs->free.size)
    6280:	6d63      	ldr	r3, [r4, #84]	; 0x54
    6282:	441a      	add	r2, r3
                % lfs->cfg->block_count;
    6284:	6ea0      	ldr	r0, [r4, #104]	; 0x68
    6286:	6a03      	ldr	r3, [r0, #32]
    6288:	fbb2 f6f3 	udiv	r6, r2, r3
    628c:	fb03 2216 	mls	r2, r3, r6, r2
        lfs->free.off = (lfs->free.off + lfs->free.size)
    6290:	6562      	str	r2, [r4, #84]	; 0x54
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size, lfs->free.ack);
    6292:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    6294:	00db      	lsls	r3, r3, #3
    6296:	428b      	cmp	r3, r1
    6298:	bf28      	it	cs
    629a:	460b      	movcs	r3, r1
    629c:	65a3      	str	r3, [r4, #88]	; 0x58
        lfs->free.i = 0;
    629e:	2100      	movs	r1, #0
    62a0:	65e1      	str	r1, [r4, #92]	; 0x5c
        memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
    62a2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    62a4:	6e60      	ldr	r0, [r4, #100]	; 0x64
    62a6:	f004 fa38 	bl	a71a <memset>
        int err = lfs_fs_rawtraverse(lfs, lfs_alloc_lookahead, lfs, true);
    62aa:	2301      	movs	r3, #1
    62ac:	4622      	mov	r2, r4
    62ae:	490e      	ldr	r1, [pc, #56]	; (62e8 <lfs_alloc+0xd8>)
    62b0:	4620      	mov	r0, r4
    62b2:	f7ff feef 	bl	6094 <lfs_fs_rawtraverse>
        if (err) {
    62b6:	4606      	mov	r6, r0
    62b8:	2800      	cmp	r0, #0
    62ba:	d0ad      	beq.n	6218 <lfs_alloc+0x8>
            lfs_alloc_drop(lfs);
    62bc:	4620      	mov	r0, r4
    62be:	f005 ff15 	bl	c0ec <lfs_alloc_drop>
            return err;
    62c2:	e00d      	b.n	62e0 <lfs_alloc+0xd0>
            LFS_ERROR("No more free space %"PRIu32,
    62c4:	6d62      	ldr	r2, [r4, #84]	; 0x54
    62c6:	4413      	add	r3, r2
    62c8:	9300      	str	r3, [sp, #0]
    62ca:	f240 234d 	movw	r3, #589	; 0x24d
    62ce:	4a07      	ldr	r2, [pc, #28]	; (62ec <lfs_alloc+0xdc>)
    62d0:	2145      	movs	r1, #69	; 0x45
    62d2:	4807      	ldr	r0, [pc, #28]	; (62f0 <lfs_alloc+0xe0>)
    62d4:	f004 f832 	bl	a33c <z_log_minimal_printk>
            return LFS_ERR_NOSPC;
    62d8:	f06f 061b 	mvn.w	r6, #27
    62dc:	e000      	b.n	62e0 <lfs_alloc+0xd0>
                return 0;
    62de:	2600      	movs	r6, #0
}
    62e0:	4630      	mov	r0, r6
    62e2:	b002      	add	sp, #8
    62e4:	bd70      	pop	{r4, r5, r6, pc}
    62e6:	bf00      	nop
    62e8:	0000c0b1 	.word	0x0000c0b1
    62ec:	0000f4d4 	.word	0x0000f4d4
    62f0:	0000f52c 	.word	0x0000f52c

000062f4 <lfs_file_relocate>:
static int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {
    62f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    62f6:	b089      	sub	sp, #36	; 0x24
    62f8:	4605      	mov	r5, r0
    62fa:	460e      	mov	r6, r1
    62fc:	e04a      	b.n	6394 <lfs_file_relocate+0xa0>
                err = lfs_bd_read(lfs,
    62fe:	2201      	movs	r2, #1
    6300:	9203      	str	r2, [sp, #12]
    6302:	f10d 021b 	add.w	r2, sp, #27
    6306:	9202      	str	r2, [sp, #8]
    6308:	9401      	str	r4, [sp, #4]
    630a:	6bb2      	ldr	r2, [r6, #56]	; 0x38
    630c:	9200      	str	r2, [sp, #0]
    630e:	1b1b      	subs	r3, r3, r4
    6310:	462a      	mov	r2, r5
    6312:	f106 0140 	add.w	r1, r6, #64	; 0x40
    6316:	4628      	mov	r0, r5
    6318:	f005 ff62 	bl	c1e0 <lfs_bd_read>
                if (err) {
    631c:	2800      	cmp	r0, #0
    631e:	d149      	bne.n	63b4 <lfs_file_relocate+0xc0>
            err = lfs_bd_prog(lfs,
    6320:	2301      	movs	r3, #1
    6322:	9303      	str	r3, [sp, #12]
    6324:	f10d 021b 	add.w	r2, sp, #27
    6328:	9202      	str	r2, [sp, #8]
    632a:	9401      	str	r4, [sp, #4]
    632c:	9a07      	ldr	r2, [sp, #28]
    632e:	9200      	str	r2, [sp, #0]
    6330:	462a      	mov	r2, r5
    6332:	f105 0110 	add.w	r1, r5, #16
    6336:	4628      	mov	r0, r5
    6338:	f006 f9ac 	bl	c694 <lfs_bd_prog>
            if (err) {
    633c:	bb20      	cbnz	r0, 6388 <lfs_file_relocate+0x94>
        for (lfs_off_t i = 0; i < file->off; i++) {
    633e:	3401      	adds	r4, #1
    6340:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    6342:	42a3      	cmp	r3, r4
    6344:	d93c      	bls.n	63c0 <lfs_file_relocate+0xcc>
            if (file->flags & LFS_F_INLINE) {
    6346:	6b32      	ldr	r2, [r6, #48]	; 0x30
    6348:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
    634c:	d0d7      	beq.n	62fe <lfs_file_relocate+0xa>
                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),
    634e:	88b2      	ldrh	r2, [r6, #4]
    6350:	0292      	lsls	r2, r2, #10
                err = lfs_dir_getread(lfs, &file->m,
    6352:	2101      	movs	r1, #1
    6354:	9105      	str	r1, [sp, #20]
    6356:	f10d 011b 	add.w	r1, sp, #27
    635a:	9104      	str	r1, [sp, #16]
    635c:	9403      	str	r4, [sp, #12]
    635e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
    6362:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    6366:	9202      	str	r2, [sp, #8]
    6368:	4a22      	ldr	r2, [pc, #136]	; (63f4 <lfs_file_relocate+0x100>)
    636a:	9201      	str	r2, [sp, #4]
    636c:	1b1b      	subs	r3, r3, r4
    636e:	9300      	str	r3, [sp, #0]
    6370:	f106 0340 	add.w	r3, r6, #64	; 0x40
    6374:	2200      	movs	r2, #0
    6376:	f106 0108 	add.w	r1, r6, #8
    637a:	4628      	mov	r0, r5
    637c:	f006 f87c 	bl	c478 <lfs_dir_getread>
                if (err) {
    6380:	2800      	cmp	r0, #0
    6382:	d0cd      	beq.n	6320 <lfs_file_relocate+0x2c>
                    return err;
    6384:	4607      	mov	r7, r0
    6386:	e032      	b.n	63ee <lfs_file_relocate+0xfa>
                if (err == LFS_ERR_CORRUPT) {
    6388:	f110 0f54 	cmn.w	r0, #84	; 0x54
    638c:	d114      	bne.n	63b8 <lfs_file_relocate+0xc4>
    rcache->block = LFS_BLOCK_NULL;
    638e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6392:	612b      	str	r3, [r5, #16]
        int err = lfs_alloc(lfs, &nblock);
    6394:	a907      	add	r1, sp, #28
    6396:	4628      	mov	r0, r5
    6398:	f7ff ff3a 	bl	6210 <lfs_alloc>
        if (err) {
    639c:	4607      	mov	r7, r0
    639e:	bb30      	cbnz	r0, 63ee <lfs_file_relocate+0xfa>
        err = lfs_bd_erase(lfs, nblock);
    63a0:	9907      	ldr	r1, [sp, #28]
    63a2:	4628      	mov	r0, r5
    63a4:	f005 fe1c 	bl	bfe0 <lfs_bd_erase>
        if (err) {
    63a8:	4607      	mov	r7, r0
    63aa:	b138      	cbz	r0, 63bc <lfs_file_relocate+0xc8>
            if (err == LFS_ERR_CORRUPT) {
    63ac:	f110 0f54 	cmn.w	r0, #84	; 0x54
    63b0:	d0ed      	beq.n	638e <lfs_file_relocate+0x9a>
    63b2:	e01c      	b.n	63ee <lfs_file_relocate+0xfa>
                    return err;
    63b4:	4607      	mov	r7, r0
    63b6:	e01a      	b.n	63ee <lfs_file_relocate+0xfa>
                return err;
    63b8:	4607      	mov	r7, r0
    63ba:	e018      	b.n	63ee <lfs_file_relocate+0xfa>
        for (lfs_off_t i = 0; i < file->off; i++) {
    63bc:	2400      	movs	r4, #0
    63be:	e7bf      	b.n	6340 <lfs_file_relocate+0x4c>
        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);
    63c0:	6eab      	ldr	r3, [r5, #104]	; 0x68
    63c2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    63c4:	69e9      	ldr	r1, [r5, #28]
    63c6:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
    63c8:	f004 f978 	bl	a6bc <memcpy>
        file->cache.block = lfs->pcache.block;
    63cc:	692b      	ldr	r3, [r5, #16]
    63ce:	6433      	str	r3, [r6, #64]	; 0x40
        file->cache.off = lfs->pcache.off;
    63d0:	696b      	ldr	r3, [r5, #20]
    63d2:	6473      	str	r3, [r6, #68]	; 0x44
        file->cache.size = lfs->pcache.size;
    63d4:	69ab      	ldr	r3, [r5, #24]
    63d6:	64b3      	str	r3, [r6, #72]	; 0x48
        lfs_cache_zero(lfs, &lfs->pcache);
    63d8:	f105 0110 	add.w	r1, r5, #16
    63dc:	4628      	mov	r0, r5
    63de:	f005 fed5 	bl	c18c <lfs_cache_zero>
        file->block = nblock;
    63e2:	9b07      	ldr	r3, [sp, #28]
    63e4:	63b3      	str	r3, [r6, #56]	; 0x38
        file->flags |= LFS_F_WRITING;
    63e6:	6b33      	ldr	r3, [r6, #48]	; 0x30
    63e8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    63ec:	6333      	str	r3, [r6, #48]	; 0x30
}
    63ee:	4638      	mov	r0, r7
    63f0:	b009      	add	sp, #36	; 0x24
    63f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    63f4:	fff7fc00 	.word	0xfff7fc00

000063f8 <lfs_fs_rawsize>:
    lfs_size_t *size = p;
    *size += 1;
    return 0;
}

static lfs_ssize_t lfs_fs_rawsize(lfs_t *lfs) {
    63f8:	b500      	push	{lr}
    63fa:	b083      	sub	sp, #12
    lfs_size_t size = 0;
    63fc:	2300      	movs	r3, #0
    63fe:	9301      	str	r3, [sp, #4]
    int err = lfs_fs_rawtraverse(lfs, lfs_fs_size_count, &size, false);
    6400:	aa01      	add	r2, sp, #4
    6402:	4904      	ldr	r1, [pc, #16]	; (6414 <lfs_fs_rawsize+0x1c>)
    6404:	f7ff fe46 	bl	6094 <lfs_fs_rawtraverse>
    if (err) {
    6408:	b900      	cbnz	r0, 640c <lfs_fs_rawsize+0x14>
        return err;
    }

    return size;
    640a:	9801      	ldr	r0, [sp, #4]
}
    640c:	b003      	add	sp, #12
    640e:	f85d fb04 	ldr.w	pc, [sp], #4
    6412:	bf00      	nop
    6414:	0000c183 	.word	0x0000c183

00006418 <lfs_dir_compact>:
        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
    6418:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    641c:	b09b      	sub	sp, #108	; 0x6c
    641e:	4605      	mov	r5, r0
    6420:	460c      	mov	r4, r1
    6422:	4616      	mov	r6, r2
    6424:	461f      	mov	r7, r3
    6426:	f8bd 8094 	ldrh.w	r8, [sp, #148]	; 0x94
    642a:	f8bd 9098 	ldrh.w	r9, [sp, #152]	; 0x98
    bool tired = lfs_dir_needsrelocation(lfs, dir);
    642e:	f005 fe72 	bl	c116 <lfs_dir_needsrelocation>
    dir->rev += 1;
    6432:	68a3      	ldr	r3, [r4, #8]
    6434:	3301      	adds	r3, #1
    6436:	60a3      	str	r3, [r4, #8]
    if (tired && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) != 0) {
    6438:	4682      	mov	sl, r0
    643a:	b380      	cbz	r0, 649e <lfs_dir_compact+0x86>
    643c:	2300      	movs	r3, #0
    643e:	9314      	str	r3, [sp, #80]	; 0x50
    6440:	2301      	movs	r3, #1
    6442:	9315      	str	r3, [sp, #84]	; 0x54
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    6444:	6823      	ldr	r3, [r4, #0]
    6446:	b353      	cbz	r3, 649e <lfs_dir_compact+0x86>
    6448:	6862      	ldr	r2, [r4, #4]
    644a:	2a01      	cmp	r2, #1
    644c:	d027      	beq.n	649e <lfs_dir_compact+0x86>
    644e:	2b01      	cmp	r3, #1
    6450:	d025      	beq.n	649e <lfs_dir_compact+0x86>
    6452:	b322      	cbz	r2, 649e <lfs_dir_compact+0x86>
    rcache->block = LFS_BLOCK_NULL;
    6454:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6458:	612b      	str	r3, [r5, #16]
        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
    645a:	2300      	movs	r3, #0
    645c:	9318      	str	r3, [sp, #96]	; 0x60
    645e:	2301      	movs	r3, #1
    6460:	9319      	str	r3, [sp, #100]	; 0x64
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    6462:	6823      	ldr	r3, [r4, #0]
    6464:	2b00      	cmp	r3, #0
    6466:	f000 80f6 	beq.w	6656 <lfs_dir_compact+0x23e>
    646a:	6862      	ldr	r2, [r4, #4]
    646c:	2a01      	cmp	r2, #1
    646e:	f000 80f2 	beq.w	6656 <lfs_dir_compact+0x23e>
    6472:	2b01      	cmp	r3, #1
    6474:	f000 80ef 	beq.w	6656 <lfs_dir_compact+0x23e>
    6478:	2a00      	cmp	r2, #0
    647a:	f000 80ec 	beq.w	6656 <lfs_dir_compact+0x23e>
        int err = lfs_alloc(lfs, &dir->pair[1]);
    647e:	1d21      	adds	r1, r4, #4
    6480:	4628      	mov	r0, r5
    6482:	f7ff fec5 	bl	6210 <lfs_alloc>
        if (err && (err != LFS_ERR_NOSPC || !tired)) {
    6486:	4603      	mov	r3, r0
    6488:	b330      	cbz	r0, 64d8 <lfs_dir_compact+0xc0>
    648a:	f110 0f1c 	cmn.w	r0, #28
    648e:	d11f      	bne.n	64d0 <lfs_dir_compact+0xb8>
    6490:	f1ba 0f00 	cmp.w	sl, #0
    6494:	d01c      	beq.n	64d0 <lfs_dir_compact+0xb8>
        relocated = true;
    6496:	46d3      	mov	fp, sl
        tired = false;
    6498:	f04f 0a00 	mov.w	sl, #0
    649c:	e001      	b.n	64a2 <lfs_dir_compact+0x8a>
    bool relocated = false;
    649e:	f04f 0b00 	mov.w	fp, #0
                .block = dir->pair[1],
    64a2:	6863      	ldr	r3, [r4, #4]
            struct lfs_commit commit = {
    64a4:	930e      	str	r3, [sp, #56]	; 0x38
    64a6:	2300      	movs	r3, #0
    64a8:	930f      	str	r3, [sp, #60]	; 0x3c
    64aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    64ae:	9210      	str	r2, [sp, #64]	; 0x40
    64b0:	9211      	str	r2, [sp, #68]	; 0x44
    64b2:	9312      	str	r3, [sp, #72]	; 0x48
                .end = (lfs->cfg->metadata_max ?
    64b4:	6eaa      	ldr	r2, [r5, #104]	; 0x68
    64b6:	6c93      	ldr	r3, [r2, #72]	; 0x48
                    lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,
    64b8:	b19b      	cbz	r3, 64e2 <lfs_dir_compact+0xca>
    64ba:	3b08      	subs	r3, #8
            struct lfs_commit commit = {
    64bc:	9313      	str	r3, [sp, #76]	; 0x4c
            int err = lfs_bd_erase(lfs, dir->pair[1]);
    64be:	6861      	ldr	r1, [r4, #4]
    64c0:	4628      	mov	r0, r5
    64c2:	f005 fd8d 	bl	bfe0 <lfs_bd_erase>
            if (err) {
    64c6:	4603      	mov	r3, r0
    64c8:	b170      	cbz	r0, 64e8 <lfs_dir_compact+0xd0>
                if (err == LFS_ERR_CORRUPT) {
    64ca:	f110 0f54 	cmn.w	r0, #84	; 0x54
    64ce:	d0c1      	beq.n	6454 <lfs_dir_compact+0x3c>
}
    64d0:	4618      	mov	r0, r3
    64d2:	b01b      	add	sp, #108	; 0x6c
    64d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tired = false;
    64d8:	f04f 0a00 	mov.w	sl, #0
        relocated = true;
    64dc:	f04f 0b01 	mov.w	fp, #1
    64e0:	e7df      	b.n	64a2 <lfs_dir_compact+0x8a>
                    lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,
    64e2:	69d3      	ldr	r3, [r2, #28]
    64e4:	3b08      	subs	r3, #8
    64e6:	e7e9      	b.n	64bc <lfs_dir_compact+0xa4>
            err = lfs_dir_commitprog(lfs, &commit,
    64e8:	2304      	movs	r3, #4
    64ea:	f104 0208 	add.w	r2, r4, #8
    64ee:	a90e      	add	r1, sp, #56	; 0x38
    64f0:	4628      	mov	r0, r5
    64f2:	f006 fd1d 	bl	cf30 <lfs_dir_commitprog>
            if (err) {
    64f6:	4603      	mov	r3, r0
    64f8:	b118      	cbz	r0, 6502 <lfs_dir_compact+0xea>
                if (err == LFS_ERR_CORRUPT) {
    64fa:	f110 0f54 	cmn.w	r0, #84	; 0x54
    64fe:	d1e7      	bne.n	64d0 <lfs_dir_compact+0xb8>
    6500:	e7a8      	b.n	6454 <lfs_dir_compact+0x3c>
                    lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){
    6502:	9516      	str	r5, [sp, #88]	; 0x58
    6504:	ab0e      	add	r3, sp, #56	; 0x38
    6506:	9317      	str	r3, [sp, #92]	; 0x5c
            err = lfs_dir_traverse(lfs,
    6508:	ab16      	add	r3, sp, #88	; 0x58
    650a:	9308      	str	r3, [sp, #32]
    650c:	4b58      	ldr	r3, [pc, #352]	; (6670 <lfs_dir_compact+0x258>)
    650e:	9307      	str	r3, [sp, #28]
    6510:	f1c8 0300 	rsb	r3, r8, #0
    6514:	b21b      	sxth	r3, r3
    6516:	9306      	str	r3, [sp, #24]
    6518:	f8cd 9014 	str.w	r9, [sp, #20]
    651c:	f8cd 8010 	str.w	r8, [sp, #16]
    6520:	2200      	movs	r2, #0
    6522:	9203      	str	r2, [sp, #12]
    6524:	4b53      	ldr	r3, [pc, #332]	; (6674 <lfs_dir_compact+0x25c>)
    6526:	9302      	str	r3, [sp, #8]
    6528:	9701      	str	r7, [sp, #4]
    652a:	9600      	str	r6, [sp, #0]
    652c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6530:	9924      	ldr	r1, [sp, #144]	; 0x90
    6532:	4628      	mov	r0, r5
    6534:	f7ff f914 	bl	5760 <lfs_dir_traverse>
            if (err) {
    6538:	4603      	mov	r3, r0
    653a:	b118      	cbz	r0, 6544 <lfs_dir_compact+0x12c>
                if (err == LFS_ERR_CORRUPT) {
    653c:	f110 0f54 	cmn.w	r0, #84	; 0x54
    6540:	d1c6      	bne.n	64d0 <lfs_dir_compact+0xb8>
    6542:	e787      	b.n	6454 <lfs_dir_compact+0x3c>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    6544:	69a2      	ldr	r2, [r4, #24]
    6546:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    654a:	d02c      	beq.n	65a6 <lfs_dir_compact+0x18e>
    654c:	69e2      	ldr	r2, [r4, #28]
    654e:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    6552:	d026      	beq.n	65a2 <lfs_dir_compact+0x18a>
            if (!lfs_pair_isnull(dir->tail)) {
    6554:	f013 0f01 	tst.w	r3, #1
    6558:	d027      	beq.n	65aa <lfs_dir_compact+0x192>
            lfs_gstate_t delta = {0};
    655a:	2300      	movs	r3, #0
    655c:	930b      	str	r3, [sp, #44]	; 0x2c
    655e:	930c      	str	r3, [sp, #48]	; 0x30
    6560:	930d      	str	r3, [sp, #52]	; 0x34
            if (!relocated) {
    6562:	f1bb 0f00 	cmp.w	fp, #0
    6566:	d033      	beq.n	65d0 <lfs_dir_compact+0x1b8>
            lfs_gstate_xor(&delta, &lfs->gdelta);
    6568:	f105 0148 	add.w	r1, r5, #72	; 0x48
    656c:	a80b      	add	r0, sp, #44	; 0x2c
    656e:	f005 fd62 	bl	c036 <lfs_gstate_xor>
            delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
    6572:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6574:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    6578:	f023 0303 	bic.w	r3, r3, #3
    657c:	930b      	str	r3, [sp, #44]	; 0x2c
            err = lfs_dir_getgstate(lfs, dir, &delta);
    657e:	aa0b      	add	r2, sp, #44	; 0x2c
    6580:	4621      	mov	r1, r4
    6582:	4628      	mov	r0, r5
    6584:	f7ff f8d0 	bl	5728 <lfs_dir_getgstate>
            if (err) {
    6588:	4603      	mov	r3, r0
    658a:	2800      	cmp	r0, #0
    658c:	d1a0      	bne.n	64d0 <lfs_dir_compact+0xb8>
    for (int i = 0; i < 3; i++) {
    658e:	2b02      	cmp	r3, #2
    6590:	dc29      	bgt.n	65e6 <lfs_dir_compact+0x1ce>
        if (((uint32_t*)a)[i] != 0) {
    6592:	aa1a      	add	r2, sp, #104	; 0x68
    6594:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    6598:	f852 2c3c 	ldr.w	r2, [r2, #-60]
    659c:	bb92      	cbnz	r2, 6604 <lfs_dir_compact+0x1ec>
    for (int i = 0; i < 3; i++) {
    659e:	3301      	adds	r3, #1
    65a0:	e7f5      	b.n	658e <lfs_dir_compact+0x176>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    65a2:	2301      	movs	r3, #1
    65a4:	e7d6      	b.n	6554 <lfs_dir_compact+0x13c>
    65a6:	2301      	movs	r3, #1
    65a8:	e7d4      	b.n	6554 <lfs_dir_compact+0x13c>
                        LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),
    65aa:	7de2      	ldrb	r2, [r4, #23]
    65ac:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
                err = lfs_dir_commitattr(lfs, &commit,
    65b0:	f104 0318 	add.w	r3, r4, #24
    65b4:	4930      	ldr	r1, [pc, #192]	; (6678 <lfs_dir_compact+0x260>)
    65b6:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
    65ba:	a90e      	add	r1, sp, #56	; 0x38
    65bc:	4628      	mov	r0, r5
    65be:	f006 fcd7 	bl	cf70 <lfs_dir_commitattr>
                if (err) {
    65c2:	4603      	mov	r3, r0
    65c4:	2800      	cmp	r0, #0
    65c6:	d0c8      	beq.n	655a <lfs_dir_compact+0x142>
                    if (err == LFS_ERR_CORRUPT) {
    65c8:	f110 0f54 	cmn.w	r0, #84	; 0x54
    65cc:	d180      	bne.n	64d0 <lfs_dir_compact+0xb8>
    65ce:	e741      	b.n	6454 <lfs_dir_compact+0x3c>
                lfs_gstate_xor(&delta, &lfs->gdisk);
    65d0:	f105 013c 	add.w	r1, r5, #60	; 0x3c
    65d4:	a80b      	add	r0, sp, #44	; 0x2c
    65d6:	f005 fd2e 	bl	c036 <lfs_gstate_xor>
                lfs_gstate_xor(&delta, &lfs->gstate);
    65da:	f105 0130 	add.w	r1, r5, #48	; 0x30
    65de:	a80b      	add	r0, sp, #44	; 0x2c
    65e0:	f005 fd29 	bl	c036 <lfs_gstate_xor>
    65e4:	e7c0      	b.n	6568 <lfs_dir_compact+0x150>
    return true;
    65e6:	2301      	movs	r3, #1
            if (!lfs_gstate_iszero(&delta)) {
    65e8:	b973      	cbnz	r3, 6608 <lfs_dir_compact+0x1f0>
                err = lfs_dir_commitattr(lfs, &commit,
    65ea:	ab0b      	add	r3, sp, #44	; 0x2c
    65ec:	4a23      	ldr	r2, [pc, #140]	; (667c <lfs_dir_compact+0x264>)
    65ee:	a90e      	add	r1, sp, #56	; 0x38
    65f0:	4628      	mov	r0, r5
    65f2:	f006 fcbd 	bl	cf70 <lfs_dir_commitattr>
                if (err) {
    65f6:	4603      	mov	r3, r0
    65f8:	b130      	cbz	r0, 6608 <lfs_dir_compact+0x1f0>
                    if (err == LFS_ERR_CORRUPT) {
    65fa:	f110 0f54 	cmn.w	r0, #84	; 0x54
    65fe:	f47f af67 	bne.w	64d0 <lfs_dir_compact+0xb8>
    6602:	e727      	b.n	6454 <lfs_dir_compact+0x3c>
            return false;
    6604:	2300      	movs	r3, #0
    6606:	e7ef      	b.n	65e8 <lfs_dir_compact+0x1d0>
            err = lfs_dir_commitcrc(lfs, &commit);
    6608:	a90e      	add	r1, sp, #56	; 0x38
    660a:	4628      	mov	r0, r5
    660c:	f006 fd15 	bl	d03a <lfs_dir_commitcrc>
            if (err) {
    6610:	4603      	mov	r3, r0
    6612:	b120      	cbz	r0, 661e <lfs_dir_compact+0x206>
                if (err == LFS_ERR_CORRUPT) {
    6614:	f110 0f54 	cmn.w	r0, #84	; 0x54
    6618:	f47f af5a 	bne.w	64d0 <lfs_dir_compact+0xb8>
    661c:	e71a      	b.n	6454 <lfs_dir_compact+0x3c>
    lfs_block_t t = pair[0];
    661e:	6823      	ldr	r3, [r4, #0]
    pair[0] = pair[1];
    6620:	6862      	ldr	r2, [r4, #4]
    6622:	6022      	str	r2, [r4, #0]
    pair[1] = t;
    6624:	6063      	str	r3, [r4, #4]
            dir->count = end - begin;
    6626:	eba9 0808 	sub.w	r8, r9, r8
    662a:	f8a4 8014 	strh.w	r8, [r4, #20]
            dir->off = commit.off;
    662e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6630:	60e3      	str	r3, [r4, #12]
            dir->etag = commit.ptag;
    6632:	9b10      	ldr	r3, [sp, #64]	; 0x40
    6634:	6123      	str	r3, [r4, #16]
            lfs->gdelta = (lfs_gstate_t){0};
    6636:	2200      	movs	r2, #0
    6638:	64aa      	str	r2, [r5, #72]	; 0x48
    663a:	64ea      	str	r2, [r5, #76]	; 0x4c
    663c:	652a      	str	r2, [r5, #80]	; 0x50
            if (!relocated) {
    663e:	f1bb 0f00 	cmp.w	fp, #0
    6642:	d106      	bne.n	6652 <lfs_dir_compact+0x23a>
                lfs->gdisk = lfs->gstate;
    6644:	f105 033c 	add.w	r3, r5, #60	; 0x3c
    6648:	3530      	adds	r5, #48	; 0x30
    664a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    664e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    return relocated ? LFS_OK_RELOCATED : 0;
    6652:	465b      	mov	r3, fp
    6654:	e73c      	b.n	64d0 <lfs_dir_compact+0xb8>
            LFS_WARN("Superblock 0x%"PRIx32" has become unwritable",
    6656:	6863      	ldr	r3, [r4, #4]
    6658:	9300      	str	r3, [sp, #0]
    665a:	f240 7369 	movw	r3, #1897	; 0x769
    665e:	4a08      	ldr	r2, [pc, #32]	; (6680 <lfs_dir_compact+0x268>)
    6660:	2157      	movs	r1, #87	; 0x57
    6662:	4808      	ldr	r0, [pc, #32]	; (6684 <lfs_dir_compact+0x26c>)
    6664:	f003 fe6a 	bl	a33c <z_log_minimal_printk>
            return LFS_ERR_NOSPC;
    6668:	f06f 031b 	mvn.w	r3, #27
    666c:	e730      	b.n	64d0 <lfs_dir_compact+0xb8>
    666e:	bf00      	nop
    6670:	0000d02b 	.word	0x0000d02b
    6674:	400ffc00 	.word	0x400ffc00
    6678:	000ffc08 	.word	0x000ffc08
    667c:	7ffffc0c 	.word	0x7ffffc0c
    6680:	0000f4d4 	.word	0x0000f4d4
    6684:	0000f550 	.word	0x0000f550

00006688 <lfs_dir_splittingcompact>:
        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
    6688:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    668c:	b091      	sub	sp, #68	; 0x44
    668e:	4607      	mov	r7, r0
    6690:	4615      	mov	r5, r2
    6692:	4699      	mov	r9, r3
    6694:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
    6698:	f8bd b06c 	ldrh.w	fp, [sp, #108]	; 0x6c
    669c:	f8bd 6070 	ldrh.w	r6, [sp, #112]	; 0x70
    66a0:	910b      	str	r1, [sp, #44]	; 0x2c
    66a2:	e04c      	b.n	673e <lfs_dir_splittingcompact+0xb6>
                    && size <= lfs_min(lfs->cfg->block_size - 36,
    66a4:	085b      	lsrs	r3, r3, #1
                            lfs->cfg->prog_size))) {
    66a6:	6988      	ldr	r0, [r1, #24]
	return lfs_aligndown(a + alignment-1, alignment);
    66a8:	4403      	add	r3, r0
    66aa:	3b01      	subs	r3, #1
	return a - (a % alignment);
    66ac:	fbb3 f1f0 	udiv	r1, r3, r0
    66b0:	fb00 3111 	mls	r1, r0, r1, r3
    66b4:	1a5b      	subs	r3, r3, r1
	return (a < b) ? a : b;
    66b6:	4293      	cmp	r3, r2
    66b8:	bf28      	it	cs
    66ba:	4613      	movcs	r3, r2
                    && size <= lfs_min(lfs->cfg->block_size - 36,
    66bc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    66be:	429a      	cmp	r2, r3
    66c0:	d92d      	bls.n	671e <lfs_dir_splittingcompact+0x96>
            split = split + ((end - split) / 2);
    66c2:	eb04 0458 	add.w	r4, r4, r8, lsr #1
        while (end - split > 1) {
    66c6:	eba6 0804 	sub.w	r8, r6, r4
    66ca:	f1b8 0f01 	cmp.w	r8, #1
    66ce:	d926      	bls.n	671e <lfs_dir_splittingcompact+0x96>
            lfs_size_t size = 0;
    66d0:	2200      	movs	r2, #0
    66d2:	920d      	str	r2, [sp, #52]	; 0x34
            int err = lfs_dir_traverse(lfs,
    66d4:	b2a1      	uxth	r1, r4
    66d6:	ab0d      	add	r3, sp, #52	; 0x34
    66d8:	9308      	str	r3, [sp, #32]
    66da:	4b48      	ldr	r3, [pc, #288]	; (67fc <lfs_dir_splittingcompact+0x174>)
    66dc:	9307      	str	r3, [sp, #28]
    66de:	424b      	negs	r3, r1
    66e0:	b21b      	sxth	r3, r3
    66e2:	9306      	str	r3, [sp, #24]
    66e4:	9605      	str	r6, [sp, #20]
    66e6:	9104      	str	r1, [sp, #16]
    66e8:	9203      	str	r2, [sp, #12]
    66ea:	4b45      	ldr	r3, [pc, #276]	; (6800 <lfs_dir_splittingcompact+0x178>)
    66ec:	9302      	str	r3, [sp, #8]
    66ee:	f8cd 9004 	str.w	r9, [sp, #4]
    66f2:	9500      	str	r5, [sp, #0]
    66f4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    66f8:	4651      	mov	r1, sl
    66fa:	4638      	mov	r0, r7
    66fc:	f7ff f830 	bl	5760 <lfs_dir_traverse>
            if (err) {
    6700:	4603      	mov	r3, r0
    6702:	2800      	cmp	r0, #0
    6704:	d15b      	bne.n	67be <lfs_dir_splittingcompact+0x136>
            if (end - split < 0xff
    6706:	f1b8 0ffe 	cmp.w	r8, #254	; 0xfe
    670a:	d8da      	bhi.n	66c2 <lfs_dir_splittingcompact+0x3a>
                    && size <= lfs_min(lfs->cfg->block_size - 36,
    670c:	6eb9      	ldr	r1, [r7, #104]	; 0x68
    670e:	69cb      	ldr	r3, [r1, #28]
    6710:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
                            (lfs->cfg->metadata_max
    6714:	6c88      	ldr	r0, [r1, #72]	; 0x48
                    && size <= lfs_min(lfs->cfg->block_size - 36,
    6716:	2800      	cmp	r0, #0
    6718:	d0c4      	beq.n	66a4 <lfs_dir_splittingcompact+0x1c>
    671a:	0843      	lsrs	r3, r0, #1
    671c:	e7c3      	b.n	66a6 <lfs_dir_splittingcompact+0x1e>
        if (split == begin) {
    671e:	45a3      	cmp	fp, r4
    6720:	d022      	beq.n	6768 <lfs_dir_splittingcompact+0xe0>
        int err = lfs_dir_split(lfs, dir, attrs, attrcount,
    6722:	b2a4      	uxth	r4, r4
    6724:	9602      	str	r6, [sp, #8]
    6726:	9401      	str	r4, [sp, #4]
    6728:	f8cd a000 	str.w	sl, [sp]
    672c:	464b      	mov	r3, r9
    672e:	462a      	mov	r2, r5
    6730:	990b      	ldr	r1, [sp, #44]	; 0x2c
    6732:	4638      	mov	r0, r7
    6734:	f006 fd5a 	bl	d1ec <lfs_dir_split>
        if (err && err != LFS_ERR_NOSPC) {
    6738:	4603      	mov	r3, r0
    673a:	b910      	cbnz	r0, 6742 <lfs_dir_splittingcompact+0xba>
            end = split;
    673c:	4626      	mov	r6, r4
        lfs_size_t split = begin;
    673e:	465c      	mov	r4, fp
        while (end - split > 1) {
    6740:	e7c1      	b.n	66c6 <lfs_dir_splittingcompact+0x3e>
        if (err && err != LFS_ERR_NOSPC) {
    6742:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
    6746:	f110 0f1c 	cmn.w	r0, #28
    674a:	d138      	bne.n	67be <lfs_dir_splittingcompact+0x136>
            LFS_WARN("Unable to split {0x%"PRIx32", 0x%"PRIx32"}",
    674c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    6750:	9301      	str	r3, [sp, #4]
    6752:	f8d8 3000 	ldr.w	r3, [r8]
    6756:	9300      	str	r3, [sp, #0]
    6758:	f240 73b3 	movw	r3, #1971	; 0x7b3
    675c:	4a29      	ldr	r2, [pc, #164]	; (6804 <lfs_dir_splittingcompact+0x17c>)
    675e:	2157      	movs	r1, #87	; 0x57
    6760:	4829      	ldr	r0, [pc, #164]	; (6808 <lfs_dir_splittingcompact+0x180>)
    6762:	f003 fdeb 	bl	a33c <z_log_minimal_printk>
    6766:	e001      	b.n	676c <lfs_dir_splittingcompact+0xe4>
    6768:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
    if (lfs_dir_needsrelocation(lfs, dir)
    676c:	4641      	mov	r1, r8
    676e:	4638      	mov	r0, r7
    6770:	f005 fcd1 	bl	c116 <lfs_dir_needsrelocation>
    6774:	b1b8      	cbz	r0, 67a6 <lfs_dir_splittingcompact+0x11e>
            && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
    6776:	2300      	movs	r3, #0
    6778:	930e      	str	r3, [sp, #56]	; 0x38
    677a:	2301      	movs	r3, #1
    677c:	930f      	str	r3, [sp, #60]	; 0x3c
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    677e:	f8d8 2000 	ldr.w	r2, [r8]
    6782:	b132      	cbz	r2, 6792 <lfs_dir_splittingcompact+0x10a>
    6784:	f8d8 3004 	ldr.w	r3, [r8, #4]
    6788:	2b01      	cmp	r3, #1
    678a:	d002      	beq.n	6792 <lfs_dir_splittingcompact+0x10a>
    678c:	2a01      	cmp	r2, #1
    678e:	d000      	beq.n	6792 <lfs_dir_splittingcompact+0x10a>
    6790:	b94b      	cbnz	r3, 67a6 <lfs_dir_splittingcompact+0x11e>
        lfs_ssize_t size = lfs_fs_rawsize(lfs);
    6792:	4638      	mov	r0, r7
    6794:	f7ff fe30 	bl	63f8 <lfs_fs_rawsize>
        if (size < 0) {
    6798:	1e03      	subs	r3, r0, #0
    679a:	db10      	blt.n	67be <lfs_dir_splittingcompact+0x136>
        if ((lfs_size_t)size < lfs->cfg->block_count/2) {
    679c:	6eba      	ldr	r2, [r7, #104]	; 0x68
    679e:	6a12      	ldr	r2, [r2, #32]
    67a0:	ebb3 0f52 	cmp.w	r3, r2, lsr #1
    67a4:	d30f      	bcc.n	67c6 <lfs_dir_splittingcompact+0x13e>
    return lfs_dir_compact(lfs, dir, attrs, attrcount, source, begin, end);
    67a6:	9602      	str	r6, [sp, #8]
    67a8:	f8cd b004 	str.w	fp, [sp, #4]
    67ac:	f8cd a000 	str.w	sl, [sp]
    67b0:	464b      	mov	r3, r9
    67b2:	462a      	mov	r2, r5
    67b4:	4641      	mov	r1, r8
    67b6:	4638      	mov	r0, r7
    67b8:	f7ff fe2e 	bl	6418 <lfs_dir_compact>
    67bc:	4603      	mov	r3, r0
}
    67be:	4618      	mov	r0, r3
    67c0:	b011      	add	sp, #68	; 0x44
    67c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            int err = lfs_dir_split(lfs, dir, attrs, attrcount,
    67c6:	9602      	str	r6, [sp, #8]
    67c8:	f8cd b004 	str.w	fp, [sp, #4]
    67cc:	f8cd a000 	str.w	sl, [sp]
    67d0:	464b      	mov	r3, r9
    67d2:	462a      	mov	r2, r5
    67d4:	4641      	mov	r1, r8
    67d6:	4638      	mov	r0, r7
    67d8:	f006 fd08 	bl	d1ec <lfs_dir_split>
            if (err && err != LFS_ERR_NOSPC) {
    67dc:	4603      	mov	r3, r0
    67de:	b150      	cbz	r0, 67f6 <lfs_dir_splittingcompact+0x16e>
    67e0:	f110 0f1c 	cmn.w	r0, #28
    67e4:	d1eb      	bne.n	67be <lfs_dir_splittingcompact+0x136>
                LFS_WARN("Unable to expand superblock");
    67e6:	f240 73d1 	movw	r3, #2001	; 0x7d1
    67ea:	4a06      	ldr	r2, [pc, #24]	; (6804 <lfs_dir_splittingcompact+0x17c>)
    67ec:	2157      	movs	r1, #87	; 0x57
    67ee:	4807      	ldr	r0, [pc, #28]	; (680c <lfs_dir_splittingcompact+0x184>)
    67f0:	f003 fda4 	bl	a33c <z_log_minimal_printk>
    67f4:	e7d7      	b.n	67a6 <lfs_dir_splittingcompact+0x11e>
                end = begin;
    67f6:	465e      	mov	r6, fp
    67f8:	e7d5      	b.n	67a6 <lfs_dir_splittingcompact+0x11e>
    67fa:	bf00      	nop
    67fc:	0000c0fb 	.word	0x0000c0fb
    6800:	400ffc00 	.word	0x400ffc00
    6804:	0000f4d4 	.word	0x0000f4d4
    6808:	0000f584 	.word	0x0000f584
    680c:	0000f5b0 	.word	0x0000f5b0

00006810 <lfs_dir_relocatingcommit>:
        lfs_mdir_t *pdir) {
    6810:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6814:	b09b      	sub	sp, #108	; 0x6c
    6816:	4607      	mov	r7, r0
    6818:	460e      	mov	r6, r1
    681a:	4691      	mov	r9, r2
    681c:	461d      	mov	r5, r3
    681e:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
    for (int i = 0; i < attrcount; i++) {
    6822:	2400      	movs	r4, #0
    bool hasdelete = false;
    6824:	46a4      	mov	ip, r4
    for (int i = 0; i < attrcount; i++) {
    6826:	e003      	b.n	6830 <lfs_dir_relocatingcommit+0x20>
            dir->count += 1;
    6828:	8ab3      	ldrh	r3, [r6, #20]
    682a:	3301      	adds	r3, #1
    682c:	82b3      	strh	r3, [r6, #20]
    for (int i = 0; i < attrcount; i++) {
    682e:	3401      	adds	r4, #1
    6830:	4544      	cmp	r4, r8
    6832:	da25      	bge.n	6880 <lfs_dir_relocatingcommit+0x70>
        if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE) {
    6834:	00e1      	lsls	r1, r4, #3
    6836:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
    683a:	f855 3034 	ldr.w	r3, [r5, r4, lsl #3]
    return (tag & 0x7ff00000) >> 20;
    683e:	0d1a      	lsrs	r2, r3, #20
    6840:	f3c3 530a 	ubfx	r3, r3, #20, #11
        if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE) {
    6844:	f240 4e01 	movw	lr, #1025	; 0x401
    6848:	4573      	cmp	r3, lr
    684a:	d0ed      	beq.n	6828 <lfs_dir_relocatingcommit+0x18>
        } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE) {
    684c:	f240 4eff 	movw	lr, #1279	; 0x4ff
    6850:	4573      	cmp	r3, lr
    6852:	d00f      	beq.n	6874 <lfs_dir_relocatingcommit+0x64>
    return (tag & 0x70000000) >> 20;
    6854:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
        } else if (lfs_tag_type1(attrs[i].tag) == LFS_TYPE_TAIL) {
    6858:	f5b2 6fc0 	cmp.w	r2, #1536	; 0x600
    685c:	d1e7      	bne.n	682e <lfs_dir_relocatingcommit+0x1e>
            dir->tail[0] = ((lfs_block_t*)attrs[i].buffer)[0];
    685e:	6843      	ldr	r3, [r0, #4]
    6860:	681b      	ldr	r3, [r3, #0]
    6862:	61b3      	str	r3, [r6, #24]
            dir->tail[1] = ((lfs_block_t*)attrs[i].buffer)[1];
    6864:	6843      	ldr	r3, [r0, #4]
    6866:	685b      	ldr	r3, [r3, #4]
    6868:	61f3      	str	r3, [r6, #28]
            dir->split = (lfs_tag_chunk(attrs[i].tag) & 1);
    686a:	586b      	ldr	r3, [r5, r1]
    686c:	f3c3 5300 	ubfx	r3, r3, #20, #1
    6870:	75f3      	strb	r3, [r6, #23]
            lfs_pair_fromle32(dir->tail);
    6872:	e7dc      	b.n	682e <lfs_dir_relocatingcommit+0x1e>
            dir->count -= 1;
    6874:	8ab3      	ldrh	r3, [r6, #20]
    6876:	3b01      	subs	r3, #1
    6878:	82b3      	strh	r3, [r6, #20]
            hasdelete = true;
    687a:	f04f 0c01 	mov.w	ip, #1
    687e:	e7d6      	b.n	682e <lfs_dir_relocatingcommit+0x1e>
    if (hasdelete && dir->count == 0) {
    6880:	f1bc 0f00 	cmp.w	ip, #0
    6884:	d002      	beq.n	688c <lfs_dir_relocatingcommit+0x7c>
    6886:	8ab3      	ldrh	r3, [r6, #20]
    6888:	2b00      	cmp	r3, #0
    688a:	d050      	beq.n	692e <lfs_dir_relocatingcommit+0x11e>
    if (dir->erased) {
    688c:	7db4      	ldrb	r4, [r6, #22]
    688e:	2c00      	cmp	r4, #0
    6890:	d02f      	beq.n	68f2 <lfs_dir_relocatingcommit+0xe2>
            .block = dir->pair[0],
    6892:	6833      	ldr	r3, [r6, #0]
        struct lfs_commit commit = {
    6894:	9310      	str	r3, [sp, #64]	; 0x40
            .off = dir->off,
    6896:	68f3      	ldr	r3, [r6, #12]
        struct lfs_commit commit = {
    6898:	9311      	str	r3, [sp, #68]	; 0x44
            .ptag = dir->etag,
    689a:	6932      	ldr	r2, [r6, #16]
        struct lfs_commit commit = {
    689c:	9212      	str	r2, [sp, #72]	; 0x48
    689e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    68a2:	9213      	str	r2, [sp, #76]	; 0x4c
    68a4:	9314      	str	r3, [sp, #80]	; 0x50
            .end = (lfs->cfg->metadata_max ?
    68a6:	6eba      	ldr	r2, [r7, #104]	; 0x68
    68a8:	6c93      	ldr	r3, [r2, #72]	; 0x48
                lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,
    68aa:	2b00      	cmp	r3, #0
    68ac:	d051      	beq.n	6952 <lfs_dir_relocatingcommit+0x142>
    68ae:	3b08      	subs	r3, #8
        struct lfs_commit commit = {
    68b0:	9315      	str	r3, [sp, #84]	; 0x54
                lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){
    68b2:	9718      	str	r7, [sp, #96]	; 0x60
    68b4:	ab10      	add	r3, sp, #64	; 0x40
    68b6:	9319      	str	r3, [sp, #100]	; 0x64
        int err = lfs_dir_traverse(lfs,
    68b8:	ab18      	add	r3, sp, #96	; 0x60
    68ba:	9308      	str	r3, [sp, #32]
    68bc:	4b8e      	ldr	r3, [pc, #568]	; (6af8 <lfs_dir_relocatingcommit+0x2e8>)
    68be:	9307      	str	r3, [sp, #28]
    68c0:	2300      	movs	r3, #0
    68c2:	9306      	str	r3, [sp, #24]
    68c4:	9305      	str	r3, [sp, #20]
    68c6:	9304      	str	r3, [sp, #16]
    68c8:	9303      	str	r3, [sp, #12]
    68ca:	9302      	str	r3, [sp, #8]
    68cc:	f8cd 8004 	str.w	r8, [sp, #4]
    68d0:	9500      	str	r5, [sp, #0]
    68d2:	6933      	ldr	r3, [r6, #16]
    68d4:	68f2      	ldr	r2, [r6, #12]
    68d6:	4631      	mov	r1, r6
    68d8:	4638      	mov	r0, r7
    68da:	f7fe ff41 	bl	5760 <lfs_dir_traverse>
        if (err) {
    68de:	4682      	mov	sl, r0
    68e0:	2800      	cmp	r0, #0
    68e2:	d039      	beq.n	6958 <lfs_dir_relocatingcommit+0x148>
            if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
    68e4:	f110 0f1c 	cmn.w	r0, #28
    68e8:	d003      	beq.n	68f2 <lfs_dir_relocatingcommit+0xe2>
    68ea:	f110 0f54 	cmn.w	r0, #84	; 0x54
    68ee:	f040 80f9 	bne.w	6ae4 <lfs_dir_relocatingcommit+0x2d4>
    rcache->block = LFS_BLOCK_NULL;
    68f2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    68f6:	613b      	str	r3, [r7, #16]
    state = lfs_dir_splittingcompact(lfs, dir, attrs, attrcount,
    68f8:	8ab3      	ldrh	r3, [r6, #20]
    68fa:	9302      	str	r3, [sp, #8]
    68fc:	2300      	movs	r3, #0
    68fe:	9301      	str	r3, [sp, #4]
    6900:	9600      	str	r6, [sp, #0]
    6902:	4643      	mov	r3, r8
    6904:	462a      	mov	r2, r5
    6906:	4631      	mov	r1, r6
    6908:	4638      	mov	r0, r7
    690a:	f7ff febd 	bl	6688 <lfs_dir_splittingcompact>
    if (state < 0) {
    690e:	1e02      	subs	r2, r0, #0
    6910:	f2c0 80ef 	blt.w	6af2 <lfs_dir_relocatingcommit+0x2e2>
    lfs_block_t oldpair[2] = {pair[0], pair[1]};
    6914:	f8d9 3000 	ldr.w	r3, [r9]
    6918:	9316      	str	r3, [sp, #88]	; 0x58
    691a:	f8d9 b004 	ldr.w	fp, [r9, #4]
    691e:	f8cd b05c 	str.w	fp, [sp, #92]	; 0x5c
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
    6922:	6abc      	ldr	r4, [r7, #40]	; 0x28
    6924:	46da      	mov	sl, fp
    6926:	469b      	mov	fp, r3
    6928:	920b      	str	r2, [sp, #44]	; 0x2c
    692a:	960a      	str	r6, [sp, #40]	; 0x28
    692c:	e0ad      	b.n	6a8a <lfs_dir_relocatingcommit+0x27a>
        int err = lfs_fs_pred(lfs, dir->pair, pdir);
    692e:	9a25      	ldr	r2, [sp, #148]	; 0x94
    6930:	4631      	mov	r1, r6
    6932:	4638      	mov	r0, r7
    6934:	f006 fabe 	bl	ceb4 <lfs_fs_pred>
        if (err && err != LFS_ERR_NOENT) {
    6938:	4682      	mov	sl, r0
    693a:	b120      	cbz	r0, 6946 <lfs_dir_relocatingcommit+0x136>
    693c:	f110 0f02 	cmn.w	r0, #2
    6940:	f040 80d0 	bne.w	6ae4 <lfs_dir_relocatingcommit+0x2d4>
    6944:	e7a2      	b.n	688c <lfs_dir_relocatingcommit+0x7c>
        if (err != LFS_ERR_NOENT && pdir->split) {
    6946:	9b25      	ldr	r3, [sp, #148]	; 0x94
    6948:	7ddb      	ldrb	r3, [r3, #23]
    694a:	2b00      	cmp	r3, #0
    694c:	d09e      	beq.n	688c <lfs_dir_relocatingcommit+0x7c>
            state = LFS_OK_DROPPED;
    694e:	2202      	movs	r2, #2
    6950:	e7e0      	b.n	6914 <lfs_dir_relocatingcommit+0x104>
                lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,
    6952:	69d3      	ldr	r3, [r2, #28]
    6954:	3b08      	subs	r3, #8
    6956:	e7ab      	b.n	68b0 <lfs_dir_relocatingcommit+0xa0>
        lfs_gstate_t delta = {0};
    6958:	2300      	movs	r3, #0
    695a:	930d      	str	r3, [sp, #52]	; 0x34
    695c:	930e      	str	r3, [sp, #56]	; 0x38
    695e:	930f      	str	r3, [sp, #60]	; 0x3c
        lfs_gstate_xor(&delta, &lfs->gstate);
    6960:	f107 0130 	add.w	r1, r7, #48	; 0x30
    6964:	a80d      	add	r0, sp, #52	; 0x34
    6966:	f005 fb66 	bl	c036 <lfs_gstate_xor>
        lfs_gstate_xor(&delta, &lfs->gdisk);
    696a:	f107 013c 	add.w	r1, r7, #60	; 0x3c
    696e:	a80d      	add	r0, sp, #52	; 0x34
    6970:	f005 fb61 	bl	c036 <lfs_gstate_xor>
        lfs_gstate_xor(&delta, &lfs->gdelta);
    6974:	f107 0148 	add.w	r1, r7, #72	; 0x48
    6978:	a80d      	add	r0, sp, #52	; 0x34
    697a:	f005 fb5c 	bl	c036 <lfs_gstate_xor>
        delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
    697e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    6980:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
    6984:	f023 0303 	bic.w	r3, r3, #3
    6988:	930d      	str	r3, [sp, #52]	; 0x34
    for (int i = 0; i < 3; i++) {
    698a:	f1ba 0f02 	cmp.w	sl, #2
    698e:	dc09      	bgt.n	69a4 <lfs_dir_relocatingcommit+0x194>
        if (((uint32_t*)a)[i] != 0) {
    6990:	ab1a      	add	r3, sp, #104	; 0x68
    6992:	eb03 038a 	add.w	r3, r3, sl, lsl #2
    6996:	f853 3c34 	ldr.w	r3, [r3, #-52]
    699a:	b913      	cbnz	r3, 69a2 <lfs_dir_relocatingcommit+0x192>
    for (int i = 0; i < 3; i++) {
    699c:	f10a 0a01 	add.w	sl, sl, #1
    69a0:	e7f3      	b.n	698a <lfs_dir_relocatingcommit+0x17a>
            return false;
    69a2:	2400      	movs	r4, #0
        if (!lfs_gstate_iszero(&delta)) {
    69a4:	b9c4      	cbnz	r4, 69d8 <lfs_dir_relocatingcommit+0x1c8>
            err = lfs_dir_getgstate(lfs, dir, &delta);
    69a6:	aa0d      	add	r2, sp, #52	; 0x34
    69a8:	4631      	mov	r1, r6
    69aa:	4638      	mov	r0, r7
    69ac:	f7fe febc 	bl	5728 <lfs_dir_getgstate>
            if (err) {
    69b0:	4682      	mov	sl, r0
    69b2:	2800      	cmp	r0, #0
    69b4:	f040 8096 	bne.w	6ae4 <lfs_dir_relocatingcommit+0x2d4>
            err = lfs_dir_commitattr(lfs, &commit,
    69b8:	ab0d      	add	r3, sp, #52	; 0x34
    69ba:	4a50      	ldr	r2, [pc, #320]	; (6afc <lfs_dir_relocatingcommit+0x2ec>)
    69bc:	a910      	add	r1, sp, #64	; 0x40
    69be:	4638      	mov	r0, r7
    69c0:	f006 fad6 	bl	cf70 <lfs_dir_commitattr>
            if (err) {
    69c4:	4682      	mov	sl, r0
    69c6:	b138      	cbz	r0, 69d8 <lfs_dir_relocatingcommit+0x1c8>
                if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
    69c8:	f110 0f1c 	cmn.w	r0, #28
    69cc:	d091      	beq.n	68f2 <lfs_dir_relocatingcommit+0xe2>
    69ce:	f110 0f54 	cmn.w	r0, #84	; 0x54
    69d2:	f040 8087 	bne.w	6ae4 <lfs_dir_relocatingcommit+0x2d4>
    69d6:	e78c      	b.n	68f2 <lfs_dir_relocatingcommit+0xe2>
        err = lfs_dir_commitcrc(lfs, &commit);
    69d8:	a910      	add	r1, sp, #64	; 0x40
    69da:	4638      	mov	r0, r7
    69dc:	f006 fb2d 	bl	d03a <lfs_dir_commitcrc>
        if (err) {
    69e0:	4682      	mov	sl, r0
    69e2:	b130      	cbz	r0, 69f2 <lfs_dir_relocatingcommit+0x1e2>
            if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
    69e4:	f110 0f1c 	cmn.w	r0, #28
    69e8:	d083      	beq.n	68f2 <lfs_dir_relocatingcommit+0xe2>
    69ea:	f110 0f54 	cmn.w	r0, #84	; 0x54
    69ee:	d179      	bne.n	6ae4 <lfs_dir_relocatingcommit+0x2d4>
    69f0:	e77f      	b.n	68f2 <lfs_dir_relocatingcommit+0xe2>
        dir->off = commit.off;
    69f2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    69f4:	60f3      	str	r3, [r6, #12]
        dir->etag = commit.ptag;
    69f6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    69f8:	6133      	str	r3, [r6, #16]
        lfs->gdisk = lfs->gstate;
    69fa:	f107 033c 	add.w	r3, r7, #60	; 0x3c
    69fe:	f107 0230 	add.w	r2, r7, #48	; 0x30
    6a02:	ca07      	ldmia	r2, {r0, r1, r2}
    6a04:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        lfs->gdelta = (lfs_gstate_t){0};
    6a08:	2200      	movs	r2, #0
    6a0a:	64ba      	str	r2, [r7, #72]	; 0x48
    6a0c:	64fa      	str	r2, [r7, #76]	; 0x4c
    6a0e:	653a      	str	r2, [r7, #80]	; 0x50
    int state = 0;
    6a10:	4652      	mov	r2, sl
    6a12:	e77f      	b.n	6914 <lfs_dir_relocatingcommit+0x104>
                            d->id == lfs_tag_id(attrs[i].tag)) {
    6a14:	88a6      	ldrh	r6, [r4, #4]
    return (tag & 0x000ffc00) >> 10;
    6a16:	f3c1 2089 	ubfx	r0, r1, #10, #10
                    if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
    6a1a:	4286      	cmp	r6, r0
    6a1c:	d10e      	bne.n	6a3c <lfs_dir_relocatingcommit+0x22c>
                        d->m.pair[0] = LFS_BLOCK_NULL;
    6a1e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    6a22:	60a2      	str	r2, [r4, #8]
                        d->m.pair[1] = LFS_BLOCK_NULL;
    6a24:	60e2      	str	r2, [r4, #12]
                for (int i = 0; i < attrcount; i++) {
    6a26:	3301      	adds	r3, #1
    6a28:	4543      	cmp	r3, r8
    6a2a:	da48      	bge.n	6abe <lfs_dir_relocatingcommit+0x2ae>
                    if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
    6a2c:	f855 1033 	ldr.w	r1, [r5, r3, lsl #3]
    return (tag & 0x7ff00000) >> 20;
    6a30:	f3c1 520a 	ubfx	r2, r1, #20, #11
                    if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
    6a34:	f240 40ff 	movw	r0, #1279	; 0x4ff
    6a38:	4282      	cmp	r2, r0
    6a3a:	d0eb      	beq.n	6a14 <lfs_dir_relocatingcommit+0x204>
                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
    6a3c:	f240 40ff 	movw	r0, #1279	; 0x4ff
    6a40:	4282      	cmp	r2, r0
    6a42:	d011      	beq.n	6a68 <lfs_dir_relocatingcommit+0x258>
                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
    6a44:	f240 4001 	movw	r0, #1025	; 0x401
    6a48:	4282      	cmp	r2, r0
    6a4a:	d1ec      	bne.n	6a26 <lfs_dir_relocatingcommit+0x216>
                            d->id >= lfs_tag_id(attrs[i].tag)) {
    6a4c:	88a2      	ldrh	r2, [r4, #4]
    return (tag & 0x000ffc00) >> 10;
    6a4e:	f3c1 2189 	ubfx	r1, r1, #10, #10
                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
    6a52:	428a      	cmp	r2, r1
    6a54:	d3e7      	bcc.n	6a26 <lfs_dir_relocatingcommit+0x216>
                        d->id += 1;
    6a56:	3201      	adds	r2, #1
    6a58:	80a2      	strh	r2, [r4, #4]
                        if (d->type == LFS_TYPE_DIR) {
    6a5a:	79a2      	ldrb	r2, [r4, #6]
    6a5c:	2a02      	cmp	r2, #2
    6a5e:	d1e2      	bne.n	6a26 <lfs_dir_relocatingcommit+0x216>
                            ((lfs_dir_t*)d)->pos += 1;
    6a60:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    6a62:	3201      	adds	r2, #1
    6a64:	62a2      	str	r2, [r4, #40]	; 0x28
    6a66:	e7de      	b.n	6a26 <lfs_dir_relocatingcommit+0x216>
                            d->id > lfs_tag_id(attrs[i].tag)) {
    6a68:	88a0      	ldrh	r0, [r4, #4]
    return (tag & 0x000ffc00) >> 10;
    6a6a:	f3c1 2689 	ubfx	r6, r1, #10, #10
                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
    6a6e:	42b0      	cmp	r0, r6
    6a70:	d9e8      	bls.n	6a44 <lfs_dir_relocatingcommit+0x234>
                        d->id -= 1;
    6a72:	3801      	subs	r0, #1
    6a74:	80a0      	strh	r0, [r4, #4]
                        if (d->type == LFS_TYPE_DIR) {
    6a76:	79a2      	ldrb	r2, [r4, #6]
    6a78:	2a02      	cmp	r2, #2
    6a7a:	d1d4      	bne.n	6a26 <lfs_dir_relocatingcommit+0x216>
                            ((lfs_dir_t*)d)->pos -= 1;
    6a7c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    6a7e:	3a01      	subs	r2, #1
    6a80:	62a2      	str	r2, [r4, #40]	; 0x28
    6a82:	e7d0      	b.n	6a26 <lfs_dir_relocatingcommit+0x216>
                for (int i = 0; i < attrcount; i++) {
    6a84:	2300      	movs	r3, #0
    6a86:	e7cf      	b.n	6a28 <lfs_dir_relocatingcommit+0x218>
    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
    6a88:	6824      	ldr	r4, [r4, #0]
    6a8a:	b37c      	cbz	r4, 6aec <lfs_dir_relocatingcommit+0x2dc>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    6a8c:	68a3      	ldr	r3, [r4, #8]
    6a8e:	459b      	cmp	fp, r3
    6a90:	d006      	beq.n	6aa0 <lfs_dir_relocatingcommit+0x290>
    6a92:	68e2      	ldr	r2, [r4, #12]
    6a94:	4592      	cmp	sl, r2
    6a96:	d003      	beq.n	6aa0 <lfs_dir_relocatingcommit+0x290>
    6a98:	459a      	cmp	sl, r3
    6a9a:	d001      	beq.n	6aa0 <lfs_dir_relocatingcommit+0x290>
    6a9c:	4593      	cmp	fp, r2
    6a9e:	d1f3      	bne.n	6a88 <lfs_dir_relocatingcommit+0x278>
            d->m = *dir;
    6aa0:	f104 0608 	add.w	r6, r4, #8
    6aa4:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    6aa8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    6aac:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    6aae:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    6ab2:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
            if (d->m.pair != pair) {
    6ab6:	f104 0308 	add.w	r3, r4, #8
    6aba:	454b      	cmp	r3, r9
    6abc:	d1e2      	bne.n	6a84 <lfs_dir_relocatingcommit+0x274>
            while (d->id >= d->m.count && d->m.split) {
    6abe:	88a3      	ldrh	r3, [r4, #4]
    6ac0:	8ba2      	ldrh	r2, [r4, #28]
    6ac2:	4293      	cmp	r3, r2
    6ac4:	d3e0      	bcc.n	6a88 <lfs_dir_relocatingcommit+0x278>
    6ac6:	7fe1      	ldrb	r1, [r4, #31]
    6ac8:	2900      	cmp	r1, #0
    6aca:	d0dd      	beq.n	6a88 <lfs_dir_relocatingcommit+0x278>
                d->id -= d->m.count;
    6acc:	1a9b      	subs	r3, r3, r2
    6ace:	80a3      	strh	r3, [r4, #4]
                int err = lfs_dir_fetch(lfs, &d->m, d->m.tail);
    6ad0:	f104 0220 	add.w	r2, r4, #32
    6ad4:	f104 0108 	add.w	r1, r4, #8
    6ad8:	4638      	mov	r0, r7
    6ada:	f005 fea2 	bl	c822 <lfs_dir_fetch>
                if (err) {
    6ade:	2800      	cmp	r0, #0
    6ae0:	d0ed      	beq.n	6abe <lfs_dir_relocatingcommit+0x2ae>
    6ae2:	4682      	mov	sl, r0
}
    6ae4:	4650      	mov	r0, sl
    6ae6:	b01b      	add	sp, #108	; 0x6c
    6ae8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return state;
    6aec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    6aee:	4692      	mov	sl, r2
    6af0:	e7f8      	b.n	6ae4 <lfs_dir_relocatingcommit+0x2d4>
        return state;
    6af2:	4692      	mov	sl, r2
    6af4:	e7f6      	b.n	6ae4 <lfs_dir_relocatingcommit+0x2d4>
    6af6:	bf00      	nop
    6af8:	0000d02b 	.word	0x0000d02b
    6afc:	7ffffc0c 	.word	0x7ffffc0c

00006b00 <lfs_dir_orphaningcommit>:
        const struct lfs_mattr *attrs, int attrcount) {
    6b00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6b04:	b0a1      	sub	sp, #132	; 0x84
    6b06:	4605      	mov	r5, r0
    6b08:	460e      	mov	r6, r1
    6b0a:	4690      	mov	r8, r2
    6b0c:	4699      	mov	r9, r3
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
    6b0e:	6a84      	ldr	r4, [r0, #40]	; 0x28
    6b10:	e003      	b.n	6b1a <lfs_dir_orphaningcommit+0x1a>
                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
    6b12:	79a3      	ldrb	r3, [r4, #6]
        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&
    6b14:	2b01      	cmp	r3, #1
    6b16:	d012      	beq.n	6b3e <lfs_dir_orphaningcommit+0x3e>
    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
    6b18:	6824      	ldr	r4, [r4, #0]
    6b1a:	b34c      	cbz	r4, 6b70 <lfs_dir_orphaningcommit+0x70>
        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&
    6b1c:	f104 0108 	add.w	r1, r4, #8
    6b20:	42b1      	cmp	r1, r6
    6b22:	d0f9      	beq.n	6b18 <lfs_dir_orphaningcommit+0x18>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    6b24:	68a1      	ldr	r1, [r4, #8]
    6b26:	6833      	ldr	r3, [r6, #0]
    6b28:	4299      	cmp	r1, r3
    6b2a:	d0f2      	beq.n	6b12 <lfs_dir_orphaningcommit+0x12>
    6b2c:	68e0      	ldr	r0, [r4, #12]
    6b2e:	6872      	ldr	r2, [r6, #4]
    6b30:	4282      	cmp	r2, r0
    6b32:	d0ee      	beq.n	6b12 <lfs_dir_orphaningcommit+0x12>
    6b34:	4291      	cmp	r1, r2
    6b36:	d0ec      	beq.n	6b12 <lfs_dir_orphaningcommit+0x12>
    6b38:	4283      	cmp	r3, r0
    6b3a:	d1ed      	bne.n	6b18 <lfs_dir_orphaningcommit+0x18>
    6b3c:	e7e9      	b.n	6b12 <lfs_dir_orphaningcommit+0x12>
                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
    6b3e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    6b40:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    6b44:	d0e8      	beq.n	6b18 <lfs_dir_orphaningcommit+0x18>
                f->ctz.size > lfs->cfg->cache_size) {
    6b46:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    6b48:	6eab      	ldr	r3, [r5, #104]	; 0x68
    6b4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
    6b4c:	429a      	cmp	r2, r3
    6b4e:	d9e3      	bls.n	6b18 <lfs_dir_orphaningcommit+0x18>
            int err = lfs_file_outline(lfs, f);
    6b50:	4621      	mov	r1, r4
    6b52:	4628      	mov	r0, r5
    6b54:	f005 feb9 	bl	c8ca <lfs_file_outline>
            if (err) {
    6b58:	4607      	mov	r7, r0
    6b5a:	2800      	cmp	r0, #0
    6b5c:	f040 8115 	bne.w	6d8a <lfs_dir_orphaningcommit+0x28a>
            err = lfs_file_flush(lfs, f);
    6b60:	4621      	mov	r1, r4
    6b62:	4628      	mov	r0, r5
    6b64:	f006 f833 	bl	cbce <lfs_file_flush>
            if (err) {
    6b68:	4607      	mov	r7, r0
    6b6a:	2800      	cmp	r0, #0
    6b6c:	d0d4      	beq.n	6b18 <lfs_dir_orphaningcommit+0x18>
    6b6e:	e10c      	b.n	6d8a <lfs_dir_orphaningcommit+0x28a>
    lfs_block_t lpair[2] = {dir->pair[0], dir->pair[1]};
    6b70:	6833      	ldr	r3, [r6, #0]
    6b72:	9314      	str	r3, [sp, #80]	; 0x50
    6b74:	6873      	ldr	r3, [r6, #4]
    6b76:	9315      	str	r3, [sp, #84]	; 0x54
    lfs_mdir_t ldir = *dir;
    6b78:	ac0c      	add	r4, sp, #48	; 0x30
    6b7a:	4637      	mov	r7, r6
    6b7c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    6b7e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    6b80:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
    6b84:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    int state = lfs_dir_relocatingcommit(lfs, &ldir, dir->pair,
    6b88:	ab04      	add	r3, sp, #16
    6b8a:	9301      	str	r3, [sp, #4]
    6b8c:	f8cd 9000 	str.w	r9, [sp]
    6b90:	4643      	mov	r3, r8
    6b92:	4632      	mov	r2, r6
    6b94:	a90c      	add	r1, sp, #48	; 0x30
    6b96:	4628      	mov	r0, r5
    6b98:	f7ff fe3a 	bl	6810 <lfs_dir_relocatingcommit>
    if (state < 0) {
    6b9c:	1e07      	subs	r7, r0, #0
    6b9e:	f2c0 80f4 	blt.w	6d8a <lfs_dir_orphaningcommit+0x28a>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    6ba2:	6833      	ldr	r3, [r6, #0]
    6ba4:	9a14      	ldr	r2, [sp, #80]	; 0x50
    6ba6:	4293      	cmp	r3, r2
    6ba8:	d007      	beq.n	6bba <lfs_dir_orphaningcommit+0xba>
    6baa:	6870      	ldr	r0, [r6, #4]
    6bac:	9915      	ldr	r1, [sp, #84]	; 0x54
    6bae:	4288      	cmp	r0, r1
    6bb0:	d003      	beq.n	6bba <lfs_dir_orphaningcommit+0xba>
    6bb2:	428b      	cmp	r3, r1
    6bb4:	d001      	beq.n	6bba <lfs_dir_orphaningcommit+0xba>
    6bb6:	4290      	cmp	r0, r2
    6bb8:	d109      	bne.n	6bce <lfs_dir_orphaningcommit+0xce>
        *dir = ldir;
    6bba:	4634      	mov	r4, r6
    6bbc:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
    6bc0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    6bc4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    6bc6:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    6bca:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    if (state == LFS_OK_DROPPED) {
    6bce:	2f02      	cmp	r7, #2
    6bd0:	d001      	beq.n	6bd6 <lfs_dir_orphaningcommit+0xd6>
                orphans = true;
    6bd2:	2600      	movs	r6, #0
    6bd4:	e06d      	b.n	6cb2 <lfs_dir_orphaningcommit+0x1b2>
        int err = lfs_dir_getgstate(lfs, dir, &lfs->gdelta);
    6bd6:	f105 0248 	add.w	r2, r5, #72	; 0x48
    6bda:	4631      	mov	r1, r6
    6bdc:	4628      	mov	r0, r5
    6bde:	f7fe fda3 	bl	5728 <lfs_dir_getgstate>
        if (err) {
    6be2:	4607      	mov	r7, r0
    6be4:	2800      	cmp	r0, #0
    6be6:	f040 80d0 	bne.w	6d8a <lfs_dir_orphaningcommit+0x28a>
        lpair[0] = pdir.pair[0];
    6bea:	9b04      	ldr	r3, [sp, #16]
    6bec:	9314      	str	r3, [sp, #80]	; 0x50
        lpair[1] = pdir.pair[1];
    6bee:	9b05      	ldr	r3, [sp, #20]
    6bf0:	9315      	str	r3, [sp, #84]	; 0x54
        lfs_pair_tole32(dir->tail);
    6bf2:	f106 0118 	add.w	r1, r6, #24
        state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(
    6bf6:	7df2      	ldrb	r2, [r6, #23]
    6bf8:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
    6bfc:	4b92      	ldr	r3, [pc, #584]	; (6e48 <lfs_dir_orphaningcommit+0x348>)
    6bfe:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    6c02:	9316      	str	r3, [sp, #88]	; 0x58
    6c04:	9117      	str	r1, [sp, #92]	; 0x5c
    6c06:	2300      	movs	r3, #0
    6c08:	9301      	str	r3, [sp, #4]
    6c0a:	2301      	movs	r3, #1
    6c0c:	9300      	str	r3, [sp, #0]
    6c0e:	ab16      	add	r3, sp, #88	; 0x58
    6c10:	aa14      	add	r2, sp, #80	; 0x50
    6c12:	a904      	add	r1, sp, #16
    6c14:	4628      	mov	r0, r5
    6c16:	f7ff fdfb 	bl	6810 <lfs_dir_relocatingcommit>
        if (state < 0) {
    6c1a:	1e07      	subs	r7, r0, #0
    6c1c:	f2c0 80b5 	blt.w	6d8a <lfs_dir_orphaningcommit+0x28a>
        ldir = pdir;
    6c20:	ac0c      	add	r4, sp, #48	; 0x30
    6c22:	ae04      	add	r6, sp, #16
    6c24:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    6c26:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    6c28:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    6c2c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    6c30:	e7cf      	b.n	6bd2 <lfs_dir_orphaningcommit+0xd2>
                d->m.pair[0] = ldir.pair[0];
    6c32:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    6c34:	609a      	str	r2, [r3, #8]
                d->m.pair[1] = ldir.pair[1];
    6c36:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    6c38:	60da      	str	r2, [r3, #12]
            if (d->type == LFS_TYPE_DIR &&
    6c3a:	799a      	ldrb	r2, [r3, #6]
    6c3c:	2a02      	cmp	r2, #2
    6c3e:	d00d      	beq.n	6c5c <lfs_dir_orphaningcommit+0x15c>
        for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
    6c40:	681b      	ldr	r3, [r3, #0]
    6c42:	b1db      	cbz	r3, 6c7c <lfs_dir_orphaningcommit+0x17c>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    6c44:	689a      	ldr	r2, [r3, #8]
    6c46:	428a      	cmp	r2, r1
    6c48:	d0f3      	beq.n	6c32 <lfs_dir_orphaningcommit+0x132>
    6c4a:	9815      	ldr	r0, [sp, #84]	; 0x54
    6c4c:	68dc      	ldr	r4, [r3, #12]
    6c4e:	42a0      	cmp	r0, r4
    6c50:	d0ef      	beq.n	6c32 <lfs_dir_orphaningcommit+0x132>
    6c52:	42a1      	cmp	r1, r4
    6c54:	d0ed      	beq.n	6c32 <lfs_dir_orphaningcommit+0x132>
    6c56:	4282      	cmp	r2, r0
    6c58:	d1ef      	bne.n	6c3a <lfs_dir_orphaningcommit+0x13a>
    6c5a:	e7ea      	b.n	6c32 <lfs_dir_orphaningcommit+0x132>
    6c5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    6c5e:	4291      	cmp	r1, r2
    6c60:	d007      	beq.n	6c72 <lfs_dir_orphaningcommit+0x172>
    6c62:	9c15      	ldr	r4, [sp, #84]	; 0x54
    6c64:	6b18      	ldr	r0, [r3, #48]	; 0x30
    6c66:	4284      	cmp	r4, r0
    6c68:	d003      	beq.n	6c72 <lfs_dir_orphaningcommit+0x172>
    6c6a:	4281      	cmp	r1, r0
    6c6c:	d001      	beq.n	6c72 <lfs_dir_orphaningcommit+0x172>
    6c6e:	42a2      	cmp	r2, r4
    6c70:	d1e6      	bne.n	6c40 <lfs_dir_orphaningcommit+0x140>
                ((lfs_dir_t*)d)->head[0] = ldir.pair[0];
    6c72:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    6c74:	62da      	str	r2, [r3, #44]	; 0x2c
                ((lfs_dir_t*)d)->head[1] = ldir.pair[1];
    6c76:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    6c78:	631a      	str	r2, [r3, #48]	; 0x30
    6c7a:	e7e1      	b.n	6c40 <lfs_dir_orphaningcommit+0x140>
        lfs_stag_t tag = lfs_fs_parent(lfs, lpair, &pdir);
    6c7c:	aa04      	add	r2, sp, #16
    6c7e:	a914      	add	r1, sp, #80	; 0x50
    6c80:	4628      	mov	r0, r5
    6c82:	f7ff f9c1 	bl	6008 <lfs_fs_parent>
        if (tag < 0 && tag != LFS_ERR_NOENT) {
    6c86:	1e07      	subs	r7, r0, #0
    6c88:	da28      	bge.n	6cdc <lfs_dir_orphaningcommit+0x1dc>
    6c8a:	f117 0f02 	cmn.w	r7, #2
    6c8e:	d17c      	bne.n	6d8a <lfs_dir_orphaningcommit+0x28a>
        bool hasparent = (tag != LFS_ERR_NOENT);
    6c90:	f117 0802 	adds.w	r8, r7, #2
    6c94:	bf18      	it	ne
    6c96:	f04f 0801 	movne.w	r8, #1
        state = 0;
    6c9a:	2700      	movs	r7, #0
        int err = lfs_fs_pred(lfs, lpair, &pdir);
    6c9c:	aa04      	add	r2, sp, #16
    6c9e:	a914      	add	r1, sp, #80	; 0x50
    6ca0:	4628      	mov	r0, r5
    6ca2:	f006 f907 	bl	ceb4 <lfs_fs_pred>
        if (err && err != LFS_ERR_NOENT) {
    6ca6:	2800      	cmp	r0, #0
    6ca8:	d073      	beq.n	6d92 <lfs_dir_orphaningcommit+0x292>
    6caa:	f110 0f02 	cmn.w	r0, #2
    6cae:	f040 80c8 	bne.w	6e42 <lfs_dir_orphaningcommit+0x342>
    while (state == LFS_OK_RELOCATED) {
    6cb2:	2f01      	cmp	r7, #1
    6cb4:	f040 80c0 	bne.w	6e38 <lfs_dir_orphaningcommit+0x338>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    6cb8:	9914      	ldr	r1, [sp, #80]	; 0x50
    6cba:	6a2b      	ldr	r3, [r5, #32]
    6cbc:	4299      	cmp	r1, r3
    6cbe:	d007      	beq.n	6cd0 <lfs_dir_orphaningcommit+0x1d0>
    6cc0:	9815      	ldr	r0, [sp, #84]	; 0x54
    6cc2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    6cc4:	4290      	cmp	r0, r2
    6cc6:	d003      	beq.n	6cd0 <lfs_dir_orphaningcommit+0x1d0>
    6cc8:	4291      	cmp	r1, r2
    6cca:	d001      	beq.n	6cd0 <lfs_dir_orphaningcommit+0x1d0>
    6ccc:	4283      	cmp	r3, r0
    6cce:	d103      	bne.n	6cd8 <lfs_dir_orphaningcommit+0x1d8>
            lfs->root[0] = ldir.pair[0];
    6cd0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6cd2:	622b      	str	r3, [r5, #32]
            lfs->root[1] = ldir.pair[1];
    6cd4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    6cd6:	626b      	str	r3, [r5, #36]	; 0x24
        for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
    6cd8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    6cda:	e7b2      	b.n	6c42 <lfs_dir_orphaningcommit+0x142>
        bool hasparent = (tag != LFS_ERR_NOENT);
    6cdc:	f117 0802 	adds.w	r8, r7, #2
    6ce0:	bf18      	it	ne
    6ce2:	f04f 0801 	movne.w	r8, #1
            int err = lfs_fs_preporphans(lfs, +1);
    6ce6:	2101      	movs	r1, #1
    6ce8:	4628      	mov	r0, r5
    6cea:	f005 fa3b 	bl	c164 <lfs_fs_preporphans>
            if (err) {
    6cee:	4603      	mov	r3, r0
    6cf0:	2800      	cmp	r0, #0
    6cf2:	d149      	bne.n	6d88 <lfs_dir_orphaningcommit+0x288>
            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
    6cf4:	a904      	add	r1, sp, #16
    6cf6:	f105 0030 	add.w	r0, r5, #48	; 0x30
    6cfa:	f005 f9ad 	bl	c058 <lfs_gstate_hasmovehere>
    6cfe:	2800      	cmp	r0, #0
    6d00:	d12f      	bne.n	6d62 <lfs_dir_orphaningcommit+0x262>
            uint16_t moveid = 0x3ff;
    6d02:	f240 34ff 	movw	r4, #1023	; 0x3ff
            lfs_block_t ppair[2] = {pdir.pair[0], pdir.pair[1]};
    6d06:	9b04      	ldr	r3, [sp, #16]
    6d08:	9302      	str	r3, [sp, #8]
    6d0a:	9b05      	ldr	r3, [sp, #20]
    6d0c:	9303      	str	r3, [sp, #12]
            state = lfs_dir_relocatingcommit(lfs, &pdir, ppair, LFS_MKATTRS(
    6d0e:	f240 33ff 	movw	r3, #1023	; 0x3ff
    6d12:	429c      	cmp	r4, r3
    6d14:	d035      	beq.n	6d82 <lfs_dir_orphaningcommit+0x282>
    6d16:	02a3      	lsls	r3, r4, #10
    6d18:	f043 439f 	orr.w	r3, r3, #1333788672	; 0x4f800000
    6d1c:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
    6d20:	9318      	str	r3, [sp, #96]	; 0x60
    6d22:	2300      	movs	r3, #0
    6d24:	9319      	str	r3, [sp, #100]	; 0x64
    6d26:	971a      	str	r7, [sp, #104]	; 0x68
    6d28:	aa0c      	add	r2, sp, #48	; 0x30
    6d2a:	921b      	str	r2, [sp, #108]	; 0x6c
    6d2c:	9301      	str	r3, [sp, #4]
    6d2e:	2302      	movs	r3, #2
    6d30:	9300      	str	r3, [sp, #0]
    6d32:	ab18      	add	r3, sp, #96	; 0x60
    6d34:	aa02      	add	r2, sp, #8
    6d36:	a904      	add	r1, sp, #16
    6d38:	4628      	mov	r0, r5
    6d3a:	f7ff fd69 	bl	6810 <lfs_dir_relocatingcommit>
            if (state < 0) {
    6d3e:	1e07      	subs	r7, r0, #0
    6d40:	db21      	blt.n	6d86 <lfs_dir_orphaningcommit+0x286>
            if (state == LFS_OK_RELOCATED) {
    6d42:	2f01      	cmp	r7, #1
    6d44:	d1aa      	bne.n	6c9c <lfs_dir_orphaningcommit+0x19c>
                lpair[0] = ppair[0];
    6d46:	9b02      	ldr	r3, [sp, #8]
    6d48:	9314      	str	r3, [sp, #80]	; 0x50
                lpair[1] = ppair[1];
    6d4a:	9b03      	ldr	r3, [sp, #12]
    6d4c:	9315      	str	r3, [sp, #84]	; 0x54
                ldir = pdir;
    6d4e:	ac0c      	add	r4, sp, #48	; 0x30
    6d50:	ae04      	add	r6, sp, #16
    6d52:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    6d54:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    6d56:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    6d5a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                orphans = true;
    6d5e:	2601      	movs	r6, #1
    6d60:	e7a7      	b.n	6cb2 <lfs_dir_orphaningcommit+0x1b2>
                moveid = lfs_tag_id(lfs->gstate.tag);
    6d62:	6b2c      	ldr	r4, [r5, #48]	; 0x30
    return (tag & 0x000ffc00) >> 10;
    6d64:	f3c4 2489 	ubfx	r4, r4, #10, #10
                lfs_fs_prepmove(lfs, 0x3ff, NULL);
    6d68:	2200      	movs	r2, #0
    6d6a:	f240 31ff 	movw	r1, #1023	; 0x3ff
    6d6e:	4628      	mov	r0, r5
    6d70:	f7fe fc0c 	bl	558c <lfs_fs_prepmove>
    return (tag & 0x000ffc00) >> 10;
    6d74:	f3c7 2389 	ubfx	r3, r7, #10, #10
                if (moveid < lfs_tag_id(tag)) {
    6d78:	429c      	cmp	r4, r3
    6d7a:	d2c4      	bcs.n	6d06 <lfs_dir_orphaningcommit+0x206>
                    tag -= LFS_MKTAG(0, 1, 0);
    6d7c:	f5a7 6780 	sub.w	r7, r7, #1024	; 0x400
    6d80:	e7c1      	b.n	6d06 <lfs_dir_orphaningcommit+0x206>
            state = lfs_dir_relocatingcommit(lfs, &pdir, ppair, LFS_MKATTRS(
    6d82:	2300      	movs	r3, #0
    6d84:	e7cc      	b.n	6d20 <lfs_dir_orphaningcommit+0x220>
                return state;
    6d86:	463b      	mov	r3, r7
                return err;
    6d88:	461f      	mov	r7, r3
}
    6d8a:	4638      	mov	r0, r7
    6d8c:	b021      	add	sp, #132	; 0x84
    6d8e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return lfs_tag_size(a->tag);
    6d92:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    return tag & 0x000003ff;
    6d94:	f3c3 0309 	ubfx	r3, r3, #0, #10
            if (lfs_gstate_hasorphans(&lfs->gstate)) {
    6d98:	2b00      	cmp	r3, #0
    6d9a:	d138      	bne.n	6e0e <lfs_dir_orphaningcommit+0x30e>
            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
    6d9c:	a904      	add	r1, sp, #16
    6d9e:	f105 0030 	add.w	r0, r5, #48	; 0x30
    6da2:	f005 f959 	bl	c058 <lfs_gstate_hasmovehere>
    6da6:	2800      	cmp	r0, #0
    6da8:	d13a      	bne.n	6e20 <lfs_dir_orphaningcommit+0x320>
            uint16_t moveid = 0x3ff;
    6daa:	f240 34ff 	movw	r4, #1023	; 0x3ff
            lpair[0] = pdir.pair[0];
    6dae:	9b04      	ldr	r3, [sp, #16]
    6db0:	9314      	str	r3, [sp, #80]	; 0x50
            lpair[1] = pdir.pair[1];
    6db2:	9b05      	ldr	r3, [sp, #20]
    6db4:	9315      	str	r3, [sp, #84]	; 0x54
            state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(
    6db6:	f240 33ff 	movw	r3, #1023	; 0x3ff
    6dba:	429c      	cmp	r4, r3
    6dbc:	d03a      	beq.n	6e34 <lfs_dir_orphaningcommit+0x334>
    6dbe:	02a3      	lsls	r3, r4, #10
    6dc0:	f043 439f 	orr.w	r3, r3, #1333788672	; 0x4f800000
    6dc4:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
    6dc8:	931c      	str	r3, [sp, #112]	; 0x70
    6dca:	2100      	movs	r1, #0
    6dcc:	911d      	str	r1, [sp, #116]	; 0x74
    6dce:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    6dd2:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
    6dd6:	4b1c      	ldr	r3, [pc, #112]	; (6e48 <lfs_dir_orphaningcommit+0x348>)
    6dd8:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    6ddc:	931e      	str	r3, [sp, #120]	; 0x78
    6dde:	ab0c      	add	r3, sp, #48	; 0x30
    6de0:	931f      	str	r3, [sp, #124]	; 0x7c
    6de2:	9101      	str	r1, [sp, #4]
    6de4:	2302      	movs	r3, #2
    6de6:	9300      	str	r3, [sp, #0]
    6de8:	ab1c      	add	r3, sp, #112	; 0x70
    6dea:	aa14      	add	r2, sp, #80	; 0x50
    6dec:	a904      	add	r1, sp, #16
    6dee:	4628      	mov	r0, r5
    6df0:	f7ff fd0e 	bl	6810 <lfs_dir_relocatingcommit>
            if (state < 0) {
    6df4:	1e07      	subs	r7, r0, #0
    6df6:	dbc8      	blt.n	6d8a <lfs_dir_orphaningcommit+0x28a>
            ldir = pdir;
    6df8:	ac0c      	add	r4, sp, #48	; 0x30
    6dfa:	f10d 0c10 	add.w	ip, sp, #16
    6dfe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
    6e02:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    6e04:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    6e08:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    6e0c:	e751      	b.n	6cb2 <lfs_dir_orphaningcommit+0x1b2>
                err = lfs_fs_preporphans(lfs, -hasparent);
    6e0e:	f1c8 0100 	rsb	r1, r8, #0
    6e12:	4628      	mov	r0, r5
    6e14:	f005 f9a6 	bl	c164 <lfs_fs_preporphans>
                if (err) {
    6e18:	4607      	mov	r7, r0
    6e1a:	2800      	cmp	r0, #0
    6e1c:	d0be      	beq.n	6d9c <lfs_dir_orphaningcommit+0x29c>
    6e1e:	e7b4      	b.n	6d8a <lfs_dir_orphaningcommit+0x28a>
                moveid = lfs_tag_id(lfs->gstate.tag);
    6e20:	6b2c      	ldr	r4, [r5, #48]	; 0x30
    return (tag & 0x000ffc00) >> 10;
    6e22:	f3c4 2489 	ubfx	r4, r4, #10, #10
                lfs_fs_prepmove(lfs, 0x3ff, NULL);
    6e26:	2200      	movs	r2, #0
    6e28:	f240 31ff 	movw	r1, #1023	; 0x3ff
    6e2c:	4628      	mov	r0, r5
    6e2e:	f7fe fbad 	bl	558c <lfs_fs_prepmove>
    6e32:	e7bc      	b.n	6dae <lfs_dir_orphaningcommit+0x2ae>
            state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(
    6e34:	2300      	movs	r3, #0
    6e36:	e7c7      	b.n	6dc8 <lfs_dir_orphaningcommit+0x2c8>
    return orphans ? LFS_OK_ORPHANED : 0;
    6e38:	b90e      	cbnz	r6, 6e3e <lfs_dir_orphaningcommit+0x33e>
    6e3a:	2700      	movs	r7, #0
    6e3c:	e7a5      	b.n	6d8a <lfs_dir_orphaningcommit+0x28a>
    6e3e:	2703      	movs	r7, #3
    6e40:	e7a3      	b.n	6d8a <lfs_dir_orphaningcommit+0x28a>
            return err;
    6e42:	4607      	mov	r7, r0
    6e44:	e7a1      	b.n	6d8a <lfs_dir_orphaningcommit+0x28a>
    6e46:	bf00      	nop
    6e48:	000ffc08 	.word	0x000ffc08

00006e4c <lfs_fs_deorphan>:
    return lfs_tag_size(a->tag);
    6e4c:	6b03      	ldr	r3, [r0, #48]	; 0x30
    return tag & 0x000003ff;
    6e4e:	f3c3 0309 	ubfx	r3, r3, #0, #10
    if (!lfs_gstate_hasorphans(&lfs->gstate)) {
    6e52:	2b00      	cmp	r3, #0
    6e54:	f000 80b2 	beq.w	6fbc <lfs_fs_deorphan+0x170>
static int lfs_fs_deorphan(lfs_t *lfs, bool powerloss) {
    6e58:	b5f0      	push	{r4, r5, r6, r7, lr}
    6e5a:	b0a3      	sub	sp, #140	; 0x8c
    6e5c:	4604      	mov	r4, r0
    6e5e:	460e      	mov	r6, r1
    int8_t found = 0;
    6e60:	2500      	movs	r5, #0
        lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};
    6e62:	2220      	movs	r2, #32
    6e64:	2100      	movs	r1, #0
    6e66:	a804      	add	r0, sp, #16
    6e68:	f003 fc57 	bl	a71a <memset>
    6e6c:	2301      	movs	r3, #1
    6e6e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    6e72:	930b      	str	r3, [sp, #44]	; 0x2c
        while (!lfs_pair_isnull(pdir.tail)) {
    6e74:	e08a      	b.n	6f8c <lfs_fs_deorphan+0x140>
                lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);
    6e76:	aa14      	add	r2, sp, #80	; 0x50
    6e78:	a90a      	add	r1, sp, #40	; 0x28
    6e7a:	4620      	mov	r0, r4
    6e7c:	f7ff f8c4 	bl	6008 <lfs_fs_parent>
                if (tag < 0 && tag != LFS_ERR_NOENT) {
    6e80:	1e03      	subs	r3, r0, #0
    6e82:	db2e      	blt.n	6ee2 <lfs_fs_deorphan+0x96>
                if (tag != LFS_ERR_NOENT) {
    6e84:	f113 0f02 	cmn.w	r3, #2
    6e88:	d074      	beq.n	6f74 <lfs_fs_deorphan+0x128>
                    lfs_stag_t state = lfs_dir_get(lfs, &parent,
    6e8a:	aa02      	add	r2, sp, #8
    6e8c:	9200      	str	r2, [sp, #0]
    6e8e:	4a4d      	ldr	r2, [pc, #308]	; (6fc4 <lfs_fs_deorphan+0x178>)
    6e90:	a914      	add	r1, sp, #80	; 0x50
    6e92:	4620      	mov	r0, r4
    6e94:	f005 fa6f 	bl	c376 <lfs_dir_get>
                    if (state < 0) {
    6e98:	1e03      	subs	r3, r0, #0
    6e9a:	f2c0 808c 	blt.w	6fb6 <lfs_fs_deorphan+0x16a>
                    if (!lfs_pair_sync(pair, pdir.tail)) {
    6e9e:	a90a      	add	r1, sp, #40	; 0x28
    6ea0:	a802      	add	r0, sp, #8
    6ea2:	f005 f8a2 	bl	bfea <lfs_pair_sync>
    6ea6:	2800      	cmp	r0, #0
    6ea8:	d164      	bne.n	6f74 <lfs_fs_deorphan+0x128>
                        if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
    6eaa:	a904      	add	r1, sp, #16
    6eac:	f104 0030 	add.w	r0, r4, #48	; 0x30
    6eb0:	f005 f8d2 	bl	c058 <lfs_gstate_hasmovehere>
    6eb4:	2800      	cmp	r0, #0
    6eb6:	d139      	bne.n	6f2c <lfs_fs_deorphan+0xe0>
                        state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(
    6eb8:	2300      	movs	r3, #0
    6eba:	931e      	str	r3, [sp, #120]	; 0x78
    6ebc:	2300      	movs	r3, #0
    6ebe:	931f      	str	r3, [sp, #124]	; 0x7c
    6ec0:	4b41      	ldr	r3, [pc, #260]	; (6fc8 <lfs_fs_deorphan+0x17c>)
    6ec2:	9320      	str	r3, [sp, #128]	; 0x80
    6ec4:	ab02      	add	r3, sp, #8
    6ec6:	9321      	str	r3, [sp, #132]	; 0x84
    6ec8:	2302      	movs	r3, #2
    6eca:	aa1e      	add	r2, sp, #120	; 0x78
    6ecc:	a904      	add	r1, sp, #16
    6ece:	4620      	mov	r0, r4
    6ed0:	f7ff fe16 	bl	6b00 <lfs_dir_orphaningcommit>
                        if (state < 0) {
    6ed4:	1e03      	subs	r3, r0, #0
    6ed6:	db6e      	blt.n	6fb6 <lfs_fs_deorphan+0x16a>
                        found += 1;
    6ed8:	3501      	adds	r5, #1
    6eda:	b26d      	sxtb	r5, r5
                        if (state == LFS_OK_ORPHANED) {
    6edc:	2b03      	cmp	r3, #3
    6ede:	d155      	bne.n	6f8c <lfs_fs_deorphan+0x140>
    6ee0:	e7bf      	b.n	6e62 <lfs_fs_deorphan+0x16>
                if (tag < 0 && tag != LFS_ERR_NOENT) {
    6ee2:	f113 0f02 	cmn.w	r3, #2
    6ee6:	d166      	bne.n	6fb6 <lfs_fs_deorphan+0x16a>
                if (tag == LFS_ERR_NOENT && powerloss) {
    6ee8:	2e00      	cmp	r6, #0
    6eea:	d0cb      	beq.n	6e84 <lfs_fs_deorphan+0x38>
                    err = lfs_dir_getgstate(lfs, &dir, &lfs->gdelta);
    6eec:	f104 0248 	add.w	r2, r4, #72	; 0x48
    6ef0:	a90c      	add	r1, sp, #48	; 0x30
    6ef2:	4620      	mov	r0, r4
    6ef4:	f7fe fc18 	bl	5728 <lfs_dir_getgstate>
                    if (err) {
    6ef8:	4603      	mov	r3, r0
    6efa:	2800      	cmp	r0, #0
    6efc:	d15b      	bne.n	6fb6 <lfs_fs_deorphan+0x16a>
                    int state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(
    6efe:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
    6f02:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
    6f06:	4b31      	ldr	r3, [pc, #196]	; (6fcc <lfs_fs_deorphan+0x180>)
    6f08:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    6f0c:	931c      	str	r3, [sp, #112]	; 0x70
    6f0e:	ab12      	add	r3, sp, #72	; 0x48
    6f10:	931d      	str	r3, [sp, #116]	; 0x74
    6f12:	2301      	movs	r3, #1
    6f14:	aa1c      	add	r2, sp, #112	; 0x70
    6f16:	a904      	add	r1, sp, #16
    6f18:	4620      	mov	r0, r4
    6f1a:	f7ff fdf1 	bl	6b00 <lfs_dir_orphaningcommit>
                    if (state < 0) {
    6f1e:	1e03      	subs	r3, r0, #0
    6f20:	db49      	blt.n	6fb6 <lfs_fs_deorphan+0x16a>
                    found += 1;
    6f22:	3501      	adds	r5, #1
    6f24:	b26d      	sxtb	r5, r5
                    if (state == LFS_OK_ORPHANED) {
    6f26:	2b03      	cmp	r3, #3
    6f28:	d130      	bne.n	6f8c <lfs_fs_deorphan+0x140>
    6f2a:	e79a      	b.n	6e62 <lfs_fs_deorphan+0x16>
                            moveid = lfs_tag_id(lfs->gstate.tag);
    6f2c:	6b27      	ldr	r7, [r4, #48]	; 0x30
    return (tag & 0x000ffc00) >> 10;
    6f2e:	f3c7 2789 	ubfx	r7, r7, #10, #10
                            lfs_fs_prepmove(lfs, 0x3ff, NULL);
    6f32:	2200      	movs	r2, #0
    6f34:	f240 31ff 	movw	r1, #1023	; 0x3ff
    6f38:	4620      	mov	r0, r4
    6f3a:	f7fe fb27 	bl	558c <lfs_fs_prepmove>
                        state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(
    6f3e:	f240 33ff 	movw	r3, #1023	; 0x3ff
    6f42:	429f      	cmp	r7, r3
    6f44:	d005      	beq.n	6f52 <lfs_fs_deorphan+0x106>
    6f46:	02bb      	lsls	r3, r7, #10
    6f48:	f043 439f 	orr.w	r3, r3, #1333788672	; 0x4f800000
    6f4c:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
    6f50:	e7b3      	b.n	6eba <lfs_fs_deorphan+0x6e>
    6f52:	2300      	movs	r3, #0
    6f54:	e7b1      	b.n	6eba <lfs_fs_deorphan+0x6e>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    6f56:	2301      	movs	r3, #1
    6f58:	e000      	b.n	6f5c <lfs_fs_deorphan+0x110>
    6f5a:	2301      	movs	r3, #1
        while (!lfs_pair_isnull(pdir.tail)) {
    6f5c:	bb03      	cbnz	r3, 6fa0 <lfs_fs_deorphan+0x154>
            int err = lfs_dir_fetch(lfs, &dir, pdir.tail);
    6f5e:	aa0a      	add	r2, sp, #40	; 0x28
    6f60:	a90c      	add	r1, sp, #48	; 0x30
    6f62:	4620      	mov	r0, r4
    6f64:	f005 fc5d 	bl	c822 <lfs_dir_fetch>
            if (err) {
    6f68:	4603      	mov	r3, r0
    6f6a:	bb20      	cbnz	r0, 6fb6 <lfs_fs_deorphan+0x16a>
            if (!pdir.split) {
    6f6c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    6f70:	2b00      	cmp	r3, #0
    6f72:	d080      	beq.n	6e76 <lfs_fs_deorphan+0x2a>
            pdir = dir;
    6f74:	f10d 0c10 	add.w	ip, sp, #16
    6f78:	f10d 0e30 	add.w	lr, sp, #48	; 0x30
    6f7c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    6f80:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    6f84:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
    6f88:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    6f8c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    6f8e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    6f92:	d0e2      	beq.n	6f5a <lfs_fs_deorphan+0x10e>
    6f94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    6f96:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    6f9a:	d0dc      	beq.n	6f56 <lfs_fs_deorphan+0x10a>
    6f9c:	2300      	movs	r3, #0
    6f9e:	e7dd      	b.n	6f5c <lfs_fs_deorphan+0x110>
    6fa0:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
    6fa4:	42a9      	cmp	r1, r5
    6fa6:	bf28      	it	cs
    6fa8:	4629      	movcs	r1, r5
    return lfs_fs_preporphans(lfs, -lfs_min(
    6faa:	4249      	negs	r1, r1
    6fac:	b249      	sxtb	r1, r1
    6fae:	4620      	mov	r0, r4
    6fb0:	f005 f8d8 	bl	c164 <lfs_fs_preporphans>
    6fb4:	4603      	mov	r3, r0
}
    6fb6:	4618      	mov	r0, r3
    6fb8:	b023      	add	sp, #140	; 0x8c
    6fba:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 0;
    6fbc:	2300      	movs	r3, #0
}
    6fbe:	4618      	mov	r0, r3
    6fc0:	4770      	bx	lr
    6fc2:	bf00      	nop
    6fc4:	7ffffc00 	.word	0x7ffffc00
    6fc8:	600ffc08 	.word	0x600ffc08
    6fcc:	000ffc08 	.word	0x000ffc08

00006fd0 <lfs_dir_drop>:
static int lfs_dir_drop(lfs_t *lfs, lfs_mdir_t *dir, lfs_mdir_t *tail) {
    6fd0:	b570      	push	{r4, r5, r6, lr}
    6fd2:	b082      	sub	sp, #8
    6fd4:	4605      	mov	r5, r0
    6fd6:	460e      	mov	r6, r1
    6fd8:	4614      	mov	r4, r2
    int err = lfs_dir_getgstate(lfs, tail, &lfs->gdelta);
    6fda:	f100 0248 	add.w	r2, r0, #72	; 0x48
    6fde:	4621      	mov	r1, r4
    6fe0:	f7fe fba2 	bl	5728 <lfs_dir_getgstate>
    if (err) {
    6fe4:	b108      	cbz	r0, 6fea <lfs_dir_drop+0x1a>
}
    6fe6:	b002      	add	sp, #8
    6fe8:	bd70      	pop	{r4, r5, r6, pc}
    lfs_pair_tole32(tail->tail);
    6fea:	f104 0118 	add.w	r1, r4, #24
    err = lfs_dir_commit(lfs, dir, LFS_MKATTRS(
    6fee:	7de2      	ldrb	r2, [r4, #23]
    6ff0:	f502 62c0 	add.w	r2, r2, #1536	; 0x600
    6ff4:	4b05      	ldr	r3, [pc, #20]	; (700c <lfs_dir_drop+0x3c>)
    6ff6:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    6ffa:	9300      	str	r3, [sp, #0]
    6ffc:	9101      	str	r1, [sp, #4]
    6ffe:	2301      	movs	r3, #1
    7000:	466a      	mov	r2, sp
    7002:	4631      	mov	r1, r6
    7004:	4628      	mov	r0, r5
    7006:	f006 f933 	bl	d270 <lfs_dir_commit>
    if (err) {
    700a:	e7ec      	b.n	6fe6 <lfs_dir_drop+0x16>
    700c:	000ffc08 	.word	0x000ffc08

00007010 <lfs_rawformat>:
static int lfs_rawformat(lfs_t *lfs, const struct lfs_config *cfg) {
    7010:	b530      	push	{r4, r5, lr}
    7012:	b097      	sub	sp, #92	; 0x5c
    7014:	4604      	mov	r4, r0
        err = lfs_init(lfs, cfg);
    7016:	f006 f9e2 	bl	d3de <lfs_init>
        if (err) {
    701a:	4605      	mov	r5, r0
    701c:	b110      	cbz	r0, 7024 <lfs_rawformat+0x14>
}
    701e:	4628      	mov	r0, r5
    7020:	b017      	add	sp, #92	; 0x5c
    7022:	bd30      	pop	{r4, r5, pc}
        memset(lfs->free.buffer, 0, lfs->cfg->lookahead_size);
    7024:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    7026:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    7028:	2100      	movs	r1, #0
    702a:	6e60      	ldr	r0, [r4, #100]	; 0x64
    702c:	f003 fb75 	bl	a71a <memset>
        lfs->free.off = 0;
    7030:	2200      	movs	r2, #0
    7032:	6562      	str	r2, [r4, #84]	; 0x54
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size,
    7034:	6ea1      	ldr	r1, [r4, #104]	; 0x68
    7036:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    7038:	00db      	lsls	r3, r3, #3
                lfs->cfg->block_count);
    703a:	6a09      	ldr	r1, [r1, #32]
    703c:	428b      	cmp	r3, r1
    703e:	bf28      	it	cs
    7040:	460b      	movcs	r3, r1
        lfs->free.size = lfs_min(8*lfs->cfg->lookahead_size,
    7042:	65a3      	str	r3, [r4, #88]	; 0x58
        lfs->free.i = 0;
    7044:	65e2      	str	r2, [r4, #92]	; 0x5c
        lfs_alloc_ack(lfs);
    7046:	4620      	mov	r0, r4
    7048:	f005 f84c 	bl	c0e4 <lfs_alloc_ack>
        err = lfs_dir_alloc(lfs, &root);
    704c:	a906      	add	r1, sp, #24
    704e:	4620      	mov	r0, r4
    7050:	f005 fbf5 	bl	c83e <lfs_dir_alloc>
        if (err) {
    7054:	4605      	mov	r5, r0
    7056:	b118      	cbz	r0, 7060 <lfs_rawformat+0x50>
    lfs_deinit(lfs);
    7058:	4620      	mov	r0, r4
    705a:	f006 f9a7 	bl	d3ac <lfs_deinit>
    return err;
    705e:	e7de      	b.n	701e <lfs_rawformat+0xe>
        lfs_superblock_t superblock = {
    7060:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    7064:	9300      	str	r3, [sp, #0]
            .block_size  = lfs->cfg->block_size,
    7066:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    7068:	69da      	ldr	r2, [r3, #28]
        lfs_superblock_t superblock = {
    706a:	9201      	str	r2, [sp, #4]
            .block_count = lfs->cfg->block_count,
    706c:	6a1b      	ldr	r3, [r3, #32]
        lfs_superblock_t superblock = {
    706e:	9302      	str	r3, [sp, #8]
            .name_max    = lfs->name_max,
    7070:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
        lfs_superblock_t superblock = {
    7072:	9303      	str	r3, [sp, #12]
            .file_max    = lfs->file_max,
    7074:	6f23      	ldr	r3, [r4, #112]	; 0x70
        lfs_superblock_t superblock = {
    7076:	9304      	str	r3, [sp, #16]
            .attr_max    = lfs->attr_max,
    7078:	6f63      	ldr	r3, [r4, #116]	; 0x74
        lfs_superblock_t superblock = {
    707a:	9305      	str	r3, [sp, #20]
        err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
    707c:	4b15      	ldr	r3, [pc, #84]	; (70d4 <lfs_rawformat+0xc4>)
    707e:	930e      	str	r3, [sp, #56]	; 0x38
    7080:	2300      	movs	r3, #0
    7082:	930f      	str	r3, [sp, #60]	; 0x3c
    7084:	4b14      	ldr	r3, [pc, #80]	; (70d8 <lfs_rawformat+0xc8>)
    7086:	9310      	str	r3, [sp, #64]	; 0x40
    7088:	4b14      	ldr	r3, [pc, #80]	; (70dc <lfs_rawformat+0xcc>)
    708a:	9311      	str	r3, [sp, #68]	; 0x44
    708c:	4b14      	ldr	r3, [pc, #80]	; (70e0 <lfs_rawformat+0xd0>)
    708e:	9312      	str	r3, [sp, #72]	; 0x48
    7090:	f8cd d04c 	str.w	sp, [sp, #76]	; 0x4c
    7094:	2303      	movs	r3, #3
    7096:	aa0e      	add	r2, sp, #56	; 0x38
    7098:	a906      	add	r1, sp, #24
    709a:	4620      	mov	r0, r4
    709c:	f006 f8e8 	bl	d270 <lfs_dir_commit>
        if (err) {
    70a0:	4605      	mov	r5, r0
    70a2:	2800      	cmp	r0, #0
    70a4:	d1d8      	bne.n	7058 <lfs_rawformat+0x48>
        root.erased = false;
    70a6:	2200      	movs	r2, #0
    70a8:	f88d 202e 	strb.w	r2, [sp, #46]	; 0x2e
        err = lfs_dir_commit(lfs, &root, NULL, 0);
    70ac:	4613      	mov	r3, r2
    70ae:	a906      	add	r1, sp, #24
    70b0:	4620      	mov	r0, r4
    70b2:	f006 f8dd 	bl	d270 <lfs_dir_commit>
        if (err) {
    70b6:	4605      	mov	r5, r0
    70b8:	2800      	cmp	r0, #0
    70ba:	d1cd      	bne.n	7058 <lfs_rawformat+0x48>
        err = lfs_dir_fetch(lfs, &root, (const lfs_block_t[2]){0, 1});
    70bc:	2300      	movs	r3, #0
    70be:	9314      	str	r3, [sp, #80]	; 0x50
    70c0:	2301      	movs	r3, #1
    70c2:	9315      	str	r3, [sp, #84]	; 0x54
    70c4:	aa14      	add	r2, sp, #80	; 0x50
    70c6:	a906      	add	r1, sp, #24
    70c8:	4620      	mov	r0, r4
    70ca:	f005 fbaa 	bl	c822 <lfs_dir_fetch>
    70ce:	4605      	mov	r5, r0
        if (err) {
    70d0:	e7c2      	b.n	7058 <lfs_rawformat+0x48>
    70d2:	bf00      	nop
    70d4:	40100000 	.word	0x40100000
    70d8:	0ff00008 	.word	0x0ff00008
    70dc:	0000efdc 	.word	0x0000efdc
    70e0:	20100018 	.word	0x20100018

000070e4 <lfs_rawmount>:
static int lfs_rawmount(lfs_t *lfs, const struct lfs_config *cfg) {
    70e4:	b570      	push	{r4, r5, r6, lr}
    70e6:	b096      	sub	sp, #88	; 0x58
    70e8:	4604      	mov	r4, r0
    int err = lfs_init(lfs, cfg);
    70ea:	f006 f978 	bl	d3de <lfs_init>
    if (err) {
    70ee:	4606      	mov	r6, r0
    70f0:	2800      	cmp	r0, #0
    70f2:	f040 80c3 	bne.w	727c <lfs_rawmount+0x198>
    lfs_mdir_t dir = {.tail = {0, 1}};
    70f6:	2220      	movs	r2, #32
    70f8:	2100      	movs	r1, #0
    70fa:	a80b      	add	r0, sp, #44	; 0x2c
    70fc:	f003 fb0d 	bl	a71a <memset>
    7100:	2301      	movs	r3, #1
    7102:	9312      	str	r3, [sp, #72]	; 0x48
    lfs_block_t cycle = 0;
    7104:	2500      	movs	r5, #0
    while (!lfs_pair_isnull(dir.tail)) {
    7106:	e041      	b.n	718c <lfs_rawmount+0xa8>
                LFS_ERROR("Invalid version v%"PRIu16".%"PRIu16,
    7108:	b29b      	uxth	r3, r3
    710a:	9301      	str	r3, [sp, #4]
    710c:	9000      	str	r0, [sp, #0]
    710e:	f241 033b 	movw	r3, #4155	; 0x103b
    7112:	4a77      	ldr	r2, [pc, #476]	; (72f0 <lfs_rawmount+0x20c>)
    7114:	2145      	movs	r1, #69	; 0x45
    7116:	4877      	ldr	r0, [pc, #476]	; (72f4 <lfs_rawmount+0x210>)
    7118:	f003 f910 	bl	a33c <z_log_minimal_printk>
                err = LFS_ERR_INVAL;
    711c:	f06f 0615 	mvn.w	r6, #21
                goto cleanup;
    7120:	e0a9      	b.n	7276 <lfs_rawmount+0x192>
                    LFS_ERROR("Unsupported name_max (%"PRIu32" > %"PRIu32")",
    7122:	9201      	str	r2, [sp, #4]
    7124:	9300      	str	r3, [sp, #0]
    7126:	f241 0344 	movw	r3, #4164	; 0x1044
    712a:	4a71      	ldr	r2, [pc, #452]	; (72f0 <lfs_rawmount+0x20c>)
    712c:	2145      	movs	r1, #69	; 0x45
    712e:	4872      	ldr	r0, [pc, #456]	; (72f8 <lfs_rawmount+0x214>)
    7130:	f003 f904 	bl	a33c <z_log_minimal_printk>
                    err = LFS_ERR_INVAL;
    7134:	f06f 0615 	mvn.w	r6, #21
                    goto cleanup;
    7138:	e09d      	b.n	7276 <lfs_rawmount+0x192>
                    LFS_ERROR("Unsupported file_max (%"PRIu32" > %"PRIu32")",
    713a:	9201      	str	r2, [sp, #4]
    713c:	9300      	str	r3, [sp, #0]
    713e:	f241 034f 	movw	r3, #4175	; 0x104f
    7142:	4a6b      	ldr	r2, [pc, #428]	; (72f0 <lfs_rawmount+0x20c>)
    7144:	2145      	movs	r1, #69	; 0x45
    7146:	486d      	ldr	r0, [pc, #436]	; (72fc <lfs_rawmount+0x218>)
    7148:	f003 f8f8 	bl	a33c <z_log_minimal_printk>
                    err = LFS_ERR_INVAL;
    714c:	f06f 0615 	mvn.w	r6, #21
                    goto cleanup;
    7150:	e091      	b.n	7276 <lfs_rawmount+0x192>
                    LFS_ERROR("Unsupported attr_max (%"PRIu32" > %"PRIu32")",
    7152:	9201      	str	r2, [sp, #4]
    7154:	9300      	str	r3, [sp, #0]
    7156:	f241 035a 	movw	r3, #4186	; 0x105a
    715a:	4a65      	ldr	r2, [pc, #404]	; (72f0 <lfs_rawmount+0x20c>)
    715c:	2145      	movs	r1, #69	; 0x45
    715e:	4868      	ldr	r0, [pc, #416]	; (7300 <lfs_rawmount+0x21c>)
    7160:	f003 f8ec 	bl	a33c <z_log_minimal_printk>
                    err = LFS_ERR_INVAL;
    7164:	f06f 0615 	mvn.w	r6, #21
                    goto cleanup;
    7168:	e085      	b.n	7276 <lfs_rawmount+0x192>
            if (superblock.block_count != lfs->cfg->block_count) {
    716a:	9a07      	ldr	r2, [sp, #28]
    716c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    716e:	6a19      	ldr	r1, [r3, #32]
    7170:	428a      	cmp	r2, r1
    7172:	d164      	bne.n	723e <lfs_rawmount+0x15a>
            if (superblock.block_size != lfs->cfg->block_size) {
    7174:	69db      	ldr	r3, [r3, #28]
    7176:	9806      	ldr	r0, [sp, #24]
    7178:	4298      	cmp	r0, r3
    717a:	d16c      	bne.n	7256 <lfs_rawmount+0x172>
        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);
    717c:	f104 0230 	add.w	r2, r4, #48	; 0x30
    7180:	a90b      	add	r1, sp, #44	; 0x2c
    7182:	4620      	mov	r0, r4
    7184:	f7fe fad0 	bl	5728 <lfs_dir_getgstate>
        if (err) {
    7188:	2800      	cmp	r0, #0
    718a:	d17c      	bne.n	7286 <lfs_rawmount+0x1a2>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    718c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    718e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    7192:	d07c      	beq.n	728e <lfs_rawmount+0x1aa>
    7194:	9b12      	ldr	r3, [sp, #72]	; 0x48
    7196:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    719a:	d076      	beq.n	728a <lfs_rawmount+0x1a6>
    719c:	4633      	mov	r3, r6
    while (!lfs_pair_isnull(dir.tail)) {
    719e:	f013 0f01 	tst.w	r3, #1
    71a2:	d176      	bne.n	7292 <lfs_rawmount+0x1ae>
        if (cycle >= lfs->cfg->block_count/2) {
    71a4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    71a6:	6a1b      	ldr	r3, [r3, #32]
    71a8:	ebb5 0f53 	cmp.w	r5, r3, lsr #1
    71ac:	d261      	bcs.n	7272 <lfs_rawmount+0x18e>
        cycle += 1;
    71ae:	3501      	adds	r5, #1
                lfs_dir_find_match, &(struct lfs_dir_find_match){
    71b0:	9413      	str	r4, [sp, #76]	; 0x4c
    71b2:	4b54      	ldr	r3, [pc, #336]	; (7304 <lfs_rawmount+0x220>)
    71b4:	9314      	str	r3, [sp, #80]	; 0x50
    71b6:	2308      	movs	r3, #8
    71b8:	9315      	str	r3, [sp, #84]	; 0x54
        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,
    71ba:	ab13      	add	r3, sp, #76	; 0x4c
    71bc:	9303      	str	r3, [sp, #12]
    71be:	4b52      	ldr	r3, [pc, #328]	; (7308 <lfs_rawmount+0x224>)
    71c0:	9302      	str	r3, [sp, #8]
    71c2:	2300      	movs	r3, #0
    71c4:	9301      	str	r3, [sp, #4]
    71c6:	4b51      	ldr	r3, [pc, #324]	; (730c <lfs_rawmount+0x228>)
    71c8:	9300      	str	r3, [sp, #0]
    71ca:	4b51      	ldr	r3, [pc, #324]	; (7310 <lfs_rawmount+0x22c>)
    71cc:	aa11      	add	r2, sp, #68	; 0x44
    71ce:	a90b      	add	r1, sp, #44	; 0x2c
    71d0:	4620      	mov	r0, r4
    71d2:	f7fe fcc9 	bl	5b68 <lfs_dir_fetchmatch>
        if (tag < 0) {
    71d6:	2800      	cmp	r0, #0
    71d8:	db53      	blt.n	7282 <lfs_rawmount+0x19e>
        if (tag && !lfs_tag_isdelete(tag)) {
    71da:	2800      	cmp	r0, #0
    71dc:	d0ce      	beq.n	717c <lfs_rawmount+0x98>
    return ((int32_t)(tag << 22) >> 22) == -1;
    71de:	f340 0009 	sbfx	r0, r0, #0, #10
        if (tag && !lfs_tag_isdelete(tag)) {
    71e2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    71e6:	d0c9      	beq.n	717c <lfs_rawmount+0x98>
            lfs->root[0] = dir.pair[0];
    71e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    71ea:	6223      	str	r3, [r4, #32]
            lfs->root[1] = dir.pair[1];
    71ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    71ee:	6263      	str	r3, [r4, #36]	; 0x24
            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
    71f0:	ab05      	add	r3, sp, #20
    71f2:	9300      	str	r3, [sp, #0]
    71f4:	4b47      	ldr	r3, [pc, #284]	; (7314 <lfs_rawmount+0x230>)
    71f6:	4a46      	ldr	r2, [pc, #280]	; (7310 <lfs_rawmount+0x22c>)
    71f8:	a90b      	add	r1, sp, #44	; 0x2c
    71fa:	4620      	mov	r0, r4
    71fc:	f005 f8bb 	bl	c376 <lfs_dir_get>
            if (tag < 0) {
    7200:	2800      	cmp	r0, #0
    7202:	db34      	blt.n	726e <lfs_rawmount+0x18a>
            uint16_t major_version = (0xffff & (superblock.version >> 16));
    7204:	9b05      	ldr	r3, [sp, #20]
    7206:	0c18      	lsrs	r0, r3, #16
            uint16_t minor_version = (0xffff & (superblock.version >>  0));
    7208:	b299      	uxth	r1, r3
            if ((major_version != LFS_DISK_VERSION_MAJOR ||
    720a:	2802      	cmp	r0, #2
    720c:	f47f af7c 	bne.w	7108 <lfs_rawmount+0x24>
    7210:	2900      	cmp	r1, #0
    7212:	f47f af79 	bne.w	7108 <lfs_rawmount+0x24>
            if (superblock.name_max) {
    7216:	9b08      	ldr	r3, [sp, #32]
    7218:	b11b      	cbz	r3, 7222 <lfs_rawmount+0x13e>
                if (superblock.name_max > lfs->name_max) {
    721a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    721c:	4293      	cmp	r3, r2
    721e:	d880      	bhi.n	7122 <lfs_rawmount+0x3e>
                lfs->name_max = superblock.name_max;
    7220:	66e3      	str	r3, [r4, #108]	; 0x6c
            if (superblock.file_max) {
    7222:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7224:	b11b      	cbz	r3, 722e <lfs_rawmount+0x14a>
                if (superblock.file_max > lfs->file_max) {
    7226:	6f22      	ldr	r2, [r4, #112]	; 0x70
    7228:	4293      	cmp	r3, r2
    722a:	d886      	bhi.n	713a <lfs_rawmount+0x56>
                lfs->file_max = superblock.file_max;
    722c:	6723      	str	r3, [r4, #112]	; 0x70
            if (superblock.attr_max) {
    722e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7230:	2b00      	cmp	r3, #0
    7232:	d09a      	beq.n	716a <lfs_rawmount+0x86>
                if (superblock.attr_max > lfs->attr_max) {
    7234:	6f62      	ldr	r2, [r4, #116]	; 0x74
    7236:	4293      	cmp	r3, r2
    7238:	d88b      	bhi.n	7152 <lfs_rawmount+0x6e>
                lfs->attr_max = superblock.attr_max;
    723a:	6763      	str	r3, [r4, #116]	; 0x74
    723c:	e795      	b.n	716a <lfs_rawmount+0x86>
                LFS_ERROR("Invalid block count (%"PRIu32" != %"PRIu32")",
    723e:	9101      	str	r1, [sp, #4]
    7240:	9200      	str	r2, [sp, #0]
    7242:	f241 0364 	movw	r3, #4196	; 0x1064
    7246:	4a2a      	ldr	r2, [pc, #168]	; (72f0 <lfs_rawmount+0x20c>)
    7248:	2145      	movs	r1, #69	; 0x45
    724a:	4833      	ldr	r0, [pc, #204]	; (7318 <lfs_rawmount+0x234>)
    724c:	f003 f876 	bl	a33c <z_log_minimal_printk>
                err = LFS_ERR_INVAL;
    7250:	f06f 0615 	mvn.w	r6, #21
                goto cleanup;
    7254:	e00f      	b.n	7276 <lfs_rawmount+0x192>
                LFS_ERROR("Invalid block size (%"PRIu32" != %"PRIu32")",
    7256:	9101      	str	r1, [sp, #4]
    7258:	9200      	str	r2, [sp, #0]
    725a:	f241 036b 	movw	r3, #4203	; 0x106b
    725e:	4a24      	ldr	r2, [pc, #144]	; (72f0 <lfs_rawmount+0x20c>)
    7260:	2145      	movs	r1, #69	; 0x45
    7262:	482e      	ldr	r0, [pc, #184]	; (731c <lfs_rawmount+0x238>)
    7264:	f003 f86a 	bl	a33c <z_log_minimal_printk>
                err = LFS_ERR_INVAL;
    7268:	f06f 0615 	mvn.w	r6, #21
                goto cleanup;
    726c:	e003      	b.n	7276 <lfs_rawmount+0x192>
                err = tag;
    726e:	4606      	mov	r6, r0
    7270:	e001      	b.n	7276 <lfs_rawmount+0x192>
            err = LFS_ERR_CORRUPT;
    7272:	f06f 0653 	mvn.w	r6, #83	; 0x53
    lfs_rawunmount(lfs);
    7276:	4620      	mov	r0, r4
    7278:	f006 f908 	bl	d48c <lfs_rawunmount>
}
    727c:	4630      	mov	r0, r6
    727e:	b016      	add	sp, #88	; 0x58
    7280:	bd70      	pop	{r4, r5, r6, pc}
            err = tag;
    7282:	4606      	mov	r6, r0
    7284:	e7f7      	b.n	7276 <lfs_rawmount+0x192>
        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);
    7286:	4606      	mov	r6, r0
    7288:	e7f5      	b.n	7276 <lfs_rawmount+0x192>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    728a:	2301      	movs	r3, #1
    728c:	e787      	b.n	719e <lfs_rawmount+0xba>
    728e:	2301      	movs	r3, #1
    7290:	e785      	b.n	719e <lfs_rawmount+0xba>
    7292:	6a23      	ldr	r3, [r4, #32]
    7294:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    7298:	d024      	beq.n	72e4 <lfs_rawmount+0x200>
    729a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    729c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    72a0:	d023      	beq.n	72ea <lfs_rawmount+0x206>
    if (!lfs_gstate_iszero(&lfs->gstate)) {
    72a2:	f104 0130 	add.w	r1, r4, #48	; 0x30
    for (int i = 0; i < 3; i++) {
    72a6:	4633      	mov	r3, r6
    72a8:	2b02      	cmp	r3, #2
    72aa:	dc04      	bgt.n	72b6 <lfs_rawmount+0x1d2>
        if (((uint32_t*)a)[i] != 0) {
    72ac:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    72b0:	b90a      	cbnz	r2, 72b6 <lfs_rawmount+0x1d2>
    for (int i = 0; i < 3; i++) {
    72b2:	3301      	adds	r3, #1
    72b4:	e7f8      	b.n	72a8 <lfs_rawmount+0x1c4>
    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);
    72b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    72b8:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
    72bc:	6323      	str	r3, [r4, #48]	; 0x30
    lfs->gdisk = lfs->gstate;
    72be:	f104 033c 	add.w	r3, r4, #60	; 0x3c
    72c2:	f104 0230 	add.w	r2, r4, #48	; 0x30
    72c6:	ca07      	ldmia	r2, {r0, r1, r2}
    72c8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    lfs->free.off = lfs->seed % lfs->cfg->block_count;
    72cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    72ce:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    72d0:	6a12      	ldr	r2, [r2, #32]
    72d2:	fbb3 f1f2 	udiv	r1, r3, r2
    72d6:	fb02 3311 	mls	r3, r2, r1, r3
    72da:	6563      	str	r3, [r4, #84]	; 0x54
    lfs_alloc_drop(lfs);
    72dc:	4620      	mov	r0, r4
    72de:	f004 ff05 	bl	c0ec <lfs_alloc_drop>
    return 0;
    72e2:	e7cb      	b.n	727c <lfs_rawmount+0x198>
        err = LFS_ERR_INVAL;
    72e4:	f06f 0615 	mvn.w	r6, #21
    72e8:	e7c5      	b.n	7276 <lfs_rawmount+0x192>
    72ea:	f06f 0615 	mvn.w	r6, #21
    72ee:	e7c2      	b.n	7276 <lfs_rawmount+0x192>
    72f0:	0000f4d4 	.word	0x0000f4d4
    72f4:	0000f5d8 	.word	0x0000f5d8
    72f8:	0000f5fc 	.word	0x0000f5fc
    72fc:	0000f628 	.word	0x0000f628
    7300:	0000f654 	.word	0x0000f654
    7304:	0000efdc 	.word	0x0000efdc
    7308:	0000c74b 	.word	0x0000c74b
    730c:	0ff00008 	.word	0x0ff00008
    7310:	7ffffc00 	.word	0x7ffffc00
    7314:	20100018 	.word	0x20100018
    7318:	0000f680 	.word	0x0000f680
    731c:	0000f6ac 	.word	0x0000f6ac

00007320 <lfs_dir_find>:
        const char **path, uint16_t *id) {
    7320:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7324:	b08d      	sub	sp, #52	; 0x34
    7326:	4682      	mov	sl, r0
    7328:	4688      	mov	r8, r1
    732a:	9207      	str	r2, [sp, #28]
    const char *name = *path;
    732c:	6812      	ldr	r2, [r2, #0]
    732e:	9206      	str	r2, [sp, #24]
    if (id) {
    7330:	9305      	str	r3, [sp, #20]
    7332:	b11b      	cbz	r3, 733c <lfs_dir_find+0x1c>
    7334:	461a      	mov	r2, r3
        *id = 0x3ff;
    7336:	f240 33ff 	movw	r3, #1023	; 0x3ff
    733a:	8013      	strh	r3, [r2, #0]
    dir->tail[0] = lfs->root[0];
    733c:	f8da 3020 	ldr.w	r3, [sl, #32]
    7340:	f8c8 3018 	str.w	r3, [r8, #24]
    dir->tail[1] = lfs->root[1];
    7344:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
    7348:	f8c8 301c 	str.w	r3, [r8, #28]
    lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);
    734c:	4e4e      	ldr	r6, [pc, #312]	; (7488 <lfs_dir_find+0x168>)
        name += strspn(name, "/");
    734e:	4c4f      	ldr	r4, [pc, #316]	; (748c <lfs_dir_find+0x16c>)
    7350:	4621      	mov	r1, r4
    7352:	f8dd 9018 	ldr.w	r9, [sp, #24]
    7356:	4648      	mov	r0, r9
    7358:	f003 f9fd 	bl	a756 <strspn>
    735c:	4481      	add	r9, r0
        lfs_size_t namelen = strcspn(name, "/");
    735e:	4621      	mov	r1, r4
    7360:	4648      	mov	r0, r9
    7362:	f003 fa07 	bl	a774 <strcspn>
    7366:	4605      	mov	r5, r0
        if ((namelen == 1 && memcmp(name, ".", 1) == 0) ||
    7368:	2801      	cmp	r0, #1
    736a:	d00a      	beq.n	7382 <lfs_dir_find+0x62>
    736c:	2d02      	cmp	r5, #2
    736e:	d013      	beq.n	7398 <lfs_dir_find+0x78>
        const char *suffix = name + namelen;
    7370:	eb09 0305 	add.w	r3, r9, r5
    7374:	9306      	str	r3, [sp, #24]
    7376:	469b      	mov	fp, r3
        int depth = 1;
    7378:	2701      	movs	r7, #1
    737a:	e017      	b.n	73ac <lfs_dir_find+0x8c>
    737c:	46b2      	mov	sl, r6
    737e:	4606      	mov	r6, r0
    7380:	e7e5      	b.n	734e <lfs_dir_find+0x2e>
        if ((namelen == 1 && memcmp(name, ".", 1) == 0) ||
    7382:	2201      	movs	r2, #1
    7384:	4942      	ldr	r1, [pc, #264]	; (7490 <lfs_dir_find+0x170>)
    7386:	4648      	mov	r0, r9
    7388:	f003 f986 	bl	a698 <memcmp>
    738c:	2800      	cmp	r0, #0
    738e:	d1ed      	bne.n	736c <lfs_dir_find+0x4c>
            name += namelen;
    7390:	eb09 0305 	add.w	r3, r9, r5
    7394:	9306      	str	r3, [sp, #24]
            goto nextname;
    7396:	e7da      	b.n	734e <lfs_dir_find+0x2e>
            (namelen == 2 && memcmp(name, "..", 2) == 0)) {
    7398:	2202      	movs	r2, #2
    739a:	493e      	ldr	r1, [pc, #248]	; (7494 <lfs_dir_find+0x174>)
    739c:	4648      	mov	r0, r9
    739e:	f003 f97b 	bl	a698 <memcmp>
    73a2:	2800      	cmp	r0, #0
    73a4:	d1e4      	bne.n	7370 <lfs_dir_find+0x50>
    73a6:	e7f3      	b.n	7390 <lfs_dir_find+0x70>
                depth += 1;
    73a8:	3701      	adds	r7, #1
            suffix += sufflen;
    73aa:	44a3      	add	fp, r4
            suffix += strspn(suffix, "/");
    73ac:	4c37      	ldr	r4, [pc, #220]	; (748c <lfs_dir_find+0x16c>)
    73ae:	4621      	mov	r1, r4
    73b0:	4658      	mov	r0, fp
    73b2:	f003 f9d0 	bl	a756 <strspn>
    73b6:	4483      	add	fp, r0
            sufflen = strcspn(suffix, "/");
    73b8:	4621      	mov	r1, r4
    73ba:	4658      	mov	r0, fp
    73bc:	f003 f9da 	bl	a774 <strcspn>
            if (sufflen == 0) {
    73c0:	4604      	mov	r4, r0
    73c2:	b170      	cbz	r0, 73e2 <lfs_dir_find+0xc2>
            if (sufflen == 2 && memcmp(suffix, "..", 2) == 0) {
    73c4:	2802      	cmp	r0, #2
    73c6:	d1ef      	bne.n	73a8 <lfs_dir_find+0x88>
    73c8:	2202      	movs	r2, #2
    73ca:	4932      	ldr	r1, [pc, #200]	; (7494 <lfs_dir_find+0x174>)
    73cc:	4658      	mov	r0, fp
    73ce:	f003 f963 	bl	a698 <memcmp>
    73d2:	2800      	cmp	r0, #0
    73d4:	d1e8      	bne.n	73a8 <lfs_dir_find+0x88>
                if (depth == 0) {
    73d6:	3f01      	subs	r7, #1
    73d8:	d1e7      	bne.n	73aa <lfs_dir_find+0x8a>
                    name = suffix + sufflen;
    73da:	eb0b 0304 	add.w	r3, fp, r4
    73de:	9306      	str	r3, [sp, #24]
                    goto nextname;
    73e0:	e7b5      	b.n	734e <lfs_dir_find+0x2e>
        if (name[0] == '\0') {
    73e2:	f899 3000 	ldrb.w	r3, [r9]
    73e6:	2b00      	cmp	r3, #0
    73e8:	d04a      	beq.n	7480 <lfs_dir_find+0x160>
        *path = name;
    73ea:	9b07      	ldr	r3, [sp, #28]
    73ec:	f8c3 9000 	str.w	r9, [r3]
    return (tag & 0x7ff00000) >> 20;
    73f0:	f3c6 530a 	ubfx	r3, r6, #20, #11
        if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {
    73f4:	2b02      	cmp	r3, #2
    73f6:	d13f      	bne.n	7478 <lfs_dir_find+0x158>
    return (tag & 0x000ffc00) >> 10;
    73f8:	f3c6 2689 	ubfx	r6, r6, #10, #10
        if (lfs_tag_id(tag) != 0x3ff) {
    73fc:	f240 33ff 	movw	r3, #1023	; 0x3ff
    7400:	429e      	cmp	r6, r3
    7402:	d102      	bne.n	740a <lfs_dir_find+0xea>
    7404:	464c      	mov	r4, r9
    7406:	4656      	mov	r6, sl
    7408:	e029      	b.n	745e <lfs_dir_find+0x13e>
                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);
    740a:	02b6      	lsls	r6, r6, #10
    740c:	f108 0318 	add.w	r3, r8, #24
            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
    7410:	9300      	str	r3, [sp, #0]
    7412:	f046 5300 	orr.w	r3, r6, #536870912	; 0x20000000
    7416:	f043 0308 	orr.w	r3, r3, #8
    741a:	4a1f      	ldr	r2, [pc, #124]	; (7498 <lfs_dir_find+0x178>)
    741c:	4641      	mov	r1, r8
    741e:	4650      	mov	r0, sl
    7420:	f004 ffa9 	bl	c376 <lfs_dir_get>
            if (res < 0) {
    7424:	1e06      	subs	r6, r0, #0
    7426:	db2b      	blt.n	7480 <lfs_dir_find+0x160>
    7428:	464c      	mov	r4, r9
    742a:	4656      	mov	r6, sl
    742c:	e017      	b.n	745e <lfs_dir_find+0x13e>
            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,
    742e:	9b05      	ldr	r3, [sp, #20]
                    lfs_dir_find_match, &(struct lfs_dir_find_match){
    7430:	9609      	str	r6, [sp, #36]	; 0x24
    7432:	940a      	str	r4, [sp, #40]	; 0x28
    7434:	950b      	str	r5, [sp, #44]	; 0x2c
            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,
    7436:	aa09      	add	r2, sp, #36	; 0x24
    7438:	9203      	str	r2, [sp, #12]
    743a:	4a18      	ldr	r2, [pc, #96]	; (749c <lfs_dir_find+0x17c>)
    743c:	9202      	str	r2, [sp, #8]
    743e:	9301      	str	r3, [sp, #4]
    7440:	9500      	str	r5, [sp, #0]
    7442:	f04f 43f0 	mov.w	r3, #2013265920	; 0x78000000
    7446:	463a      	mov	r2, r7
    7448:	4641      	mov	r1, r8
    744a:	4630      	mov	r0, r6
    744c:	f7fe fb8c 	bl	5b68 <lfs_dir_fetchmatch>
            if (tag < 0) {
    7450:	2800      	cmp	r0, #0
    7452:	db14      	blt.n	747e <lfs_dir_find+0x15e>
            if (tag) {
    7454:	2800      	cmp	r0, #0
    7456:	d191      	bne.n	737c <lfs_dir_find+0x5c>
            if (!dir->split) {
    7458:	f898 3017 	ldrb.w	r3, [r8, #23]
    745c:	b14b      	cbz	r3, 7472 <lfs_dir_find+0x152>
            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,
    745e:	f108 0718 	add.w	r7, r8, #24
                    (strchr(name, '/') == NULL) ? id : NULL,
    7462:	212f      	movs	r1, #47	; 0x2f
    7464:	4620      	mov	r0, r4
    7466:	f003 f8d9 	bl	a61c <strchr>
            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,
    746a:	2800      	cmp	r0, #0
    746c:	d0df      	beq.n	742e <lfs_dir_find+0x10e>
    746e:	2300      	movs	r3, #0
    7470:	e7de      	b.n	7430 <lfs_dir_find+0x110>
                return LFS_ERR_NOENT;
    7472:	f06f 0601 	mvn.w	r6, #1
    7476:	e003      	b.n	7480 <lfs_dir_find+0x160>
            return LFS_ERR_NOTDIR;
    7478:	f06f 0613 	mvn.w	r6, #19
    747c:	e000      	b.n	7480 <lfs_dir_find+0x160>
    747e:	4606      	mov	r6, r0
}
    7480:	4630      	mov	r0, r6
    7482:	b00d      	add	sp, #52	; 0x34
    7484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7488:	002ffc00 	.word	0x002ffc00
    748c:	0000ebc4 	.word	0x0000ebc4
    7490:	0000ebe8 	.word	0x0000ebe8
    7494:	0000ebec 	.word	0x0000ebec
    7498:	700ffc00 	.word	0x700ffc00
    749c:	0000c74b 	.word	0x0000c74b

000074a0 <lfs_rawremove>:
static int lfs_rawremove(lfs_t *lfs, const char *path) {
    74a0:	b570      	push	{r4, r5, r6, lr}
    74a2:	b09a      	sub	sp, #104	; 0x68
    74a4:	4604      	mov	r4, r0
    74a6:	9103      	str	r1, [sp, #12]
    int err = lfs_fs_forceconsistency(lfs);
    74a8:	f005 ff19 	bl	d2de <lfs_fs_forceconsistency>
    if (err) {
    74ac:	4603      	mov	r3, r0
    74ae:	b110      	cbz	r0, 74b6 <lfs_rawremove+0x16>
}
    74b0:	4618      	mov	r0, r3
    74b2:	b01a      	add	sp, #104	; 0x68
    74b4:	bd70      	pop	{r4, r5, r6, pc}
    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
    74b6:	2300      	movs	r3, #0
    74b8:	aa03      	add	r2, sp, #12
    74ba:	a910      	add	r1, sp, #64	; 0x40
    74bc:	4620      	mov	r0, r4
    74be:	f7ff ff2f 	bl	7320 <lfs_dir_find>
    if (tag < 0 || lfs_tag_id(tag) == 0x3ff) {
    74c2:	1e03      	subs	r3, r0, #0
    74c4:	dbf4      	blt.n	74b0 <lfs_rawremove+0x10>
    return (tag & 0x000ffc00) >> 10;
    74c6:	f3c3 2589 	ubfx	r5, r3, #10, #10
    if (tag < 0 || lfs_tag_id(tag) == 0x3ff) {
    74ca:	f240 32ff 	movw	r2, #1023	; 0x3ff
    74ce:	4295      	cmp	r5, r2
    74d0:	d031      	beq.n	7536 <lfs_rawremove+0x96>
    dir.next = lfs->mlist;
    74d2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    74d4:	9206      	str	r2, [sp, #24]
    return (tag & 0x7ff00000) >> 20;
    74d6:	f3c3 560a 	ubfx	r6, r3, #20, #11
    if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {
    74da:	2e02      	cmp	r6, #2
    74dc:	d02e      	beq.n	753c <lfs_rawremove+0x9c>
    err = lfs_dir_commit(lfs, &cwd, LFS_MKATTRS(
    74de:	02ad      	lsls	r5, r5, #10
    74e0:	f045 459f 	orr.w	r5, r5, #1333788672	; 0x4f800000
    74e4:	f445 05e0 	orr.w	r5, r5, #7340032	; 0x700000
    74e8:	9518      	str	r5, [sp, #96]	; 0x60
    74ea:	2300      	movs	r3, #0
    74ec:	9319      	str	r3, [sp, #100]	; 0x64
    74ee:	2301      	movs	r3, #1
    74f0:	aa18      	add	r2, sp, #96	; 0x60
    74f2:	a910      	add	r1, sp, #64	; 0x40
    74f4:	4620      	mov	r0, r4
    74f6:	f005 febb 	bl	d270 <lfs_dir_commit>
    if (err) {
    74fa:	4603      	mov	r3, r0
    74fc:	2800      	cmp	r0, #0
    74fe:	d149      	bne.n	7594 <lfs_rawremove+0xf4>
    lfs->mlist = dir.next;
    7500:	9a06      	ldr	r2, [sp, #24]
    7502:	62a2      	str	r2, [r4, #40]	; 0x28
    if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {
    7504:	2e02      	cmp	r6, #2
    7506:	d1d3      	bne.n	74b0 <lfs_rawremove+0x10>
        err = lfs_fs_preporphans(lfs, -1);
    7508:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    750c:	4620      	mov	r0, r4
    750e:	f004 fe29 	bl	c164 <lfs_fs_preporphans>
        if (err) {
    7512:	4603      	mov	r3, r0
    7514:	2800      	cmp	r0, #0
    7516:	d1cb      	bne.n	74b0 <lfs_rawremove+0x10>
        err = lfs_fs_pred(lfs, dir.m.pair, &cwd);
    7518:	aa10      	add	r2, sp, #64	; 0x40
    751a:	a908      	add	r1, sp, #32
    751c:	4620      	mov	r0, r4
    751e:	f005 fcc9 	bl	ceb4 <lfs_fs_pred>
        if (err) {
    7522:	4603      	mov	r3, r0
    7524:	2800      	cmp	r0, #0
    7526:	d1c3      	bne.n	74b0 <lfs_rawremove+0x10>
        err = lfs_dir_drop(lfs, &cwd, &dir.m);
    7528:	aa08      	add	r2, sp, #32
    752a:	a910      	add	r1, sp, #64	; 0x40
    752c:	4620      	mov	r0, r4
    752e:	f7ff fd4f 	bl	6fd0 <lfs_dir_drop>
    7532:	4603      	mov	r3, r0
        if (err) {
    7534:	e7bc      	b.n	74b0 <lfs_rawremove+0x10>
        return (tag < 0) ? (int)tag : LFS_ERR_INVAL;
    7536:	f06f 0315 	mvn.w	r3, #21
    753a:	e7b9      	b.n	74b0 <lfs_rawremove+0x10>
                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);
    753c:	02ab      	lsls	r3, r5, #10
        lfs_stag_t res = lfs_dir_get(lfs, &cwd, LFS_MKTAG(0x700, 0x3ff, 0),
    753e:	aa04      	add	r2, sp, #16
    7540:	9200      	str	r2, [sp, #0]
    7542:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    7546:	f043 0308 	orr.w	r3, r3, #8
    754a:	4a14      	ldr	r2, [pc, #80]	; (759c <lfs_rawremove+0xfc>)
    754c:	a910      	add	r1, sp, #64	; 0x40
    754e:	4620      	mov	r0, r4
    7550:	f004 ff11 	bl	c376 <lfs_dir_get>
        if (res < 0) {
    7554:	1e03      	subs	r3, r0, #0
    7556:	dbab      	blt.n	74b0 <lfs_rawremove+0x10>
        err = lfs_dir_fetch(lfs, &dir.m, pair);
    7558:	aa04      	add	r2, sp, #16
    755a:	a908      	add	r1, sp, #32
    755c:	4620      	mov	r0, r4
    755e:	f005 f960 	bl	c822 <lfs_dir_fetch>
        if (err) {
    7562:	4603      	mov	r3, r0
    7564:	2800      	cmp	r0, #0
    7566:	d1a3      	bne.n	74b0 <lfs_rawremove+0x10>
        if (dir.m.count > 0 || dir.m.split) {
    7568:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    756a:	f433 037f 	bics.w	r3, r3, #16711680	; 0xff0000
    756e:	d002      	beq.n	7576 <lfs_rawremove+0xd6>
            return LFS_ERR_NOTEMPTY;
    7570:	f06f 0326 	mvn.w	r3, #38	; 0x26
    7574:	e79c      	b.n	74b0 <lfs_rawremove+0x10>
        err = lfs_fs_preporphans(lfs, +1);
    7576:	2101      	movs	r1, #1
    7578:	4620      	mov	r0, r4
    757a:	f004 fdf3 	bl	c164 <lfs_fs_preporphans>
        if (err) {
    757e:	4603      	mov	r3, r0
    7580:	2800      	cmp	r0, #0
    7582:	d195      	bne.n	74b0 <lfs_rawremove+0x10>
        dir.type = 0;
    7584:	2300      	movs	r3, #0
    7586:	f88d 301e 	strb.w	r3, [sp, #30]
        dir.id = 0;
    758a:	f8ad 301c 	strh.w	r3, [sp, #28]
        lfs->mlist = &dir;
    758e:	ab06      	add	r3, sp, #24
    7590:	62a3      	str	r3, [r4, #40]	; 0x28
    7592:	e7a4      	b.n	74de <lfs_rawremove+0x3e>
        lfs->mlist = dir.next;
    7594:	9a06      	ldr	r2, [sp, #24]
    7596:	62a2      	str	r2, [r4, #40]	; 0x28
        return err;
    7598:	e78a      	b.n	74b0 <lfs_rawremove+0x10>
    759a:	bf00      	nop
    759c:	700ffc00 	.word	0x700ffc00

000075a0 <lfs_dir_rawopen>:
static int lfs_dir_rawopen(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
    75a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    75a2:	b087      	sub	sp, #28
    75a4:	4607      	mov	r7, r0
    75a6:	460d      	mov	r5, r1
    75a8:	9203      	str	r2, [sp, #12]
    lfs_stag_t tag = lfs_dir_find(lfs, &dir->m, &path, NULL);
    75aa:	f101 0608 	add.w	r6, r1, #8
    75ae:	2300      	movs	r3, #0
    75b0:	aa03      	add	r2, sp, #12
    75b2:	4631      	mov	r1, r6
    75b4:	f7ff feb4 	bl	7320 <lfs_dir_find>
    if (tag < 0) {
    75b8:	1e04      	subs	r4, r0, #0
    75ba:	db14      	blt.n	75e6 <lfs_dir_rawopen+0x46>
    return (tag & 0x7ff00000) >> 20;
    75bc:	f3c4 530a 	ubfx	r3, r4, #20, #11
    if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {
    75c0:	2b02      	cmp	r3, #2
    75c2:	d130      	bne.n	7626 <lfs_dir_rawopen+0x86>
    return (tag & 0x000ffc00) >> 10;
    75c4:	f3c4 2489 	ubfx	r4, r4, #10, #10
    if (lfs_tag_id(tag) == 0x3ff) {
    75c8:	f240 33ff 	movw	r3, #1023	; 0x3ff
    75cc:	429c      	cmp	r4, r3
    75ce:	d10d      	bne.n	75ec <lfs_dir_rawopen+0x4c>
        pair[0] = lfs->root[0];
    75d0:	6a3b      	ldr	r3, [r7, #32]
    75d2:	9304      	str	r3, [sp, #16]
        pair[1] = lfs->root[1];
    75d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    75d6:	9305      	str	r3, [sp, #20]
    int err = lfs_dir_fetch(lfs, &dir->m, pair);
    75d8:	aa04      	add	r2, sp, #16
    75da:	4631      	mov	r1, r6
    75dc:	4638      	mov	r0, r7
    75de:	f005 f920 	bl	c822 <lfs_dir_fetch>
    if (err) {
    75e2:	4604      	mov	r4, r0
    75e4:	b188      	cbz	r0, 760a <lfs_dir_rawopen+0x6a>
}
    75e6:	4620      	mov	r0, r4
    75e8:	b007      	add	sp, #28
    75ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);
    75ec:	02a4      	lsls	r4, r4, #10
        lfs_stag_t res = lfs_dir_get(lfs, &dir->m, LFS_MKTAG(0x700, 0x3ff, 0),
    75ee:	ab04      	add	r3, sp, #16
    75f0:	9300      	str	r3, [sp, #0]
    75f2:	f044 5300 	orr.w	r3, r4, #536870912	; 0x20000000
    75f6:	f043 0308 	orr.w	r3, r3, #8
    75fa:	4a0c      	ldr	r2, [pc, #48]	; (762c <lfs_dir_rawopen+0x8c>)
    75fc:	4631      	mov	r1, r6
    75fe:	4638      	mov	r0, r7
    7600:	f004 feb9 	bl	c376 <lfs_dir_get>
        if (res < 0) {
    7604:	1e04      	subs	r4, r0, #0
    7606:	dae7      	bge.n	75d8 <lfs_dir_rawopen+0x38>
    7608:	e7ed      	b.n	75e6 <lfs_dir_rawopen+0x46>
    dir->head[0] = dir->m.pair[0];
    760a:	68ab      	ldr	r3, [r5, #8]
    760c:	62eb      	str	r3, [r5, #44]	; 0x2c
    dir->head[1] = dir->m.pair[1];
    760e:	68eb      	ldr	r3, [r5, #12]
    7610:	632b      	str	r3, [r5, #48]	; 0x30
    dir->id = 0;
    7612:	2300      	movs	r3, #0
    7614:	80ab      	strh	r3, [r5, #4]
    dir->pos = 0;
    7616:	62ab      	str	r3, [r5, #40]	; 0x28
    dir->type = LFS_TYPE_DIR;
    7618:	2302      	movs	r3, #2
    761a:	71ab      	strb	r3, [r5, #6]
    lfs_mlist_append(lfs, (struct lfs_mlist *)dir);
    761c:	4629      	mov	r1, r5
    761e:	4638      	mov	r0, r7
    7620:	f004 fd42 	bl	c0a8 <lfs_mlist_append>
    return 0;
    7624:	e7df      	b.n	75e6 <lfs_dir_rawopen+0x46>
        return LFS_ERR_NOTDIR;
    7626:	f06f 0413 	mvn.w	r4, #19
    762a:	e7dc      	b.n	75e6 <lfs_dir_rawopen+0x46>
    762c:	700ffc00 	.word	0x700ffc00

00007630 <lfs_rawrename>:
static int lfs_rawrename(lfs_t *lfs, const char *oldpath, const char *newpath) {
    7630:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7634:	b0ad      	sub	sp, #180	; 0xb4
    7636:	4604      	mov	r4, r0
    7638:	9103      	str	r1, [sp, #12]
    763a:	9202      	str	r2, [sp, #8]
    int err = lfs_fs_forceconsistency(lfs);
    763c:	f005 fe4f 	bl	d2de <lfs_fs_forceconsistency>
    if (err) {
    7640:	4606      	mov	r6, r0
    7642:	b118      	cbz	r0, 764c <lfs_rawrename+0x1c>
}
    7644:	4630      	mov	r0, r6
    7646:	b02d      	add	sp, #180	; 0xb4
    7648:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);
    764c:	2300      	movs	r3, #0
    764e:	aa03      	add	r2, sp, #12
    7650:	a922      	add	r1, sp, #136	; 0x88
    7652:	4620      	mov	r0, r4
    7654:	f7ff fe64 	bl	7320 <lfs_dir_find>
    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {
    7658:	2800      	cmp	r0, #0
    765a:	f2c0 809b 	blt.w	7794 <lfs_rawrename+0x164>
    765e:	4680      	mov	r8, r0
    return (tag & 0x000ffc00) >> 10;
    7660:	f3c0 2589 	ubfx	r5, r0, #10, #10
    if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {
    7664:	f240 33ff 	movw	r3, #1023	; 0x3ff
    7668:	429d      	cmp	r5, r3
    766a:	f000 8091 	beq.w	7790 <lfs_rawrename+0x160>
    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);
    766e:	f10d 0366 	add.w	r3, sp, #102	; 0x66
    7672:	aa02      	add	r2, sp, #8
    7674:	a91a      	add	r1, sp, #104	; 0x68
    7676:	4620      	mov	r0, r4
    7678:	f7ff fe52 	bl	7320 <lfs_dir_find>
    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&
    767c:	1e07      	subs	r7, r0, #0
    767e:	f2c0 808b 	blt.w	7798 <lfs_rawrename+0x168>
    return (tag & 0x000ffc00) >> 10;
    7682:	f3c7 2289 	ubfx	r2, r7, #10, #10
    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&
    7686:	f240 33ff 	movw	r3, #1023	; 0x3ff
    768a:	429a      	cmp	r2, r3
    768c:	f000 8084 	beq.w	7798 <lfs_rawrename+0x168>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    7690:	9b22      	ldr	r3, [sp, #136]	; 0x88
    7692:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    7694:	429a      	cmp	r2, r3
    7696:	d008      	beq.n	76aa <lfs_rawrename+0x7a>
    7698:	9823      	ldr	r0, [sp, #140]	; 0x8c
    769a:	991b      	ldr	r1, [sp, #108]	; 0x6c
    769c:	4281      	cmp	r1, r0
    769e:	d004      	beq.n	76aa <lfs_rawrename+0x7a>
    76a0:	4299      	cmp	r1, r3
    76a2:	d002      	beq.n	76aa <lfs_rawrename+0x7a>
    76a4:	4290      	cmp	r0, r2
    76a6:	d000      	beq.n	76aa <lfs_rawrename+0x7a>
    76a8:	2601      	movs	r6, #1
    prevdir.next = lfs->mlist;
    76aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    76ac:	930f      	str	r3, [sp, #60]	; 0x3c
    if (prevtag == LFS_ERR_NOENT) {
    76ae:	f117 0f02 	cmn.w	r7, #2
    76b2:	f000 8082 	beq.w	77ba <lfs_rawrename+0x18a>
    return (tag & 0x7ff00000) >> 20;
    76b6:	f3c7 520a 	ubfx	r2, r7, #20, #11
    76ba:	ea4f 5318 	mov.w	r3, r8, lsr #20
    } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {
    76be:	ea83 5317 	eor.w	r3, r3, r7, lsr #20
    76c2:	f3c3 030a 	ubfx	r3, r3, #0, #11
    76c6:	2b00      	cmp	r3, #0
    76c8:	f040 80fa 	bne.w	78c0 <lfs_rawrename+0x290>
    } else if (samepair && newid == newoldid) {
    76cc:	b91e      	cbnz	r6, 76d6 <lfs_rawrename+0xa6>
    76ce:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
    76d2:	42ab      	cmp	r3, r5
    76d4:	d0b6      	beq.n	7644 <lfs_rawrename+0x14>
    } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
    76d6:	2a02      	cmp	r2, #2
    76d8:	d07e      	beq.n	77d8 <lfs_rawrename+0x1a8>
    uint16_t newoldid = lfs_tag_id(oldtag);
    76da:	46a9      	mov	r9, r5
    if (!samepair) {
    76dc:	b126      	cbz	r6, 76e8 <lfs_rawrename+0xb8>
        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);
    76de:	aa22      	add	r2, sp, #136	; 0x88
    76e0:	4649      	mov	r1, r9
    76e2:	4620      	mov	r0, r4
    76e4:	f7fd ff52 	bl	558c <lfs_fs_prepmove>
    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(
    76e8:	f117 0f02 	cmn.w	r7, #2
    76ec:	f000 80a9 	beq.w	7842 <lfs_rawrename+0x212>
    76f0:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
    76f4:	029b      	lsls	r3, r3, #10
    76f6:	f043 439f 	orr.w	r3, r3, #1333788672	; 0x4f800000
    76fa:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
    76fe:	9305      	str	r3, [sp, #20]
    7700:	2100      	movs	r1, #0
    7702:	9106      	str	r1, [sp, #24]
    7704:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
    7708:	029b      	lsls	r3, r3, #10
    770a:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    770e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    7712:	9207      	str	r2, [sp, #28]
    7714:	9108      	str	r1, [sp, #32]
    return (tag & 0x7ff00000) >> 20;
    7716:	f3c8 580a 	ubfx	r8, r8, #20, #11
    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(
    771a:	ea43 5808 	orr.w	r8, r3, r8, lsl #20
    771e:	9802      	ldr	r0, [sp, #8]
    7720:	f002 ff89 	bl	a636 <strlen>
    7724:	ea48 0000 	orr.w	r0, r8, r0
    7728:	9009      	str	r0, [sp, #36]	; 0x24
    772a:	9b02      	ldr	r3, [sp, #8]
    772c:	930a      	str	r3, [sp, #40]	; 0x28
    772e:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
    7732:	ea45 2383 	orr.w	r3, r5, r3, lsl #10
    7736:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    773a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    773e:	930b      	str	r3, [sp, #44]	; 0x2c
    7740:	ab22      	add	r3, sp, #136	; 0x88
    7742:	930c      	str	r3, [sp, #48]	; 0x30
    7744:	2e00      	cmp	r6, #0
    7746:	d17e      	bne.n	7846 <lfs_rawrename+0x216>
    7748:	ea4f 2989 	mov.w	r9, r9, lsl #10
    774c:	f049 439f 	orr.w	r3, r9, #1333788672	; 0x4f800000
    7750:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
    7754:	930d      	str	r3, [sp, #52]	; 0x34
    7756:	2300      	movs	r3, #0
    7758:	930e      	str	r3, [sp, #56]	; 0x38
    775a:	2305      	movs	r3, #5
    775c:	aa05      	add	r2, sp, #20
    775e:	a91a      	add	r1, sp, #104	; 0x68
    7760:	4620      	mov	r0, r4
    7762:	f005 fd85 	bl	d270 <lfs_dir_commit>
    if (err) {
    7766:	4680      	mov	r8, r0
    7768:	2800      	cmp	r0, #0
    776a:	d16e      	bne.n	784a <lfs_rawrename+0x21a>
    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {
    776c:	b126      	cbz	r6, 7778 <lfs_rawrename+0x148>
    return lfs_tag_type1(a->tag);
    776e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    return (tag & 0x70000000) >> 20;
    7770:	0d1b      	lsrs	r3, r3, #20
    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {
    7772:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    7776:	d16c      	bne.n	7852 <lfs_rawrename+0x222>
    lfs->mlist = prevdir.next;
    7778:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    777a:	62a3      	str	r3, [r4, #40]	; 0x28
    if (prevtag != LFS_ERR_NOENT
    777c:	f117 0f02 	cmn.w	r7, #2
    7780:	f000 80a1 	beq.w	78c6 <lfs_rawrename+0x296>
    return (tag & 0x7ff00000) >> 20;
    7784:	f3c7 500a 	ubfx	r0, r7, #20, #11
            && lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
    7788:	2802      	cmp	r0, #2
    778a:	d07d      	beq.n	7888 <lfs_rawrename+0x258>
    return 0;
    778c:	4646      	mov	r6, r8
    778e:	e759      	b.n	7644 <lfs_rawrename+0x14>
        return (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;
    7790:	f06f 0015 	mvn.w	r0, #21
    7794:	4606      	mov	r6, r0
    7796:	e755      	b.n	7644 <lfs_rawrename+0x14>
    if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&
    7798:	f117 0f02 	cmn.w	r7, #2
    779c:	d106      	bne.n	77ac <lfs_rawrename+0x17c>
            !(prevtag == LFS_ERR_NOENT && newid != 0x3ff)) {
    779e:	f8bd 2066 	ldrh.w	r2, [sp, #102]	; 0x66
    77a2:	f240 33ff 	movw	r3, #1023	; 0x3ff
    77a6:	429a      	cmp	r2, r3
    77a8:	f47f af72 	bne.w	7690 <lfs_rawrename+0x60>
        return (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;
    77ac:	2f00      	cmp	r7, #0
    77ae:	db02      	blt.n	77b6 <lfs_rawrename+0x186>
    77b0:	f06f 0615 	mvn.w	r6, #21
    77b4:	e746      	b.n	7644 <lfs_rawrename+0x14>
    77b6:	463e      	mov	r6, r7
    77b8:	e744      	b.n	7644 <lfs_rawrename+0x14>
        lfs_size_t nlen = strlen(newpath);
    77ba:	9802      	ldr	r0, [sp, #8]
    77bc:	f002 ff3b 	bl	a636 <strlen>
        if (nlen > lfs->name_max) {
    77c0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    77c2:	4283      	cmp	r3, r0
    77c4:	d379      	bcc.n	78ba <lfs_rawrename+0x28a>
        if (samepair && newid <= newoldid) {
    77c6:	2e00      	cmp	r6, #0
    77c8:	d139      	bne.n	783e <lfs_rawrename+0x20e>
    77ca:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
    77ce:	42ab      	cmp	r3, r5
    77d0:	d833      	bhi.n	783a <lfs_rawrename+0x20a>
            newoldid += 1;
    77d2:	f105 0901 	add.w	r9, r5, #1
    77d6:	e781      	b.n	76dc <lfs_rawrename+0xac>
                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);
    77d8:	f8bd 3066 	ldrh.w	r3, [sp, #102]	; 0x66
    77dc:	029b      	lsls	r3, r3, #10
        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),
    77de:	aa05      	add	r2, sp, #20
    77e0:	9200      	str	r2, [sp, #0]
    77e2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    77e6:	f043 0308 	orr.w	r3, r3, #8
    77ea:	4a38      	ldr	r2, [pc, #224]	; (78cc <lfs_rawrename+0x29c>)
    77ec:	a91a      	add	r1, sp, #104	; 0x68
    77ee:	4620      	mov	r0, r4
    77f0:	f004 fdc1 	bl	c376 <lfs_dir_get>
        if (res < 0) {
    77f4:	2800      	cmp	r0, #0
    77f6:	db1a      	blt.n	782e <lfs_rawrename+0x1fe>
        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);
    77f8:	aa05      	add	r2, sp, #20
    77fa:	a911      	add	r1, sp, #68	; 0x44
    77fc:	4620      	mov	r0, r4
    77fe:	f005 f810 	bl	c822 <lfs_dir_fetch>
        if (err) {
    7802:	b9b0      	cbnz	r0, 7832 <lfs_rawrename+0x202>
        if (prevdir.m.count > 0 || prevdir.m.split) {
    7804:	9b16      	ldr	r3, [sp, #88]	; 0x58
    7806:	f433 037f 	bics.w	r3, r3, #16711680	; 0xff0000
    780a:	d002      	beq.n	7812 <lfs_rawrename+0x1e2>
            return LFS_ERR_NOTEMPTY;
    780c:	f06f 0626 	mvn.w	r6, #38	; 0x26
    7810:	e718      	b.n	7644 <lfs_rawrename+0x14>
        err = lfs_fs_preporphans(lfs, +1);
    7812:	2101      	movs	r1, #1
    7814:	4620      	mov	r0, r4
    7816:	f004 fca5 	bl	c164 <lfs_fs_preporphans>
        if (err) {
    781a:	b960      	cbnz	r0, 7836 <lfs_rawrename+0x206>
        prevdir.type = 0;
    781c:	2300      	movs	r3, #0
    781e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
        prevdir.id = 0;
    7822:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
        lfs->mlist = &prevdir;
    7826:	ab0f      	add	r3, sp, #60	; 0x3c
    7828:	62a3      	str	r3, [r4, #40]	; 0x28
    uint16_t newoldid = lfs_tag_id(oldtag);
    782a:	46a9      	mov	r9, r5
    782c:	e756      	b.n	76dc <lfs_rawrename+0xac>
            return (int)res;
    782e:	4606      	mov	r6, r0
    7830:	e708      	b.n	7644 <lfs_rawrename+0x14>
            return err;
    7832:	4606      	mov	r6, r0
    7834:	e706      	b.n	7644 <lfs_rawrename+0x14>
            return err;
    7836:	4606      	mov	r6, r0
    7838:	e704      	b.n	7644 <lfs_rawrename+0x14>
    uint16_t newoldid = lfs_tag_id(oldtag);
    783a:	46a9      	mov	r9, r5
    783c:	e74e      	b.n	76dc <lfs_rawrename+0xac>
    783e:	46a9      	mov	r9, r5
    7840:	e74d      	b.n	76de <lfs_rawrename+0xae>
    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(
    7842:	2300      	movs	r3, #0
    7844:	e75b      	b.n	76fe <lfs_rawrename+0xce>
    7846:	2300      	movs	r3, #0
    7848:	e784      	b.n	7754 <lfs_rawrename+0x124>
        lfs->mlist = prevdir.next;
    784a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    784c:	62a3      	str	r3, [r4, #40]	; 0x28
        return err;
    784e:	4606      	mov	r6, r0
    7850:	e6f8      	b.n	7644 <lfs_rawrename+0x14>
        lfs_fs_prepmove(lfs, 0x3ff, NULL);
    7852:	2200      	movs	r2, #0
    7854:	f240 31ff 	movw	r1, #1023	; 0x3ff
    7858:	4620      	mov	r0, r4
    785a:	f7fd fe97 	bl	558c <lfs_fs_prepmove>
        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(
    785e:	02ab      	lsls	r3, r5, #10
    7860:	f043 439f 	orr.w	r3, r3, #1333788672	; 0x4f800000
    7864:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
    7868:	932a      	str	r3, [sp, #168]	; 0xa8
    786a:	2300      	movs	r3, #0
    786c:	932b      	str	r3, [sp, #172]	; 0xac
    786e:	2301      	movs	r3, #1
    7870:	aa2a      	add	r2, sp, #168	; 0xa8
    7872:	a922      	add	r1, sp, #136	; 0x88
    7874:	4620      	mov	r0, r4
    7876:	f005 fcfb 	bl	d270 <lfs_dir_commit>
        if (err) {
    787a:	4606      	mov	r6, r0
    787c:	2800      	cmp	r0, #0
    787e:	f43f af7b 	beq.w	7778 <lfs_rawrename+0x148>
            lfs->mlist = prevdir.next;
    7882:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7884:	62a3      	str	r3, [r4, #40]	; 0x28
            return err;
    7886:	e6dd      	b.n	7644 <lfs_rawrename+0x14>
        err = lfs_fs_preporphans(lfs, -1);
    7888:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    788c:	4620      	mov	r0, r4
    788e:	f004 fc69 	bl	c164 <lfs_fs_preporphans>
        if (err) {
    7892:	4606      	mov	r6, r0
    7894:	2800      	cmp	r0, #0
    7896:	f47f aed5 	bne.w	7644 <lfs_rawrename+0x14>
        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);
    789a:	aa1a      	add	r2, sp, #104	; 0x68
    789c:	a911      	add	r1, sp, #68	; 0x44
    789e:	4620      	mov	r0, r4
    78a0:	f005 fb08 	bl	ceb4 <lfs_fs_pred>
        if (err) {
    78a4:	4606      	mov	r6, r0
    78a6:	2800      	cmp	r0, #0
    78a8:	f47f aecc 	bne.w	7644 <lfs_rawrename+0x14>
        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);
    78ac:	aa11      	add	r2, sp, #68	; 0x44
    78ae:	a91a      	add	r1, sp, #104	; 0x68
    78b0:	4620      	mov	r0, r4
    78b2:	f7ff fb8d 	bl	6fd0 <lfs_dir_drop>
    78b6:	4606      	mov	r6, r0
        if (err) {
    78b8:	e6c4      	b.n	7644 <lfs_rawrename+0x14>
            return LFS_ERR_NAMETOOLONG;
    78ba:	f06f 0623 	mvn.w	r6, #35	; 0x23
    78be:	e6c1      	b.n	7644 <lfs_rawrename+0x14>
        return LFS_ERR_ISDIR;
    78c0:	f06f 0614 	mvn.w	r6, #20
    78c4:	e6be      	b.n	7644 <lfs_rawrename+0x14>
    return 0;
    78c6:	4646      	mov	r6, r8
    78c8:	e6bc      	b.n	7644 <lfs_rawrename+0x14>
    78ca:	bf00      	nop
    78cc:	700ffc00 	.word	0x700ffc00

000078d0 <lfs_file_rawopencfg>:
        const struct lfs_file_config *cfg) {
    78d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    78d4:	b08b      	sub	sp, #44	; 0x2c
    78d6:	4607      	mov	r7, r0
    78d8:	460c      	mov	r4, r1
    78da:	9203      	str	r2, [sp, #12]
    78dc:	461e      	mov	r6, r3
    if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {
    78de:	f013 0f02 	tst.w	r3, #2
    78e2:	d005      	beq.n	78f0 <lfs_file_rawopencfg+0x20>
        int err = lfs_fs_forceconsistency(lfs);
    78e4:	f005 fcfb 	bl	d2de <lfs_fs_forceconsistency>
        if (err) {
    78e8:	4605      	mov	r5, r0
    78ea:	2800      	cmp	r0, #0
    78ec:	f040 8109 	bne.w	7b02 <lfs_file_rawopencfg+0x232>
    file->cfg = cfg;
    78f0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    78f2:	6523      	str	r3, [r4, #80]	; 0x50
    file->flags = flags;
    78f4:	6326      	str	r6, [r4, #48]	; 0x30
    file->pos = 0;
    78f6:	2300      	movs	r3, #0
    78f8:	6363      	str	r3, [r4, #52]	; 0x34
    file->off = 0;
    78fa:	63e3      	str	r3, [r4, #60]	; 0x3c
    file->cache.buffer = NULL;
    78fc:	64e3      	str	r3, [r4, #76]	; 0x4c
    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);
    78fe:	f104 0808 	add.w	r8, r4, #8
    7902:	1d23      	adds	r3, r4, #4
    7904:	aa03      	add	r2, sp, #12
    7906:	4641      	mov	r1, r8
    7908:	4638      	mov	r0, r7
    790a:	f7ff fd09 	bl	7320 <lfs_dir_find>
    if (tag < 0 && !(tag == LFS_ERR_NOENT && file->id != 0x3ff)) {
    790e:	1e05      	subs	r5, r0, #0
    7910:	da09      	bge.n	7926 <lfs_file_rawopencfg+0x56>
    7912:	f115 0f02 	cmn.w	r5, #2
    7916:	f040 80ec 	bne.w	7af2 <lfs_file_rawopencfg+0x222>
    791a:	88a2      	ldrh	r2, [r4, #4]
    791c:	f240 33ff 	movw	r3, #1023	; 0x3ff
    7920:	429a      	cmp	r2, r3
    7922:	f000 80e6 	beq.w	7af2 <lfs_file_rawopencfg+0x222>
    file->type = LFS_TYPE_REG;
    7926:	2301      	movs	r3, #1
    7928:	71a3      	strb	r3, [r4, #6]
    lfs_mlist_append(lfs, (struct lfs_mlist *)file);
    792a:	4621      	mov	r1, r4
    792c:	4638      	mov	r0, r7
    792e:	f004 fbbb 	bl	c0a8 <lfs_mlist_append>
    if (tag == LFS_ERR_NOENT) {
    7932:	f115 0f02 	cmn.w	r5, #2
    7936:	d019      	beq.n	796c <lfs_file_rawopencfg+0x9c>
    } else if (flags & LFS_O_EXCL) {
    7938:	f416 7f00 	tst.w	r6, #512	; 0x200
    793c:	f040 80d7 	bne.w	7aee <lfs_file_rawopencfg+0x21e>
    return (tag & 0x7ff00000) >> 20;
    7940:	f3c5 550a 	ubfx	r5, r5, #20, #11
    } else if (lfs_tag_type3(tag) != LFS_TYPE_REG) {
    7944:	2d01      	cmp	r5, #1
    7946:	f040 80e0 	bne.w	7b0a <lfs_file_rawopencfg+0x23a>
    } else if (flags & LFS_O_TRUNC) {
    794a:	f416 6f80 	tst.w	r6, #1024	; 0x400
    794e:	d042      	beq.n	79d6 <lfs_file_rawopencfg+0x106>
        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0);
    7950:	f8b4 9004 	ldrh.w	r9, [r4, #4]
    7954:	ea4f 2989 	mov.w	r9, r9, lsl #10
    7958:	f049 5900 	orr.w	r9, r9, #536870912	; 0x20000000
    795c:	f449 1980 	orr.w	r9, r9, #1048576	; 0x100000
        file->flags |= LFS_F_DIRTY;
    7960:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7962:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    7966:	6323      	str	r3, [r4, #48]	; 0x30
    for (unsigned i = 0; i < file->cfg->attr_count; i++) {
    7968:	2600      	movs	r6, #0
    796a:	e064      	b.n	7a36 <lfs_file_rawopencfg+0x166>
        if (!(flags & LFS_O_CREAT)) {
    796c:	f416 7f80 	tst.w	r6, #256	; 0x100
    7970:	f000 80bf 	beq.w	7af2 <lfs_file_rawopencfg+0x222>
        lfs_size_t nlen = strlen(path);
    7974:	9803      	ldr	r0, [sp, #12]
    7976:	f002 fe5e 	bl	a636 <strlen>
        if (nlen > lfs->name_max) {
    797a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    797c:	4283      	cmp	r3, r0
    797e:	d202      	bcs.n	7986 <lfs_file_rawopencfg+0xb6>
            err = LFS_ERR_NAMETOOLONG;
    7980:	f06f 0523 	mvn.w	r5, #35	; 0x23
    7984:	e0b5      	b.n	7af2 <lfs_file_rawopencfg+0x222>
        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
    7986:	88a3      	ldrh	r3, [r4, #4]
    7988:	029b      	lsls	r3, r3, #10
    798a:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    798e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    7992:	9204      	str	r2, [sp, #16]
    7994:	2200      	movs	r2, #0
    7996:	9205      	str	r2, [sp, #20]
    7998:	4318      	orrs	r0, r3
    799a:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
    799e:	9006      	str	r0, [sp, #24]
    79a0:	9903      	ldr	r1, [sp, #12]
    79a2:	9107      	str	r1, [sp, #28]
    79a4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    79a8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    79ac:	9308      	str	r3, [sp, #32]
    79ae:	9209      	str	r2, [sp, #36]	; 0x24
    79b0:	2303      	movs	r3, #3
    79b2:	aa04      	add	r2, sp, #16
    79b4:	4641      	mov	r1, r8
    79b6:	4638      	mov	r0, r7
    79b8:	f005 fc5a 	bl	d270 <lfs_dir_commit>
    79bc:	4605      	mov	r5, r0
        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;
    79be:	f110 0f1c 	cmn.w	r0, #28
    79c2:	d005      	beq.n	79d0 <lfs_file_rawopencfg+0x100>
        if (err) {
    79c4:	2800      	cmp	r0, #0
    79c6:	f040 8094 	bne.w	7af2 <lfs_file_rawopencfg+0x222>
        tag = LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, 0);
    79ca:	f8df 914c 	ldr.w	r9, [pc, #332]	; 7b18 <lfs_file_rawopencfg+0x248>
    79ce:	e7cb      	b.n	7968 <lfs_file_rawopencfg+0x98>
        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;
    79d0:	f06f 0523 	mvn.w	r5, #35	; 0x23
            goto cleanup;
    79d4:	e08d      	b.n	7af2 <lfs_file_rawopencfg+0x222>
                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);
    79d6:	88a3      	ldrh	r3, [r4, #4]
    79d8:	029b      	lsls	r3, r3, #10
    79da:	f104 0228 	add.w	r2, r4, #40	; 0x28
        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),
    79de:	9200      	str	r2, [sp, #0]
    79e0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    79e4:	f043 0308 	orr.w	r3, r3, #8
    79e8:	4a4c      	ldr	r2, [pc, #304]	; (7b1c <lfs_file_rawopencfg+0x24c>)
    79ea:	4641      	mov	r1, r8
    79ec:	4638      	mov	r0, r7
    79ee:	f004 fcc2 	bl	c376 <lfs_dir_get>
        if (tag < 0) {
    79f2:	f1b0 0900 	subs.w	r9, r0, #0
    79f6:	dab7      	bge.n	7968 <lfs_file_rawopencfg+0x98>
            err = tag;
    79f8:	464d      	mov	r5, r9
    79fa:	e07a      	b.n	7af2 <lfs_file_rawopencfg+0x222>
                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,
    79fc:	685b      	ldr	r3, [r3, #4]
    79fe:	eb06 0246 	add.w	r2, r6, r6, lsl #1
    7a02:	eb03 0182 	add.w	r1, r3, r2, lsl #2
    7a06:	f813 2022 	ldrb.w	r2, [r3, r2, lsl #2]
    7a0a:	f502 7240 	add.w	r2, r2, #768	; 0x300
    7a0e:	88a3      	ldrh	r3, [r4, #4]
    7a10:	029b      	lsls	r3, r3, #10
    7a12:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    7a16:	688a      	ldr	r2, [r1, #8]
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
    7a18:	6849      	ldr	r1, [r1, #4]
    7a1a:	9100      	str	r1, [sp, #0]
    7a1c:	4313      	orrs	r3, r2
    7a1e:	4a40      	ldr	r2, [pc, #256]	; (7b20 <lfs_file_rawopencfg+0x250>)
    7a20:	4641      	mov	r1, r8
    7a22:	4638      	mov	r0, r7
    7a24:	f004 fca7 	bl	c376 <lfs_dir_get>
            if (res < 0 && res != LFS_ERR_NOENT) {
    7a28:	1e05      	subs	r5, r0, #0
    7a2a:	da0c      	bge.n	7a46 <lfs_file_rawopencfg+0x176>
    7a2c:	f115 0f02 	cmn.w	r5, #2
    7a30:	d009      	beq.n	7a46 <lfs_file_rawopencfg+0x176>
    7a32:	e05e      	b.n	7af2 <lfs_file_rawopencfg+0x222>
    for (unsigned i = 0; i < file->cfg->attr_count; i++) {
    7a34:	3601      	adds	r6, #1
    7a36:	6d23      	ldr	r3, [r4, #80]	; 0x50
    7a38:	689a      	ldr	r2, [r3, #8]
    7a3a:	42b2      	cmp	r2, r6
    7a3c:	d915      	bls.n	7a6a <lfs_file_rawopencfg+0x19a>
        if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {
    7a3e:	6b22      	ldr	r2, [r4, #48]	; 0x30
    7a40:	f012 0f01 	tst.w	r2, #1
    7a44:	d1da      	bne.n	79fc <lfs_file_rawopencfg+0x12c>
        if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {
    7a46:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7a48:	f013 0f02 	tst.w	r3, #2
    7a4c:	d0f2      	beq.n	7a34 <lfs_file_rawopencfg+0x164>
            if (file->cfg->attrs[i].size > lfs->attr_max) {
    7a4e:	6d22      	ldr	r2, [r4, #80]	; 0x50
    7a50:	6852      	ldr	r2, [r2, #4]
    7a52:	eb06 0146 	add.w	r1, r6, r6, lsl #1
    7a56:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    7a5a:	6891      	ldr	r1, [r2, #8]
    7a5c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
    7a5e:	4291      	cmp	r1, r2
    7a60:	d856      	bhi.n	7b10 <lfs_file_rawopencfg+0x240>
            file->flags |= LFS_F_DIRTY;
    7a62:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    7a66:	6323      	str	r3, [r4, #48]	; 0x30
    7a68:	e7e4      	b.n	7a34 <lfs_file_rawopencfg+0x164>
    if (file->cfg->buffer) {
    7a6a:	681b      	ldr	r3, [r3, #0]
    7a6c:	b16b      	cbz	r3, 7a8a <lfs_file_rawopencfg+0x1ba>
        file->cache.buffer = file->cfg->buffer;
    7a6e:	64e3      	str	r3, [r4, #76]	; 0x4c
    lfs_cache_zero(lfs, &file->cache);
    7a70:	f104 0140 	add.w	r1, r4, #64	; 0x40
    7a74:	4638      	mov	r0, r7
    7a76:	f004 fb89 	bl	c18c <lfs_cache_zero>
    return (tag & 0x7ff00000) >> 20;
    7a7a:	f3c9 520a 	ubfx	r2, r9, #20, #11
    if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {
    7a7e:	f240 2301 	movw	r3, #513	; 0x201
    7a82:	429a      	cmp	r2, r3
    7a84:	d00b      	beq.n	7a9e <lfs_file_rawopencfg+0x1ce>
    return 0;
    7a86:	2500      	movs	r5, #0
    7a88:	e03b      	b.n	7b02 <lfs_file_rawopencfg+0x232>
        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);
    7a8a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
/* Allocate memory, only used if buffers are not provided to littlefs */
/* Note, memory must be 64-bit aligned */
static inline void *lfs_malloc(size_t size)
{
#ifndef LFS_NO_MALLOC
	return malloc(size);
    7a8c:	6a98      	ldr	r0, [r3, #40]	; 0x28
    7a8e:	f7fa fc43 	bl	2318 <malloc>
    7a92:	64e0      	str	r0, [r4, #76]	; 0x4c
        if (!file->cache.buffer) {
    7a94:	2800      	cmp	r0, #0
    7a96:	d1eb      	bne.n	7a70 <lfs_file_rawopencfg+0x1a0>
            err = LFS_ERR_NOMEM;
    7a98:	f06f 050b 	mvn.w	r5, #11
    7a9c:	e029      	b.n	7af2 <lfs_file_rawopencfg+0x222>
        file->ctz.head = LFS_BLOCK_INLINE;
    7a9e:	f06f 0101 	mvn.w	r1, #1
    7aa2:	62a1      	str	r1, [r4, #40]	; 0x28
    return tag & 0x000003ff;
    7aa4:	f3c9 0209 	ubfx	r2, r9, #0, #10
        file->ctz.size = lfs_tag_size(tag);
    7aa8:	62e2      	str	r2, [r4, #44]	; 0x2c
        file->flags |= LFS_F_INLINE;
    7aaa:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7aac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    7ab0:	6323      	str	r3, [r4, #48]	; 0x30
        file->cache.block = file->ctz.head;
    7ab2:	6421      	str	r1, [r4, #64]	; 0x40
        file->cache.off = 0;
    7ab4:	2300      	movs	r3, #0
    7ab6:	6463      	str	r3, [r4, #68]	; 0x44
        file->cache.size = lfs->cfg->cache_size;
    7ab8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    7aba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7abc:	64a3      	str	r3, [r4, #72]	; 0x48
        if (file->ctz.size > 0) {
    7abe:	b90a      	cbnz	r2, 7ac4 <lfs_file_rawopencfg+0x1f4>
    return 0;
    7ac0:	2500      	movs	r5, #0
    7ac2:	e01e      	b.n	7b02 <lfs_file_rawopencfg+0x232>
                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,
    7ac4:	88a1      	ldrh	r1, [r4, #4]
	return (a < b) ? a : b;
    7ac6:	f240 32fe 	movw	r2, #1022	; 0x3fe
    7aca:	4293      	cmp	r3, r2
    7acc:	bf28      	it	cs
    7ace:	4613      	movcs	r3, r2
    7ad0:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
                    file->cache.buffer);
    7ad4:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
    7ad6:	9200      	str	r2, [sp, #0]
    7ad8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    7adc:	4a0f      	ldr	r2, [pc, #60]	; (7b1c <lfs_file_rawopencfg+0x24c>)
    7ade:	4641      	mov	r1, r8
    7ae0:	4638      	mov	r0, r7
    7ae2:	f004 fc48 	bl	c376 <lfs_dir_get>
            if (res < 0) {
    7ae6:	1e05      	subs	r5, r0, #0
    7ae8:	db03      	blt.n	7af2 <lfs_file_rawopencfg+0x222>
    return 0;
    7aea:	2500      	movs	r5, #0
    7aec:	e009      	b.n	7b02 <lfs_file_rawopencfg+0x232>
        err = LFS_ERR_EXIST;
    7aee:	f06f 0510 	mvn.w	r5, #16
    file->flags |= LFS_F_ERRED;
    7af2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7af4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    7af8:	6323      	str	r3, [r4, #48]	; 0x30
    lfs_file_rawclose(lfs, file);
    7afa:	4621      	mov	r1, r4
    7afc:	4638      	mov	r0, r7
    7afe:	f005 fcc9 	bl	d494 <lfs_file_rawclose>
}
    7b02:	4628      	mov	r0, r5
    7b04:	b00b      	add	sp, #44	; 0x2c
    7b06:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        err = LFS_ERR_ISDIR;
    7b0a:	f06f 0514 	mvn.w	r5, #20
    7b0e:	e7f0      	b.n	7af2 <lfs_file_rawopencfg+0x222>
                err = LFS_ERR_NOSPC;
    7b10:	f06f 051b 	mvn.w	r5, #27
    7b14:	e7ed      	b.n	7af2 <lfs_file_rawopencfg+0x222>
    7b16:	bf00      	nop
    7b18:	20100000 	.word	0x20100000
    7b1c:	700ffc00 	.word	0x700ffc00
    7b20:	7ffffc00 	.word	0x7ffffc00

00007b24 <lfs_rawmkdir>:
static int lfs_rawmkdir(lfs_t *lfs, const char *path) {
    7b24:	b530      	push	{r4, r5, lr}
    7b26:	b0ab      	sub	sp, #172	; 0xac
    7b28:	4604      	mov	r4, r0
    7b2a:	9101      	str	r1, [sp, #4]
    int err = lfs_fs_forceconsistency(lfs);
    7b2c:	f005 fbd7 	bl	d2de <lfs_fs_forceconsistency>
    if (err) {
    7b30:	4603      	mov	r3, r0
    7b32:	b110      	cbz	r0, 7b3a <lfs_rawmkdir+0x16>
}
    7b34:	4618      	mov	r0, r3
    7b36:	b02b      	add	sp, #172	; 0xac
    7b38:	bd30      	pop	{r4, r5, pc}
    cwd.next = lfs->mlist;
    7b3a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7b3c:	931c      	str	r3, [sp, #112]	; 0x70
    err = lfs_dir_find(lfs, &cwd.m, &path, &id);
    7b3e:	f10d 036e 	add.w	r3, sp, #110	; 0x6e
    7b42:	aa01      	add	r2, sp, #4
    7b44:	a91e      	add	r1, sp, #120	; 0x78
    7b46:	4620      	mov	r0, r4
    7b48:	f7ff fbea 	bl	7320 <lfs_dir_find>
    7b4c:	4603      	mov	r3, r0
    if (!(err == LFS_ERR_NOENT && id != 0x3ff)) {
    7b4e:	f110 0f02 	cmn.w	r0, #2
    7b52:	d12f      	bne.n	7bb4 <lfs_rawmkdir+0x90>
    7b54:	f8bd 106e 	ldrh.w	r1, [sp, #110]	; 0x6e
    7b58:	f240 32ff 	movw	r2, #1023	; 0x3ff
    7b5c:	4291      	cmp	r1, r2
    7b5e:	d029      	beq.n	7bb4 <lfs_rawmkdir+0x90>
    lfs_size_t nlen = strlen(path);
    7b60:	9801      	ldr	r0, [sp, #4]
    7b62:	f002 fd68 	bl	a636 <strlen>
    7b66:	4605      	mov	r5, r0
    if (nlen > lfs->name_max) {
    7b68:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    7b6a:	4283      	cmp	r3, r0
    7b6c:	f0c0 8089 	bcc.w	7c82 <lfs_rawmkdir+0x15e>
    lfs_alloc_ack(lfs);
    7b70:	4620      	mov	r0, r4
    7b72:	f004 fab7 	bl	c0e4 <lfs_alloc_ack>
    err = lfs_dir_alloc(lfs, &dir);
    7b76:	a913      	add	r1, sp, #76	; 0x4c
    7b78:	4620      	mov	r0, r4
    7b7a:	f004 fe60 	bl	c83e <lfs_dir_alloc>
    if (err) {
    7b7e:	4603      	mov	r3, r0
    7b80:	2800      	cmp	r0, #0
    7b82:	d1d7      	bne.n	7b34 <lfs_rawmkdir+0x10>
    lfs_mdir_t pred = cwd.m;
    7b84:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
    7b88:	f10d 0e78 	add.w	lr, sp, #120	; 0x78
    7b8c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    7b90:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    7b94:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
    7b98:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    while (pred.split) {
    7b9c:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    7ba0:	b16b      	cbz	r3, 7bbe <lfs_rawmkdir+0x9a>
        err = lfs_dir_fetch(lfs, &pred, pred.tail);
    7ba2:	aa11      	add	r2, sp, #68	; 0x44
    7ba4:	a90b      	add	r1, sp, #44	; 0x2c
    7ba6:	4620      	mov	r0, r4
    7ba8:	f004 fe3b 	bl	c822 <lfs_dir_fetch>
        if (err) {
    7bac:	4603      	mov	r3, r0
    7bae:	2800      	cmp	r0, #0
    7bb0:	d0f4      	beq.n	7b9c <lfs_rawmkdir+0x78>
    7bb2:	e7bf      	b.n	7b34 <lfs_rawmkdir+0x10>
        return (err < 0) ? err : LFS_ERR_EXIST;
    7bb4:	2b00      	cmp	r3, #0
    7bb6:	dbbd      	blt.n	7b34 <lfs_rawmkdir+0x10>
    7bb8:	f06f 0310 	mvn.w	r3, #16
    7bbc:	e7ba      	b.n	7b34 <lfs_rawmkdir+0x10>
    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(
    7bbe:	4b32      	ldr	r3, [pc, #200]	; (7c88 <lfs_rawmkdir+0x164>)
    7bc0:	9326      	str	r3, [sp, #152]	; 0x98
    7bc2:	ab11      	add	r3, sp, #68	; 0x44
    7bc4:	9327      	str	r3, [sp, #156]	; 0x9c
    7bc6:	2301      	movs	r3, #1
    7bc8:	aa26      	add	r2, sp, #152	; 0x98
    7bca:	a913      	add	r1, sp, #76	; 0x4c
    7bcc:	4620      	mov	r0, r4
    7bce:	f005 fb4f 	bl	d270 <lfs_dir_commit>
    if (err) {
    7bd2:	4603      	mov	r3, r0
    7bd4:	2800      	cmp	r0, #0
    7bd6:	d1ad      	bne.n	7b34 <lfs_rawmkdir+0x10>
    if (cwd.m.split) {
    7bd8:	f89d 308f 	ldrb.w	r3, [sp, #143]	; 0x8f
    7bdc:	bb33      	cbnz	r3, 7c2c <lfs_rawmkdir+0x108>
    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(
    7bde:	f8bd 306e 	ldrh.w	r3, [sp, #110]	; 0x6e
    7be2:	029b      	lsls	r3, r3, #10
    7be4:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    7be8:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    7bec:	9203      	str	r2, [sp, #12]
    7bee:	2200      	movs	r2, #0
    7bf0:	9204      	str	r2, [sp, #16]
    7bf2:	431d      	orrs	r5, r3
    7bf4:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
    7bf8:	9505      	str	r5, [sp, #20]
    7bfa:	9a01      	ldr	r2, [sp, #4]
    7bfc:	9206      	str	r2, [sp, #24]
    7bfe:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    7c02:	f043 0308 	orr.w	r3, r3, #8
    7c06:	9307      	str	r3, [sp, #28]
    7c08:	ab13      	add	r3, sp, #76	; 0x4c
    7c0a:	9308      	str	r3, [sp, #32]
    7c0c:	f89d 308f 	ldrb.w	r3, [sp, #143]	; 0x8f
    7c10:	2b00      	cmp	r3, #0
    7c12:	d134      	bne.n	7c7e <lfs_rawmkdir+0x15a>
    7c14:	4b1c      	ldr	r3, [pc, #112]	; (7c88 <lfs_rawmkdir+0x164>)
    7c16:	9309      	str	r3, [sp, #36]	; 0x24
    7c18:	ab13      	add	r3, sp, #76	; 0x4c
    7c1a:	930a      	str	r3, [sp, #40]	; 0x28
    7c1c:	2304      	movs	r3, #4
    7c1e:	aa03      	add	r2, sp, #12
    7c20:	a91e      	add	r1, sp, #120	; 0x78
    7c22:	4620      	mov	r0, r4
    7c24:	f005 fb24 	bl	d270 <lfs_dir_commit>
    7c28:	4603      	mov	r3, r0
    if (err) {
    7c2a:	e783      	b.n	7b34 <lfs_rawmkdir+0x10>
        err = lfs_fs_preporphans(lfs, +1);
    7c2c:	2101      	movs	r1, #1
    7c2e:	4620      	mov	r0, r4
    7c30:	f004 fa98 	bl	c164 <lfs_fs_preporphans>
        if (err) {
    7c34:	4603      	mov	r3, r0
    7c36:	2800      	cmp	r0, #0
    7c38:	f47f af7c 	bne.w	7b34 <lfs_rawmkdir+0x10>
        cwd.type = 0;
    7c3c:	2300      	movs	r3, #0
    7c3e:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
        cwd.id = 0;
    7c42:	f8ad 3074 	strh.w	r3, [sp, #116]	; 0x74
        lfs->mlist = &cwd;
    7c46:	ab1c      	add	r3, sp, #112	; 0x70
    7c48:	62a3      	str	r3, [r4, #40]	; 0x28
        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(
    7c4a:	4b0f      	ldr	r3, [pc, #60]	; (7c88 <lfs_rawmkdir+0x164>)
    7c4c:	9328      	str	r3, [sp, #160]	; 0xa0
    7c4e:	ab13      	add	r3, sp, #76	; 0x4c
    7c50:	9329      	str	r3, [sp, #164]	; 0xa4
    7c52:	2301      	movs	r3, #1
    7c54:	aa28      	add	r2, sp, #160	; 0xa0
    7c56:	a90b      	add	r1, sp, #44	; 0x2c
    7c58:	4620      	mov	r0, r4
    7c5a:	f005 fb09 	bl	d270 <lfs_dir_commit>
        if (err) {
    7c5e:	4603      	mov	r3, r0
    7c60:	b110      	cbz	r0, 7c68 <lfs_rawmkdir+0x144>
            lfs->mlist = cwd.next;
    7c62:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    7c64:	62a2      	str	r2, [r4, #40]	; 0x28
            return err;
    7c66:	e765      	b.n	7b34 <lfs_rawmkdir+0x10>
        lfs->mlist = cwd.next;
    7c68:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    7c6a:	62a3      	str	r3, [r4, #40]	; 0x28
        err = lfs_fs_preporphans(lfs, -1);
    7c6c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    7c70:	4620      	mov	r0, r4
    7c72:	f004 fa77 	bl	c164 <lfs_fs_preporphans>
        if (err) {
    7c76:	4603      	mov	r3, r0
    7c78:	2800      	cmp	r0, #0
    7c7a:	d0b0      	beq.n	7bde <lfs_rawmkdir+0xba>
    7c7c:	e75a      	b.n	7b34 <lfs_rawmkdir+0x10>
    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(
    7c7e:	2300      	movs	r3, #0
    7c80:	e7c9      	b.n	7c16 <lfs_rawmkdir+0xf2>
        return LFS_ERR_NAMETOOLONG;
    7c82:	f06f 0323 	mvn.w	r3, #35	; 0x23
    7c86:	e755      	b.n	7b34 <lfs_rawmkdir+0x10>
    7c88:	600ffc08 	.word	0x600ffc08

00007c8c <lfs_dir_getinfo>:
        uint16_t id, struct lfs_info *info) {
    7c8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    7c8e:	b085      	sub	sp, #20
    7c90:	461d      	mov	r5, r3
    if (id == 0x3ff) {
    7c92:	f240 33ff 	movw	r3, #1023	; 0x3ff
    7c96:	429a      	cmp	r2, r3
    7c98:	d02b      	beq.n	7cf2 <lfs_dir_getinfo+0x66>
    7c9a:	4604      	mov	r4, r0
    7c9c:	460e      	mov	r6, r1
            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);
    7c9e:	0297      	lsls	r7, r2, #10
    7ca0:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    7ca2:	3301      	adds	r3, #1
    7ca4:	f105 0108 	add.w	r1, r5, #8
    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),
    7ca8:	9100      	str	r1, [sp, #0]
    7caa:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
    7cae:	4a1a      	ldr	r2, [pc, #104]	; (7d18 <lfs_dir_getinfo+0x8c>)
    7cb0:	4631      	mov	r1, r6
    7cb2:	f004 fb60 	bl	c376 <lfs_dir_get>
    if (tag < 0) {
    7cb6:	2800      	cmp	r0, #0
    7cb8:	db23      	blt.n	7d02 <lfs_dir_getinfo+0x76>
    return (tag & 0x7ff00000) >> 20;
    7cba:	f3c0 520a 	ubfx	r2, r0, #20, #11
    info->type = lfs_tag_type3(tag);
    7cbe:	702a      	strb	r2, [r5, #0]
    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
    7cc0:	ab02      	add	r3, sp, #8
    7cc2:	9300      	str	r3, [sp, #0]
    7cc4:	f047 5300 	orr.w	r3, r7, #536870912	; 0x20000000
    7cc8:	f043 0308 	orr.w	r3, r3, #8
    7ccc:	4a13      	ldr	r2, [pc, #76]	; (7d1c <lfs_dir_getinfo+0x90>)
    7cce:	4631      	mov	r1, r6
    7cd0:	4620      	mov	r0, r4
    7cd2:	f004 fb50 	bl	c376 <lfs_dir_get>
    if (tag < 0) {
    7cd6:	2800      	cmp	r0, #0
    7cd8:	db13      	blt.n	7d02 <lfs_dir_getinfo+0x76>
    return (tag & 0x7ff00000) >> 20;
    7cda:	f3c0 530a 	ubfx	r3, r0, #20, #11
    if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {
    7cde:	f240 2202 	movw	r2, #514	; 0x202
    7ce2:	4293      	cmp	r3, r2
    7ce4:	d00f      	beq.n	7d06 <lfs_dir_getinfo+0x7a>
    } else if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {
    7ce6:	f240 2201 	movw	r2, #513	; 0x201
    7cea:	4293      	cmp	r3, r2
    7cec:	d00f      	beq.n	7d0e <lfs_dir_getinfo+0x82>
    return 0;
    7cee:	2000      	movs	r0, #0
    7cf0:	e007      	b.n	7d02 <lfs_dir_getinfo+0x76>
        strcpy(info->name, "/");
    7cf2:	490b      	ldr	r1, [pc, #44]	; (7d20 <lfs_dir_getinfo+0x94>)
    7cf4:	f105 0008 	add.w	r0, r5, #8
    7cf8:	f002 fc6c 	bl	a5d4 <strcpy>
        info->type = LFS_TYPE_DIR;
    7cfc:	2302      	movs	r3, #2
    7cfe:	702b      	strb	r3, [r5, #0]
        return 0;
    7d00:	2000      	movs	r0, #0
}
    7d02:	b005      	add	sp, #20
    7d04:	bdf0      	pop	{r4, r5, r6, r7, pc}
        info->size = ctz.size;
    7d06:	9b03      	ldr	r3, [sp, #12]
    7d08:	606b      	str	r3, [r5, #4]
    return 0;
    7d0a:	2000      	movs	r0, #0
    7d0c:	e7f9      	b.n	7d02 <lfs_dir_getinfo+0x76>
    return tag & 0x000003ff;
    7d0e:	f3c0 0009 	ubfx	r0, r0, #0, #10
        info->size = lfs_tag_size(tag);
    7d12:	6068      	str	r0, [r5, #4]
    return 0;
    7d14:	2000      	movs	r0, #0
    7d16:	e7f4      	b.n	7d02 <lfs_dir_getinfo+0x76>
    7d18:	780ffc00 	.word	0x780ffc00
    7d1c:	700ffc00 	.word	0x700ffc00
    7d20:	0000ebc4 	.word	0x0000ebc4

00007d24 <lfs_dir_rawread>:
static int lfs_dir_rawread(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
    7d24:	b570      	push	{r4, r5, r6, lr}
    7d26:	4605      	mov	r5, r0
    7d28:	460c      	mov	r4, r1
    7d2a:	4616      	mov	r6, r2
    memset(info, 0, sizeof(*info));
    7d2c:	f44f 7284 	mov.w	r2, #264	; 0x108
    7d30:	2100      	movs	r1, #0
    7d32:	4630      	mov	r0, r6
    7d34:	f002 fcf1 	bl	a71a <memset>
    if (dir->pos == 0) {
    7d38:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7d3a:	b173      	cbz	r3, 7d5a <lfs_dir_rawread+0x36>
    } else if (dir->pos == 1) {
    7d3c:	2b01      	cmp	r3, #1
    7d3e:	d11f      	bne.n	7d80 <lfs_dir_rawread+0x5c>
        info->type = LFS_TYPE_DIR;
    7d40:	4630      	mov	r0, r6
    7d42:	2302      	movs	r3, #2
    7d44:	f800 3b08 	strb.w	r3, [r0], #8
        strcpy(info->name, "..");
    7d48:	4922      	ldr	r1, [pc, #136]	; (7dd4 <lfs_dir_rawread+0xb0>)
    7d4a:	f002 fc43 	bl	a5d4 <strcpy>
        dir->pos += 1;
    7d4e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7d50:	3301      	adds	r3, #1
    7d52:	62a3      	str	r3, [r4, #40]	; 0x28
        return true;
    7d54:	f04f 0c01 	mov.w	ip, #1
    7d58:	e036      	b.n	7dc8 <lfs_dir_rawread+0xa4>
        info->type = LFS_TYPE_DIR;
    7d5a:	4630      	mov	r0, r6
    7d5c:	2302      	movs	r3, #2
    7d5e:	f800 3b08 	strb.w	r3, [r0], #8
        strcpy(info->name, ".");
    7d62:	491d      	ldr	r1, [pc, #116]	; (7dd8 <lfs_dir_rawread+0xb4>)
    7d64:	f002 fc36 	bl	a5d4 <strcpy>
        dir->pos += 1;
    7d68:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7d6a:	3301      	adds	r3, #1
    7d6c:	62a3      	str	r3, [r4, #40]	; 0x28
        return true;
    7d6e:	f04f 0c01 	mov.w	ip, #1
    7d72:	e029      	b.n	7dc8 <lfs_dir_rawread+0xa4>
        dir->id += 1;
    7d74:	88a1      	ldrh	r1, [r4, #4]
    7d76:	3101      	adds	r1, #1
    7d78:	80a1      	strh	r1, [r4, #4]
        if (err != LFS_ERR_NOENT) {
    7d7a:	f11c 0f02 	cmn.w	ip, #2
    7d7e:	d11e      	bne.n	7dbe <lfs_dir_rawread+0x9a>
        if (dir->id == dir->m.count) {
    7d80:	88a3      	ldrh	r3, [r4, #4]
    7d82:	8ba1      	ldrh	r1, [r4, #28]
    7d84:	428b      	cmp	r3, r1
    7d86:	d10c      	bne.n	7da2 <lfs_dir_rawread+0x7e>
            if (!dir->m.split) {
    7d88:	7fe3      	ldrb	r3, [r4, #31]
    7d8a:	b1fb      	cbz	r3, 7dcc <lfs_dir_rawread+0xa8>
            int err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);
    7d8c:	f104 0220 	add.w	r2, r4, #32
    7d90:	f104 0108 	add.w	r1, r4, #8
    7d94:	4628      	mov	r0, r5
    7d96:	f004 fd44 	bl	c822 <lfs_dir_fetch>
            if (err) {
    7d9a:	4684      	mov	ip, r0
    7d9c:	b9a0      	cbnz	r0, 7dc8 <lfs_dir_rawread+0xa4>
            dir->id = 0;
    7d9e:	2300      	movs	r3, #0
    7da0:	80a3      	strh	r3, [r4, #4]
        int err = lfs_dir_getinfo(lfs, &dir->m, dir->id, info);
    7da2:	4633      	mov	r3, r6
    7da4:	88a2      	ldrh	r2, [r4, #4]
    7da6:	f104 0108 	add.w	r1, r4, #8
    7daa:	4628      	mov	r0, r5
    7dac:	f7ff ff6e 	bl	7c8c <lfs_dir_getinfo>
        if (err && err != LFS_ERR_NOENT) {
    7db0:	4684      	mov	ip, r0
    7db2:	2800      	cmp	r0, #0
    7db4:	d0de      	beq.n	7d74 <lfs_dir_rawread+0x50>
    7db6:	f110 0f02 	cmn.w	r0, #2
    7dba:	d0db      	beq.n	7d74 <lfs_dir_rawread+0x50>
    7dbc:	e004      	b.n	7dc8 <lfs_dir_rawread+0xa4>
    dir->pos += 1;
    7dbe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    7dc0:	3301      	adds	r3, #1
    7dc2:	62a3      	str	r3, [r4, #40]	; 0x28
    return true;
    7dc4:	f04f 0c01 	mov.w	ip, #1
}
    7dc8:	4660      	mov	r0, ip
    7dca:	bd70      	pop	{r4, r5, r6, pc}
                return false;
    7dcc:	f04f 0c00 	mov.w	ip, #0
    7dd0:	e7fa      	b.n	7dc8 <lfs_dir_rawread+0xa4>
    7dd2:	bf00      	nop
    7dd4:	0000ebec 	.word	0x0000ebec
    7dd8:	0000ebe8 	.word	0x0000ebe8

00007ddc <lfs_crc>:
		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c,
	};

	const uint8_t *data = buffer;

	for (size_t i = 0; i < size; i++) {
    7ddc:	f04f 0c00 	mov.w	ip, #0
    7de0:	4594      	cmp	ip, r2
    7de2:	d218      	bcs.n	7e16 <lfs_crc+0x3a>
{
    7de4:	b530      	push	{r4, r5, lr}
		crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 0)) & 0xf];
    7de6:	f811 300c 	ldrb.w	r3, [r1, ip]
    7dea:	ea83 0e00 	eor.w	lr, r3, r0
    7dee:	f00e 0e0f 	and.w	lr, lr, #15
    7df2:	4c09      	ldr	r4, [pc, #36]	; (7e18 <lfs_crc+0x3c>)
    7df4:	f854 502e 	ldr.w	r5, [r4, lr, lsl #2]
    7df8:	ea85 1010 	eor.w	r0, r5, r0, lsr #4
		crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 4)) & 0xf];
    7dfc:	ea80 1313 	eor.w	r3, r0, r3, lsr #4
    7e00:	f003 030f 	and.w	r3, r3, #15
    7e04:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    7e08:	ea83 1010 	eor.w	r0, r3, r0, lsr #4
	for (size_t i = 0; i < size; i++) {
    7e0c:	f10c 0c01 	add.w	ip, ip, #1
    7e10:	4594      	cmp	ip, r2
    7e12:	d3e8      	bcc.n	7de6 <lfs_crc+0xa>
	}

	return crc;
}
    7e14:	bd30      	pop	{r4, r5, pc}
    7e16:	4770      	bx	lr
    7e18:	0000f6d8 	.word	0x0000f6d8

00007e1c <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
    7e1c:	b510      	push	{r4, lr}
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    7e1e:	4c14      	ldr	r4, [pc, #80]	; (7e70 <_DoInit+0x54>)
    7e20:	2303      	movs	r3, #3
    7e22:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    7e24:	6163      	str	r3, [r4, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    7e26:	4a13      	ldr	r2, [pc, #76]	; (7e74 <_DoInit+0x58>)
    7e28:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    7e2a:	4b13      	ldr	r3, [pc, #76]	; (7e78 <_DoInit+0x5c>)
    7e2c:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    7e2e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    7e32:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
    7e34:	2300      	movs	r3, #0
    7e36:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    7e38:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    7e3a:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    7e3c:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    7e3e:	4a0f      	ldr	r2, [pc, #60]	; (7e7c <_DoInit+0x60>)
    7e40:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    7e42:	2210      	movs	r2, #16
    7e44:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    7e46:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    7e48:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    7e4a:	6763      	str	r3, [r4, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
    7e4c:	490c      	ldr	r1, [pc, #48]	; (7e80 <_DoInit+0x64>)
    7e4e:	1de0      	adds	r0, r4, #7
    7e50:	f002 fbc0 	bl	a5d4 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
    7e54:	f3bf 8f5f 	dmb	sy
  STRCPY((char*)&p->acID[0], "SEGGER");
    7e58:	490a      	ldr	r1, [pc, #40]	; (7e84 <_DoInit+0x68>)
    7e5a:	4620      	mov	r0, r4
    7e5c:	f002 fbba 	bl	a5d4 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
    7e60:	f3bf 8f5f 	dmb	sy
  p->acID[6] = ' ';
    7e64:	2320      	movs	r3, #32
    7e66:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
    7e68:	f3bf 8f5f 	dmb	sy
}
    7e6c:	bd10      	pop	{r4, pc}
    7e6e:	bf00      	nop
    7e70:	20001338 	.word	0x20001338
    7e74:	0000f718 	.word	0x0000f718
    7e78:	20000f38 	.word	0x20000f38
    7e7c:	20000f28 	.word	0x20000f28
    7e80:	0000f724 	.word	0x0000f724
    7e84:	0000f728 	.word	0x0000f728

00007e88 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    7e88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7e8a:	460f      	mov	r7, r1
    7e8c:	4616      	mov	r6, r2
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
    7e8e:	1c45      	adds	r5, r0, #1
    7e90:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    7e94:	4b16      	ldr	r3, [pc, #88]	; (7ef0 <SEGGER_RTT_WriteNoLock+0x68>)
    7e96:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
    7e9a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    7e9e:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    7ea2:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    7ea4:	2c01      	cmp	r4, #1
    7ea6:	d011      	beq.n	7ecc <SEGGER_RTT_WriteNoLock+0x44>
    7ea8:	2c02      	cmp	r4, #2
    7eaa:	d01c      	beq.n	7ee6 <SEGGER_RTT_WriteNoLock+0x5e>
    7eac:	b114      	cbz	r4, 7eb4 <SEGGER_RTT_WriteNoLock+0x2c>
    7eae:	2400      	movs	r4, #0
  }
  //
  // Finish up.
  //
  return Status;
}
    7eb0:	4620      	mov	r0, r4
    7eb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Avail = _GetAvailWriteSpace(pRing);
    7eb4:	4628      	mov	r0, r5
    7eb6:	f005 fb68 	bl	d58a <_GetAvailWriteSpace>
    if (Avail < NumBytes) {
    7eba:	4286      	cmp	r6, r0
    7ebc:	d8f8      	bhi.n	7eb0 <SEGGER_RTT_WriteNoLock+0x28>
      _WriteNoCheck(pRing, pData, NumBytes);
    7ebe:	4632      	mov	r2, r6
    7ec0:	4639      	mov	r1, r7
    7ec2:	4628      	mov	r0, r5
    7ec4:	f005 fb6d 	bl	d5a2 <_WriteNoCheck>
      Status = NumBytes;
    7ec8:	4634      	mov	r4, r6
    7eca:	e7f1      	b.n	7eb0 <SEGGER_RTT_WriteNoLock+0x28>
    Avail = _GetAvailWriteSpace(pRing);
    7ecc:	4628      	mov	r0, r5
    7ece:	f005 fb5c 	bl	d58a <_GetAvailWriteSpace>
    Status = Avail < NumBytes ? Avail : NumBytes;
    7ed2:	4634      	mov	r4, r6
    7ed4:	4286      	cmp	r6, r0
    7ed6:	bf28      	it	cs
    7ed8:	4604      	movcs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
    7eda:	4622      	mov	r2, r4
    7edc:	4639      	mov	r1, r7
    7ede:	4628      	mov	r0, r5
    7ee0:	f005 fb5f 	bl	d5a2 <_WriteNoCheck>
    break;
    7ee4:	e7e4      	b.n	7eb0 <SEGGER_RTT_WriteNoLock+0x28>
    Status = _WriteBlocking(pRing, pData, NumBytes);
    7ee6:	4628      	mov	r0, r5
    7ee8:	f005 fb81 	bl	d5ee <_WriteBlocking>
    7eec:	4604      	mov	r4, r0
    break;
    7eee:	e7df      	b.n	7eb0 <SEGGER_RTT_WriteNoLock+0x28>
    7ef0:	20001338 	.word	0x20001338

00007ef4 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	const struct device *dev = __device_start;
    7ef4:	4b03      	ldr	r3, [pc, #12]	; (7f04 <z_device_state_init+0x10>)

	while (dev < __device_end) {
    7ef6:	e000      	b.n	7efa <z_device_state_init+0x6>
		z_object_init(dev);
		++dev;
    7ef8:	3318      	adds	r3, #24
	while (dev < __device_end) {
    7efa:	4a03      	ldr	r2, [pc, #12]	; (7f08 <z_device_state_init+0x14>)
    7efc:	4293      	cmp	r3, r2
    7efe:	d3fb      	bcc.n	7ef8 <z_device_state_init+0x4>
	}
}
    7f00:	4770      	bx	lr
    7f02:	bf00      	nop
    7f04:	0000dd24 	.word	0x0000dd24
    7f08:	0000ddb4 	.word	0x0000ddb4

00007f0c <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
    7f0c:	4b01      	ldr	r3, [pc, #4]	; (7f14 <z_impl_z_errno+0x8>)
    7f0e:	6898      	ldr	r0, [r3, #8]
}
    7f10:	3060      	adds	r0, #96	; 0x60
    7f12:	4770      	bx	lr
    7f14:	200013e0 	.word	0x200013e0

00007f18 <reason_to_str>:
	return thread_name;
}

static const char *reason_to_str(unsigned int reason)
{
	switch (reason) {
    7f18:	2804      	cmp	r0, #4
    7f1a:	d80c      	bhi.n	7f36 <reason_to_str+0x1e>
    7f1c:	e8df f000 	tbb	[pc, r0]
    7f20:	07050d03 	.word	0x07050d03
    7f24:	09          	.byte	0x09
    7f25:	00          	.byte	0x00
    7f26:	4806      	ldr	r0, [pc, #24]	; (7f40 <reason_to_str+0x28>)
    7f28:	4770      	bx	lr
	case K_ERR_CPU_EXCEPTION:
		return "CPU exception";
	case K_ERR_SPURIOUS_IRQ:
		return "Unhandled interrupt";
	case K_ERR_STACK_CHK_FAIL:
		return "Stack overflow";
    7f2a:	4806      	ldr	r0, [pc, #24]	; (7f44 <reason_to_str+0x2c>)
    7f2c:	4770      	bx	lr
	case K_ERR_KERNEL_OOPS:
		return "Kernel oops";
    7f2e:	4806      	ldr	r0, [pc, #24]	; (7f48 <reason_to_str+0x30>)
    7f30:	4770      	bx	lr
	case K_ERR_KERNEL_PANIC:
		return "Kernel panic";
    7f32:	4806      	ldr	r0, [pc, #24]	; (7f4c <reason_to_str+0x34>)
    7f34:	4770      	bx	lr
	default:
		return "Unknown error";
    7f36:	4806      	ldr	r0, [pc, #24]	; (7f50 <reason_to_str+0x38>)
    7f38:	4770      	bx	lr
		return "Unhandled interrupt";
    7f3a:	4806      	ldr	r0, [pc, #24]	; (7f54 <reason_to_str+0x3c>)
	}
}
    7f3c:	4770      	bx	lr
    7f3e:	bf00      	nop
    7f40:	0000f734 	.word	0x0000f734
    7f44:	0000f758 	.word	0x0000f758
    7f48:	0000f768 	.word	0x0000f768
    7f4c:	0000f774 	.word	0x0000f774
    7f50:	0000f784 	.word	0x0000f784
    7f54:	0000f744 	.word	0x0000f744

00007f58 <thread_name_get>:
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    7f58:	b130      	cbz	r0, 7f68 <thread_name_get+0x10>
{
    7f5a:	b508      	push	{r3, lr}
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    7f5c:	f005 fc8a 	bl	d874 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
    7f60:	b120      	cbz	r0, 7f6c <thread_name_get+0x14>
    7f62:	7803      	ldrb	r3, [r0, #0]
    7f64:	b123      	cbz	r3, 7f70 <thread_name_get+0x18>
}
    7f66:	bd08      	pop	{r3, pc}
		thread_name = "unknown";
    7f68:	4802      	ldr	r0, [pc, #8]	; (7f74 <thread_name_get+0x1c>)
}
    7f6a:	4770      	bx	lr
		thread_name = "unknown";
    7f6c:	4801      	ldr	r0, [pc, #4]	; (7f74 <thread_name_get+0x1c>)
    7f6e:	e7fa      	b.n	7f66 <thread_name_get+0xe>
    7f70:	4800      	ldr	r0, [pc, #0]	; (7f74 <thread_name_get+0x1c>)
	return thread_name;
    7f72:	e7f8      	b.n	7f66 <thread_name_get+0xe>
    7f74:	0000f794 	.word	0x0000f794

00007f78 <k_sys_fatal_error_handler>:
{
    7f78:	b510      	push	{r4, lr}
    7f7a:	4604      	mov	r4, r0
	LOG_ERR("Halting system");
    7f7c:	2145      	movs	r1, #69	; 0x45
    7f7e:	4803      	ldr	r0, [pc, #12]	; (7f8c <k_sys_fatal_error_handler+0x14>)
    7f80:	f002 f9dc 	bl	a33c <z_log_minimal_printk>
	arch_system_halt(reason);
    7f84:	4620      	mov	r0, r4
    7f86:	f005 fb7c 	bl	d682 <arch_system_halt>
    7f8a:	bf00      	nop
    7f8c:	0000f79c 	.word	0x0000f79c

00007f90 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    7f90:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f92:	b083      	sub	sp, #12
    7f94:	4605      	mov	r5, r0
    7f96:	460e      	mov	r6, r1
	__asm__ volatile(
    7f98:	f04f 0320 	mov.w	r3, #32
    7f9c:	f3ef 8711 	mrs	r7, BASEPRI
    7fa0:	f383 8812 	msr	BASEPRI_MAX, r3
    7fa4:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
    7fa8:	f000 fef8 	bl	8d9c <z_impl_z_current_get>
    7fac:	4604      	mov	r4, r0
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    7fae:	4628      	mov	r0, r5
    7fb0:	f7ff ffb2 	bl	7f18 <reason_to_str>
    7fb4:	4603      	mov	r3, r0
    7fb6:	2200      	movs	r2, #0
    7fb8:	9200      	str	r2, [sp, #0]
    7fba:	462a      	mov	r2, r5
    7fbc:	2145      	movs	r1, #69	; 0x45
    7fbe:	4811      	ldr	r0, [pc, #68]	; (8004 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x4>)
    7fc0:	f002 f9bc 	bl	a33c <z_log_minimal_printk>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    7fc4:	b11e      	cbz	r6, 7fce <z_fatal_error+0x3e>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    7fc6:	69f3      	ldr	r3, [r6, #28]
    7fc8:	f3c3 0308 	ubfx	r3, r3, #0, #9
    7fcc:	b9ab      	cbnz	r3, 7ffa <z_fatal_error+0x6a>
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    7fce:	4620      	mov	r0, r4
    7fd0:	f7ff ffc2 	bl	7f58 <thread_name_get>
    7fd4:	4603      	mov	r3, r0
    7fd6:	4622      	mov	r2, r4
    7fd8:	2145      	movs	r1, #69	; 0x45
    7fda:	480b      	ldr	r0, [pc, #44]	; (8008 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x8>)
    7fdc:	f002 f9ae 	bl	a33c <z_log_minimal_printk>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
    7fe0:	4631      	mov	r1, r6
    7fe2:	4628      	mov	r0, r5
    7fe4:	f7ff ffc8 	bl	7f78 <k_sys_fatal_error_handler>
	__asm__ volatile(
    7fe8:	f387 8811 	msr	BASEPRI, r7
    7fec:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    7ff0:	4620      	mov	r0, r4
    7ff2:	f7f9 ffcd 	bl	1f90 <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    7ff6:	b003      	add	sp, #12
    7ff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("Fault during interrupt handling\n");
    7ffa:	2145      	movs	r1, #69	; 0x45
    7ffc:	4803      	ldr	r0, [pc, #12]	; (800c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xc>)
    7ffe:	f002 f99d 	bl	a33c <z_log_minimal_printk>
    8002:	e7e4      	b.n	7fce <z_fatal_error+0x3e>
    8004:	0000f7b0 	.word	0x0000f7b0
    8008:	0000f808 	.word	0x0000f808
    800c:	0000f7e0 	.word	0x0000f7e0

00008010 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
    8010:	b570      	push	{r4, r5, r6, lr}
    8012:	4606      	mov	r6, r0
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    8014:	4b12      	ldr	r3, [pc, #72]	; (8060 <z_sys_init_run_level+0x50>)
    8016:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    801a:	e009      	b.n	8030 <z_sys_init_run_level+0x20>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
				if (rc < 0) {
					rc = -rc;
    801c:	4243      	negs	r3, r0
    801e:	e017      	b.n	8050 <z_sys_init_run_level+0x40>
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    8020:	68ea      	ldr	r2, [r5, #12]
    8022:	7013      	strb	r3, [r2, #0]
			}
			dev->state->initialized = true;
    8024:	68ea      	ldr	r2, [r5, #12]
    8026:	7853      	ldrb	r3, [r2, #1]
    8028:	f043 0301 	orr.w	r3, r3, #1
    802c:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    802e:	3408      	adds	r4, #8
    8030:	1c73      	adds	r3, r6, #1
    8032:	4a0b      	ldr	r2, [pc, #44]	; (8060 <z_sys_init_run_level+0x50>)
    8034:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8038:	42a3      	cmp	r3, r4
    803a:	d910      	bls.n	805e <z_sys_init_run_level+0x4e>
		const struct device *dev = entry->dev;
    803c:	6865      	ldr	r5, [r4, #4]
		if (dev != NULL) {
    803e:	b15d      	cbz	r5, 8058 <z_sys_init_run_level+0x48>
			int rc = entry->init_fn.dev(dev);
    8040:	6823      	ldr	r3, [r4, #0]
    8042:	4628      	mov	r0, r5
    8044:	4798      	blx	r3
			if (rc != 0) {
    8046:	4603      	mov	r3, r0
    8048:	2800      	cmp	r0, #0
    804a:	d0eb      	beq.n	8024 <z_sys_init_run_level+0x14>
				if (rc < 0) {
    804c:	2800      	cmp	r0, #0
    804e:	dbe5      	blt.n	801c <z_sys_init_run_level+0xc>
				if (rc > UINT8_MAX) {
    8050:	2bff      	cmp	r3, #255	; 0xff
    8052:	dde5      	ble.n	8020 <z_sys_init_run_level+0x10>
					rc = UINT8_MAX;
    8054:	23ff      	movs	r3, #255	; 0xff
    8056:	e7e3      	b.n	8020 <z_sys_init_run_level+0x10>
			if (rc == 0) {
				/* Run automatic device runtime enablement */
				(void)pm_device_runtime_auto_enable(dev);
			}
		} else {
			(void)entry->init_fn.sys();
    8058:	6823      	ldr	r3, [r4, #0]
    805a:	4798      	blx	r3
    805c:	e7e7      	b.n	802e <z_sys_init_run_level+0x1e>
		}
	}
}
    805e:	bd70      	pop	{r4, r5, r6, pc}
    8060:	0000f828 	.word	0x0000f828

00008064 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    8064:	b510      	push	{r4, lr}
    8066:	b086      	sub	sp, #24
	struct k_thread *thread = &z_idle_threads[i];
    8068:	4c0f      	ldr	r4, [pc, #60]	; (80a8 <init_idle_thread+0x44>)
    806a:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	k_thread_stack_t *stack = z_idle_stacks[i];
    806e:	eb00 0c80 	add.w	ip, r0, r0, lsl #2
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    8072:	4b0e      	ldr	r3, [pc, #56]	; (80ac <init_idle_thread+0x48>)
    8074:	eb03 038c 	add.w	r3, r3, ip, lsl #2
	z_setup_new_thread(thread, stack,
    8078:	2200      	movs	r2, #0
    807a:	9205      	str	r2, [sp, #20]
    807c:	2101      	movs	r1, #1
    807e:	9104      	str	r1, [sp, #16]
    8080:	210f      	movs	r1, #15
    8082:	9103      	str	r1, [sp, #12]
    8084:	9202      	str	r2, [sp, #8]
    8086:	9201      	str	r2, [sp, #4]
    8088:	9300      	str	r3, [sp, #0]
    808a:	4b09      	ldr	r3, [pc, #36]	; (80b0 <init_idle_thread+0x4c>)
    808c:	f44f 72a0 	mov.w	r2, #320	; 0x140
    8090:	4908      	ldr	r1, [pc, #32]	; (80b4 <init_idle_thread+0x50>)
    8092:	eb01 118c 	add.w	r1, r1, ip, lsl #6
    8096:	4620      	mov	r0, r4
    8098:	f000 f93a 	bl	8310 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    809c:	7b63      	ldrb	r3, [r4, #13]
    809e:	f023 0304 	bic.w	r3, r3, #4
    80a2:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    80a4:	b006      	add	sp, #24
    80a6:	bd10      	pop	{r4, pc}
    80a8:	20000380 	.word	0x20000380
    80ac:	200013e0 	.word	0x200013e0
    80b0:	00008405 	.word	0x00008405
    80b4:	20001f78 	.word	0x20001f78

000080b8 <bg_thread_main>:
{
    80b8:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    80ba:	4b0a      	ldr	r3, [pc, #40]	; (80e4 <bg_thread_main+0x2c>)
    80bc:	2201      	movs	r2, #1
    80be:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
    80c0:	2003      	movs	r0, #3
    80c2:	f7ff ffa5 	bl	8010 <z_sys_init_run_level>
	boot_banner();
    80c6:	f000 ffe7 	bl	9098 <boot_banner>
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
    80ca:	2004      	movs	r0, #4
    80cc:	f7ff ffa0 	bl	8010 <z_sys_init_run_level>
	z_init_static_threads();
    80d0:	f000 f94e 	bl	8370 <z_init_static_threads>
	(void)main();
    80d4:	f7f8 fba6 	bl	824 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    80d8:	4a03      	ldr	r2, [pc, #12]	; (80e8 <bg_thread_main+0x30>)
    80da:	7b13      	ldrb	r3, [r2, #12]
    80dc:	f023 0301 	bic.w	r3, r3, #1
    80e0:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    80e2:	bd08      	pop	{r3, pc}
    80e4:	200015f3 	.word	0x200015f3
    80e8:	20000400 	.word	0x20000400

000080ec <switch_to_main_thread>:
	return stack_ptr;
}

__boot_func
static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
    80ec:	b508      	push	{r3, lr}
    80ee:	4601      	mov	r1, r0
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    80f0:	4a01      	ldr	r2, [pc, #4]	; (80f8 <switch_to_main_thread+0xc>)
    80f2:	4802      	ldr	r0, [pc, #8]	; (80fc <switch_to_main_thread+0x10>)
    80f4:	f7f9 fc04 	bl	1900 <arch_switch_to_main_thread>
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
#endif
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    80f8:	000080b9 	.word	0x000080b9
    80fc:	20000400 	.word	0x20000400

00008100 <z_bss_zero>:
{
    8100:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
    8102:	4803      	ldr	r0, [pc, #12]	; (8110 <z_bss_zero+0x10>)
    8104:	4a03      	ldr	r2, [pc, #12]	; (8114 <z_bss_zero+0x14>)
    8106:	1a12      	subs	r2, r2, r0
    8108:	2100      	movs	r1, #0
    810a:	f005 fac3 	bl	d694 <z_early_memset>
}
    810e:	bd08      	pop	{r3, pc}
    8110:	20000360 	.word	0x20000360
    8114:	200015f4 	.word	0x200015f4

00008118 <z_init_cpu>:
{
    8118:	b510      	push	{r4, lr}
    811a:	4604      	mov	r4, r0
	init_idle_thread(id);
    811c:	f7ff ffa2 	bl	8064 <init_idle_thread>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
    8120:	490a      	ldr	r1, [pc, #40]	; (814c <z_init_cpu+0x34>)
    8122:	eb01 11c4 	add.w	r1, r1, r4, lsl #7
    8126:	4a0a      	ldr	r2, [pc, #40]	; (8150 <z_init_cpu+0x38>)
    8128:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    812c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8130:	60d9      	str	r1, [r3, #12]
	_kernel.cpus[id].id = id;
    8132:	741c      	strb	r4, [r3, #16]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
    8134:	4b07      	ldr	r3, [pc, #28]	; (8154 <z_init_cpu+0x3c>)
    8136:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
    813a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
	_kernel.cpus[id].irq_stack =
    813e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    8142:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    8146:	6053      	str	r3, [r2, #4]
}
    8148:	bd10      	pop	{r4, pc}
    814a:	bf00      	nop
    814c:	20000380 	.word	0x20000380
    8150:	200013e0 	.word	0x200013e0
    8154:	20001778 	.word	0x20001778

00008158 <prepare_multithreading>:
{
    8158:	b570      	push	{r4, r5, r6, lr}
    815a:	b086      	sub	sp, #24
	z_sched_init();
    815c:	f000 fd5a 	bl	8c14 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
    8160:	4d10      	ldr	r5, [pc, #64]	; (81a4 <prepare_multithreading+0x4c>)
    8162:	4b11      	ldr	r3, [pc, #68]	; (81a8 <prepare_multithreading+0x50>)
    8164:	619d      	str	r5, [r3, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    8166:	4b11      	ldr	r3, [pc, #68]	; (81ac <prepare_multithreading+0x54>)
    8168:	9305      	str	r3, [sp, #20]
    816a:	2301      	movs	r3, #1
    816c:	9304      	str	r3, [sp, #16]
    816e:	2400      	movs	r4, #0
    8170:	9403      	str	r4, [sp, #12]
    8172:	9402      	str	r4, [sp, #8]
    8174:	9401      	str	r4, [sp, #4]
    8176:	9400      	str	r4, [sp, #0]
    8178:	4b0d      	ldr	r3, [pc, #52]	; (81b0 <prepare_multithreading+0x58>)
    817a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    817e:	490d      	ldr	r1, [pc, #52]	; (81b4 <prepare_multithreading+0x5c>)
    8180:	4628      	mov	r0, r5
    8182:	f000 f8c5 	bl	8310 <z_setup_new_thread>
    8186:	4606      	mov	r6, r0
    8188:	7b6b      	ldrb	r3, [r5, #13]
    818a:	f023 0304 	bic.w	r3, r3, #4
    818e:	736b      	strb	r3, [r5, #13]
	z_ready_thread(&z_main_thread);
    8190:	4628      	mov	r0, r5
    8192:	f005 fc15 	bl	d9c0 <z_ready_thread>
	z_init_cpu(0);
    8196:	4620      	mov	r0, r4
    8198:	f7ff ffbe 	bl	8118 <z_init_cpu>
}
    819c:	4630      	mov	r0, r6
    819e:	b006      	add	sp, #24
    81a0:	bd70      	pop	{r4, r5, r6, pc}
    81a2:	bf00      	nop
    81a4:	20000400 	.word	0x20000400
    81a8:	200013e0 	.word	0x200013e0
    81ac:	0000e3e4 	.word	0x0000e3e4
    81b0:	000080b9 	.word	0x000080b9
    81b4:	200020b8 	.word	0x200020b8

000081b8 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
    81b8:	b500      	push	{lr}
    81ba:	b0a1      	sub	sp, #132	; 0x84
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
    81bc:	2000      	movs	r0, #0
    81be:	f7ff ff27 	bl	8010 <z_sys_init_run_level>
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
    81c2:	4b1d      	ldr	r3, [pc, #116]	; (8238 <z_cstart+0x80>)
	uint32_t msp =
    81c4:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    81c8:	f382 8808 	msr	MSP, r2
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
    81cc:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    81d0:	4c1a      	ldr	r4, [pc, #104]	; (823c <z_cstart+0x84>)
    81d2:	23e0      	movs	r3, #224	; 0xe0
    81d4:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    81d8:	2500      	movs	r5, #0
    81da:	77e5      	strb	r5, [r4, #31]
    81dc:	7625      	strb	r5, [r4, #24]
    81de:	7665      	strb	r5, [r4, #25]
    81e0:	76a5      	strb	r5, [r4, #26]
    81e2:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    81e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    81e8:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    81ec:	6263      	str	r3, [r4, #36]	; 0x24
    81ee:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    81f2:	f7f9 fe2f 	bl	1e54 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    81f6:	f7f9 fa63 	bl	16c0 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    81fa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    81fe:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    8200:	62e3      	str	r3, [r4, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
    8202:	f7fa f867 	bl	22d4 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    8206:	f7f9 fedd 	bl	1fc4 <z_arm_configure_static_mpu_regions>
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    820a:	2401      	movs	r4, #1
    820c:	f88d 400d 	strb.w	r4, [sp, #13]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    8210:	f88d 400c 	strb.w	r4, [sp, #12]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
    8214:	9519      	str	r5, [sp, #100]	; 0x64
	dummy_thread->stack_info.size = 0U;
    8216:	951a      	str	r5, [sp, #104]	; 0x68
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
    8218:	951c      	str	r5, [sp, #112]	; 0x70

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
    821a:	4b09      	ldr	r3, [pc, #36]	; (8240 <z_cstart+0x88>)
    821c:	f8c3 d008 	str.w	sp, [r3, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    8220:	f7ff fe68 	bl	7ef4 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
    8224:	4620      	mov	r0, r4
    8226:	f7ff fef3 	bl	8010 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
    822a:	2002      	movs	r0, #2
    822c:	f7ff fef0 	bl	8010 <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
    8230:	f7ff ff92 	bl	8158 <prepare_multithreading>
    8234:	f7ff ff5a 	bl	80ec <switch_to_main_thread>
    8238:	20001778 	.word	0x20001778
    823c:	e000ed00 	.word	0xe000ed00
    8240:	200013e0 	.word	0x200013e0

00008244 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
    8244:	b510      	push	{r4, lr}
	STRUCT_SECTION_FOREACH(k_heap, h) {
    8246:	4c06      	ldr	r4, [pc, #24]	; (8260 <statics_init+0x1c>)
    8248:	e005      	b.n	8256 <statics_init+0x12>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    824a:	68a2      	ldr	r2, [r4, #8]
    824c:	6861      	ldr	r1, [r4, #4]
    824e:	4620      	mov	r0, r4
    8250:	f005 fa28 	bl	d6a4 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    8254:	3414      	adds	r4, #20
    8256:	4b03      	ldr	r3, [pc, #12]	; (8264 <statics_init+0x20>)
    8258:	429c      	cmp	r4, r3
    825a:	d3f6      	bcc.n	824a <statics_init+0x6>
		}
	}
	return 0;
}
    825c:	2000      	movs	r0, #0
    825e:	bd10      	pop	{r4, pc}
    8260:	200002f8 	.word	0x200002f8
    8264:	2000030c 	.word	0x2000030c

00008268 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
    8268:	b510      	push	{r4, lr}
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    826a:	4c06      	ldr	r4, [pc, #24]	; (8284 <init_mem_slab_module+0x1c>)
	int rc = 0;
    826c:	2000      	movs	r0, #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    826e:	e000      	b.n	8272 <init_mem_slab_module+0xa>
    8270:	341c      	adds	r4, #28
    8272:	4b05      	ldr	r3, [pc, #20]	; (8288 <init_mem_slab_module+0x20>)
    8274:	429c      	cmp	r4, r3
    8276:	d204      	bcs.n	8282 <init_mem_slab_module+0x1a>
		rc = create_free_list(slab);
    8278:	4620      	mov	r0, r4
    827a:	f005 fa99 	bl	d7b0 <create_free_list>
		if (rc < 0) {
    827e:	2800      	cmp	r0, #0
    8280:	daf6      	bge.n	8270 <init_mem_slab_module+0x8>
		z_object_init(slab);
	}

out:
	return rc;
}
    8282:	bd10      	pop	{r4, pc}
    8284:	200002c0 	.word	0x200002c0
    8288:	200002f8 	.word	0x200002f8

0000828c <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    828c:	b530      	push	{r4, r5, lr}
    828e:	b083      	sub	sp, #12
    8290:	460d      	mov	r5, r1
	__asm__ volatile(
    8292:	f04f 0120 	mov.w	r1, #32
    8296:	f3ef 8c11 	mrs	ip, BASEPRI
    829a:	f381 8812 	msr	BASEPRI_MAX, r1
    829e:	f3bf 8f6f 	isb	sy
    82a2:	4661      	mov	r1, ip
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
    82a4:	6944      	ldr	r4, [r0, #20]
    82a6:	b164      	cbz	r4, 82c2 <k_mem_slab_alloc+0x36>
		/* take a free block */
		*mem = slab->free_list;
    82a8:	602c      	str	r4, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
    82aa:	6823      	ldr	r3, [r4, #0]
    82ac:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    82ae:	6983      	ldr	r3, [r0, #24]
    82b0:	3301      	adds	r3, #1
    82b2:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    82b4:	2000      	movs	r0, #0
	__asm__ volatile(
    82b6:	f381 8811 	msr	BASEPRI, r1
    82ba:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
    82be:	b003      	add	sp, #12
    82c0:	bd30      	pop	{r4, r5, pc}
    82c2:	f100 0e08 	add.w	lr, r0, #8
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
    82c6:	ea53 0402 	orrs.w	r4, r3, r2
    82ca:	d104      	bne.n	82d6 <k_mem_slab_alloc+0x4a>
		*mem = NULL;
    82cc:	2300      	movs	r3, #0
    82ce:	602b      	str	r3, [r5, #0]
		result = -ENOMEM;
    82d0:	f06f 000b 	mvn.w	r0, #11
    82d4:	e7ef      	b.n	82b6 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    82d6:	9200      	str	r2, [sp, #0]
    82d8:	9301      	str	r3, [sp, #4]
    82da:	4602      	mov	r2, r0
    82dc:	4670      	mov	r0, lr
    82de:	f000 fb95 	bl	8a0c <z_pend_curr>
		if (result == 0) {
    82e2:	2800      	cmp	r0, #0
    82e4:	d1eb      	bne.n	82be <k_mem_slab_alloc+0x32>
			*mem = _current->base.swap_data;
    82e6:	4b02      	ldr	r3, [pc, #8]	; (82f0 <k_mem_slab_alloc+0x64>)
    82e8:	689b      	ldr	r3, [r3, #8]
    82ea:	695b      	ldr	r3, [r3, #20]
    82ec:	602b      	str	r3, [r5, #0]
		return result;
    82ee:	e7e6      	b.n	82be <k_mem_slab_alloc+0x32>
    82f0:	200013e0 	.word	0x200013e0

000082f4 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
    82f4:	b508      	push	{r3, lr}
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    82f6:	ea53 0102 	orrs.w	r1, r3, r2
    82fa:	d102      	bne.n	8302 <schedule_new_thread+0xe>
	z_impl_k_thread_start(thread);
    82fc:	f005 fabc 	bl	d878 <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
    8300:	bd08      	pop	{r3, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    8302:	4902      	ldr	r1, [pc, #8]	; (830c <schedule_new_thread+0x18>)
    8304:	3018      	adds	r0, #24
    8306:	f000 fdc3 	bl	8e90 <z_add_timeout>
    830a:	e7f9      	b.n	8300 <schedule_new_thread+0xc>
    830c:	0000da4d 	.word	0x0000da4d

00008310 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    8310:	b5f0      	push	{r4, r5, r6, r7, lr}
    8312:	b085      	sub	sp, #20
    8314:	4604      	mov	r4, r0
    8316:	460e      	mov	r6, r1
    8318:	4615      	mov	r5, r2
    831a:	461f      	mov	r7, r3
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    831c:	f100 0358 	add.w	r3, r0, #88	; 0x58
	list->head = (sys_dnode_t *)list;
    8320:	6583      	str	r3, [r0, #88]	; 0x58
	list->tail = (sys_dnode_t *)list;
    8322:	65c3      	str	r3, [r0, #92]	; 0x5c
	k_object_access_grant(new_thread, new_thread);
#endif
	z_waitq_init(&new_thread->join_queue);

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    8324:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8326:	2204      	movs	r2, #4
    8328:	990d      	ldr	r1, [sp, #52]	; 0x34
    832a:	f005 faa9 	bl	d880 <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
    832e:	462a      	mov	r2, r5
    8330:	4631      	mov	r1, r6
    8332:	4620      	mov	r0, r4
    8334:	f005 fa8f 	bl	d856 <setup_thread_stack>
    8338:	4605      	mov	r5, r0
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    833a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    833c:	9302      	str	r3, [sp, #8]
    833e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8340:	9301      	str	r3, [sp, #4]
    8342:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8344:	9300      	str	r3, [sp, #0]
    8346:	463b      	mov	r3, r7
    8348:	4602      	mov	r2, r0
    834a:	4631      	mov	r1, r6
    834c:	4620      	mov	r0, r4
    834e:	f7f9 fab7 	bl	18c0 <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
    8352:	2300      	movs	r3, #0
    8354:	6563      	str	r3, [r4, #84]	; 0x54
		new_thread->base.cpu_mask = -1; /* allow all cpus */
	}
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    8356:	4b05      	ldr	r3, [pc, #20]	; (836c <z_setup_new_thread+0x5c>)
    8358:	689b      	ldr	r3, [r3, #8]
    835a:	b123      	cbz	r3, 8366 <z_setup_new_thread+0x56>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    835c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    835e:	6723      	str	r3, [r4, #112]	; 0x70
#endif

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);

	return stack_ptr;
}
    8360:	4628      	mov	r0, r5
    8362:	b005      	add	sp, #20
    8364:	bdf0      	pop	{r4, r5, r6, r7, pc}
		new_thread->resource_pool = NULL;
    8366:	6723      	str	r3, [r4, #112]	; 0x70
		return stack_ptr;
    8368:	e7fa      	b.n	8360 <z_setup_new_thread+0x50>
    836a:	bf00      	nop
    836c:	200013e0 	.word	0x200013e0

00008370 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    8370:	b530      	push	{r4, r5, lr}
    8372:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
    8374:	4c21      	ldr	r4, [pc, #132]	; (83fc <z_init_static_threads+0x8c>)
    8376:	e014      	b.n	83a2 <z_init_static_threads+0x32>
		z_setup_new_thread(
    8378:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    837a:	9305      	str	r3, [sp, #20]
    837c:	6a23      	ldr	r3, [r4, #32]
    837e:	9304      	str	r3, [sp, #16]
    8380:	69e3      	ldr	r3, [r4, #28]
    8382:	9303      	str	r3, [sp, #12]
    8384:	69a3      	ldr	r3, [r4, #24]
    8386:	9302      	str	r3, [sp, #8]
    8388:	6963      	ldr	r3, [r4, #20]
    838a:	9301      	str	r3, [sp, #4]
    838c:	6923      	ldr	r3, [r4, #16]
    838e:	9300      	str	r3, [sp, #0]
    8390:	68e3      	ldr	r3, [r4, #12]
    8392:	68a2      	ldr	r2, [r4, #8]
    8394:	6861      	ldr	r1, [r4, #4]
    8396:	6820      	ldr	r0, [r4, #0]
    8398:	f7ff ffba 	bl	8310 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
    839c:	6823      	ldr	r3, [r4, #0]
    839e:	655c      	str	r4, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    83a0:	342c      	adds	r4, #44	; 0x2c
    83a2:	4b17      	ldr	r3, [pc, #92]	; (8400 <z_init_static_threads+0x90>)
    83a4:	429c      	cmp	r4, r3
    83a6:	d3e7      	bcc.n	8378 <z_init_static_threads+0x8>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    83a8:	f000 f9f8 	bl	879c <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    83ac:	4c13      	ldr	r4, [pc, #76]	; (83fc <z_init_static_threads+0x8c>)
    83ae:	e000      	b.n	83b2 <z_init_static_threads+0x42>
    83b0:	342c      	adds	r4, #44	; 0x2c
    83b2:	4b13      	ldr	r3, [pc, #76]	; (8400 <z_init_static_threads+0x90>)
    83b4:	429c      	cmp	r4, r3
    83b6:	d21c      	bcs.n	83f2 <z_init_static_threads+0x82>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    83b8:	6a60      	ldr	r0, [r4, #36]	; 0x24
    83ba:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    83be:	d0f7      	beq.n	83b0 <z_init_static_threads+0x40>
			schedule_new_thread(thread_data->init_thread,
    83c0:	6825      	ldr	r5, [r4, #0]
					    K_MSEC(thread_data->init_delay));
    83c2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    83c6:	17c1      	asrs	r1, r0, #31
    83c8:	03c9      	lsls	r1, r1, #15
    83ca:	ea41 4150 	orr.w	r1, r1, r0, lsr #17
    83ce:	03c0      	lsls	r0, r0, #15
    83d0:	f240 33e7 	movw	r3, #999	; 0x3e7
    83d4:	18c0      	adds	r0, r0, r3
    83d6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    83da:	f04f 0300 	mov.w	r3, #0
    83de:	f141 0100 	adc.w	r1, r1, #0
    83e2:	f7f7 feb7 	bl	154 <__aeabi_uldivmod>
    83e6:	4602      	mov	r2, r0
    83e8:	460b      	mov	r3, r1
			schedule_new_thread(thread_data->init_thread,
    83ea:	4628      	mov	r0, r5
    83ec:	f7ff ff82 	bl	82f4 <schedule_new_thread>
    83f0:	e7de      	b.n	83b0 <z_init_static_threads+0x40>
		}
	}
	k_sched_unlock();
    83f2:	f000 fbbf 	bl	8b74 <k_sched_unlock>
}
    83f6:	b007      	add	sp, #28
    83f8:	bd30      	pop	{r4, r5, pc}
    83fa:	bf00      	nop
    83fc:	0000dfdc 	.word	0x0000dfdc
    8400:	0000dfdc 	.word	0x0000dfdc

00008404 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    8404:	b508      	push	{r3, lr}
    8406:	e001      	b.n	840c <idle+0x8>
	arch_cpu_idle();
    8408:	f7f9 f960 	bl	16cc <arch_cpu_idle>
	__asm__ volatile(
    840c:	f04f 0220 	mov.w	r2, #32
    8410:	f3ef 8311 	mrs	r3, BASEPRI
    8414:	f382 8812 	msr	BASEPRI_MAX, r2
    8418:	f3bf 8f6f 	isb	sy
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
    841c:	f005 fbef 	bl	dbfe <z_get_next_timeout_expiry>
    8420:	4b05      	ldr	r3, [pc, #20]	; (8438 <idle+0x34>)
    8422:	6158      	str	r0, [r3, #20]
	return !z_sys_post_kernel;
    8424:	4b05      	ldr	r3, [pc, #20]	; (843c <idle+0x38>)
    8426:	781b      	ldrb	r3, [r3, #0]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
    8428:	2b00      	cmp	r3, #0
    842a:	d0ed      	beq.n	8408 <idle+0x4>
    842c:	f7f8 ff18 	bl	1260 <pm_system_suspend>
    8430:	2800      	cmp	r0, #0
    8432:	d1eb      	bne.n	840c <idle+0x8>
    8434:	e7e8      	b.n	8408 <idle+0x4>
    8436:	bf00      	nop
    8438:	200013e0 	.word	0x200013e0
    843c:	200015f3 	.word	0x200015f3

00008440 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    8440:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8444:	b082      	sub	sp, #8
    8446:	4604      	mov	r4, r0
    8448:	461e      	mov	r6, r3
    844a:	f04f 0320 	mov.w	r3, #32
    844e:	f3ef 8511 	mrs	r5, BASEPRI
    8452:	f383 8812 	msr	BASEPRI_MAX, r3
    8456:	f3bf 8f6f 	isb	sy
    845a:	462b      	mov	r3, r5

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    845c:	68c1      	ldr	r1, [r0, #12]
    845e:	b999      	cbnz	r1, 8488 <z_impl_k_mutex_lock+0x48>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
    8460:	2900      	cmp	r1, #0
    8462:	d151      	bne.n	8508 <z_impl_k_mutex_lock+0xc8>
    8464:	4a36      	ldr	r2, [pc, #216]	; (8540 <z_impl_k_mutex_lock+0x100>)
    8466:	6892      	ldr	r2, [r2, #8]
    8468:	f992 200e 	ldrsb.w	r2, [r2, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    846c:	6122      	str	r2, [r4, #16]
					mutex->owner_orig_prio;

		mutex->lock_count++;
    846e:	3101      	adds	r1, #1
    8470:	60e1      	str	r1, [r4, #12]
		mutex->owner = _current;
    8472:	4a33      	ldr	r2, [pc, #204]	; (8540 <z_impl_k_mutex_lock+0x100>)
    8474:	6892      	ldr	r2, [r2, #8]
    8476:	60a2      	str	r2, [r4, #8]
	__asm__ volatile(
    8478:	f383 8811 	msr	BASEPRI, r3
    847c:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
    8480:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    8482:	b002      	add	sp, #8
    8484:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8488:	4617      	mov	r7, r2
	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    848a:	6880      	ldr	r0, [r0, #8]
    848c:	4a2c      	ldr	r2, [pc, #176]	; (8540 <z_impl_k_mutex_lock+0x100>)
    848e:	6892      	ldr	r2, [r2, #8]
    8490:	4290      	cmp	r0, r2
    8492:	d0e5      	beq.n	8460 <z_impl_k_mutex_lock+0x20>
	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    8494:	ea56 0107 	orrs.w	r1, r6, r7
    8498:	d038      	beq.n	850c <z_impl_k_mutex_lock+0xcc>
					    mutex->owner->base.prio);
    849a:	f990 800e 	ldrsb.w	r8, [r0, #14]
	new_prio = new_prio_for_inheritance(_current->base.prio,
    849e:	4641      	mov	r1, r8
    84a0:	f992 000e 	ldrsb.w	r0, [r2, #14]
    84a4:	f005 f9fd 	bl	d8a2 <new_prio_for_inheritance>
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    84a8:	4580      	cmp	r8, r0
    84aa:	dc36      	bgt.n	851a <z_impl_k_mutex_lock+0xda>
	bool resched = false;
    84ac:	f04f 0800 	mov.w	r8, #0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    84b0:	9700      	str	r7, [sp, #0]
    84b2:	9601      	str	r6, [sp, #4]
    84b4:	4622      	mov	r2, r4
    84b6:	4629      	mov	r1, r5
    84b8:	4822      	ldr	r0, [pc, #136]	; (8544 <z_impl_k_mutex_lock+0x104>)
    84ba:	f000 faa7 	bl	8a0c <z_pend_curr>
	if (got_mutex == 0) {
    84be:	2800      	cmp	r0, #0
    84c0:	d0df      	beq.n	8482 <z_impl_k_mutex_lock+0x42>
	__asm__ volatile(
    84c2:	f04f 0320 	mov.w	r3, #32
    84c6:	f3ef 8511 	mrs	r5, BASEPRI
    84ca:	f383 8812 	msr	BASEPRI_MAX, r3
    84ce:	f3bf 8f6f 	isb	sy
    84d2:	462e      	mov	r6, r5
	if (likely(mutex->owner != NULL)) {
    84d4:	68a3      	ldr	r3, [r4, #8]
    84d6:	b343      	cbz	r3, 852a <z_impl_k_mutex_lock+0xea>
	return list->head == list;
    84d8:	6823      	ldr	r3, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    84da:	429c      	cmp	r4, r3
    84dc:	d023      	beq.n	8526 <z_impl_k_mutex_lock+0xe6>
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    84de:	b313      	cbz	r3, 8526 <z_impl_k_mutex_lock+0xe6>
    84e0:	6921      	ldr	r1, [r4, #16]
    84e2:	f993 000e 	ldrsb.w	r0, [r3, #14]
    84e6:	f005 f9dc 	bl	d8a2 <new_prio_for_inheritance>
    84ea:	4601      	mov	r1, r0
		resched = adjust_owner_prio(mutex, new_prio) || resched;
    84ec:	4620      	mov	r0, r4
    84ee:	f005 f9e3 	bl	d8b8 <adjust_owner_prio>
    84f2:	b9e8      	cbnz	r0, 8530 <z_impl_k_mutex_lock+0xf0>
    84f4:	f1b8 0f00 	cmp.w	r8, #0
    84f8:	d11a      	bne.n	8530 <z_impl_k_mutex_lock+0xf0>
	__asm__ volatile(
    84fa:	f386 8811 	msr	BASEPRI, r6
    84fe:	f3bf 8f6f 	isb	sy
	return -EAGAIN;
    8502:	f06f 000a 	mvn.w	r0, #10
    8506:	e7bc      	b.n	8482 <z_impl_k_mutex_lock+0x42>
					_current->base.prio :
    8508:	6922      	ldr	r2, [r4, #16]
    850a:	e7af      	b.n	846c <z_impl_k_mutex_lock+0x2c>
    850c:	f385 8811 	msr	BASEPRI, r5
    8510:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    8514:	f06f 000f 	mvn.w	r0, #15
    8518:	e7b3      	b.n	8482 <z_impl_k_mutex_lock+0x42>
		resched = adjust_owner_prio(mutex, new_prio);
    851a:	4601      	mov	r1, r0
    851c:	4620      	mov	r0, r4
    851e:	f005 f9cb 	bl	d8b8 <adjust_owner_prio>
    8522:	4680      	mov	r8, r0
    8524:	e7c4      	b.n	84b0 <z_impl_k_mutex_lock+0x70>
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    8526:	6921      	ldr	r1, [r4, #16]
    8528:	e7e0      	b.n	84ec <z_impl_k_mutex_lock+0xac>
	if (resched) {
    852a:	f1b8 0f00 	cmp.w	r8, #0
    852e:	d0e4      	beq.n	84fa <z_impl_k_mutex_lock+0xba>
		z_reschedule(&lock, key);
    8530:	4629      	mov	r1, r5
    8532:	4804      	ldr	r0, [pc, #16]	; (8544 <z_impl_k_mutex_lock+0x104>)
    8534:	f000 f91c 	bl	8770 <z_reschedule>
	return -EAGAIN;
    8538:	f06f 000a 	mvn.w	r0, #10
    853c:	e7a1      	b.n	8482 <z_impl_k_mutex_lock+0x42>
    853e:	bf00      	nop
    8540:	200013e0 	.word	0x200013e0
    8544:	20001404 	.word	0x20001404

00008548 <z_impl_k_mutex_unlock>:

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    8548:	6883      	ldr	r3, [r0, #8]
    854a:	b383      	cbz	r3, 85ae <z_impl_k_mutex_unlock+0x66>
{
    854c:	b570      	push	{r4, r5, r6, lr}
    854e:	4604      	mov	r4, r0
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    8550:	4a1a      	ldr	r2, [pc, #104]	; (85bc <z_impl_k_mutex_unlock+0x74>)
    8552:	6892      	ldr	r2, [r2, #8]
    8554:	4293      	cmp	r3, r2
    8556:	d12d      	bne.n	85b4 <z_impl_k_mutex_unlock+0x6c>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    8558:	68c3      	ldr	r3, [r0, #12]
    855a:	2b01      	cmp	r3, #1
    855c:	d903      	bls.n	8566 <z_impl_k_mutex_unlock+0x1e>
		mutex->lock_count--;
    855e:	3b01      	subs	r3, #1
    8560:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
    8562:	2000      	movs	r0, #0
}
    8564:	bd70      	pop	{r4, r5, r6, pc}
	__asm__ volatile(
    8566:	f04f 0320 	mov.w	r3, #32
    856a:	f3ef 8511 	mrs	r5, BASEPRI
    856e:	f383 8812 	msr	BASEPRI_MAX, r3
    8572:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    8576:	6901      	ldr	r1, [r0, #16]
    8578:	f005 f99e 	bl	d8b8 <adjust_owner_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    857c:	4620      	mov	r0, r4
    857e:	f005 fab6 	bl	daee <z_unpend_first_thread>
	mutex->owner = new_owner;
    8582:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    8584:	b160      	cbz	r0, 85a0 <z_impl_k_mutex_unlock+0x58>
		mutex->owner_orig_prio = new_owner->base.prio;
    8586:	f990 300e 	ldrsb.w	r3, [r0, #14]
    858a:	6123      	str	r3, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    858c:	2400      	movs	r4, #0
    858e:	6784      	str	r4, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
    8590:	f005 fa16 	bl	d9c0 <z_ready_thread>
		z_reschedule(&lock, key);
    8594:	4629      	mov	r1, r5
    8596:	480a      	ldr	r0, [pc, #40]	; (85c0 <z_impl_k_mutex_unlock+0x78>)
    8598:	f000 f8ea 	bl	8770 <z_reschedule>
	return 0;
    859c:	4620      	mov	r0, r4
    859e:	e7e1      	b.n	8564 <z_impl_k_mutex_unlock+0x1c>
		mutex->lock_count = 0U;
    85a0:	2000      	movs	r0, #0
    85a2:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    85a4:	f385 8811 	msr	BASEPRI, r5
    85a8:	f3bf 8f6f 	isb	sy
    85ac:	e7da      	b.n	8564 <z_impl_k_mutex_unlock+0x1c>
		return -EINVAL;
    85ae:	f06f 0015 	mvn.w	r0, #21
}
    85b2:	4770      	bx	lr
		return -EPERM;
    85b4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    85b8:	e7d4      	b.n	8564 <z_impl_k_mutex_unlock+0x1c>
    85ba:	bf00      	nop
    85bc:	200013e0 	.word	0x200013e0
    85c0:	20001404 	.word	0x20001404

000085c4 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    85c4:	b538      	push	{r3, r4, r5, lr}
    85c6:	4604      	mov	r4, r0
	__asm__ volatile(
    85c8:	f04f 0320 	mov.w	r3, #32
    85cc:	f3ef 8511 	mrs	r5, BASEPRI
    85d0:	f383 8812 	msr	BASEPRI_MAX, r3
    85d4:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    85d8:	f005 fa89 	bl	daee <z_unpend_first_thread>

	if (thread != NULL) {
    85dc:	b140      	cbz	r0, 85f0 <z_impl_k_sem_give+0x2c>
    85de:	2200      	movs	r2, #0
    85e0:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    85e2:	f005 f9ed 	bl	d9c0 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    85e6:	4629      	mov	r1, r5
    85e8:	4806      	ldr	r0, [pc, #24]	; (8604 <z_impl_k_sem_give+0x40>)
    85ea:	f000 f8c1 	bl	8770 <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    85ee:	bd38      	pop	{r3, r4, r5, pc}
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    85f0:	68a3      	ldr	r3, [r4, #8]
    85f2:	68e2      	ldr	r2, [r4, #12]
    85f4:	4293      	cmp	r3, r2
    85f6:	d003      	beq.n	8600 <z_impl_k_sem_give+0x3c>
    85f8:	2201      	movs	r2, #1
    85fa:	4413      	add	r3, r2
    85fc:	60a3      	str	r3, [r4, #8]
}
    85fe:	e7f2      	b.n	85e6 <z_impl_k_sem_give+0x22>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    8600:	2200      	movs	r2, #0
    8602:	e7fa      	b.n	85fa <z_impl_k_sem_give+0x36>
    8604:	20001404 	.word	0x20001404

00008608 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    8608:	b510      	push	{r4, lr}
    860a:	b082      	sub	sp, #8
    860c:	f04f 0420 	mov.w	r4, #32
    8610:	f3ef 8111 	mrs	r1, BASEPRI
    8614:	f384 8812 	msr	BASEPRI_MAX, r4
    8618:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    861c:	6884      	ldr	r4, [r0, #8]
    861e:	b144      	cbz	r4, 8632 <z_impl_k_sem_take+0x2a>
		sem->count--;
    8620:	3c01      	subs	r4, #1
    8622:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
    8624:	f381 8811 	msr	BASEPRI, r1
    8628:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    862c:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    862e:	b002      	add	sp, #8
    8630:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    8632:	ea53 0402 	orrs.w	r4, r3, r2
    8636:	d006      	beq.n	8646 <z_impl_k_sem_take+0x3e>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    8638:	9200      	str	r2, [sp, #0]
    863a:	9301      	str	r3, [sp, #4]
    863c:	4602      	mov	r2, r0
    863e:	4805      	ldr	r0, [pc, #20]	; (8654 <z_impl_k_sem_take+0x4c>)
    8640:	f000 f9e4 	bl	8a0c <z_pend_curr>
	return ret;
    8644:	e7f3      	b.n	862e <z_impl_k_sem_take+0x26>
    8646:	f381 8811 	msr	BASEPRI, r1
    864a:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    864e:	f06f 000f 	mvn.w	r0, #15
    8652:	e7ec      	b.n	862e <z_impl_k_sem_take+0x26>
    8654:	20001404 	.word	0x20001404

00008658 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
    8658:	b538      	push	{r3, r4, r5, lr}
    865a:	4604      	mov	r4, r0
	__asm__ volatile(
    865c:	f04f 0320 	mov.w	r3, #32
    8660:	f3ef 8511 	mrs	r5, BASEPRI
    8664:	f383 8812 	msr	BASEPRI_MAX, r3
    8668:	f3bf 8f6f 	isb	sy
	z_spin_lock_set_owner(l);
#if defined(CONFIG_SPIN_LOCK_TIME_LIMIT) && (CONFIG_SPIN_LOCK_TIME_LIMIT != 0)
	l->lock_time = sys_clock_cycle_get_32();
#endif /* CONFIG_SPIN_LOCK_TIME_LIMIT */
#endif/* CONFIG_SPIN_VALIDATE */
	return k;
    866c:	e004      	b.n	8678 <z_impl_k_sem_reset+0x20>
    866e:	f06f 020a 	mvn.w	r2, #10
    8672:	6782      	str	r2, [r0, #120]	; 0x78
		thread = z_unpend_first_thread(&sem->wait_q);
		if (thread == NULL) {
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
    8674:	f005 f9a4 	bl	d9c0 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
    8678:	4620      	mov	r0, r4
    867a:	f005 fa38 	bl	daee <z_unpend_first_thread>
		if (thread == NULL) {
    867e:	2800      	cmp	r0, #0
    8680:	d1f5      	bne.n	866e <z_impl_k_sem_reset+0x16>
	}
	sem->count = 0;
    8682:	2300      	movs	r3, #0
    8684:	60a3      	str	r3, [r4, #8]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
    8686:	4629      	mov	r1, r5
    8688:	4801      	ldr	r0, [pc, #4]	; (8690 <z_impl_k_sem_reset+0x38>)
    868a:	f000 f871 	bl	8770 <z_reschedule>
}
    868e:	bd38      	pop	{r3, r4, r5, pc}
    8690:	20001404 	.word	0x20001404

00008694 <sliceable>:


static inline int is_preempt(struct k_thread *thread)
{
	/* explanation in kernel_struct.h */
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    8694:	89c3      	ldrh	r3, [r0, #14]
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
    8696:	2b7f      	cmp	r3, #127	; 0x7f
    8698:	d811      	bhi.n	86be <sliceable+0x2a>
	int ret = slice_ticks;
    869a:	4b0e      	ldr	r3, [pc, #56]	; (86d4 <sliceable+0x40>)
    869c:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
    869e:	b17b      	cbz	r3, 86c0 <sliceable+0x2c>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    86a0:	f990 200e 	ldrsb.w	r2, [r0, #14]
    86a4:	4b0c      	ldr	r3, [pc, #48]	; (86d8 <sliceable+0x44>)
    86a6:	681b      	ldr	r3, [r3, #0]
    86a8:	429a      	cmp	r2, r3
    86aa:	db0c      	blt.n	86c6 <sliceable+0x32>
	uint8_t state = thread->base.thread_state;
    86ac:	7b43      	ldrb	r3, [r0, #13]
		&& !z_is_thread_prevented_from_running(thread)
    86ae:	f013 0f1f 	tst.w	r3, #31
    86b2:	d10a      	bne.n	86ca <sliceable+0x36>
		&& !z_is_idle_thread_object(thread);
    86b4:	4b09      	ldr	r3, [pc, #36]	; (86dc <sliceable+0x48>)
    86b6:	4298      	cmp	r0, r3
    86b8:	d009      	beq.n	86ce <sliceable+0x3a>
    86ba:	2301      	movs	r3, #1
    86bc:	e000      	b.n	86c0 <sliceable+0x2c>
    86be:	2300      	movs	r3, #0
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
    86c0:	f003 0001 	and.w	r0, r3, #1
    86c4:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
    86c6:	2300      	movs	r3, #0
    86c8:	e7fa      	b.n	86c0 <sliceable+0x2c>
    86ca:	2300      	movs	r3, #0
    86cc:	e7f8      	b.n	86c0 <sliceable+0x2c>
    86ce:	2300      	movs	r3, #0
    86d0:	e7f6      	b.n	86c0 <sliceable+0x2c>
    86d2:	bf00      	nop
    86d4:	20001410 	.word	0x20001410
    86d8:	2000140c 	.word	0x2000140c
    86dc:	20000380 	.word	0x20000380

000086e0 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
    86e0:	4b04      	ldr	r3, [pc, #16]	; (86f4 <slice_timeout+0x14>)
    86e2:	1ac0      	subs	r0, r0, r3
    86e4:	10c0      	asrs	r0, r0, #3
    86e6:	4b04      	ldr	r3, [pc, #16]	; (86f8 <slice_timeout+0x18>)
    86e8:	fb03 f000 	mul.w	r0, r3, r0

	slice_expired[cpu] = true;
    86ec:	4b03      	ldr	r3, [pc, #12]	; (86fc <slice_timeout+0x1c>)
    86ee:	2201      	movs	r2, #1
    86f0:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
    86f2:	4770      	bx	lr
    86f4:	20000480 	.word	0x20000480
    86f8:	aaaaaaab 	.word	0xaaaaaaab
    86fc:	20001408 	.word	0x20001408

00008700 <add_thread_timeout>:
	}
}

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    8700:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    8704:	bf08      	it	eq
    8706:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    870a:	d100      	bne.n	870e <add_thread_timeout+0xe>
    870c:	4770      	bx	lr
{
    870e:	b508      	push	{r3, lr}
    8710:	4902      	ldr	r1, [pc, #8]	; (871c <add_thread_timeout+0x1c>)
    8712:	3018      	adds	r0, #24
    8714:	f000 fbbc 	bl	8e90 <z_add_timeout>
		z_add_thread_timeout(thread, timeout);
	}
}
    8718:	bd08      	pop	{r3, pc}
    871a:	bf00      	nop
    871c:	0000da4d 	.word	0x0000da4d

00008720 <z_reset_time_slice>:
{
    8720:	b570      	push	{r4, r5, r6, lr}
    8722:	4605      	mov	r5, r0
	int cpu = _current_cpu->id;
    8724:	4b0d      	ldr	r3, [pc, #52]	; (875c <z_reset_time_slice+0x3c>)
    8726:	7c1e      	ldrb	r6, [r3, #16]
	z_abort_timeout(&slice_timeouts[cpu]);
    8728:	eb06 0346 	add.w	r3, r6, r6, lsl #1
    872c:	4c0c      	ldr	r4, [pc, #48]	; (8760 <z_reset_time_slice+0x40>)
    872e:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
    8732:	4620      	mov	r0, r4
    8734:	f005 fa45 	bl	dbc2 <z_abort_timeout>
	slice_expired[cpu] = false;
    8738:	4b0a      	ldr	r3, [pc, #40]	; (8764 <z_reset_time_slice+0x44>)
    873a:	2200      	movs	r2, #0
    873c:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
    873e:	4628      	mov	r0, r5
    8740:	f7ff ffa8 	bl	8694 <sliceable>
    8744:	b900      	cbnz	r0, 8748 <z_reset_time_slice+0x28>
}
    8746:	bd70      	pop	{r4, r5, r6, pc}
	int ret = slice_ticks;
    8748:	4b07      	ldr	r3, [pc, #28]	; (8768 <z_reset_time_slice+0x48>)
    874a:	681a      	ldr	r2, [r3, #0]
			      K_TICKS(slice_time(curr) - 1));
    874c:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
    874e:	17d3      	asrs	r3, r2, #31
    8750:	4906      	ldr	r1, [pc, #24]	; (876c <z_reset_time_slice+0x4c>)
    8752:	4620      	mov	r0, r4
    8754:	f000 fb9c 	bl	8e90 <z_add_timeout>
}
    8758:	e7f5      	b.n	8746 <z_reset_time_slice+0x26>
    875a:	bf00      	nop
    875c:	200013e0 	.word	0x200013e0
    8760:	20000480 	.word	0x20000480
    8764:	20001408 	.word	0x20001408
    8768:	20001410 	.word	0x20001410
    876c:	000086e1 	.word	0x000086e1

00008770 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    8770:	b508      	push	{r3, lr}
	if (resched(key.key) && need_swap()) {
    8772:	460b      	mov	r3, r1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    8774:	b959      	cbnz	r1, 878e <z_reschedule+0x1e>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    8776:	f3ef 8205 	mrs	r2, IPSR
    877a:	b942      	cbnz	r2, 878e <z_reschedule+0x1e>
	new_thread = _kernel.ready_q.cache;
    877c:	4a06      	ldr	r2, [pc, #24]	; (8798 <z_reschedule+0x28>)
    877e:	6990      	ldr	r0, [r2, #24]
	return new_thread != _current;
    8780:	6892      	ldr	r2, [r2, #8]
	if (resched(key.key) && need_swap()) {
    8782:	4290      	cmp	r0, r2
    8784:	d003      	beq.n	878e <z_reschedule+0x1e>
	ret = arch_swap(key);
    8786:	4608      	mov	r0, r1
    8788:	f7f9 f844 	bl	1814 <arch_swap>
		z_swap(lock, key);
    878c:	e003      	b.n	8796 <z_reschedule+0x26>
	__asm__ volatile(
    878e:	f383 8811 	msr	BASEPRI, r3
    8792:	f3bf 8f6f 	isb	sy
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
    8796:	bd08      	pop	{r3, pc}
    8798:	200013e0 	.word	0x200013e0

0000879c <k_sched_lock>:
	}
}

void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
    879c:	2300      	movs	r3, #0
	__asm__ volatile(
    879e:	f04f 0220 	mov.w	r2, #32
    87a2:	f3ef 8111 	mrs	r1, BASEPRI
    87a6:	f382 8812 	msr	BASEPRI_MAX, r2
    87aa:	f3bf 8f6f 	isb	sy
    87ae:	e009      	b.n	87c4 <k_sched_lock+0x28>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    87b0:	4b06      	ldr	r3, [pc, #24]	; (87cc <k_sched_lock+0x30>)
    87b2:	689a      	ldr	r2, [r3, #8]
    87b4:	7bd3      	ldrb	r3, [r2, #15]
    87b6:	3b01      	subs	r3, #1
    87b8:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    87ba:	f381 8811 	msr	BASEPRI, r1
    87be:	f3bf 8f6f 	isb	sy
    87c2:	2301      	movs	r3, #1
    87c4:	2b00      	cmp	r3, #0
    87c6:	d0f3      	beq.n	87b0 <k_sched_lock+0x14>
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    87c8:	4770      	bx	lr
    87ca:	bf00      	nop
    87cc:	200013e0 	.word	0x200013e0

000087d0 <update_cache>:
{
    87d0:	b538      	push	{r3, r4, r5, lr}
    87d2:	4604      	mov	r4, r0
	return _priq_run_best(curr_cpu_runq());
    87d4:	4810      	ldr	r0, [pc, #64]	; (8818 <update_cache+0x48>)
    87d6:	f005 f8ec 	bl	d9b2 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    87da:	4605      	mov	r5, r0
    87dc:	b170      	cbz	r0, 87fc <update_cache+0x2c>
	if (preempt_ok != 0) {
    87de:	b984      	cbnz	r4, 8802 <update_cache+0x32>
	if (z_is_thread_prevented_from_running(_current)) {
    87e0:	4b0e      	ldr	r3, [pc, #56]	; (881c <update_cache+0x4c>)
    87e2:	689b      	ldr	r3, [r3, #8]
	uint8_t state = thread->base.thread_state;
    87e4:	7b5a      	ldrb	r2, [r3, #13]
    87e6:	f012 0f1f 	tst.w	r2, #31
    87ea:	d10a      	bne.n	8802 <update_cache+0x32>
	return node->next != NULL;
    87ec:	69aa      	ldr	r2, [r5, #24]
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    87ee:	b942      	cbnz	r2, 8802 <update_cache+0x32>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    87f0:	89da      	ldrh	r2, [r3, #14]
	if (is_preempt(_current) || is_metairq(thread)) {
    87f2:	2a7f      	cmp	r2, #127	; 0x7f
    87f4:	d905      	bls.n	8802 <update_cache+0x32>
		_kernel.ready_q.cache = _current;
    87f6:	4a09      	ldr	r2, [pc, #36]	; (881c <update_cache+0x4c>)
    87f8:	6193      	str	r3, [r2, #24]
    87fa:	e00b      	b.n	8814 <update_cache+0x44>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    87fc:	4b07      	ldr	r3, [pc, #28]	; (881c <update_cache+0x4c>)
    87fe:	68dd      	ldr	r5, [r3, #12]
    8800:	e7ed      	b.n	87de <update_cache+0xe>
		if (thread != _current) {
    8802:	4b06      	ldr	r3, [pc, #24]	; (881c <update_cache+0x4c>)
    8804:	689b      	ldr	r3, [r3, #8]
    8806:	42ab      	cmp	r3, r5
    8808:	d002      	beq.n	8810 <update_cache+0x40>
			z_reset_time_slice(thread);
    880a:	4628      	mov	r0, r5
    880c:	f7ff ff88 	bl	8720 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    8810:	4b02      	ldr	r3, [pc, #8]	; (881c <update_cache+0x4c>)
    8812:	619d      	str	r5, [r3, #24]
}
    8814:	bd38      	pop	{r3, r4, r5, pc}
    8816:	bf00      	nop
    8818:	200013fc 	.word	0x200013fc
    881c:	200013e0 	.word	0x200013e0

00008820 <move_thread_to_end_of_prio_q>:
{
    8820:	b538      	push	{r3, r4, r5, lr}
    8822:	4605      	mov	r5, r0
	return (thread->base.thread_state & state) != 0U;
    8824:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    8826:	f990 300d 	ldrsb.w	r3, [r0, #13]
    882a:	2b00      	cmp	r3, #0
    882c:	db0a      	blt.n	8844 <move_thread_to_end_of_prio_q+0x24>
	thread->base.thread_state |= _THREAD_QUEUED;
    882e:	7b6b      	ldrb	r3, [r5, #13]
    8830:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8834:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    8836:	4b1b      	ldr	r3, [pc, #108]	; (88a4 <move_thread_to_end_of_prio_q+0x84>)
    8838:	f853 4f1c 	ldr.w	r4, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    883c:	429c      	cmp	r4, r3
    883e:	d110      	bne.n	8862 <move_thread_to_end_of_prio_q+0x42>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8840:	2400      	movs	r4, #0
    8842:	e00e      	b.n	8862 <move_thread_to_end_of_prio_q+0x42>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8844:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    8848:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    884a:	4601      	mov	r1, r0
    884c:	4816      	ldr	r0, [pc, #88]	; (88a8 <move_thread_to_end_of_prio_q+0x88>)
    884e:	f005 f87c 	bl	d94a <z_priq_dumb_remove>
}
    8852:	e7ec      	b.n	882e <move_thread_to_end_of_prio_q+0xe>
	sys_dnode_t *const prev = successor->prev;
    8854:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    8856:	606b      	str	r3, [r5, #4]
	node->next = successor;
    8858:	602c      	str	r4, [r5, #0]
	prev->next = node;
    885a:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    885c:	6065      	str	r5, [r4, #4]
}
    885e:	e017      	b.n	8890 <move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8860:	2400      	movs	r4, #0
    8862:	b16c      	cbz	r4, 8880 <move_thread_to_end_of_prio_q+0x60>
		if (z_sched_prio_cmp(thread, t) > 0) {
    8864:	4621      	mov	r1, r4
    8866:	4628      	mov	r0, r5
    8868:	f005 f84b 	bl	d902 <z_sched_prio_cmp>
    886c:	2800      	cmp	r0, #0
    886e:	dcf1      	bgt.n	8854 <move_thread_to_end_of_prio_q+0x34>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    8870:	2c00      	cmp	r4, #0
    8872:	d0f6      	beq.n	8862 <move_thread_to_end_of_prio_q+0x42>
	return (node == list->tail) ? NULL : node->next;
    8874:	4b0b      	ldr	r3, [pc, #44]	; (88a4 <move_thread_to_end_of_prio_q+0x84>)
    8876:	6a1b      	ldr	r3, [r3, #32]
    8878:	429c      	cmp	r4, r3
    887a:	d0f1      	beq.n	8860 <move_thread_to_end_of_prio_q+0x40>
    887c:	6824      	ldr	r4, [r4, #0]
    887e:	e7f0      	b.n	8862 <move_thread_to_end_of_prio_q+0x42>
	sys_dnode_t *const tail = list->tail;
    8880:	4b08      	ldr	r3, [pc, #32]	; (88a4 <move_thread_to_end_of_prio_q+0x84>)
    8882:	6a1a      	ldr	r2, [r3, #32]
	node->next = list;
    8884:	f103 011c 	add.w	r1, r3, #28
    8888:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    888a:	606a      	str	r2, [r5, #4]
	tail->next = node;
    888c:	6015      	str	r5, [r2, #0]
	list->tail = node;
    888e:	621d      	str	r5, [r3, #32]
	update_cache(thread == _current);
    8890:	4b04      	ldr	r3, [pc, #16]	; (88a4 <move_thread_to_end_of_prio_q+0x84>)
    8892:	6898      	ldr	r0, [r3, #8]
    8894:	42a8      	cmp	r0, r5
    8896:	bf14      	ite	ne
    8898:	2000      	movne	r0, #0
    889a:	2001      	moveq	r0, #1
    889c:	f7ff ff98 	bl	87d0 <update_cache>
}
    88a0:	bd38      	pop	{r3, r4, r5, pc}
    88a2:	bf00      	nop
    88a4:	200013e0 	.word	0x200013e0
    88a8:	200013fc 	.word	0x200013fc

000088ac <z_time_slice>:
{
    88ac:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    88ae:	f04f 0220 	mov.w	r2, #32
    88b2:	f3ef 8311 	mrs	r3, BASEPRI
    88b6:	f382 8812 	msr	BASEPRI_MAX, r2
    88ba:	f3bf 8f6f 	isb	sy
    88be:	461d      	mov	r5, r3
	struct k_thread *curr = _current;
    88c0:	4b14      	ldr	r3, [pc, #80]	; (8914 <z_time_slice+0x68>)
    88c2:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
    88c4:	4b14      	ldr	r3, [pc, #80]	; (8918 <z_time_slice+0x6c>)
    88c6:	681b      	ldr	r3, [r3, #0]
    88c8:	42a3      	cmp	r3, r4
    88ca:	d017      	beq.n	88fc <z_time_slice+0x50>
	pending_current = NULL;
    88cc:	4b12      	ldr	r3, [pc, #72]	; (8918 <z_time_slice+0x6c>)
    88ce:	2200      	movs	r2, #0
    88d0:	601a      	str	r2, [r3, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
    88d2:	4b10      	ldr	r3, [pc, #64]	; (8914 <z_time_slice+0x68>)
    88d4:	7c1b      	ldrb	r3, [r3, #16]
    88d6:	4a11      	ldr	r2, [pc, #68]	; (891c <z_time_slice+0x70>)
    88d8:	5cd3      	ldrb	r3, [r2, r3]
    88da:	b153      	cbz	r3, 88f2 <z_time_slice+0x46>
    88dc:	4620      	mov	r0, r4
    88de:	f7ff fed9 	bl	8694 <sliceable>
    88e2:	b130      	cbz	r0, 88f2 <z_time_slice+0x46>
	uint8_t state = thread->base.thread_state;
    88e4:	7b63      	ldrb	r3, [r4, #13]
		if (!z_is_thread_prevented_from_running(curr)) {
    88e6:	f013 0f1f 	tst.w	r3, #31
    88ea:	d00f      	beq.n	890c <z_time_slice+0x60>
		z_reset_time_slice(curr);
    88ec:	4620      	mov	r0, r4
    88ee:	f7ff ff17 	bl	8720 <z_reset_time_slice>
	__asm__ volatile(
    88f2:	f385 8811 	msr	BASEPRI, r5
    88f6:	f3bf 8f6f 	isb	sy
}
    88fa:	bd38      	pop	{r3, r4, r5, pc}
		z_reset_time_slice(curr);
    88fc:	4620      	mov	r0, r4
    88fe:	f7ff ff0f 	bl	8720 <z_reset_time_slice>
    8902:	f385 8811 	msr	BASEPRI, r5
    8906:	f3bf 8f6f 	isb	sy
		return;
    890a:	e7f6      	b.n	88fa <z_time_slice+0x4e>
			move_thread_to_end_of_prio_q(curr);
    890c:	4620      	mov	r0, r4
    890e:	f7ff ff87 	bl	8820 <move_thread_to_end_of_prio_q>
    8912:	e7eb      	b.n	88ec <z_time_slice+0x40>
    8914:	200013e0 	.word	0x200013e0
    8918:	20001404 	.word	0x20001404
    891c:	20001408 	.word	0x20001408

00008920 <ready_thread>:
	return (thread->base.thread_state & state) != 0U;
    8920:	7b42      	ldrb	r2, [r0, #13]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    8922:	f990 300d 	ldrsb.w	r3, [r0, #13]
    8926:	2b00      	cmp	r3, #0
    8928:	db33      	blt.n	8992 <ready_thread+0x72>
{
    892a:	b570      	push	{r4, r5, r6, lr}
    892c:	4604      	mov	r4, r0
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    892e:	f012 0f1f 	tst.w	r2, #31
    8932:	d101      	bne.n	8938 <ready_thread+0x18>
	return node->next != NULL;
    8934:	6986      	ldr	r6, [r0, #24]
    8936:	b106      	cbz	r6, 893a <ready_thread+0x1a>
}
    8938:	bd70      	pop	{r4, r5, r6, pc}
	thread->base.thread_state |= _THREAD_QUEUED;
    893a:	f062 027f 	orn	r2, r2, #127	; 0x7f
    893e:	7342      	strb	r2, [r0, #13]
	return list->head == list;
    8940:	4b14      	ldr	r3, [pc, #80]	; (8994 <ready_thread+0x74>)
    8942:	f853 5f1c 	ldr.w	r5, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8946:	429d      	cmp	r5, r3
    8948:	d108      	bne.n	895c <ready_thread+0x3c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    894a:	4635      	mov	r5, r6
    894c:	e006      	b.n	895c <ready_thread+0x3c>
	sys_dnode_t *const prev = successor->prev;
    894e:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
    8950:	6063      	str	r3, [r4, #4]
	node->next = successor;
    8952:	6025      	str	r5, [r4, #0]
	prev->next = node;
    8954:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    8956:	606c      	str	r4, [r5, #4]
}
    8958:	e017      	b.n	898a <ready_thread+0x6a>
    895a:	4635      	mov	r5, r6
    895c:	b16d      	cbz	r5, 897a <ready_thread+0x5a>
		if (z_sched_prio_cmp(thread, t) > 0) {
    895e:	4629      	mov	r1, r5
    8960:	4620      	mov	r0, r4
    8962:	f004 ffce 	bl	d902 <z_sched_prio_cmp>
    8966:	2800      	cmp	r0, #0
    8968:	dcf1      	bgt.n	894e <ready_thread+0x2e>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    896a:	2d00      	cmp	r5, #0
    896c:	d0f6      	beq.n	895c <ready_thread+0x3c>
	return (node == list->tail) ? NULL : node->next;
    896e:	4b09      	ldr	r3, [pc, #36]	; (8994 <ready_thread+0x74>)
    8970:	6a1b      	ldr	r3, [r3, #32]
    8972:	429d      	cmp	r5, r3
    8974:	d0f1      	beq.n	895a <ready_thread+0x3a>
    8976:	682d      	ldr	r5, [r5, #0]
    8978:	e7f0      	b.n	895c <ready_thread+0x3c>
	sys_dnode_t *const tail = list->tail;
    897a:	4b06      	ldr	r3, [pc, #24]	; (8994 <ready_thread+0x74>)
    897c:	6a1a      	ldr	r2, [r3, #32]
	node->next = list;
    897e:	f103 011c 	add.w	r1, r3, #28
    8982:	6021      	str	r1, [r4, #0]
	node->prev = tail;
    8984:	6062      	str	r2, [r4, #4]
	tail->next = node;
    8986:	6014      	str	r4, [r2, #0]
	list->tail = node;
    8988:	621c      	str	r4, [r3, #32]
		update_cache(0);
    898a:	2000      	movs	r0, #0
    898c:	f7ff ff20 	bl	87d0 <update_cache>
}
    8990:	e7d2      	b.n	8938 <ready_thread+0x18>
    8992:	4770      	bx	lr
    8994:	200013e0 	.word	0x200013e0

00008998 <z_sched_start>:
{
    8998:	b510      	push	{r4, lr}
	__asm__ volatile(
    899a:	f04f 0320 	mov.w	r3, #32
    899e:	f3ef 8411 	mrs	r4, BASEPRI
    89a2:	f383 8812 	msr	BASEPRI_MAX, r3
    89a6:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    89aa:	7b43      	ldrb	r3, [r0, #13]
	if (z_has_thread_started(thread)) {
    89ac:	f013 0f04 	tst.w	r3, #4
    89b0:	d104      	bne.n	89bc <z_sched_start+0x24>
	__asm__ volatile(
    89b2:	f384 8811 	msr	BASEPRI, r4
    89b6:	f3bf 8f6f 	isb	sy
}
    89ba:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    89bc:	f023 0304 	bic.w	r3, r3, #4
    89c0:	7343      	strb	r3, [r0, #13]
	ready_thread(thread);
    89c2:	f7ff ffad 	bl	8920 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    89c6:	4621      	mov	r1, r4
    89c8:	4801      	ldr	r0, [pc, #4]	; (89d0 <z_sched_start+0x38>)
    89ca:	f7ff fed1 	bl	8770 <z_reschedule>
    89ce:	e7f4      	b.n	89ba <z_sched_start+0x22>
    89d0:	20001414 	.word	0x20001414

000089d4 <unready_thread>:
{
    89d4:	b510      	push	{r4, lr}
    89d6:	4604      	mov	r4, r0
	return (thread->base.thread_state & state) != 0U;
    89d8:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    89da:	f990 300d 	ldrsb.w	r3, [r0, #13]
    89de:	2b00      	cmp	r3, #0
    89e0:	db08      	blt.n	89f4 <unready_thread+0x20>
	update_cache(thread == _current);
    89e2:	4b08      	ldr	r3, [pc, #32]	; (8a04 <unready_thread+0x30>)
    89e4:	6898      	ldr	r0, [r3, #8]
    89e6:	42a0      	cmp	r0, r4
    89e8:	bf14      	ite	ne
    89ea:	2000      	movne	r0, #0
    89ec:	2001      	moveq	r0, #1
    89ee:	f7ff feef 	bl	87d0 <update_cache>
}
    89f2:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    89f4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    89f8:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    89fa:	4601      	mov	r1, r0
    89fc:	4802      	ldr	r0, [pc, #8]	; (8a08 <unready_thread+0x34>)
    89fe:	f004 ffa4 	bl	d94a <z_priq_dumb_remove>
}
    8a02:	e7ee      	b.n	89e2 <unready_thread+0xe>
    8a04:	200013e0 	.word	0x200013e0
    8a08:	200013fc 	.word	0x200013fc

00008a0c <z_pend_curr>:
{
    8a0c:	b510      	push	{r4, lr}
    8a0e:	460c      	mov	r4, r1
    8a10:	4611      	mov	r1, r2
	pending_current = _current;
    8a12:	480a      	ldr	r0, [pc, #40]	; (8a3c <z_pend_curr+0x30>)
    8a14:	6882      	ldr	r2, [r0, #8]
    8a16:	4b0a      	ldr	r3, [pc, #40]	; (8a40 <z_pend_curr+0x34>)
    8a18:	601a      	str	r2, [r3, #0]
	__asm__ volatile(
    8a1a:	f04f 0220 	mov.w	r2, #32
    8a1e:	f3ef 8311 	mrs	r3, BASEPRI
    8a22:	f382 8812 	msr	BASEPRI_MAX, r2
    8a26:	f3bf 8f6f 	isb	sy
	pend_locked(_current, wait_q, timeout);
    8a2a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    8a2e:	6880      	ldr	r0, [r0, #8]
    8a30:	f005 f851 	bl	dad6 <pend_locked>
    8a34:	4620      	mov	r0, r4
    8a36:	f7f8 feed 	bl	1814 <arch_swap>
}
    8a3a:	bd10      	pop	{r4, pc}
    8a3c:	200013e0 	.word	0x200013e0
    8a40:	20001404 	.word	0x20001404

00008a44 <z_set_prio>:
{
    8a44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8a48:	4605      	mov	r5, r0
    8a4a:	460f      	mov	r7, r1
	LOCKED(&sched_spinlock) {
    8a4c:	2300      	movs	r3, #0
    8a4e:	f04f 0220 	mov.w	r2, #32
    8a52:	f3ef 8611 	mrs	r6, BASEPRI
    8a56:	f382 8812 	msr	BASEPRI_MAX, r2
    8a5a:	f3bf 8f6f 	isb	sy
	bool need_sched = 0;
    8a5e:	4618      	mov	r0, r3
    8a60:	e029      	b.n	8ab6 <z_set_prio+0x72>
	sys_dnode_t *const prev = successor->prev;
    8a62:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    8a64:	606b      	str	r3, [r5, #4]
	node->next = successor;
    8a66:	602c      	str	r4, [r5, #0]
	prev->next = node;
    8a68:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    8a6a:	6065      	str	r5, [r4, #4]
}
    8a6c:	e017      	b.n	8a9e <z_set_prio+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8a6e:	4644      	mov	r4, r8
    8a70:	b16c      	cbz	r4, 8a8e <z_set_prio+0x4a>
		if (z_sched_prio_cmp(thread, t) > 0) {
    8a72:	4621      	mov	r1, r4
    8a74:	4628      	mov	r0, r5
    8a76:	f004 ff44 	bl	d902 <z_sched_prio_cmp>
    8a7a:	2800      	cmp	r0, #0
    8a7c:	dcf1      	bgt.n	8a62 <z_set_prio+0x1e>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    8a7e:	2c00      	cmp	r4, #0
    8a80:	d0f6      	beq.n	8a70 <z_set_prio+0x2c>
	return (node == list->tail) ? NULL : node->next;
    8a82:	4b1d      	ldr	r3, [pc, #116]	; (8af8 <z_set_prio+0xb4>)
    8a84:	6a1b      	ldr	r3, [r3, #32]
    8a86:	429c      	cmp	r4, r3
    8a88:	d0f1      	beq.n	8a6e <z_set_prio+0x2a>
    8a8a:	6824      	ldr	r4, [r4, #0]
    8a8c:	e7f0      	b.n	8a70 <z_set_prio+0x2c>
	sys_dnode_t *const tail = list->tail;
    8a8e:	4b1a      	ldr	r3, [pc, #104]	; (8af8 <z_set_prio+0xb4>)
    8a90:	6a1a      	ldr	r2, [r3, #32]
	node->next = list;
    8a92:	f103 011c 	add.w	r1, r3, #28
    8a96:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    8a98:	606a      	str	r2, [r5, #4]
	tail->next = node;
    8a9a:	6015      	str	r5, [r2, #0]
	list->tail = node;
    8a9c:	621d      	str	r5, [r3, #32]
			update_cache(1);
    8a9e:	2001      	movs	r0, #1
    8aa0:	f7ff fe96 	bl	87d0 <update_cache>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    8aa4:	2001      	movs	r0, #1
    8aa6:	e001      	b.n	8aac <z_set_prio+0x68>
			thread->base.prio = prio;
    8aa8:	73af      	strb	r7, [r5, #14]
    8aaa:	2000      	movs	r0, #0
	__asm__ volatile(
    8aac:	f386 8811 	msr	BASEPRI, r6
    8ab0:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    8ab4:	2301      	movs	r3, #1
    8ab6:	b9e3      	cbnz	r3, 8af2 <z_set_prio+0xae>
	uint8_t state = thread->base.thread_state;
    8ab8:	7b6b      	ldrb	r3, [r5, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    8aba:	f013 0f1f 	tst.w	r3, #31
    8abe:	d1f3      	bne.n	8aa8 <z_set_prio+0x64>
	return node->next != NULL;
    8ac0:	f8d5 8018 	ldr.w	r8, [r5, #24]
    8ac4:	f1b8 0f00 	cmp.w	r8, #0
    8ac8:	d1ee      	bne.n	8aa8 <z_set_prio+0x64>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8aca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    8ace:	736b      	strb	r3, [r5, #13]
	_priq_run_remove(thread_runq(thread), thread);
    8ad0:	f8df 9028 	ldr.w	r9, [pc, #40]	; 8afc <z_set_prio+0xb8>
    8ad4:	4629      	mov	r1, r5
    8ad6:	4648      	mov	r0, r9
    8ad8:	f004 ff37 	bl	d94a <z_priq_dumb_remove>
				thread->base.prio = prio;
    8adc:	73af      	strb	r7, [r5, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
    8ade:	7b6b      	ldrb	r3, [r5, #13]
    8ae0:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8ae4:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    8ae6:	f8d9 4000 	ldr.w	r4, [r9]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8aea:	454c      	cmp	r4, r9
    8aec:	d1c0      	bne.n	8a70 <z_set_prio+0x2c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8aee:	4644      	mov	r4, r8
    8af0:	e7be      	b.n	8a70 <z_set_prio+0x2c>
}
    8af2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8af6:	bf00      	nop
    8af8:	200013e0 	.word	0x200013e0
    8afc:	200013fc 	.word	0x200013fc

00008b00 <z_impl_k_thread_suspend>:
{
    8b00:	b538      	push	{r3, r4, r5, lr}
    8b02:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    8b04:	3018      	adds	r0, #24
    8b06:	f005 f85c 	bl	dbc2 <z_abort_timeout>
	LOCKED(&sched_spinlock) {
    8b0a:	2300      	movs	r3, #0
	__asm__ volatile(
    8b0c:	f04f 0220 	mov.w	r2, #32
    8b10:	f3ef 8511 	mrs	r5, BASEPRI
    8b14:	f382 8812 	msr	BASEPRI_MAX, r2
    8b18:	f3bf 8f6f 	isb	sy
    8b1c:	e010      	b.n	8b40 <z_impl_k_thread_suspend+0x40>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    8b1e:	7b63      	ldrb	r3, [r4, #13]
    8b20:	f043 0310 	orr.w	r3, r3, #16
    8b24:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    8b26:	4b11      	ldr	r3, [pc, #68]	; (8b6c <z_impl_k_thread_suspend+0x6c>)
    8b28:	6898      	ldr	r0, [r3, #8]
    8b2a:	42a0      	cmp	r0, r4
    8b2c:	bf14      	ite	ne
    8b2e:	2000      	movne	r0, #0
    8b30:	2001      	moveq	r0, #1
    8b32:	f7ff fe4d 	bl	87d0 <update_cache>
	__asm__ volatile(
    8b36:	f385 8811 	msr	BASEPRI, r5
    8b3a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    8b3e:	2301      	movs	r3, #1
    8b40:	b963      	cbnz	r3, 8b5c <z_impl_k_thread_suspend+0x5c>
	return (thread->base.thread_state & state) != 0U;
    8b42:	7b62      	ldrb	r2, [r4, #13]
		if (z_is_thread_queued(thread)) {
    8b44:	f994 300d 	ldrsb.w	r3, [r4, #13]
    8b48:	2b00      	cmp	r3, #0
    8b4a:	dae8      	bge.n	8b1e <z_impl_k_thread_suspend+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8b4c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    8b50:	7362      	strb	r2, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
    8b52:	4621      	mov	r1, r4
    8b54:	4806      	ldr	r0, [pc, #24]	; (8b70 <z_impl_k_thread_suspend+0x70>)
    8b56:	f004 fef8 	bl	d94a <z_priq_dumb_remove>
}
    8b5a:	e7e0      	b.n	8b1e <z_impl_k_thread_suspend+0x1e>
	if (thread == _current) {
    8b5c:	4b03      	ldr	r3, [pc, #12]	; (8b6c <z_impl_k_thread_suspend+0x6c>)
    8b5e:	689b      	ldr	r3, [r3, #8]
    8b60:	42a3      	cmp	r3, r4
    8b62:	d000      	beq.n	8b66 <z_impl_k_thread_suspend+0x66>
}
    8b64:	bd38      	pop	{r3, r4, r5, pc}
		z_reschedule_unlocked();
    8b66:	f004 fee4 	bl	d932 <z_reschedule_unlocked>
}
    8b6a:	e7fb      	b.n	8b64 <z_impl_k_thread_suspend+0x64>
    8b6c:	200013e0 	.word	0x200013e0
    8b70:	200013fc 	.word	0x200013fc

00008b74 <k_sched_unlock>:

void k_sched_unlock(void)
{
    8b74:	b510      	push	{r4, lr}
	LOCKED(&sched_spinlock) {
    8b76:	2300      	movs	r3, #0
	__asm__ volatile(
    8b78:	f04f 0220 	mov.w	r2, #32
    8b7c:	f3ef 8411 	mrs	r4, BASEPRI
    8b80:	f382 8812 	msr	BASEPRI_MAX, r2
    8b84:	f3bf 8f6f 	isb	sy
    8b88:	e00c      	b.n	8ba4 <k_sched_unlock+0x30>
		__ASSERT(_current->base.sched_locked != 0U, "");
		__ASSERT(!arch_is_in_isr(), "");

		++_current->base.sched_locked;
    8b8a:	4b09      	ldr	r3, [pc, #36]	; (8bb0 <k_sched_unlock+0x3c>)
    8b8c:	689a      	ldr	r2, [r3, #8]
    8b8e:	7bd3      	ldrb	r3, [r2, #15]
    8b90:	3301      	adds	r3, #1
    8b92:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    8b94:	2000      	movs	r0, #0
    8b96:	f7ff fe1b 	bl	87d0 <update_cache>
	__asm__ volatile(
    8b9a:	f384 8811 	msr	BASEPRI, r4
    8b9e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    8ba2:	2301      	movs	r3, #1
    8ba4:	2b00      	cmp	r3, #0
    8ba6:	d0f0      	beq.n	8b8a <k_sched_unlock+0x16>
	LOG_DBG("scheduler unlocked (%p:%d)",
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
    8ba8:	f004 fec3 	bl	d932 <z_reschedule_unlocked>
}
    8bac:	bd10      	pop	{r4, pc}
    8bae:	bf00      	nop
    8bb0:	200013e0 	.word	0x200013e0

00008bb4 <end_thread>:
static void end_thread(struct k_thread *thread)
{
	/* We hold the lock, and the thread is known not to be running
	 * anywhere.
	 */
	if ((thread->base.thread_state & _THREAD_DEAD) == 0U) {
    8bb4:	7b43      	ldrb	r3, [r0, #13]
    8bb6:	f013 0f08 	tst.w	r3, #8
    8bba:	d127      	bne.n	8c0c <end_thread+0x58>
{
    8bbc:	b510      	push	{r4, lr}
    8bbe:	4604      	mov	r4, r0
		thread->base.thread_state |= _THREAD_DEAD;
    8bc0:	f043 0208 	orr.w	r2, r3, #8
    8bc4:	7342      	strb	r2, [r0, #13]
		thread->base.thread_state &= ~_THREAD_ABORTING;
    8bc6:	f023 0220 	bic.w	r2, r3, #32
    8bca:	f042 0208 	orr.w	r2, r2, #8
    8bce:	7342      	strb	r2, [r0, #13]
		if (z_is_thread_queued(thread)) {
    8bd0:	f012 0f80 	tst.w	r2, #128	; 0x80
    8bd4:	d110      	bne.n	8bf8 <end_thread+0x44>
			dequeue_thread(thread);
		}
		if (thread->base.pended_on != NULL) {
    8bd6:	68a3      	ldr	r3, [r4, #8]
    8bd8:	b113      	cbz	r3, 8be0 <end_thread+0x2c>
			unpend_thread_no_timeout(thread);
    8bda:	4620      	mov	r0, r4
    8bdc:	f004 febd 	bl	d95a <unpend_thread_no_timeout>
    8be0:	f104 0018 	add.w	r0, r4, #24
    8be4:	f004 ffed 	bl	dbc2 <z_abort_timeout>
		}
		(void)z_abort_thread_timeout(thread);
		unpend_all(&thread->join_queue);
    8be8:	f104 0058 	add.w	r0, r4, #88	; 0x58
    8bec:	f004 ff34 	bl	da58 <unpend_all>
		update_cache(1);
    8bf0:	2001      	movs	r0, #1
    8bf2:	f7ff fded 	bl	87d0 <update_cache>
		z_thread_perms_all_clear(thread);
		z_object_uninit(thread->stack_obj);
		z_object_uninit(thread);
#endif
	}
}
    8bf6:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8bf8:	f003 035f 	and.w	r3, r3, #95	; 0x5f
    8bfc:	f043 0308 	orr.w	r3, r3, #8
    8c00:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    8c02:	4601      	mov	r1, r0
    8c04:	4802      	ldr	r0, [pc, #8]	; (8c10 <end_thread+0x5c>)
    8c06:	f004 fea0 	bl	d94a <z_priq_dumb_remove>
}
    8c0a:	e7e4      	b.n	8bd6 <end_thread+0x22>
    8c0c:	4770      	bx	lr
    8c0e:	bf00      	nop
    8c10:	200013fc 	.word	0x200013fc

00008c14 <z_sched_init>:
{
    8c14:	b508      	push	{r3, lr}
	init_ready_q(&_kernel.ready_q);
    8c16:	4802      	ldr	r0, [pc, #8]	; (8c20 <z_sched_init+0xc>)
    8c18:	f004 ff9b 	bl	db52 <init_ready_q>
}
    8c1c:	bd08      	pop	{r3, pc}
    8c1e:	bf00      	nop
    8c20:	200013f8 	.word	0x200013f8

00008c24 <z_impl_k_yield>:
{
    8c24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    8c26:	f04f 0320 	mov.w	r3, #32
    8c2a:	f3ef 8611 	mrs	r6, BASEPRI
    8c2e:	f383 8812 	msr	BASEPRI_MAX, r3
    8c32:	f3bf 8f6f 	isb	sy
		dequeue_thread(_current);
    8c36:	4c1d      	ldr	r4, [pc, #116]	; (8cac <z_impl_k_yield+0x88>)
    8c38:	68a1      	ldr	r1, [r4, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    8c3a:	7b4b      	ldrb	r3, [r1, #13]
    8c3c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    8c40:	734b      	strb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
    8c42:	f104 071c 	add.w	r7, r4, #28
    8c46:	4638      	mov	r0, r7
    8c48:	f004 fe7f 	bl	d94a <z_priq_dumb_remove>
	queue_thread(_current);
    8c4c:	68a5      	ldr	r5, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    8c4e:	7b6b      	ldrb	r3, [r5, #13]
    8c50:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8c54:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    8c56:	69e4      	ldr	r4, [r4, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8c58:	42bc      	cmp	r4, r7
    8c5a:	d108      	bne.n	8c6e <z_impl_k_yield+0x4a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8c5c:	2400      	movs	r4, #0
    8c5e:	e006      	b.n	8c6e <z_impl_k_yield+0x4a>
	sys_dnode_t *const prev = successor->prev;
    8c60:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    8c62:	606b      	str	r3, [r5, #4]
	node->next = successor;
    8c64:	602c      	str	r4, [r5, #0]
	prev->next = node;
    8c66:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    8c68:	6065      	str	r5, [r4, #4]
}
    8c6a:	e017      	b.n	8c9c <z_impl_k_yield+0x78>
    8c6c:	2400      	movs	r4, #0
    8c6e:	b16c      	cbz	r4, 8c8c <z_impl_k_yield+0x68>
		if (z_sched_prio_cmp(thread, t) > 0) {
    8c70:	4621      	mov	r1, r4
    8c72:	4628      	mov	r0, r5
    8c74:	f004 fe45 	bl	d902 <z_sched_prio_cmp>
    8c78:	2800      	cmp	r0, #0
    8c7a:	dcf1      	bgt.n	8c60 <z_impl_k_yield+0x3c>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    8c7c:	2c00      	cmp	r4, #0
    8c7e:	d0f6      	beq.n	8c6e <z_impl_k_yield+0x4a>
	return (node == list->tail) ? NULL : node->next;
    8c80:	4b0a      	ldr	r3, [pc, #40]	; (8cac <z_impl_k_yield+0x88>)
    8c82:	6a1b      	ldr	r3, [r3, #32]
    8c84:	429c      	cmp	r4, r3
    8c86:	d0f1      	beq.n	8c6c <z_impl_k_yield+0x48>
    8c88:	6824      	ldr	r4, [r4, #0]
    8c8a:	e7f0      	b.n	8c6e <z_impl_k_yield+0x4a>
	sys_dnode_t *const tail = list->tail;
    8c8c:	4b07      	ldr	r3, [pc, #28]	; (8cac <z_impl_k_yield+0x88>)
    8c8e:	6a1a      	ldr	r2, [r3, #32]
	node->next = list;
    8c90:	f103 011c 	add.w	r1, r3, #28
    8c94:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    8c96:	606a      	str	r2, [r5, #4]
	tail->next = node;
    8c98:	6015      	str	r5, [r2, #0]
	list->tail = node;
    8c9a:	621d      	str	r5, [r3, #32]
	update_cache(1);
    8c9c:	2001      	movs	r0, #1
    8c9e:	f7ff fd97 	bl	87d0 <update_cache>
    8ca2:	4630      	mov	r0, r6
    8ca4:	f7f8 fdb6 	bl	1814 <arch_swap>
}
    8ca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8caa:	bf00      	nop
    8cac:	200013e0 	.word	0x200013e0

00008cb0 <z_tick_sleep>:
{
    8cb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (ticks == 0) {
    8cb4:	ea50 0301 	orrs.w	r3, r0, r1
    8cb8:	d038      	beq.n	8d2c <z_tick_sleep+0x7c>
    8cba:	4604      	mov	r4, r0
    8cbc:	460e      	mov	r6, r1
	if (Z_TICK_ABS(ticks) <= 0) {
    8cbe:	f06f 0301 	mvn.w	r3, #1
    8cc2:	1a1b      	subs	r3, r3, r0
    8cc4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    8cc8:	eb62 0201 	sbc.w	r2, r2, r1
    8ccc:	2b01      	cmp	r3, #1
    8cce:	f172 0200 	sbcs.w	r2, r2, #0
    8cd2:	db2f      	blt.n	8d34 <z_tick_sleep+0x84>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    8cd4:	f06f 0501 	mvn.w	r5, #1
    8cd8:	1a2d      	subs	r5, r5, r0
    8cda:	f04f 0320 	mov.w	r3, #32
    8cde:	f3ef 8811 	mrs	r8, BASEPRI
    8ce2:	f383 8812 	msr	BASEPRI_MAX, r3
    8ce6:	f3bf 8f6f 	isb	sy
	pending_current = _current;
    8cea:	4f14      	ldr	r7, [pc, #80]	; (8d3c <z_tick_sleep+0x8c>)
    8cec:	68b8      	ldr	r0, [r7, #8]
    8cee:	4b14      	ldr	r3, [pc, #80]	; (8d40 <z_tick_sleep+0x90>)
    8cf0:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
    8cf2:	f7ff fe6f 	bl	89d4 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    8cf6:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    8cf8:	4622      	mov	r2, r4
    8cfa:	4633      	mov	r3, r6
    8cfc:	4911      	ldr	r1, [pc, #68]	; (8d44 <z_tick_sleep+0x94>)
    8cfe:	3018      	adds	r0, #24
    8d00:	f000 f8c6 	bl	8e90 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    8d04:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    8d06:	7b53      	ldrb	r3, [r2, #13]
    8d08:	f043 0310 	orr.w	r3, r3, #16
    8d0c:	7353      	strb	r3, [r2, #13]
    8d0e:	4640      	mov	r0, r8
    8d10:	f7f8 fd80 	bl	1814 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    8d14:	f004 ff8a 	bl	dc2c <sys_clock_tick_get_32>
    8d18:	1a28      	subs	r0, r5, r0
    8d1a:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
    8d1e:	2801      	cmp	r0, #1
    8d20:	f173 0300 	sbcs.w	r3, r3, #0
    8d24:	da00      	bge.n	8d28 <z_tick_sleep+0x78>
	return 0;
    8d26:	2000      	movs	r0, #0
}
    8d28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	z_impl_k_yield();
    8d2c:	f7ff ff7a 	bl	8c24 <z_impl_k_yield>
		return 0;
    8d30:	2000      	movs	r0, #0
    8d32:	e7f9      	b.n	8d28 <z_tick_sleep+0x78>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    8d34:	f004 ff7a 	bl	dc2c <sys_clock_tick_get_32>
    8d38:	1905      	adds	r5, r0, r4
    8d3a:	e7ce      	b.n	8cda <z_tick_sleep+0x2a>
    8d3c:	200013e0 	.word	0x200013e0
    8d40:	20001404 	.word	0x20001404
    8d44:	0000da4d 	.word	0x0000da4d

00008d48 <z_impl_k_sleep>:
{
    8d48:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    8d4a:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    8d4e:	bf08      	it	eq
    8d50:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
    8d54:	d018      	beq.n	8d88 <z_impl_k_sleep+0x40>
	ticks = z_tick_sleep(ticks);
    8d56:	f7ff ffab 	bl	8cb0 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    8d5a:	17c2      	asrs	r2, r0, #31
    8d5c:	0151      	lsls	r1, r2, #5
    8d5e:	ea41 61d0 	orr.w	r1, r1, r0, lsr #27
    8d62:	0143      	lsls	r3, r0, #5
    8d64:	1a1b      	subs	r3, r3, r0
    8d66:	eb61 0102 	sbc.w	r1, r1, r2
    8d6a:	0089      	lsls	r1, r1, #2
    8d6c:	ea41 7193 	orr.w	r1, r1, r3, lsr #30
    8d70:	009b      	lsls	r3, r3, #2
    8d72:	181b      	adds	r3, r3, r0
    8d74:	eb42 0201 	adc.w	r2, r2, r1
    8d78:	00d2      	lsls	r2, r2, #3
    8d7a:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
    8d7e:	f3c3 3310 	ubfx	r3, r3, #12, #17
    8d82:	ea43 4042 	orr.w	r0, r3, r2, lsl #17
}
    8d86:	bd08      	pop	{r3, pc}
		k_thread_suspend(_current);
    8d88:	4b03      	ldr	r3, [pc, #12]	; (8d98 <z_impl_k_sleep+0x50>)
    8d8a:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    8d8c:	f7ff feb8 	bl	8b00 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    8d90:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8d94:	e7f7      	b.n	8d86 <z_impl_k_sleep+0x3e>
    8d96:	bf00      	nop
    8d98:	200013e0 	.word	0x200013e0

00008d9c <z_impl_z_current_get>:
}
    8d9c:	4b01      	ldr	r3, [pc, #4]	; (8da4 <z_impl_z_current_get+0x8>)
    8d9e:	6898      	ldr	r0, [r3, #8]
    8da0:	4770      	bx	lr
    8da2:	bf00      	nop
    8da4:	200013e0 	.word	0x200013e0

00008da8 <z_thread_abort>:

void z_thread_abort(struct k_thread *thread)
{
    8da8:	b570      	push	{r4, r5, r6, lr}
    8daa:	f04f 0320 	mov.w	r3, #32
    8dae:	f3ef 8511 	mrs	r5, BASEPRI
    8db2:	f383 8812 	msr	BASEPRI_MAX, r3
    8db6:	f3bf 8f6f 	isb	sy
    8dba:	462e      	mov	r6, r5
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
    8dbc:	7b03      	ldrb	r3, [r0, #12]
    8dbe:	f013 0f01 	tst.w	r3, #1
    8dc2:	d109      	bne.n	8dd8 <z_thread_abort+0x30>
    8dc4:	4604      	mov	r4, r0
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
		return;
	}

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    8dc6:	7b43      	ldrb	r3, [r0, #13]
    8dc8:	f013 0f08 	tst.w	r3, #8
    8dcc:	d00f      	beq.n	8dee <z_thread_abort+0x46>
	__asm__ volatile(
    8dce:	f385 8811 	msr	BASEPRI, r5
    8dd2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		return;
    8dd6:	e009      	b.n	8dec <z_thread_abort+0x44>
    8dd8:	f385 8811 	msr	BASEPRI, r5
    8ddc:	f3bf 8f6f 	isb	sy
		k_panic();
    8de0:	4040      	eors	r0, r0
    8de2:	f380 8811 	msr	BASEPRI, r0
    8de6:	f04f 0004 	mov.w	r0, #4
    8dea:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    8dec:	bd70      	pop	{r4, r5, r6, pc}
	end_thread(thread);
    8dee:	f7ff fee1 	bl	8bb4 <end_thread>
	if (thread == _current && !arch_is_in_isr()) {
    8df2:	4b08      	ldr	r3, [pc, #32]	; (8e14 <z_thread_abort+0x6c>)
    8df4:	689b      	ldr	r3, [r3, #8]
    8df6:	42a3      	cmp	r3, r4
    8df8:	d004      	beq.n	8e04 <z_thread_abort+0x5c>
    8dfa:	f386 8811 	msr	BASEPRI, r6
    8dfe:	f3bf 8f6f 	isb	sy
    8e02:	e7f3      	b.n	8dec <z_thread_abort+0x44>
    8e04:	f3ef 8305 	mrs	r3, IPSR
    8e08:	2b00      	cmp	r3, #0
    8e0a:	d1f6      	bne.n	8dfa <z_thread_abort+0x52>
    8e0c:	4628      	mov	r0, r5
    8e0e:	f7f8 fd01 	bl	1814 <arch_swap>
	return ret;
    8e12:	e7f2      	b.n	8dfa <z_thread_abort+0x52>
    8e14:	200013e0 	.word	0x200013e0

00008e18 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
    8e18:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
    8e1a:	4806      	ldr	r0, [pc, #24]	; (8e34 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
    8e1c:	4a06      	ldr	r2, [pc, #24]	; (8e38 <z_data_copy+0x20>)
    8e1e:	1a12      	subs	r2, r2, r0
    8e20:	4906      	ldr	r1, [pc, #24]	; (8e3c <z_data_copy+0x24>)
    8e22:	f004 fc3b 	bl	d69c <z_early_memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
    8e26:	4a06      	ldr	r2, [pc, #24]	; (8e40 <z_data_copy+0x28>)
    8e28:	4906      	ldr	r1, [pc, #24]	; (8e44 <z_data_copy+0x2c>)
    8e2a:	4807      	ldr	r0, [pc, #28]	; (8e48 <z_data_copy+0x30>)
    8e2c:	f004 fc36 	bl	d69c <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    8e30:	bd08      	pop	{r3, pc}
    8e32:	bf00      	nop
    8e34:	20000000 	.word	0x20000000
    8e38:	2000035c 	.word	0x2000035c
    8e3c:	0000f900 	.word	0x0000f900
    8e40:	00000000 	.word	0x00000000
    8e44:	0000f900 	.word	0x0000f900
    8e48:	20000000 	.word	0x20000000

00008e4c <first>:
	return list->head == list;
    8e4c:	4b03      	ldr	r3, [pc, #12]	; (8e5c <first+0x10>)
    8e4e:	6818      	ldr	r0, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8e50:	4298      	cmp	r0, r3
    8e52:	d000      	beq.n	8e56 <first+0xa>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
    8e54:	4770      	bx	lr
    8e56:	2000      	movs	r0, #0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    8e58:	e7fc      	b.n	8e54 <first+0x8>
    8e5a:	bf00      	nop
    8e5c:	2000024c 	.word	0x2000024c

00008e60 <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    8e60:	b130      	cbz	r0, 8e70 <next+0x10>
	return (node == list->tail) ? NULL : node->next;
    8e62:	4a04      	ldr	r2, [pc, #16]	; (8e74 <next+0x14>)
    8e64:	6852      	ldr	r2, [r2, #4]
    8e66:	4290      	cmp	r0, r2
    8e68:	d001      	beq.n	8e6e <next+0xe>
    8e6a:	6800      	ldr	r0, [r0, #0]
    8e6c:	4770      	bx	lr
    8e6e:	2000      	movs	r0, #0
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
    8e70:	4770      	bx	lr
    8e72:	bf00      	nop
    8e74:	2000024c 	.word	0x2000024c

00008e78 <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
    8e78:	b508      	push	{r3, lr}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    8e7a:	4b04      	ldr	r3, [pc, #16]	; (8e8c <elapsed+0x14>)
    8e7c:	681b      	ldr	r3, [r3, #0]
    8e7e:	b10b      	cbz	r3, 8e84 <elapsed+0xc>
    8e80:	2000      	movs	r0, #0
}
    8e82:	bd08      	pop	{r3, pc}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    8e84:	f7fb fa62 	bl	434c <sys_clock_elapsed>
    8e88:	e7fb      	b.n	8e82 <elapsed+0xa>
    8e8a:	bf00      	nop
    8e8c:	20001414 	.word	0x20001414

00008e90 <z_add_timeout>:
}

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    8e90:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    8e94:	bf08      	it	eq
    8e96:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    8e9a:	d074      	beq.n	8f86 <z_add_timeout+0xf6>
{
    8e9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8ea0:	4604      	mov	r4, r0
    8ea2:	4692      	mov	sl, r2
    8ea4:	461d      	mov	r5, r3
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    8ea6:	6081      	str	r1, [r0, #8]

	LOCKED(&timeout_lock) {
    8ea8:	2300      	movs	r3, #0
	__asm__ volatile(
    8eaa:	f04f 0220 	mov.w	r2, #32
    8eae:	f3ef 8711 	mrs	r7, BASEPRI
    8eb2:	f382 8812 	msr	BASEPRI_MAX, r2
    8eb6:	f3bf 8f6f 	isb	sy
    8eba:	e026      	b.n	8f0a <z_add_timeout+0x7a>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;

			to->dticks = MAX(1, ticks);
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    8ebc:	f11a 0801 	adds.w	r8, sl, #1
    8ec0:	f145 0900 	adc.w	r9, r5, #0
    8ec4:	f7ff ffd8 	bl	8e78 <elapsed>
    8ec8:	eb18 0300 	adds.w	r3, r8, r0
    8ecc:	eb49 70e0 	adc.w	r0, r9, r0, asr #31
    8ed0:	6123      	str	r3, [r4, #16]
    8ed2:	6160      	str	r0, [r4, #20]
    8ed4:	e03b      	b.n	8f4e <z_add_timeout+0xbe>
		}

		for (t = first(); t != NULL; t = next(t)) {
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
    8ed6:	1a52      	subs	r2, r2, r1
    8ed8:	eb66 0303 	sbc.w	r3, r6, r3
    8edc:	6102      	str	r2, [r0, #16]
    8ede:	6143      	str	r3, [r0, #20]
	sys_dnode_t *const prev = successor->prev;
    8ee0:	6843      	ldr	r3, [r0, #4]
	node->prev = prev;
    8ee2:	6063      	str	r3, [r4, #4]
	node->next = successor;
    8ee4:	6020      	str	r0, [r4, #0]
	prev->next = node;
    8ee6:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    8ee8:	6044      	str	r4, [r0, #4]
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    8eea:	e005      	b.n	8ef8 <z_add_timeout+0x68>
	sys_dnode_t *const tail = list->tail;
    8eec:	4b26      	ldr	r3, [pc, #152]	; (8f88 <z_add_timeout+0xf8>)
    8eee:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    8ef0:	6023      	str	r3, [r4, #0]
	node->prev = tail;
    8ef2:	6062      	str	r2, [r4, #4]
	tail->next = node;
    8ef4:	6014      	str	r4, [r2, #0]
	list->tail = node;
    8ef6:	605c      	str	r4, [r3, #4]
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    8ef8:	f7ff ffa8 	bl	8e4c <first>
    8efc:	4284      	cmp	r4, r0
    8efe:	d03a      	beq.n	8f76 <z_add_timeout+0xe6>
	__asm__ volatile(
    8f00:	f387 8811 	msr	BASEPRI, r7
    8f04:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    8f08:	2301      	movs	r3, #1
    8f0a:	2b00      	cmp	r3, #0
    8f0c:	d139      	bne.n	8f82 <z_add_timeout+0xf2>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    8f0e:	4653      	mov	r3, sl
    8f10:	f06f 0101 	mvn.w	r1, #1
    8f14:	ebb1 010a 	subs.w	r1, r1, sl
    8f18:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8f1c:	eb60 0205 	sbc.w	r2, r0, r5
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    8f20:	2a00      	cmp	r2, #0
    8f22:	dbcb      	blt.n	8ebc <z_add_timeout+0x2c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    8f24:	4a19      	ldr	r2, [pc, #100]	; (8f8c <z_add_timeout+0xfc>)
    8f26:	6811      	ldr	r1, [r2, #0]
    8f28:	6852      	ldr	r2, [r2, #4]
    8f2a:	185b      	adds	r3, r3, r1
    8f2c:	eb42 0205 	adc.w	r2, r2, r5
    8f30:	f06f 0101 	mvn.w	r1, #1
    8f34:	1ac9      	subs	r1, r1, r3
    8f36:	eb60 0302 	sbc.w	r3, r0, r2
			to->dticks = MAX(1, ticks);
    8f3a:	4608      	mov	r0, r1
    8f3c:	461a      	mov	r2, r3
    8f3e:	2901      	cmp	r1, #1
    8f40:	f173 0300 	sbcs.w	r3, r3, #0
    8f44:	da01      	bge.n	8f4a <z_add_timeout+0xba>
    8f46:	2001      	movs	r0, #1
    8f48:	2200      	movs	r2, #0
    8f4a:	6120      	str	r0, [r4, #16]
    8f4c:	6162      	str	r2, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
    8f4e:	f7ff ff7d 	bl	8e4c <first>
    8f52:	2800      	cmp	r0, #0
    8f54:	d0ca      	beq.n	8eec <z_add_timeout+0x5c>
			if (t->dticks > to->dticks) {
    8f56:	6902      	ldr	r2, [r0, #16]
    8f58:	6946      	ldr	r6, [r0, #20]
    8f5a:	6921      	ldr	r1, [r4, #16]
    8f5c:	6963      	ldr	r3, [r4, #20]
    8f5e:	4291      	cmp	r1, r2
    8f60:	eb73 0e06 	sbcs.w	lr, r3, r6
    8f64:	dbb7      	blt.n	8ed6 <z_add_timeout+0x46>
			to->dticks -= t->dticks;
    8f66:	1a89      	subs	r1, r1, r2
    8f68:	eb63 0306 	sbc.w	r3, r3, r6
    8f6c:	6121      	str	r1, [r4, #16]
    8f6e:	6163      	str	r3, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
    8f70:	f7ff ff76 	bl	8e60 <next>
    8f74:	e7ed      	b.n	8f52 <z_add_timeout+0xc2>
			sys_clock_set_timeout(next_timeout(), false);
    8f76:	f004 fe07 	bl	db88 <next_timeout>
    8f7a:	2100      	movs	r1, #0
    8f7c:	f7fb f9aa 	bl	42d4 <sys_clock_set_timeout>
    8f80:	e7be      	b.n	8f00 <z_add_timeout+0x70>
		}
	}
}
    8f82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8f86:	4770      	bx	lr
    8f88:	2000024c 	.word	0x2000024c
    8f8c:	20000498 	.word	0x20000498

00008f90 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
    8f90:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
    8f92:	f04f 0320 	mov.w	r3, #32
    8f96:	f3ef 8611 	mrs	r6, BASEPRI
    8f9a:	f383 8812 	msr	BASEPRI_MAX, r3
    8f9e:	f3bf 8f6f 	isb	sy
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
    8fa2:	4b2b      	ldr	r3, [pc, #172]	; (9050 <sys_clock_announce+0xc0>)
    8fa4:	6018      	str	r0, [r3, #0]

	struct _timeout *t = first();
    8fa6:	f7ff ff51 	bl	8e4c <first>
    8faa:	4604      	mov	r4, r0

	for (t = first();
    8fac:	e024      	b.n	8ff8 <sys_clock_announce+0x68>
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
    8fae:	4a29      	ldr	r2, [pc, #164]	; (9054 <sys_clock_announce+0xc4>)
    8fb0:	6813      	ldr	r3, [r2, #0]
    8fb2:	6851      	ldr	r1, [r2, #4]
    8fb4:	195b      	adds	r3, r3, r5
    8fb6:	eb41 71e5 	adc.w	r1, r1, r5, asr #31
    8fba:	6013      	str	r3, [r2, #0]
    8fbc:	6051      	str	r1, [r2, #4]
		t->dticks = 0;
    8fbe:	2200      	movs	r2, #0
    8fc0:	2300      	movs	r3, #0
    8fc2:	e9c4 2304 	strd	r2, r3, [r4, #16]
		remove_timeout(t);
    8fc6:	4620      	mov	r0, r4
    8fc8:	f004 fdc7 	bl	db5a <remove_timeout>
	__asm__ volatile(
    8fcc:	f386 8811 	msr	BASEPRI, r6
    8fd0:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    8fd4:	68a3      	ldr	r3, [r4, #8]
    8fd6:	4620      	mov	r0, r4
    8fd8:	4798      	blx	r3
	__asm__ volatile(
    8fda:	f04f 0320 	mov.w	r3, #32
    8fde:	f3ef 8611 	mrs	r6, BASEPRI
    8fe2:	f383 8812 	msr	BASEPRI_MAX, r3
    8fe6:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
    8fea:	4a19      	ldr	r2, [pc, #100]	; (9050 <sys_clock_announce+0xc0>)
    8fec:	6813      	ldr	r3, [r2, #0]
    8fee:	1b5b      	subs	r3, r3, r5
    8ff0:	6013      	str	r3, [r2, #0]
	     t = first()) {
    8ff2:	f7ff ff2b 	bl	8e4c <first>
    8ff6:	4604      	mov	r4, r0
	     (t != NULL) && (t->dticks <= announce_remaining);
    8ff8:	b13c      	cbz	r4, 900a <sys_clock_announce+0x7a>
    8ffa:	6925      	ldr	r5, [r4, #16]
    8ffc:	6961      	ldr	r1, [r4, #20]
    8ffe:	4b14      	ldr	r3, [pc, #80]	; (9050 <sys_clock_announce+0xc0>)
    9000:	681a      	ldr	r2, [r3, #0]
    9002:	17d3      	asrs	r3, r2, #31
    9004:	42aa      	cmp	r2, r5
    9006:	418b      	sbcs	r3, r1
    9008:	dad1      	bge.n	8fae <sys_clock_announce+0x1e>
	}

	if (t != NULL) {
    900a:	b144      	cbz	r4, 901e <sys_clock_announce+0x8e>
		t->dticks -= announce_remaining;
    900c:	6923      	ldr	r3, [r4, #16]
    900e:	6962      	ldr	r2, [r4, #20]
    9010:	490f      	ldr	r1, [pc, #60]	; (9050 <sys_clock_announce+0xc0>)
    9012:	6809      	ldr	r1, [r1, #0]
    9014:	1a5b      	subs	r3, r3, r1
    9016:	eb62 72e1 	sbc.w	r2, r2, r1, asr #31
    901a:	6123      	str	r3, [r4, #16]
    901c:	6162      	str	r2, [r4, #20]
	}

	curr_tick += announce_remaining;
    901e:	4a0d      	ldr	r2, [pc, #52]	; (9054 <sys_clock_announce+0xc4>)
    9020:	4d0b      	ldr	r5, [pc, #44]	; (9050 <sys_clock_announce+0xc0>)
    9022:	6828      	ldr	r0, [r5, #0]
    9024:	6813      	ldr	r3, [r2, #0]
    9026:	6851      	ldr	r1, [r2, #4]
    9028:	181b      	adds	r3, r3, r0
    902a:	eb41 71e0 	adc.w	r1, r1, r0, asr #31
    902e:	6013      	str	r3, [r2, #0]
    9030:	6051      	str	r1, [r2, #4]
	announce_remaining = 0;
    9032:	2400      	movs	r4, #0
    9034:	602c      	str	r4, [r5, #0]

	sys_clock_set_timeout(next_timeout(), false);
    9036:	f004 fda7 	bl	db88 <next_timeout>
    903a:	4621      	mov	r1, r4
    903c:	f7fb f94a 	bl	42d4 <sys_clock_set_timeout>
	__asm__ volatile(
    9040:	f386 8811 	msr	BASEPRI, r6
    9044:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
    9048:	f7ff fc30 	bl	88ac <z_time_slice>
#endif
}
    904c:	bd70      	pop	{r4, r5, r6, pc}
    904e:	bf00      	nop
    9050:	20001414 	.word	0x20001414
    9054:	20000498 	.word	0x20000498

00009058 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    9058:	b510      	push	{r4, lr}
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
    905a:	2200      	movs	r2, #0
	__asm__ volatile(
    905c:	f04f 0320 	mov.w	r3, #32
    9060:	f3ef 8411 	mrs	r4, BASEPRI
    9064:	f383 8812 	msr	BASEPRI_MAX, r3
    9068:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;
    906c:	4613      	mov	r3, r2
    906e:	4611      	mov	r1, r2
    9070:	e00c      	b.n	908c <sys_clock_tick_get+0x34>
		t = curr_tick + elapsed();
    9072:	f7ff ff01 	bl	8e78 <elapsed>
    9076:	4a07      	ldr	r2, [pc, #28]	; (9094 <sys_clock_tick_get+0x3c>)
    9078:	6813      	ldr	r3, [r2, #0]
    907a:	6851      	ldr	r1, [r2, #4]
    907c:	18c3      	adds	r3, r0, r3
    907e:	eb41 71e0 	adc.w	r1, r1, r0, asr #31
	__asm__ volatile(
    9082:	f384 8811 	msr	BASEPRI, r4
    9086:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    908a:	2201      	movs	r2, #1
    908c:	2a00      	cmp	r2, #0
    908e:	d0f0      	beq.n	9072 <sys_clock_tick_get+0x1a>
	}
	return t;
}
    9090:	4618      	mov	r0, r3
    9092:	bd10      	pop	{r4, pc}
    9094:	20000498 	.word	0x20000498

00009098 <boot_banner>:
#else
#define BANNER_VERSION KERNEL_VERSION_STRING
#endif

void boot_banner(void)
{
    9098:	b508      	push	{r3, lr}
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
    909a:	4802      	ldr	r0, [pc, #8]	; (90a4 <boot_banner+0xc>)
    909c:	f000 f9e9 	bl	9472 <printk>
#endif /* CONFIG_BOOT_BANNER */
}
    90a0:	bd08      	pop	{r3, pc}
    90a2:	bf00      	nop
    90a4:	0000f844 	.word	0x0000f844

000090a8 <nrf_cc3xx_platform_init_no_rng>:
    90a8:	b510      	push	{r4, lr}
    90aa:	4c0a      	ldr	r4, [pc, #40]	; (90d4 <nrf_cc3xx_platform_init_no_rng+0x2c>)
    90ac:	6823      	ldr	r3, [r4, #0]
    90ae:	b11b      	cbz	r3, 90b8 <nrf_cc3xx_platform_init_no_rng+0x10>
    90b0:	2301      	movs	r3, #1
    90b2:	6023      	str	r3, [r4, #0]
    90b4:	2000      	movs	r0, #0
    90b6:	bd10      	pop	{r4, pc}
    90b8:	f000 f8f4 	bl	92a4 <CC_LibInitNoRng>
    90bc:	2800      	cmp	r0, #0
    90be:	d0f7      	beq.n	90b0 <nrf_cc3xx_platform_init_no_rng+0x8>
    90c0:	3801      	subs	r0, #1
    90c2:	2807      	cmp	r0, #7
    90c4:	d803      	bhi.n	90ce <nrf_cc3xx_platform_init_no_rng+0x26>
    90c6:	4b04      	ldr	r3, [pc, #16]	; (90d8 <nrf_cc3xx_platform_init_no_rng+0x30>)
    90c8:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    90cc:	bd10      	pop	{r4, pc}
    90ce:	4803      	ldr	r0, [pc, #12]	; (90dc <nrf_cc3xx_platform_init_no_rng+0x34>)
    90d0:	bd10      	pop	{r4, pc}
    90d2:	bf00      	nop
    90d4:	20001418 	.word	0x20001418
    90d8:	0000f874 	.word	0x0000f874
    90dc:	ffff8ffe 	.word	0xffff8ffe

000090e0 <nrf_cc3xx_platform_abort>:
    90e0:	f3bf 8f4f 	dsb	sy
    90e4:	4905      	ldr	r1, [pc, #20]	; (90fc <nrf_cc3xx_platform_abort+0x1c>)
    90e6:	4b06      	ldr	r3, [pc, #24]	; (9100 <nrf_cc3xx_platform_abort+0x20>)
    90e8:	68ca      	ldr	r2, [r1, #12]
    90ea:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    90ee:	4313      	orrs	r3, r2
    90f0:	60cb      	str	r3, [r1, #12]
    90f2:	f3bf 8f4f 	dsb	sy
    90f6:	bf00      	nop
    90f8:	e7fd      	b.n	90f6 <nrf_cc3xx_platform_abort+0x16>
    90fa:	bf00      	nop
    90fc:	e000ed00 	.word	0xe000ed00
    9100:	05fa0004 	.word	0x05fa0004

00009104 <CC_PalAbort>:
    9104:	b430      	push	{r4, r5}
    9106:	f04f 32fe 	mov.w	r2, #4278124286	; 0xfefefefe
    910a:	2500      	movs	r5, #0
    910c:	4b0b      	ldr	r3, [pc, #44]	; (913c <CC_PalAbort+0x38>)
    910e:	4c0c      	ldr	r4, [pc, #48]	; (9140 <CC_PalAbort+0x3c>)
    9110:	490c      	ldr	r1, [pc, #48]	; (9144 <CC_PalAbort+0x40>)
    9112:	6849      	ldr	r1, [r1, #4]
    9114:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    9118:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
    911c:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
    9120:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
    9124:	f8c3 2410 	str.w	r2, [r3, #1040]	; 0x410
    9128:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
    912c:	f8c3 2418 	str.w	r2, [r3, #1048]	; 0x418
    9130:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
    9134:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
    9138:	bc30      	pop	{r4, r5}
    913a:	4708      	bx	r1
    913c:	50845000 	.word	0x50845000
    9140:	50844000 	.word	0x50844000
    9144:	20000254 	.word	0x20000254

00009148 <nrf_cc3xx_platform_set_abort>:
    9148:	4b02      	ldr	r3, [pc, #8]	; (9154 <nrf_cc3xx_platform_set_abort+0xc>)
    914a:	e9d0 1200 	ldrd	r1, r2, [r0]
    914e:	e9c3 1200 	strd	r1, r2, [r3]
    9152:	4770      	bx	lr
    9154:	20000254 	.word	0x20000254

00009158 <mutex_free>:
    9158:	b510      	push	{r4, lr}
    915a:	4604      	mov	r4, r0
    915c:	b150      	cbz	r0, 9174 <mutex_free+0x1c>
    915e:	6863      	ldr	r3, [r4, #4]
    9160:	f013 5f68 	tst.w	r3, #973078528	; 0x3a000000
    9164:	d005      	beq.n	9172 <mutex_free+0x1a>
    9166:	4a06      	ldr	r2, [pc, #24]	; (9180 <mutex_free+0x28>)
    9168:	4293      	cmp	r3, r2
    916a:	d002      	beq.n	9172 <mutex_free+0x1a>
    916c:	2300      	movs	r3, #0
    916e:	6062      	str	r2, [r4, #4]
    9170:	6023      	str	r3, [r4, #0]
    9172:	bd10      	pop	{r4, pc}
    9174:	4b03      	ldr	r3, [pc, #12]	; (9184 <mutex_free+0x2c>)
    9176:	4804      	ldr	r0, [pc, #16]	; (9188 <mutex_free+0x30>)
    9178:	685b      	ldr	r3, [r3, #4]
    917a:	4798      	blx	r3
    917c:	e7ef      	b.n	915e <mutex_free+0x6>
    917e:	bf00      	nop
    9180:	a95c5f2c 	.word	0xa95c5f2c
    9184:	20000254 	.word	0x20000254
    9188:	0000f894 	.word	0x0000f894

0000918c <mutex_lock>:
    918c:	b1c8      	cbz	r0, 91c2 <mutex_lock+0x36>
    918e:	6843      	ldr	r3, [r0, #4]
    9190:	4a0d      	ldr	r2, [pc, #52]	; (91c8 <mutex_lock+0x3c>)
    9192:	4293      	cmp	r3, r2
    9194:	d013      	beq.n	91be <mutex_lock+0x32>
    9196:	f013 5f68 	tst.w	r3, #973078528	; 0x3a000000
    919a:	d00e      	beq.n	91ba <mutex_lock+0x2e>
    919c:	2301      	movs	r3, #1
    919e:	e850 2f00 	ldrex	r2, [r0]
    91a2:	4619      	mov	r1, r3
    91a4:	e840 1c00 	strex	ip, r1, [r0]
    91a8:	f09c 0f00 	teq	ip, #0
    91ac:	d1f7      	bne.n	919e <mutex_lock+0x12>
    91ae:	2a01      	cmp	r2, #1
    91b0:	d0f5      	beq.n	919e <mutex_lock+0x12>
    91b2:	f3bf 8f5f 	dmb	sy
    91b6:	2000      	movs	r0, #0
    91b8:	4770      	bx	lr
    91ba:	4804      	ldr	r0, [pc, #16]	; (91cc <mutex_lock+0x40>)
    91bc:	4770      	bx	lr
    91be:	4804      	ldr	r0, [pc, #16]	; (91d0 <mutex_lock+0x44>)
    91c0:	4770      	bx	lr
    91c2:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    91c6:	4770      	bx	lr
    91c8:	a95c5f2c 	.word	0xa95c5f2c
    91cc:	ffff8fe9 	.word	0xffff8fe9
    91d0:	ffff8fea 	.word	0xffff8fea

000091d4 <mutex_unlock>:
    91d4:	4603      	mov	r3, r0
    91d6:	b180      	cbz	r0, 91fa <mutex_unlock+0x26>
    91d8:	6842      	ldr	r2, [r0, #4]
    91da:	4909      	ldr	r1, [pc, #36]	; (9200 <mutex_unlock+0x2c>)
    91dc:	428a      	cmp	r2, r1
    91de:	d00a      	beq.n	91f6 <mutex_unlock+0x22>
    91e0:	f012 5f68 	tst.w	r2, #973078528	; 0x3a000000
    91e4:	d005      	beq.n	91f2 <mutex_unlock+0x1e>
    91e6:	f3bf 8f5f 	dmb	sy
    91ea:	2200      	movs	r2, #0
    91ec:	4610      	mov	r0, r2
    91ee:	601a      	str	r2, [r3, #0]
    91f0:	4770      	bx	lr
    91f2:	4804      	ldr	r0, [pc, #16]	; (9204 <mutex_unlock+0x30>)
    91f4:	4770      	bx	lr
    91f6:	4804      	ldr	r0, [pc, #16]	; (9208 <mutex_unlock+0x34>)
    91f8:	4770      	bx	lr
    91fa:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    91fe:	4770      	bx	lr
    9200:	a95c5f2c 	.word	0xa95c5f2c
    9204:	ffff8fe9 	.word	0xffff8fe9
    9208:	ffff8fea 	.word	0xffff8fea

0000920c <mutex_init>:
    920c:	b510      	push	{r4, lr}
    920e:	4604      	mov	r4, r0
    9210:	b120      	cbz	r0, 921c <mutex_init+0x10>
    9212:	2300      	movs	r3, #0
    9214:	4a03      	ldr	r2, [pc, #12]	; (9224 <mutex_init+0x18>)
    9216:	6023      	str	r3, [r4, #0]
    9218:	6062      	str	r2, [r4, #4]
    921a:	bd10      	pop	{r4, pc}
    921c:	4802      	ldr	r0, [pc, #8]	; (9228 <mutex_init+0x1c>)
    921e:	f7ff ff71 	bl	9104 <CC_PalAbort>
    9222:	e7f6      	b.n	9212 <mutex_init+0x6>
    9224:	3a00003a 	.word	0x3a00003a
    9228:	0000f8bc 	.word	0x0000f8bc

0000922c <nrf_cc3xx_platform_set_mutexes>:
    922c:	b570      	push	{r4, r5, r6, lr}
    922e:	4c19      	ldr	r4, [pc, #100]	; (9294 <nrf_cc3xx_platform_set_mutexes+0x68>)
    9230:	f8d0 c004 	ldr.w	ip, [r0, #4]
    9234:	6806      	ldr	r6, [r0, #0]
    9236:	f8c4 c004 	str.w	ip, [r4, #4]
    923a:	f8d0 c008 	ldr.w	ip, [r0, #8]
    923e:	68c0      	ldr	r0, [r0, #12]
    9240:	f8c4 c008 	str.w	ip, [r4, #8]
    9244:	60e0      	str	r0, [r4, #12]
    9246:	6026      	str	r6, [r4, #0]
    9248:	6808      	ldr	r0, [r1, #0]
    924a:	4b13      	ldr	r3, [pc, #76]	; (9298 <nrf_cc3xx_platform_set_mutexes+0x6c>)
    924c:	4d13      	ldr	r5, [pc, #76]	; (929c <nrf_cc3xx_platform_set_mutexes+0x70>)
    924e:	6018      	str	r0, [r3, #0]
    9250:	6848      	ldr	r0, [r1, #4]
    9252:	f8d5 2118 	ldr.w	r2, [r5, #280]	; 0x118
    9256:	6058      	str	r0, [r3, #4]
    9258:	6888      	ldr	r0, [r1, #8]
    925a:	f012 5f68 	tst.w	r2, #973078528	; 0x3a000000
    925e:	6098      	str	r0, [r3, #8]
    9260:	68c8      	ldr	r0, [r1, #12]
    9262:	6909      	ldr	r1, [r1, #16]
    9264:	60d8      	str	r0, [r3, #12]
    9266:	6119      	str	r1, [r3, #16]
    9268:	d012      	beq.n	9290 <nrf_cc3xx_platform_set_mutexes+0x64>
    926a:	2300      	movs	r3, #0
    926c:	4a0c      	ldr	r2, [pc, #48]	; (92a0 <nrf_cc3xx_platform_set_mutexes+0x74>)
    926e:	f505 708a 	add.w	r0, r5, #276	; 0x114
    9272:	f8c5 3114 	str.w	r3, [r5, #276]	; 0x114
    9276:	f8c5 31b8 	str.w	r3, [r5, #440]	; 0x1b8
    927a:	f8c5 2118 	str.w	r2, [r5, #280]	; 0x118
    927e:	f8c5 21bc 	str.w	r2, [r5, #444]	; 0x1bc
    9282:	47b0      	blx	r6
    9284:	6823      	ldr	r3, [r4, #0]
    9286:	f505 70dc 	add.w	r0, r5, #440	; 0x1b8
    928a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    928e:	4718      	bx	r3
    9290:	bd70      	pop	{r4, r5, r6, pc}
    9292:	bf00      	nop
    9294:	20000270 	.word	0x20000270
    9298:	2000025c 	.word	0x2000025c
    929c:	20001430 	.word	0x20001430
    92a0:	a95c5f2c 	.word	0xa95c5f2c

000092a4 <CC_LibInitNoRng>:
    92a4:	b508      	push	{r3, lr}
    92a6:	f000 f811 	bl	92cc <CC_HalInit>
    92aa:	b930      	cbnz	r0, 92ba <CC_LibInitNoRng+0x16>
    92ac:	f000 f810 	bl	92d0 <CC_PalInit>
    92b0:	b938      	cbnz	r0, 92c2 <CC_LibInitNoRng+0x1e>
    92b2:	4a05      	ldr	r2, [pc, #20]	; (92c8 <CC_LibInitNoRng+0x24>)
    92b4:	f8c2 0a0c 	str.w	r0, [r2, #2572]	; 0xa0c
    92b8:	bd08      	pop	{r3, pc}
    92ba:	f000 f837 	bl	932c <CC_PalTerminate>
    92be:	2003      	movs	r0, #3
    92c0:	bd08      	pop	{r3, pc}
    92c2:	2004      	movs	r0, #4
    92c4:	bd08      	pop	{r3, pc}
    92c6:	bf00      	nop
    92c8:	50845000 	.word	0x50845000

000092cc <CC_HalInit>:
    92cc:	2000      	movs	r0, #0
    92ce:	4770      	bx	lr

000092d0 <CC_PalInit>:
    92d0:	b510      	push	{r4, lr}
    92d2:	4811      	ldr	r0, [pc, #68]	; (9318 <CC_PalInit+0x48>)
    92d4:	f000 f848 	bl	9368 <CC_PalMutexCreate>
    92d8:	b100      	cbz	r0, 92dc <CC_PalInit+0xc>
    92da:	bd10      	pop	{r4, pc}
    92dc:	480f      	ldr	r0, [pc, #60]	; (931c <CC_PalInit+0x4c>)
    92de:	f000 f843 	bl	9368 <CC_PalMutexCreate>
    92e2:	2800      	cmp	r0, #0
    92e4:	d1f9      	bne.n	92da <CC_PalInit+0xa>
    92e6:	4c0e      	ldr	r4, [pc, #56]	; (9320 <CC_PalInit+0x50>)
    92e8:	4620      	mov	r0, r4
    92ea:	f000 f83d 	bl	9368 <CC_PalMutexCreate>
    92ee:	2800      	cmp	r0, #0
    92f0:	d1f3      	bne.n	92da <CC_PalInit+0xa>
    92f2:	4b0c      	ldr	r3, [pc, #48]	; (9324 <CC_PalInit+0x54>)
    92f4:	480c      	ldr	r0, [pc, #48]	; (9328 <CC_PalInit+0x58>)
    92f6:	601c      	str	r4, [r3, #0]
    92f8:	f000 f836 	bl	9368 <CC_PalMutexCreate>
    92fc:	4601      	mov	r1, r0
    92fe:	2800      	cmp	r0, #0
    9300:	d1eb      	bne.n	92da <CC_PalInit+0xa>
    9302:	f000 f82d 	bl	9360 <CC_PalDmaInit>
    9306:	4604      	mov	r4, r0
    9308:	b108      	cbz	r0, 930e <CC_PalInit+0x3e>
    930a:	4620      	mov	r0, r4
    930c:	bd10      	pop	{r4, pc}
    930e:	f000 f83f 	bl	9390 <CC_PalPowerSaveModeInit>
    9312:	4620      	mov	r0, r4
    9314:	e7fa      	b.n	930c <CC_PalInit+0x3c>
    9316:	bf00      	nop
    9318:	200002b0 	.word	0x200002b0
    931c:	200002ac 	.word	0x200002ac
    9320:	200002a8 	.word	0x200002a8
    9324:	200002a0 	.word	0x200002a0
    9328:	200002a4 	.word	0x200002a4

0000932c <CC_PalTerminate>:
    932c:	b508      	push	{r3, lr}
    932e:	4808      	ldr	r0, [pc, #32]	; (9350 <CC_PalTerminate+0x24>)
    9330:	f000 f824 	bl	937c <CC_PalMutexDestroy>
    9334:	4807      	ldr	r0, [pc, #28]	; (9354 <CC_PalTerminate+0x28>)
    9336:	f000 f821 	bl	937c <CC_PalMutexDestroy>
    933a:	4807      	ldr	r0, [pc, #28]	; (9358 <CC_PalTerminate+0x2c>)
    933c:	f000 f81e 	bl	937c <CC_PalMutexDestroy>
    9340:	4806      	ldr	r0, [pc, #24]	; (935c <CC_PalTerminate+0x30>)
    9342:	f000 f81b 	bl	937c <CC_PalMutexDestroy>
    9346:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    934a:	f000 b80b 	b.w	9364 <CC_PalDmaTerminate>
    934e:	bf00      	nop
    9350:	200002b0 	.word	0x200002b0
    9354:	200002ac 	.word	0x200002ac
    9358:	200002a8 	.word	0x200002a8
    935c:	200002a4 	.word	0x200002a4

00009360 <CC_PalDmaInit>:
    9360:	2000      	movs	r0, #0
    9362:	4770      	bx	lr

00009364 <CC_PalDmaTerminate>:
    9364:	4770      	bx	lr
    9366:	bf00      	nop

00009368 <CC_PalMutexCreate>:
    9368:	b508      	push	{r3, lr}
    936a:	4b03      	ldr	r3, [pc, #12]	; (9378 <CC_PalMutexCreate+0x10>)
    936c:	6802      	ldr	r2, [r0, #0]
    936e:	681b      	ldr	r3, [r3, #0]
    9370:	6810      	ldr	r0, [r2, #0]
    9372:	4798      	blx	r3
    9374:	2000      	movs	r0, #0
    9376:	bd08      	pop	{r3, pc}
    9378:	20000270 	.word	0x20000270

0000937c <CC_PalMutexDestroy>:
    937c:	b508      	push	{r3, lr}
    937e:	4b03      	ldr	r3, [pc, #12]	; (938c <CC_PalMutexDestroy+0x10>)
    9380:	6802      	ldr	r2, [r0, #0]
    9382:	685b      	ldr	r3, [r3, #4]
    9384:	6810      	ldr	r0, [r2, #0]
    9386:	4798      	blx	r3
    9388:	2000      	movs	r0, #0
    938a:	bd08      	pop	{r3, pc}
    938c:	20000270 	.word	0x20000270

00009390 <CC_PalPowerSaveModeInit>:
    9390:	b570      	push	{r4, r5, r6, lr}
    9392:	4c09      	ldr	r4, [pc, #36]	; (93b8 <CC_PalPowerSaveModeInit+0x28>)
    9394:	4d09      	ldr	r5, [pc, #36]	; (93bc <CC_PalPowerSaveModeInit+0x2c>)
    9396:	6920      	ldr	r0, [r4, #16]
    9398:	68ab      	ldr	r3, [r5, #8]
    939a:	4798      	blx	r3
    939c:	b118      	cbz	r0, 93a6 <CC_PalPowerSaveModeInit+0x16>
    939e:	4b08      	ldr	r3, [pc, #32]	; (93c0 <CC_PalPowerSaveModeInit+0x30>)
    93a0:	4808      	ldr	r0, [pc, #32]	; (93c4 <CC_PalPowerSaveModeInit+0x34>)
    93a2:	685b      	ldr	r3, [r3, #4]
    93a4:	4798      	blx	r3
    93a6:	2100      	movs	r1, #0
    93a8:	4a07      	ldr	r2, [pc, #28]	; (93c8 <CC_PalPowerSaveModeInit+0x38>)
    93aa:	68eb      	ldr	r3, [r5, #12]
    93ac:	6011      	str	r1, [r2, #0]
    93ae:	6920      	ldr	r0, [r4, #16]
    93b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    93b4:	4718      	bx	r3
    93b6:	bf00      	nop
    93b8:	2000025c 	.word	0x2000025c
    93bc:	20000270 	.word	0x20000270
    93c0:	20000254 	.word	0x20000254
    93c4:	0000f8e0 	.word	0x0000f8e0
    93c8:	2000142c 	.word	0x2000142c

000093cc <incr_pattern>:
{
    93cc:	b500      	push	{lr}
	if (p[0] % 2 == 0) {
    93ce:	7803      	ldrb	r3, [r0, #0]
    93d0:	f013 0f01 	tst.w	r3, #1
    93d4:	d003      	beq.n	93de <incr_pattern+0x12>
	uint8_t fill = 0x55;
    93d6:	f04f 0e55 	mov.w	lr, #85	; 0x55
	for (int i = 0; i < (size - 1); i++) {
    93da:	2300      	movs	r3, #0
    93dc:	e005      	b.n	93ea <incr_pattern+0x1e>
		fill = 0xAA;
    93de:	f04f 0eaa 	mov.w	lr, #170	; 0xaa
    93e2:	e7fa      	b.n	93da <incr_pattern+0xe>
			p[i] = fill;
    93e4:	f800 e003 	strb.w	lr, [r0, r3]
	for (int i = 0; i < (size - 1); i++) {
    93e8:	3301      	adds	r3, #1
    93ea:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
    93ee:	459c      	cmp	ip, r3
    93f0:	dd08      	ble.n	9404 <incr_pattern+0x38>
		if (i % 8 == 0) {
    93f2:	f013 0f07 	tst.w	r3, #7
    93f6:	d1f5      	bne.n	93e4 <incr_pattern+0x18>
			p[i] += inc;
    93f8:	f810 c003 	ldrb.w	ip, [r0, r3]
    93fc:	4494      	add	ip, r2
    93fe:	f800 c003 	strb.w	ip, [r0, r3]
    9402:	e7f1      	b.n	93e8 <incr_pattern+0x1c>
	p[size - 1] += inc;
    9404:	f810 300c 	ldrb.w	r3, [r0, ip]
    9408:	4413      	add	r3, r2
    940a:	f800 300c 	strb.w	r3, [r0, ip]
}
    940e:	f85d fb04 	ldr.w	pc, [sp], #4

00009412 <init_pattern>:
{
    9412:	b538      	push	{r3, r4, r5, lr}
    9414:	4605      	mov	r5, r0
    9416:	460c      	mov	r4, r1
	memset(p, 0x55, size);
    9418:	460a      	mov	r2, r1
    941a:	2155      	movs	r1, #85	; 0x55
    941c:	f001 f97d 	bl	a71a <memset>
	for (int i = 0; i < size; i += 8) {
    9420:	2300      	movs	r3, #0
	uint8_t v = 0x1;
    9422:	f04f 0c01 	mov.w	ip, #1
	for (int i = 0; i < size; i += 8) {
    9426:	e006      	b.n	9436 <init_pattern+0x24>
		p[i] = v++;
    9428:	f10c 0e01 	add.w	lr, ip, #1
    942c:	f805 c003 	strb.w	ip, [r5, r3]
	for (int i = 0; i < size; i += 8) {
    9430:	3308      	adds	r3, #8
		p[i] = v++;
    9432:	fa5f fc8e 	uxtb.w	ip, lr
	for (int i = 0; i < size; i += 8) {
    9436:	429c      	cmp	r4, r3
    9438:	dcf6      	bgt.n	9428 <init_pattern+0x16>
	p[size - 1] = 0xAA;
    943a:	3c01      	subs	r4, #1
    943c:	23aa      	movs	r3, #170	; 0xaa
    943e:	552b      	strb	r3, [r5, r4]
}
    9440:	bd38      	pop	{r3, r4, r5, pc}

00009442 <k_msleep>:
{
    9442:	b508      	push	{r3, lr}
	return k_sleep(Z_TIMEOUT_MS(ms));
    9444:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    9448:	17c1      	asrs	r1, r0, #31
    944a:	03c9      	lsls	r1, r1, #15
    944c:	ea41 4150 	orr.w	r1, r1, r0, lsr #17
    9450:	03c0      	lsls	r0, r0, #15
    9452:	f240 33e7 	movw	r3, #999	; 0x3e7
    9456:	18c0      	adds	r0, r0, r3
    9458:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    945c:	f04f 0300 	mov.w	r3, #0
    9460:	f141 0100 	adc.w	r1, r1, #0
    9464:	f7f6 fe76 	bl	154 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
    9468:	f7ff fc6e 	bl	8d48 <z_impl_k_sleep>
}
    946c:	bd08      	pop	{r3, pc}

0000946e <arch_printk_char_out>:
}
    946e:	2000      	movs	r0, #0
    9470:	4770      	bx	lr

00009472 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
    9472:	b40f      	push	{r0, r1, r2, r3}
    9474:	b500      	push	{lr}
    9476:	b083      	sub	sp, #12
    9478:	a904      	add	r1, sp, #16
    947a:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
    947e:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
    9480:	f7f7 fa4c 	bl	91c <vprintk>

	va_end(ap);
}
    9484:	b003      	add	sp, #12
    9486:	f85d eb04 	ldr.w	lr, [sp], #4
    948a:	b004      	add	sp, #16
    948c:	4770      	bx	lr

0000948e <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    948e:	b508      	push	{r3, lr}
    9490:	4604      	mov	r4, r0
    9492:	4608      	mov	r0, r1
    9494:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    9496:	461a      	mov	r2, r3
    9498:	47a0      	blx	r4
	return z_impl_z_current_get();
    949a:	f7ff fc7f 	bl	8d9c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    949e:	f7f8 fd77 	bl	1f90 <z_impl_k_thread_abort>

000094a2 <set_chunk_used>:
}

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
    94a2:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
    94a6:	6883      	ldr	r3, [r0, #8]

	if (big_heap(h)) {
    94a8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    94ac:	d30a      	bcc.n	94c4 <set_chunk_used+0x22>
		if (used) {
    94ae:	b122      	cbz	r2, 94ba <set_chunk_used+0x18>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    94b0:	684b      	ldr	r3, [r1, #4]
    94b2:	f043 0301 	orr.w	r3, r3, #1
    94b6:	604b      	str	r3, [r1, #4]
    94b8:	4770      	bx	lr
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
    94ba:	684b      	ldr	r3, [r1, #4]
    94bc:	f023 0301 	bic.w	r3, r3, #1
    94c0:	604b      	str	r3, [r1, #4]
    94c2:	4770      	bx	lr
		}
	} else {
		if (used) {
    94c4:	b122      	cbz	r2, 94d0 <set_chunk_used+0x2e>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    94c6:	884b      	ldrh	r3, [r1, #2]
    94c8:	f043 0301 	orr.w	r3, r3, #1
    94cc:	804b      	strh	r3, [r1, #2]
    94ce:	4770      	bx	lr
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
    94d0:	884b      	ldrh	r3, [r1, #2]
    94d2:	f023 0301 	bic.w	r3, r3, #1
    94d6:	804b      	strh	r3, [r1, #2]
		}
	}
}
    94d8:	4770      	bx	lr

000094da <chunk_mem>:
#endif

static void *chunk_mem(struct z_heap *h, chunkid_t c)
{
	chunk_unit_t *buf = chunk_buf(h);
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
    94da:	00c9      	lsls	r1, r1, #3
	return big_heap_chunks(h->end_chunk);
    94dc:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
    94de:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    94e2:	d303      	bcc.n	94ec <chunk_mem+0x12>
    94e4:	2308      	movs	r3, #8
    94e6:	4419      	add	r1, r3

	CHECK(!(((uintptr_t)ret) & (big_heap(h) ? 7 : 3)));

	return ret;
}
    94e8:	4408      	add	r0, r1
    94ea:	4770      	bx	lr
    94ec:	2304      	movs	r3, #4
    94ee:	e7fa      	b.n	94e6 <chunk_mem+0xc>

000094f0 <free_list_remove_bidx>:

static void free_list_remove_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
    94f0:	b410      	push	{r4}
	void *cmem = &buf[c];
    94f2:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
    94f6:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
    94f8:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    94fc:	d319      	bcc.n	9532 <free_list_remove_bidx+0x42>
		return ((uint32_t *)cmem)[f];
    94fe:	f8dc 300c 	ldr.w	r3, [ip, #12]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
    9502:	4299      	cmp	r1, r3
    9504:	d018      	beq.n	9538 <free_list_remove_bidx+0x48>
	if (big_heap(h)) {
    9506:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    950a:	d321      	bcc.n	9550 <free_list_remove_bidx+0x60>
		return ((uint32_t *)cmem)[f];
    950c:	f8dc 1008 	ldr.w	r1, [ip, #8]
		b->next = 0;
	} else {
		chunkid_t first = prev_free_chunk(h, c),
			  second = next_free_chunk(h, c);

		b->next = second;
    9510:	3204      	adds	r2, #4
    9512:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	void *cmem = &buf[c];
    9516:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
	if (big_heap(h)) {
    951a:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    951e:	d31a      	bcc.n	9556 <free_list_remove_bidx+0x66>
		((uint32_t *)cmem)[f] = val;
    9520:	60d3      	str	r3, [r2, #12]
	void *cmem = &buf[c];
    9522:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
	return big_heap_chunks(h->end_chunk);
    9526:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
    9528:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    952c:	d315      	bcc.n	955a <free_list_remove_bidx+0x6a>
		((uint32_t *)cmem)[f] = val;
    952e:	6099      	str	r1, [r3, #8]
    9530:	e00c      	b.n	954c <free_list_remove_bidx+0x5c>
		return ((uint16_t *)cmem)[f];
    9532:	f8bc 3006 	ldrh.w	r3, [ip, #6]
    9536:	e7e4      	b.n	9502 <free_list_remove_bidx+0x12>
		h->avail_buckets &= ~BIT(bidx);
    9538:	68c3      	ldr	r3, [r0, #12]
    953a:	2101      	movs	r1, #1
    953c:	4091      	lsls	r1, r2
    953e:	ea23 0301 	bic.w	r3, r3, r1
    9542:	60c3      	str	r3, [r0, #12]
		b->next = 0;
    9544:	3204      	adds	r2, #4
    9546:	2300      	movs	r3, #0
    9548:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
    954c:	bc10      	pop	{r4}
    954e:	4770      	bx	lr
    9550:	f8bc 1004 	ldrh.w	r1, [ip, #4]
    9554:	e7dc      	b.n	9510 <free_list_remove_bidx+0x20>
		((uint16_t *)cmem)[f] = val;
    9556:	80d3      	strh	r3, [r2, #6]
    9558:	e7e3      	b.n	9522 <free_list_remove_bidx+0x32>
    955a:	8099      	strh	r1, [r3, #4]
    955c:	e7f6      	b.n	954c <free_list_remove_bidx+0x5c>

0000955e <free_list_add_bidx>:

static void free_list_add_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
	struct z_heap_bucket *b = &h->buckets[bidx];

	if (b->next == 0U) {
    955e:	1d13      	adds	r3, r2, #4
    9560:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    9564:	b9db      	cbnz	r3, 959e <free_list_add_bidx+0x40>
		CHECK((h->avail_buckets & BIT(bidx)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= BIT(bidx);
    9566:	68c3      	ldr	r3, [r0, #12]
    9568:	f04f 0c01 	mov.w	ip, #1
    956c:	fa0c fc02 	lsl.w	ip, ip, r2
    9570:	ea43 030c 	orr.w	r3, r3, ip
    9574:	60c3      	str	r3, [r0, #12]
		b->next = c;
    9576:	3204      	adds	r2, #4
    9578:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
	void *cmem = &buf[c];
    957c:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
    9580:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
    9582:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    9586:	d306      	bcc.n	9596 <free_list_add_bidx+0x38>
		((uint32_t *)cmem)[f] = val;
    9588:	6099      	str	r1, [r3, #8]
	return big_heap_chunks(h->end_chunk);
    958a:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
    958c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    9590:	d303      	bcc.n	959a <free_list_add_bidx+0x3c>
		((uint32_t *)cmem)[f] = val;
    9592:	60d9      	str	r1, [r3, #12]
    9594:	4770      	bx	lr
		((uint16_t *)cmem)[f] = val;
    9596:	8099      	strh	r1, [r3, #4]
    9598:	e7f7      	b.n	958a <free_list_add_bidx+0x2c>
    959a:	80d9      	strh	r1, [r3, #6]
    959c:	4770      	bx	lr
{
    959e:	b510      	push	{r4, lr}
	void *cmem = &buf[c];
    95a0:	eb00 0cc3 	add.w	ip, r0, r3, lsl #3
	return big_heap_chunks(h->end_chunk);
    95a4:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
    95a6:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    95aa:	d31c      	bcc.n	95e6 <free_list_add_bidx+0x88>
		return ((uint32_t *)cmem)[f];
    95ac:	f8dc 2008 	ldr.w	r2, [ip, #8]
	void *cmem = &buf[c];
    95b0:	eb00 0ec1 	add.w	lr, r0, r1, lsl #3
	if (big_heap(h)) {
    95b4:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    95b8:	d318      	bcc.n	95ec <free_list_add_bidx+0x8e>
		((uint32_t *)cmem)[f] = val;
    95ba:	f8ce 2008 	str.w	r2, [lr, #8]
	return big_heap_chunks(h->end_chunk);
    95be:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
    95c0:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    95c4:	d315      	bcc.n	95f2 <free_list_add_bidx+0x94>
		((uint32_t *)cmem)[f] = val;
    95c6:	f8ce 300c 	str.w	r3, [lr, #12]
	void *cmem = &buf[c];
    95ca:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
	return big_heap_chunks(h->end_chunk);
    95ce:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
    95d0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    95d4:	d310      	bcc.n	95f8 <free_list_add_bidx+0x9a>
		((uint32_t *)cmem)[f] = val;
    95d6:	60d1      	str	r1, [r2, #12]
	return big_heap_chunks(h->end_chunk);
    95d8:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
    95da:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    95de:	d30d      	bcc.n	95fc <free_list_add_bidx+0x9e>
		((uint32_t *)cmem)[f] = val;
    95e0:	f8cc 1008 	str.w	r1, [ip, #8]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
    95e4:	bd10      	pop	{r4, pc}
		return ((uint16_t *)cmem)[f];
    95e6:	f8bc 2004 	ldrh.w	r2, [ip, #4]
    95ea:	e7e1      	b.n	95b0 <free_list_add_bidx+0x52>
		((uint16_t *)cmem)[f] = val;
    95ec:	f8ae 2004 	strh.w	r2, [lr, #4]
    95f0:	e7e5      	b.n	95be <free_list_add_bidx+0x60>
    95f2:	f8ae 3006 	strh.w	r3, [lr, #6]
    95f6:	e7e8      	b.n	95ca <free_list_add_bidx+0x6c>
    95f8:	80d1      	strh	r1, [r2, #6]
    95fa:	e7ed      	b.n	95d8 <free_list_add_bidx+0x7a>
    95fc:	f8ac 1004 	strh.w	r1, [ip, #4]
    9600:	e7f0      	b.n	95e4 <free_list_add_bidx+0x86>

00009602 <split_chunks>:

/* Splits a chunk "lc" into a left chunk and a right chunk at "rc".
 * Leaves both chunks marked "free"
 */
static void split_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
    9602:	b430      	push	{r4, r5}
	void *cmem = &buf[c];
    9604:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
    9608:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
    960a:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    960e:	d329      	bcc.n	9664 <split_chunks+0x62>
		return ((uint32_t *)cmem)[f];
    9610:	f8dc 5004 	ldr.w	r5, [ip, #4]
	CHECK(rc > lc);
	CHECK(rc - lc < chunk_size(h, lc));

	chunksz_t sz0 = chunk_size(h, lc);
	chunksz_t lsz = rc - lc;
    9614:	1a53      	subs	r3, r2, r1
	chunksz_t rsz = sz0 - lsz;
    9616:	1a89      	subs	r1, r1, r2
    9618:	eb01 0155 	add.w	r1, r1, r5, lsr #1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    961c:	005d      	lsls	r5, r3, #1
	if (big_heap(h)) {
    961e:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    9622:	d322      	bcc.n	966a <split_chunks+0x68>
		((uint32_t *)cmem)[f] = val;
    9624:	f8cc 5004 	str.w	r5, [ip, #4]
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    9628:	004c      	lsls	r4, r1, #1
	void *cmem = &buf[c];
    962a:	eb00 0cc2 	add.w	ip, r0, r2, lsl #3
	if (big_heap(h)) {
    962e:	6885      	ldr	r5, [r0, #8]
    9630:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    9634:	d31c      	bcc.n	9670 <split_chunks+0x6e>
		((uint32_t *)cmem)[f] = val;
    9636:	f8cc 4004 	str.w	r4, [ip, #4]
	return big_heap_chunks(h->end_chunk);
    963a:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
    963c:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    9640:	d319      	bcc.n	9676 <split_chunks+0x74>
		((uint32_t *)cmem)[f] = val;
    9642:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
	return big_heap_chunks(h->end_chunk);
    9646:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
    9648:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    964c:	d316      	bcc.n	967c <split_chunks+0x7a>
		return ((uint32_t *)cmem)[f];
    964e:	f8dc 4004 	ldr.w	r4, [ip, #4]
	return c + chunk_size(h, c);
    9652:	eb02 0254 	add.w	r2, r2, r4, lsr #1
	if (big_heap(h)) {
    9656:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    965a:	d312      	bcc.n	9682 <split_chunks+0x80>
		((uint32_t *)cmem)[f] = val;
    965c:	f840 1032 	str.w	r1, [r0, r2, lsl #3]

	set_chunk_size(h, lc, lsz);
	set_chunk_size(h, rc, rsz);
	set_left_chunk_size(h, rc, lsz);
	set_left_chunk_size(h, right_chunk(h, rc), rsz);
}
    9660:	bc30      	pop	{r4, r5}
    9662:	4770      	bx	lr
		return ((uint16_t *)cmem)[f];
    9664:	f8bc 5002 	ldrh.w	r5, [ip, #2]
    9668:	e7d4      	b.n	9614 <split_chunks+0x12>
		((uint16_t *)cmem)[f] = val;
    966a:	f8ac 5002 	strh.w	r5, [ip, #2]
    966e:	e7db      	b.n	9628 <split_chunks+0x26>
    9670:	f8ac 4002 	strh.w	r4, [ip, #2]
    9674:	e7e1      	b.n	963a <split_chunks+0x38>
    9676:	f820 3032 	strh.w	r3, [r0, r2, lsl #3]
    967a:	e7e4      	b.n	9646 <split_chunks+0x44>
		return ((uint16_t *)cmem)[f];
    967c:	f8bc 4002 	ldrh.w	r4, [ip, #2]
    9680:	e7e7      	b.n	9652 <split_chunks+0x50>
		((uint16_t *)cmem)[f] = val;
    9682:	f820 1032 	strh.w	r1, [r0, r2, lsl #3]
    9686:	e7eb      	b.n	9660 <split_chunks+0x5e>

00009688 <merge_chunks>:

/* Does not modify free list */
static void merge_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
    9688:	b430      	push	{r4, r5}
	void *cmem = &buf[c];
    968a:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
    968e:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
    9690:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    9694:	d31e      	bcc.n	96d4 <merge_chunks+0x4c>
		return ((uint32_t *)cmem)[f];
    9696:	684b      	ldr	r3, [r1, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    9698:	085b      	lsrs	r3, r3, #1
	void *cmem = &buf[c];
    969a:	eb00 0cc2 	add.w	ip, r0, r2, lsl #3
	if (big_heap(h)) {
    969e:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    96a2:	d319      	bcc.n	96d8 <merge_chunks+0x50>
		return ((uint32_t *)cmem)[f];
    96a4:	f8dc 5004 	ldr.w	r5, [ip, #4]
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    96a8:	eb03 0355 	add.w	r3, r3, r5, lsr #1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    96ac:	005d      	lsls	r5, r3, #1
	if (big_heap(h)) {
    96ae:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
    96b2:	d314      	bcc.n	96de <merge_chunks+0x56>
		((uint32_t *)cmem)[f] = val;
    96b4:	604d      	str	r5, [r1, #4]
	return big_heap_chunks(h->end_chunk);
    96b6:	6881      	ldr	r1, [r0, #8]
	if (big_heap(h)) {
    96b8:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
    96bc:	d311      	bcc.n	96e2 <merge_chunks+0x5a>
		return ((uint32_t *)cmem)[f];
    96be:	f8dc 4004 	ldr.w	r4, [ip, #4]
	return c + chunk_size(h, c);
    96c2:	eb02 0254 	add.w	r2, r2, r4, lsr #1
	if (big_heap(h)) {
    96c6:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
    96ca:	d30d      	bcc.n	96e8 <merge_chunks+0x60>
		((uint32_t *)cmem)[f] = val;
    96cc:	f840 3032 	str.w	r3, [r0, r2, lsl #3]

	set_chunk_size(h, lc, newsz);
	set_left_chunk_size(h, right_chunk(h, rc), newsz);
}
    96d0:	bc30      	pop	{r4, r5}
    96d2:	4770      	bx	lr
		return ((uint16_t *)cmem)[f];
    96d4:	884b      	ldrh	r3, [r1, #2]
    96d6:	e7df      	b.n	9698 <merge_chunks+0x10>
    96d8:	f8bc 5002 	ldrh.w	r5, [ip, #2]
    96dc:	e7e4      	b.n	96a8 <merge_chunks+0x20>
		((uint16_t *)cmem)[f] = val;
    96de:	804d      	strh	r5, [r1, #2]
    96e0:	e7e9      	b.n	96b6 <merge_chunks+0x2e>
		return ((uint16_t *)cmem)[f];
    96e2:	f8bc 4002 	ldrh.w	r4, [ip, #2]
    96e6:	e7ec      	b.n	96c2 <merge_chunks+0x3a>
		((uint16_t *)cmem)[f] = val;
    96e8:	f820 3032 	strh.w	r3, [r0, r2, lsl #3]
    96ec:	e7f0      	b.n	96d0 <merge_chunks+0x48>

000096ee <mem_to_chunkid>:
	return big_heap_chunks(h->end_chunk);
    96ee:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) ? 8 : 4;
    96f0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    96f4:	d304      	bcc.n	9700 <mem_to_chunkid+0x12>
    96f6:	2308      	movs	r3, #8
 * boundary.
 */
static chunkid_t mem_to_chunkid(struct z_heap *h, void *p)
{
	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    96f8:	1ac9      	subs	r1, r1, r3
    96fa:	1a08      	subs	r0, r1, r0
}
    96fc:	08c0      	lsrs	r0, r0, #3
    96fe:	4770      	bx	lr
    9700:	2304      	movs	r3, #4
    9702:	e7f9      	b.n	96f8 <mem_to_chunkid+0xa>

00009704 <free_list_remove>:
{
    9704:	b508      	push	{r3, lr}
	return big_heap_chunks(h->end_chunk);
    9706:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) && chunk_size(h, c) == 1U;
    9708:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    970c:	d307      	bcc.n	971e <free_list_remove+0x1a>
	void *cmem = &buf[c];
    970e:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
		return ((uint32_t *)cmem)[f];
    9712:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    9714:	0852      	lsrs	r2, r2, #1
	return big_heap(h) && chunk_size(h, c) == 1U;
    9716:	2a01      	cmp	r2, #1
    9718:	d002      	beq.n	9720 <free_list_remove+0x1c>
    971a:	2200      	movs	r2, #0
    971c:	e000      	b.n	9720 <free_list_remove+0x1c>
    971e:	2200      	movs	r2, #0
	if (!solo_free_header(h, c)) {
    9720:	b9a2      	cbnz	r2, 974c <free_list_remove+0x48>
	void *cmem = &buf[c];
    9722:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
	if (big_heap(h)) {
    9726:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    972a:	d310      	bcc.n	974e <free_list_remove+0x4a>
		return ((uint32_t *)cmem)[f];
    972c:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    972e:	0852      	lsrs	r2, r2, #1
	return big_heap(h) ? 8 : 4;
    9730:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    9734:	d30d      	bcc.n	9752 <free_list_remove+0x4e>
    9736:	2308      	movs	r3, #8
	return big_heap_bytes(size) ? 8 : 4;
}

static inline chunksz_t chunksz(size_t bytes)
{
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    9738:	3308      	adds	r3, #8
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    973a:	eba2 02d3 	sub.w	r2, r2, r3, lsr #3
    973e:	3201      	adds	r2, #1
	return 31 - __builtin_clz(usable_sz);
    9740:	fab2 f282 	clz	r2, r2
		free_list_remove_bidx(h, c, bidx);
    9744:	f1c2 021f 	rsb	r2, r2, #31
    9748:	f7ff fed2 	bl	94f0 <free_list_remove_bidx>
}
    974c:	bd08      	pop	{r3, pc}
		return ((uint16_t *)cmem)[f];
    974e:	8852      	ldrh	r2, [r2, #2]
    9750:	e7ed      	b.n	972e <free_list_remove+0x2a>
	return big_heap(h) ? 8 : 4;
    9752:	2304      	movs	r3, #4
    9754:	e7f0      	b.n	9738 <free_list_remove+0x34>

00009756 <free_list_add>:
{
    9756:	b508      	push	{r3, lr}
	return big_heap_chunks(h->end_chunk);
    9758:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) && chunk_size(h, c) == 1U;
    975a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    975e:	d307      	bcc.n	9770 <free_list_add+0x1a>
	void *cmem = &buf[c];
    9760:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
		return ((uint32_t *)cmem)[f];
    9764:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    9766:	0852      	lsrs	r2, r2, #1
	return big_heap(h) && chunk_size(h, c) == 1U;
    9768:	2a01      	cmp	r2, #1
    976a:	d002      	beq.n	9772 <free_list_add+0x1c>
    976c:	2200      	movs	r2, #0
    976e:	e000      	b.n	9772 <free_list_add+0x1c>
    9770:	2200      	movs	r2, #0
	if (!solo_free_header(h, c)) {
    9772:	b9a2      	cbnz	r2, 979e <free_list_add+0x48>
	void *cmem = &buf[c];
    9774:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
	if (big_heap(h)) {
    9778:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    977c:	d310      	bcc.n	97a0 <free_list_add+0x4a>
		return ((uint32_t *)cmem)[f];
    977e:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    9780:	0852      	lsrs	r2, r2, #1
	return big_heap(h) ? 8 : 4;
    9782:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    9786:	d30d      	bcc.n	97a4 <free_list_add+0x4e>
    9788:	2308      	movs	r3, #8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    978a:	3308      	adds	r3, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    978c:	eba2 02d3 	sub.w	r2, r2, r3, lsr #3
    9790:	3201      	adds	r2, #1
	return 31 - __builtin_clz(usable_sz);
    9792:	fab2 f282 	clz	r2, r2
		free_list_add_bidx(h, c, bidx);
    9796:	f1c2 021f 	rsb	r2, r2, #31
    979a:	f7ff fee0 	bl	955e <free_list_add_bidx>
}
    979e:	bd08      	pop	{r3, pc}
		return ((uint16_t *)cmem)[f];
    97a0:	8852      	ldrh	r2, [r2, #2]
    97a2:	e7ed      	b.n	9780 <free_list_add+0x2a>
	return big_heap(h) ? 8 : 4;
    97a4:	2304      	movs	r3, #4
    97a6:	e7f0      	b.n	978a <free_list_add+0x34>

000097a8 <free_chunk>:
{
    97a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    97aa:	4604      	mov	r4, r0
    97ac:	460d      	mov	r5, r1
	void *cmem = &buf[c];
    97ae:	00ce      	lsls	r6, r1, #3
    97b0:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
    97b4:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
    97b6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    97ba:	d31f      	bcc.n	97fc <free_chunk+0x54>
		return ((uint32_t *)cmem)[f];
    97bc:	6879      	ldr	r1, [r7, #4]
	return c + chunk_size(h, c);
    97be:	eb05 0151 	add.w	r1, r5, r1, lsr #1
	void *cmem = &buf[c];
    97c2:	eb04 02c1 	add.w	r2, r4, r1, lsl #3
	if (big_heap(h)) {
    97c6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    97ca:	d319      	bcc.n	9800 <free_chunk+0x58>
		return ((uint32_t *)cmem)[f];
    97cc:	6853      	ldr	r3, [r2, #4]
	if (!chunk_used(h, right_chunk(h, c))) {
    97ce:	f013 0f01 	tst.w	r3, #1
    97d2:	d017      	beq.n	9804 <free_chunk+0x5c>
	return big_heap_chunks(h->end_chunk);
    97d4:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
    97d6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    97da:	d324      	bcc.n	9826 <free_chunk+0x7e>
		return ((uint32_t *)cmem)[f];
    97dc:	59a1      	ldr	r1, [r4, r6]
	return c - chunk_field(h, c, LEFT_SIZE);
    97de:	1a69      	subs	r1, r5, r1
	void *cmem = &buf[c];
    97e0:	eb04 02c1 	add.w	r2, r4, r1, lsl #3
	if (big_heap(h)) {
    97e4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    97e8:	d31f      	bcc.n	982a <free_chunk+0x82>
		return ((uint32_t *)cmem)[f];
    97ea:	6853      	ldr	r3, [r2, #4]
	if (!chunk_used(h, left_chunk(h, c))) {
    97ec:	f013 0f01 	tst.w	r3, #1
    97f0:	d01d      	beq.n	982e <free_chunk+0x86>
	free_list_add(h, c);
    97f2:	4629      	mov	r1, r5
    97f4:	4620      	mov	r0, r4
    97f6:	f7ff ffae 	bl	9756 <free_list_add>
}
    97fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return ((uint16_t *)cmem)[f];
    97fc:	8879      	ldrh	r1, [r7, #2]
    97fe:	e7de      	b.n	97be <free_chunk+0x16>
    9800:	8853      	ldrh	r3, [r2, #2]
    9802:	e7e4      	b.n	97ce <free_chunk+0x26>
		free_list_remove(h, right_chunk(h, c));
    9804:	4620      	mov	r0, r4
    9806:	f7ff ff7d 	bl	9704 <free_list_remove>
	return big_heap_chunks(h->end_chunk);
    980a:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
    980c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    9810:	d307      	bcc.n	9822 <free_chunk+0x7a>
		return ((uint32_t *)cmem)[f];
    9812:	687a      	ldr	r2, [r7, #4]
		merge_chunks(h, c, right_chunk(h, c));
    9814:	eb05 0252 	add.w	r2, r5, r2, lsr #1
    9818:	4629      	mov	r1, r5
    981a:	4620      	mov	r0, r4
    981c:	f7ff ff34 	bl	9688 <merge_chunks>
    9820:	e7d8      	b.n	97d4 <free_chunk+0x2c>
		return ((uint16_t *)cmem)[f];
    9822:	887a      	ldrh	r2, [r7, #2]
    9824:	e7f6      	b.n	9814 <free_chunk+0x6c>
    9826:	5ba1      	ldrh	r1, [r4, r6]
    9828:	e7d9      	b.n	97de <free_chunk+0x36>
    982a:	8853      	ldrh	r3, [r2, #2]
    982c:	e7de      	b.n	97ec <free_chunk+0x44>
		free_list_remove(h, left_chunk(h, c));
    982e:	4620      	mov	r0, r4
    9830:	f7ff ff68 	bl	9704 <free_list_remove>
	return big_heap_chunks(h->end_chunk);
    9834:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
    9836:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    983a:	d30c      	bcc.n	9856 <free_chunk+0xae>
		return ((uint32_t *)cmem)[f];
    983c:	59a1      	ldr	r1, [r4, r6]
		merge_chunks(h, left_chunk(h, c), c);
    983e:	462a      	mov	r2, r5
    9840:	1a69      	subs	r1, r5, r1
    9842:	4620      	mov	r0, r4
    9844:	f7ff ff20 	bl	9688 <merge_chunks>
	return big_heap_chunks(h->end_chunk);
    9848:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
    984a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    984e:	d304      	bcc.n	985a <free_chunk+0xb2>
		return ((uint32_t *)cmem)[f];
    9850:	59a3      	ldr	r3, [r4, r6]
	return c - chunk_field(h, c, LEFT_SIZE);
    9852:	1aed      	subs	r5, r5, r3
    9854:	e7cd      	b.n	97f2 <free_chunk+0x4a>
		return ((uint16_t *)cmem)[f];
    9856:	5ba1      	ldrh	r1, [r4, r6]
    9858:	e7f1      	b.n	983e <free_chunk+0x96>
    985a:	5ba3      	ldrh	r3, [r4, r6]
    985c:	e7f9      	b.n	9852 <free_chunk+0xaa>

0000985e <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
    985e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return big_heap_chunks(h->end_chunk);
    9860:	6885      	ldr	r5, [r0, #8]
	return big_heap(h) ? 8 : 4;
    9862:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    9866:	d310      	bcc.n	988a <alloc_chunk+0x2c>
    9868:	2308      	movs	r3, #8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    986a:	3308      	adds	r3, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    986c:	eba1 03d3 	sub.w	r3, r1, r3, lsr #3
    9870:	3301      	adds	r3, #1
	return 31 - __builtin_clz(usable_sz);
    9872:	fab3 f383 	clz	r3, r3
    9876:	f1c3 021f 	rsb	r2, r3, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
    987a:	f1c3 0423 	rsb	r4, r3, #35	; 0x23
    987e:	f850 6024 	ldr.w	r6, [r0, r4, lsl #2]
    9882:	b346      	cbz	r6, 98d6 <alloc_chunk+0x78>
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
    9884:	f04f 0c03 	mov.w	ip, #3
    9888:	e012      	b.n	98b0 <alloc_chunk+0x52>
	return big_heap(h) ? 8 : 4;
    988a:	2304      	movs	r3, #4
    988c:	e7ed      	b.n	986a <alloc_chunk+0xc>
		return ((uint16_t *)cmem)[f];
    988e:	f8be 7002 	ldrh.w	r7, [lr, #2]
    9892:	e017      	b.n	98c4 <alloc_chunk+0x66>
		do {
			chunkid_t c = b->next;
			if (chunk_size(h, c) >= sz) {
				free_list_remove_bidx(h, c, bi);
    9894:	4621      	mov	r1, r4
    9896:	f7ff fe2b 	bl	94f0 <free_list_remove_bidx>
				return c;
    989a:	e024      	b.n	98e6 <alloc_chunk+0x88>
    989c:	f8be 4006 	ldrh.w	r4, [lr, #6]
			}
			b->next = next_free_chunk(h, c);
    98a0:	1d17      	adds	r7, r2, #4
    98a2:	f840 4027 	str.w	r4, [r0, r7, lsl #2]
			CHECK(b->next != 0);
		} while (--i && b->next != first);
    98a6:	f1bc 0c01 	subs.w	ip, ip, #1
    98aa:	d014      	beq.n	98d6 <alloc_chunk+0x78>
    98ac:	42a6      	cmp	r6, r4
    98ae:	d012      	beq.n	98d6 <alloc_chunk+0x78>
			chunkid_t c = b->next;
    98b0:	1d14      	adds	r4, r2, #4
    98b2:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
	void *cmem = &buf[c];
    98b6:	eb00 0ec4 	add.w	lr, r0, r4, lsl #3
	if (big_heap(h)) {
    98ba:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    98be:	d3e6      	bcc.n	988e <alloc_chunk+0x30>
		return ((uint32_t *)cmem)[f];
    98c0:	f8de 7004 	ldr.w	r7, [lr, #4]
			if (chunk_size(h, c) >= sz) {
    98c4:	ebb1 0f57 	cmp.w	r1, r7, lsr #1
    98c8:	d9e4      	bls.n	9894 <alloc_chunk+0x36>
	if (big_heap(h)) {
    98ca:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
    98ce:	d3e5      	bcc.n	989c <alloc_chunk+0x3e>
		return ((uint32_t *)cmem)[f];
    98d0:	f8de 400c 	ldr.w	r4, [lr, #12]
    98d4:	e7e4      	b.n	98a0 <alloc_chunk+0x42>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
    98d6:	68c4      	ldr	r4, [r0, #12]
    98d8:	f1c3 0220 	rsb	r2, r3, #32
    98dc:	2301      	movs	r3, #1
    98de:	4093      	lsls	r3, r2
    98e0:	425b      	negs	r3, r3

	if (bmask != 0U) {
    98e2:	401c      	ands	r4, r3
    98e4:	d101      	bne.n	98ea <alloc_chunk+0x8c>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
    98e6:	4620      	mov	r0, r4
    98e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		int minbucket = __builtin_ctz(bmask);
    98ea:	fa94 f2a4 	rbit	r2, r4
    98ee:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
    98f2:	1d13      	adds	r3, r2, #4
    98f4:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
    98f8:	4621      	mov	r1, r4
    98fa:	f7ff fdf9 	bl	94f0 <free_list_remove_bidx>
		return c;
    98fe:	e7f2      	b.n	98e6 <alloc_chunk+0x88>

00009900 <sys_heap_free>:
	if (mem == NULL) {
    9900:	b179      	cbz	r1, 9922 <sys_heap_free+0x22>
{
    9902:	b538      	push	{r3, r4, r5, lr}
	struct z_heap *h = heap->heap;
    9904:	6805      	ldr	r5, [r0, #0]
	chunkid_t c = mem_to_chunkid(h, mem);
    9906:	4628      	mov	r0, r5
    9908:	f7ff fef1 	bl	96ee <mem_to_chunkid>
    990c:	4604      	mov	r4, r0
	set_chunk_used(h, c, false);
    990e:	2200      	movs	r2, #0
    9910:	4601      	mov	r1, r0
    9912:	4628      	mov	r0, r5
    9914:	f7ff fdc5 	bl	94a2 <set_chunk_used>
	free_chunk(h, c);
    9918:	4621      	mov	r1, r4
    991a:	4628      	mov	r0, r5
    991c:	f7ff ff44 	bl	97a8 <free_chunk>
}
    9920:	bd38      	pop	{r3, r4, r5, pc}
    9922:	4770      	bx	lr

00009924 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
    9924:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
    9926:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
    9928:	b3a1      	cbz	r1, 9994 <sys_heap_alloc+0x70>
    992a:	460b      	mov	r3, r1
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
    992c:	68aa      	ldr	r2, [r5, #8]
    992e:	ebb2 0fd1 	cmp.w	r2, r1, lsr #3
    9932:	d931      	bls.n	9998 <sys_heap_alloc+0x74>
	return big_heap(h) ? 8 : 4;
    9934:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    9938:	d31d      	bcc.n	9976 <sys_heap_alloc+0x52>
    993a:	2208      	movs	r2, #8
	return chunksz(chunk_header_bytes(h) + bytes);
    993c:	189c      	adds	r4, r3, r2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    993e:	3407      	adds	r4, #7
    9940:	08e4      	lsrs	r4, r4, #3
		return NULL;
	}

	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
	chunkid_t c = alloc_chunk(h, chunk_sz);
    9942:	4621      	mov	r1, r4
    9944:	4628      	mov	r0, r5
    9946:	f7ff ff8a 	bl	985e <alloc_chunk>
	if (c == 0U) {
    994a:	4606      	mov	r6, r0
    994c:	b330      	cbz	r0, 999c <sys_heap_alloc+0x78>
	void *cmem = &buf[c];
    994e:	eb05 03c0 	add.w	r3, r5, r0, lsl #3
	return big_heap_chunks(h->end_chunk);
    9952:	68aa      	ldr	r2, [r5, #8]
	if (big_heap(h)) {
    9954:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    9958:	d30f      	bcc.n	997a <sys_heap_alloc+0x56>
		return ((uint32_t *)cmem)[f];
    995a:	685b      	ldr	r3, [r3, #4]
		return NULL;
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
    995c:	ebb4 0f53 	cmp.w	r4, r3, lsr #1
    9960:	d30d      	bcc.n	997e <sys_heap_alloc+0x5a>
		split_chunks(h, c, c + chunk_sz);
		free_list_add(h, c + chunk_sz);
	}

	set_chunk_used(h, c, true);
    9962:	2201      	movs	r2, #1
    9964:	4631      	mov	r1, r6
    9966:	4628      	mov	r0, r5
    9968:	f7ff fd9b 	bl	94a2 <set_chunk_used>

	mem = chunk_mem(h, c);
    996c:	4631      	mov	r1, r6
    996e:	4628      	mov	r0, r5
    9970:	f7ff fdb3 	bl	94da <chunk_mem>
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
    9974:	bd70      	pop	{r4, r5, r6, pc}
	return big_heap(h) ? 8 : 4;
    9976:	2204      	movs	r2, #4
    9978:	e7e0      	b.n	993c <sys_heap_alloc+0x18>
		return ((uint16_t *)cmem)[f];
    997a:	885b      	ldrh	r3, [r3, #2]
    997c:	e7ee      	b.n	995c <sys_heap_alloc+0x38>
		split_chunks(h, c, c + chunk_sz);
    997e:	4434      	add	r4, r6
    9980:	4622      	mov	r2, r4
    9982:	4631      	mov	r1, r6
    9984:	4628      	mov	r0, r5
    9986:	f7ff fe3c 	bl	9602 <split_chunks>
		free_list_add(h, c + chunk_sz);
    998a:	4621      	mov	r1, r4
    998c:	4628      	mov	r0, r5
    998e:	f7ff fee2 	bl	9756 <free_list_add>
    9992:	e7e6      	b.n	9962 <sys_heap_alloc+0x3e>
		return NULL;
    9994:	2000      	movs	r0, #0
    9996:	e7ed      	b.n	9974 <sys_heap_alloc+0x50>
    9998:	2000      	movs	r0, #0
    999a:	e7eb      	b.n	9974 <sys_heap_alloc+0x50>
		return NULL;
    999c:	2000      	movs	r0, #0
    999e:	e7e9      	b.n	9974 <sys_heap_alloc+0x50>

000099a0 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
    99a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    99a4:	4615      	mov	r5, r2
	struct z_heap *h = heap->heap;
    99a6:	6806      	ldr	r6, [r0, #0]
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
    99a8:	424b      	negs	r3, r1
    99aa:	400b      	ands	r3, r1
	if (align != rew) {
    99ac:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
    99b0:	ea19 0901 	ands.w	r9, r9, r1
    99b4:	d00c      	beq.n	99d0 <sys_heap_aligned_alloc+0x30>
	return big_heap_chunks(h->end_chunk);
    99b6:	68b2      	ldr	r2, [r6, #8]
	return big_heap(h) ? 8 : 4;
    99b8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    99bc:	d306      	bcc.n	99cc <sys_heap_aligned_alloc+0x2c>
    99be:	2208      	movs	r2, #8
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
    99c0:	4293      	cmp	r3, r2
    99c2:	d258      	bcs.n	9a76 <sys_heap_aligned_alloc+0xd6>
    99c4:	461a      	mov	r2, r3
		align -= rew;
    99c6:	464c      	mov	r4, r9
	rew = align & -align;
    99c8:	4699      	mov	r9, r3
    99ca:	e009      	b.n	99e0 <sys_heap_aligned_alloc+0x40>
    99cc:	2204      	movs	r2, #4
    99ce:	e7f7      	b.n	99c0 <sys_heap_aligned_alloc+0x20>
    99d0:	460c      	mov	r4, r1
	return big_heap_chunks(h->end_chunk);
    99d2:	68b3      	ldr	r3, [r6, #8]
	return big_heap(h) ? 8 : 4;
    99d4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    99d8:	d346      	bcc.n	9a68 <sys_heap_aligned_alloc+0xc8>
    99da:	2208      	movs	r2, #8
	} else {
		if (align <= chunk_header_bytes(h)) {
    99dc:	4294      	cmp	r4, r2
    99de:	d945      	bls.n	9a6c <sys_heap_aligned_alloc+0xcc>
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
    99e0:	2d00      	cmp	r5, #0
    99e2:	d063      	beq.n	9aac <sys_heap_aligned_alloc+0x10c>
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
    99e4:	68b3      	ldr	r3, [r6, #8]
    99e6:	ebb3 0fd5 	cmp.w	r3, r5, lsr #3
    99ea:	d962      	bls.n	9ab2 <sys_heap_aligned_alloc+0x112>
	/*
	 * Find a free block that is guaranteed to fit.
	 * We over-allocate to account for alignment and then free
	 * the extra allocations afterwards.
	 */
	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
    99ec:	1961      	adds	r1, r4, r5
    99ee:	1a89      	subs	r1, r1, r2
	return big_heap(h) ? 8 : 4;
    99f0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    99f4:	d342      	bcc.n	9a7c <sys_heap_aligned_alloc+0xdc>
    99f6:	2308      	movs	r3, #8
	return chunksz(chunk_header_bytes(h) + bytes);
    99f8:	4419      	add	r1, r3
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    99fa:	3107      	adds	r1, #7
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    99fc:	08c9      	lsrs	r1, r1, #3
    99fe:	4630      	mov	r0, r6
    9a00:	f7ff ff2d 	bl	985e <alloc_chunk>

	if (c0 == 0) {
    9a04:	4607      	mov	r7, r0
    9a06:	2800      	cmp	r0, #0
    9a08:	d056      	beq.n	9ab8 <sys_heap_aligned_alloc+0x118>
		return NULL;
	}
	uint8_t *mem = chunk_mem(h, c0);
    9a0a:	4601      	mov	r1, r0
    9a0c:	4630      	mov	r0, r6
    9a0e:	f7ff fd64 	bl	94da <chunk_mem>

	/* Align allocated memory */
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
    9a12:	eb00 0809 	add.w	r8, r0, r9
    9a16:	44a0      	add	r8, r4
    9a18:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    9a1c:	4264      	negs	r4, r4
    9a1e:	ea08 0804 	and.w	r8, r8, r4
    9a22:	eba8 0809 	sub.w	r8, r8, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    9a26:	eb08 0405 	add.w	r4, r8, r5
    9a2a:	3407      	adds	r4, #7
    9a2c:	f024 0407 	bic.w	r4, r4, #7

	/* Get corresponding chunks */
	chunkid_t c = mem_to_chunkid(h, mem);
    9a30:	4641      	mov	r1, r8
    9a32:	4630      	mov	r0, r6
    9a34:	f7ff fe5b 	bl	96ee <mem_to_chunkid>
    9a38:	4605      	mov	r5, r0
	chunkid_t c_end = end - chunk_buf(h);
    9a3a:	1ba4      	subs	r4, r4, r6
    9a3c:	10e4      	asrs	r4, r4, #3
	CHECK(c >= c0 && c  < c_end && c_end <= c0 + padded_sz);

	/* Split and free unused prefix */
	if (c > c0) {
    9a3e:	4287      	cmp	r7, r0
    9a40:	d31e      	bcc.n	9a80 <sys_heap_aligned_alloc+0xe0>
	void *cmem = &buf[c];
    9a42:	eb06 03c5 	add.w	r3, r6, r5, lsl #3
	return big_heap_chunks(h->end_chunk);
    9a46:	68b2      	ldr	r2, [r6, #8]
	if (big_heap(h)) {
    9a48:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
    9a4c:	d322      	bcc.n	9a94 <sys_heap_aligned_alloc+0xf4>
		return ((uint32_t *)cmem)[f];
    9a4e:	685b      	ldr	r3, [r3, #4]
	return c + chunk_size(h, c);
    9a50:	eb05 0353 	add.w	r3, r5, r3, lsr #1
		split_chunks(h, c0, c);
		free_list_add(h, c0);
	}

	/* Split and free unused suffix */
	if (right_chunk(h, c) > c_end) {
    9a54:	429c      	cmp	r4, r3
    9a56:	d31f      	bcc.n	9a98 <sys_heap_aligned_alloc+0xf8>
		split_chunks(h, c, c_end);
		free_list_add(h, c_end);
	}

	set_chunk_used(h, c, true);
    9a58:	2201      	movs	r2, #1
    9a5a:	4629      	mov	r1, r5
    9a5c:	4630      	mov	r0, r6
    9a5e:	f7ff fd20 	bl	94a2 <set_chunk_used>
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
    9a62:	4640      	mov	r0, r8
    9a64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return big_heap(h) ? 8 : 4;
    9a68:	2204      	movs	r2, #4
    9a6a:	e7b7      	b.n	99dc <sys_heap_aligned_alloc+0x3c>
			return sys_heap_alloc(heap, bytes);
    9a6c:	4629      	mov	r1, r5
    9a6e:	f7ff ff59 	bl	9924 <sys_heap_alloc>
    9a72:	4680      	mov	r8, r0
    9a74:	e7f5      	b.n	9a62 <sys_heap_aligned_alloc+0xc2>
		align -= rew;
    9a76:	464c      	mov	r4, r9
	rew = align & -align;
    9a78:	4699      	mov	r9, r3
    9a7a:	e7b1      	b.n	99e0 <sys_heap_aligned_alloc+0x40>
    9a7c:	2304      	movs	r3, #4
    9a7e:	e7bb      	b.n	99f8 <sys_heap_aligned_alloc+0x58>
		split_chunks(h, c0, c);
    9a80:	4602      	mov	r2, r0
    9a82:	4639      	mov	r1, r7
    9a84:	4630      	mov	r0, r6
    9a86:	f7ff fdbc 	bl	9602 <split_chunks>
		free_list_add(h, c0);
    9a8a:	4639      	mov	r1, r7
    9a8c:	4630      	mov	r0, r6
    9a8e:	f7ff fe62 	bl	9756 <free_list_add>
    9a92:	e7d6      	b.n	9a42 <sys_heap_aligned_alloc+0xa2>
		return ((uint16_t *)cmem)[f];
    9a94:	885b      	ldrh	r3, [r3, #2]
    9a96:	e7db      	b.n	9a50 <sys_heap_aligned_alloc+0xb0>
		split_chunks(h, c, c_end);
    9a98:	4622      	mov	r2, r4
    9a9a:	4629      	mov	r1, r5
    9a9c:	4630      	mov	r0, r6
    9a9e:	f7ff fdb0 	bl	9602 <split_chunks>
		free_list_add(h, c_end);
    9aa2:	4621      	mov	r1, r4
    9aa4:	4630      	mov	r0, r6
    9aa6:	f7ff fe56 	bl	9756 <free_list_add>
    9aaa:	e7d5      	b.n	9a58 <sys_heap_aligned_alloc+0xb8>
		return NULL;
    9aac:	f04f 0800 	mov.w	r8, #0
    9ab0:	e7d7      	b.n	9a62 <sys_heap_aligned_alloc+0xc2>
    9ab2:	f04f 0800 	mov.w	r8, #0
    9ab6:	e7d4      	b.n	9a62 <sys_heap_aligned_alloc+0xc2>
		return NULL;
    9ab8:	f04f 0800 	mov.w	r8, #0
    9abc:	e7d1      	b.n	9a62 <sys_heap_aligned_alloc+0xc2>

00009abe <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    9abe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return big_heap_bytes(size) ? 8 : 4;
    9ac0:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
    9ac4:	d323      	bcc.n	9b0e <sys_heap_init+0x50>
    9ac6:	2308      	movs	r3, #8
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    9ac8:	1ad2      	subs	r2, r2, r3

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    9aca:	1dcc      	adds	r4, r1, #7
    9acc:	f024 0407 	bic.w	r4, r4, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    9ad0:	eb01 0c02 	add.w	ip, r1, r2
    9ad4:	f02c 0c07 	bic.w	ip, ip, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    9ad8:	ebac 0c04 	sub.w	ip, ip, r4
    9adc:	ea4f 01dc 	mov.w	r1, ip, lsr #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
    9ae0:	6004      	str	r4, [r0, #0]
	h->end_chunk = heap_sz;
    9ae2:	60a1      	str	r1, [r4, #8]
	h->avail_buckets = 0;
    9ae4:	2300      	movs	r3, #0
    9ae6:	60e3      	str	r3, [r4, #12]
	return big_heap(h) ? 8 : 4;
    9ae8:	f5bc 2f80 	cmp.w	ip, #262144	; 0x40000
    9aec:	d311      	bcc.n	9b12 <sys_heap_init+0x54>
    9aee:	2308      	movs	r3, #8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    9af0:	3308      	adds	r3, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    9af2:	eba1 03d3 	sub.w	r3, r1, r3, lsr #3
    9af6:	3301      	adds	r3, #1
	return 31 - __builtin_clz(usable_sz);
    9af8:	fab3 f383 	clz	r3, r3
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    9afc:	f1c3 0e20 	rsb	lr, r3, #32
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    9b00:	f1c3 0324 	rsb	r3, r3, #36	; 0x24
    9b04:	009b      	lsls	r3, r3, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    9b06:	1dde      	adds	r6, r3, #7
    9b08:	08f5      	lsrs	r5, r6, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    9b0a:	2300      	movs	r3, #0
    9b0c:	e008      	b.n	9b20 <sys_heap_init+0x62>
	return big_heap_bytes(size) ? 8 : 4;
    9b0e:	2304      	movs	r3, #4
    9b10:	e7da      	b.n	9ac8 <sys_heap_init+0xa>
	return big_heap(h) ? 8 : 4;
    9b12:	2304      	movs	r3, #4
    9b14:	e7ec      	b.n	9af0 <sys_heap_init+0x32>
		h->buckets[i].next = 0;
    9b16:	1d1a      	adds	r2, r3, #4
    9b18:	2000      	movs	r0, #0
    9b1a:	f844 0022 	str.w	r0, [r4, r2, lsl #2]
	for (int i = 0; i < nb_buckets; i++) {
    9b1e:	3301      	adds	r3, #1
    9b20:	4573      	cmp	r3, lr
    9b22:	dbf8      	blt.n	9b16 <sys_heap_init+0x58>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    9b24:	006b      	lsls	r3, r5, #1
	if (big_heap(h)) {
    9b26:	f5bc 2f80 	cmp.w	ip, #262144	; 0x40000
    9b2a:	d332      	bcc.n	9b92 <sys_heap_init+0xd4>
		((uint32_t *)cmem)[f] = val;
    9b2c:	6063      	str	r3, [r4, #4]
	if (big_heap(h)) {
    9b2e:	f5bc 2f80 	cmp.w	ip, #262144	; 0x40000
    9b32:	d330      	bcc.n	9b96 <sys_heap_init+0xd8>
		((uint32_t *)cmem)[f] = val;
    9b34:	2300      	movs	r3, #0
    9b36:	6023      	str	r3, [r4, #0]
	if (big_heap(h)) {
    9b38:	f5bc 2f80 	cmp.w	ip, #262144	; 0x40000
    9b3c:	d32e      	bcc.n	9b9c <sys_heap_init+0xde>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    9b3e:	6863      	ldr	r3, [r4, #4]
    9b40:	f043 0301 	orr.w	r3, r3, #1
    9b44:	6063      	str	r3, [r4, #4]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    9b46:	1b4a      	subs	r2, r1, r5
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    9b48:	0057      	lsls	r7, r2, #1
	void *cmem = &buf[c];
    9b4a:	f026 0307 	bic.w	r3, r6, #7
    9b4e:	18e0      	adds	r0, r4, r3
	if (big_heap(h)) {
    9b50:	f5bc 2f80 	cmp.w	ip, #262144	; 0x40000
    9b54:	d327      	bcc.n	9ba6 <sys_heap_init+0xe8>
		((uint32_t *)cmem)[f] = val;
    9b56:	6047      	str	r7, [r0, #4]
	return big_heap_chunks(h->end_chunk);
    9b58:	68a0      	ldr	r0, [r4, #8]
	if (big_heap(h)) {
    9b5a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    9b5e:	d324      	bcc.n	9baa <sys_heap_init+0xec>
		((uint32_t *)cmem)[f] = val;
    9b60:	50e5      	str	r5, [r4, r3]
	void *cmem = &buf[c];
    9b62:	f02c 0307 	bic.w	r3, ip, #7
    9b66:	44a4      	add	ip, r4
	return big_heap_chunks(h->end_chunk);
    9b68:	68a0      	ldr	r0, [r4, #8]
	if (big_heap(h)) {
    9b6a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    9b6e:	d31e      	bcc.n	9bae <sys_heap_init+0xf0>
		((uint32_t *)cmem)[f] = val;
    9b70:	2000      	movs	r0, #0
    9b72:	f8cc 0004 	str.w	r0, [ip, #4]
	return big_heap_chunks(h->end_chunk);
    9b76:	68a0      	ldr	r0, [r4, #8]
	if (big_heap(h)) {
    9b78:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    9b7c:	d31b      	bcc.n	9bb6 <sys_heap_init+0xf8>
		((uint32_t *)cmem)[f] = val;
    9b7e:	50e2      	str	r2, [r4, r3]
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);
    9b80:	2201      	movs	r2, #1
    9b82:	4620      	mov	r0, r4
    9b84:	f7ff fc8d 	bl	94a2 <set_chunk_used>

	free_list_add(h, chunk0_size);
    9b88:	4629      	mov	r1, r5
    9b8a:	4620      	mov	r0, r4
    9b8c:	f7ff fde3 	bl	9756 <free_list_add>
}
    9b90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		((uint16_t *)cmem)[f] = val;
    9b92:	8063      	strh	r3, [r4, #2]
    9b94:	e7cb      	b.n	9b2e <sys_heap_init+0x70>
    9b96:	2300      	movs	r3, #0
    9b98:	8023      	strh	r3, [r4, #0]
    9b9a:	e7cd      	b.n	9b38 <sys_heap_init+0x7a>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    9b9c:	8863      	ldrh	r3, [r4, #2]
    9b9e:	f043 0301 	orr.w	r3, r3, #1
    9ba2:	8063      	strh	r3, [r4, #2]
    9ba4:	e7cf      	b.n	9b46 <sys_heap_init+0x88>
		((uint16_t *)cmem)[f] = val;
    9ba6:	8047      	strh	r7, [r0, #2]
    9ba8:	e7d6      	b.n	9b58 <sys_heap_init+0x9a>
    9baa:	52e5      	strh	r5, [r4, r3]
    9bac:	e7d9      	b.n	9b62 <sys_heap_init+0xa4>
    9bae:	2000      	movs	r0, #0
    9bb0:	f8ac 0002 	strh.w	r0, [ip, #2]
    9bb4:	e7df      	b.n	9b76 <sys_heap_init+0xb8>
    9bb6:	52e2      	strh	r2, [r4, r3]
    9bb8:	e7e2      	b.n	9b80 <sys_heap_init+0xc2>

00009bba <set_state>:
	mgr->flags = (state & ONOFF_STATE_MASK)
    9bba:	f001 0107 	and.w	r1, r1, #7
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    9bbe:	8b03      	ldrh	r3, [r0, #24]
    9bc0:	f023 0307 	bic.w	r3, r3, #7
    9bc4:	430b      	orrs	r3, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
    9bc6:	8303      	strh	r3, [r0, #24]
}
    9bc8:	4770      	bx	lr

00009bca <notify_monitors>:
{
    9bca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9bce:	4606      	mov	r6, r0
    9bd0:	460f      	mov	r7, r1
    9bd2:	4690      	mov	r8, r2
	return list->head;
    9bd4:	6881      	ldr	r1, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    9bd6:	b121      	cbz	r1, 9be2 <notify_monitors+0x18>
	return node->next;
    9bd8:	680c      	ldr	r4, [r1, #0]
    9bda:	b13c      	cbz	r4, 9bec <notify_monitors+0x22>
Z_GENLIST_PEEK_NEXT(slist, snode)
    9bdc:	b931      	cbnz	r1, 9bec <notify_monitors+0x22>
    9bde:	460c      	mov	r4, r1
    9be0:	e004      	b.n	9bec <notify_monitors+0x22>
    9be2:	460c      	mov	r4, r1
    9be4:	e002      	b.n	9bec <notify_monitors+0x22>
    9be6:	4623      	mov	r3, r4
    9be8:	4621      	mov	r1, r4
    9bea:	461c      	mov	r4, r3
    9bec:	b169      	cbz	r1, 9c0a <notify_monitors+0x40>
		mon->callback(mgr, mon, state, res);
    9bee:	684d      	ldr	r5, [r1, #4]
    9bf0:	4643      	mov	r3, r8
    9bf2:	463a      	mov	r2, r7
    9bf4:	4630      	mov	r0, r6
    9bf6:	47a8      	blx	r5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    9bf8:	2c00      	cmp	r4, #0
    9bfa:	d0f4      	beq.n	9be6 <notify_monitors+0x1c>
	return node->next;
    9bfc:	6823      	ldr	r3, [r4, #0]
    9bfe:	2b00      	cmp	r3, #0
    9c00:	d0f2      	beq.n	9be8 <notify_monitors+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
    9c02:	2c00      	cmp	r4, #0
    9c04:	d1f0      	bne.n	9be8 <notify_monitors+0x1e>
    9c06:	4623      	mov	r3, r4
    9c08:	e7ee      	b.n	9be8 <notify_monitors+0x1e>
}
    9c0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00009c0e <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    9c0e:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
    9c10:	f013 0307 	ands.w	r3, r3, #7
    9c14:	d103      	bne.n	9c1e <process_recheck+0x10>
	return list->head;
    9c16:	6802      	ldr	r2, [r0, #0]
	    && !sys_slist_is_empty(&mgr->clients)) {
    9c18:	b10a      	cbz	r2, 9c1e <process_recheck+0x10>
		evt = EVT_START;
    9c1a:	2003      	movs	r0, #3
    9c1c:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
    9c1e:	2b02      	cmp	r3, #2
    9c20:	d003      	beq.n	9c2a <process_recheck+0x1c>
	} else if ((state == ONOFF_STATE_ERROR)
    9c22:	2b01      	cmp	r3, #1
    9c24:	d006      	beq.n	9c34 <process_recheck+0x26>
	int evt = EVT_NOP;
    9c26:	2000      	movs	r0, #0
    9c28:	4770      	bx	lr
		   && (mgr->refs == 0U)) {
    9c2a:	8b42      	ldrh	r2, [r0, #26]
    9c2c:	2a00      	cmp	r2, #0
    9c2e:	d1f8      	bne.n	9c22 <process_recheck+0x14>
		evt = EVT_STOP;
    9c30:	2004      	movs	r0, #4
    9c32:	4770      	bx	lr
    9c34:	6803      	ldr	r3, [r0, #0]
		   && !sys_slist_is_empty(&mgr->clients)) {
    9c36:	b10b      	cbz	r3, 9c3c <process_recheck+0x2e>
		evt = EVT_RESET;
    9c38:	2005      	movs	r0, #5
}
    9c3a:	4770      	bx	lr
	int evt = EVT_NOP;
    9c3c:	2000      	movs	r0, #0
    9c3e:	4770      	bx	lr

00009c40 <process_complete>:
{
    9c40:	b510      	push	{r4, lr}
    9c42:	4604      	mov	r4, r0
    9c44:	468c      	mov	ip, r1
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    9c46:	8b03      	ldrh	r3, [r0, #24]
	if (res < 0) {
    9c48:	2a00      	cmp	r2, #0
    9c4a:	db07      	blt.n	9c5c <process_complete+0x1c>
    9c4c:	f003 0307 	and.w	r3, r3, #7
		   || (state == ONOFF_STATE_RESETTING)) {
    9c50:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    9c52:	2a01      	cmp	r2, #1
    9c54:	d90e      	bls.n	9c74 <process_complete+0x34>
	} else if (state == ONOFF_STATE_TO_OFF) {
    9c56:	2b04      	cmp	r3, #4
    9c58:	d036      	beq.n	9cc8 <process_complete+0x88>
}
    9c5a:	bd10      	pop	{r4, pc}
		*clients = mgr->clients;
    9c5c:	e9d0 0100 	ldrd	r0, r1, [r0]
    9c60:	e88c 0003 	stmia.w	ip, {r0, r1}
	list->head = NULL;
    9c64:	2300      	movs	r3, #0
    9c66:	6023      	str	r3, [r4, #0]
	list->tail = NULL;
    9c68:	6063      	str	r3, [r4, #4]
		set_state(mgr, ONOFF_STATE_ERROR);
    9c6a:	2101      	movs	r1, #1
    9c6c:	4620      	mov	r0, r4
    9c6e:	f7ff ffa4 	bl	9bba <set_state>
    9c72:	e7f2      	b.n	9c5a <process_complete+0x1a>
		*clients = mgr->clients;
    9c74:	e9d0 0100 	ldrd	r0, r1, [r0]
    9c78:	e88c 0003 	stmia.w	ip, {r0, r1}
	list->head = NULL;
    9c7c:	2200      	movs	r2, #0
    9c7e:	6022      	str	r2, [r4, #0]
	list->tail = NULL;
    9c80:	6062      	str	r2, [r4, #4]
		if (state == ONOFF_STATE_TO_ON) {
    9c82:	2b06      	cmp	r3, #6
    9c84:	d11b      	bne.n	9cbe <process_complete+0x7e>
	return list->head;
    9c86:	f8dc 3000 	ldr.w	r3, [ip]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    9c8a:	b153      	cbz	r3, 9ca2 <process_complete+0x62>
				mgr->refs += 1U;
    9c8c:	8b62      	ldrh	r2, [r4, #26]
    9c8e:	3201      	adds	r2, #1
    9c90:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    9c92:	461a      	mov	r2, r3
	return node->next;
    9c94:	681b      	ldr	r3, [r3, #0]
    9c96:	2b00      	cmp	r3, #0
    9c98:	d0f7      	beq.n	9c8a <process_complete+0x4a>
Z_GENLIST_PEEK_NEXT(slist, snode)
    9c9a:	2a00      	cmp	r2, #0
    9c9c:	d1f5      	bne.n	9c8a <process_complete+0x4a>
    9c9e:	4613      	mov	r3, r2
    9ca0:	e7f3      	b.n	9c8a <process_complete+0x4a>
			set_state(mgr, ONOFF_STATE_ON);
    9ca2:	2102      	movs	r1, #2
    9ca4:	4620      	mov	r0, r4
    9ca6:	f7ff ff88 	bl	9bba <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    9caa:	4620      	mov	r0, r4
    9cac:	f7ff ffaf 	bl	9c0e <process_recheck>
    9cb0:	2800      	cmp	r0, #0
    9cb2:	d0d2      	beq.n	9c5a <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    9cb4:	8b23      	ldrh	r3, [r4, #24]
    9cb6:	f043 0320 	orr.w	r3, r3, #32
    9cba:	8323      	strh	r3, [r4, #24]
    9cbc:	e7cd      	b.n	9c5a <process_complete+0x1a>
			set_state(mgr, ONOFF_STATE_OFF);
    9cbe:	2100      	movs	r1, #0
    9cc0:	4620      	mov	r0, r4
    9cc2:	f7ff ff7a 	bl	9bba <set_state>
    9cc6:	e7f0      	b.n	9caa <process_complete+0x6a>
		set_state(mgr, ONOFF_STATE_OFF);
    9cc8:	2100      	movs	r1, #0
    9cca:	f7ff ff76 	bl	9bba <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    9cce:	4620      	mov	r0, r4
    9cd0:	f7ff ff9d 	bl	9c0e <process_recheck>
    9cd4:	2800      	cmp	r0, #0
    9cd6:	d0c0      	beq.n	9c5a <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    9cd8:	8b23      	ldrh	r3, [r4, #24]
    9cda:	f043 0320 	orr.w	r3, r3, #32
    9cde:	8323      	strh	r3, [r4, #24]
}
    9ce0:	e7bb      	b.n	9c5a <process_complete+0x1a>

00009ce2 <validate_args>:
	if ((mgr == NULL) || (cli == NULL)) {
    9ce2:	b150      	cbz	r0, 9cfa <validate_args+0x18>
{
    9ce4:	b510      	push	{r4, lr}
    9ce6:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    9ce8:	b151      	cbz	r1, 9d00 <validate_args+0x1e>
	int rv = sys_notify_validate(&cli->notify);
    9cea:	1d08      	adds	r0, r1, #4
    9cec:	f000 f8c4 	bl	9e78 <sys_notify_validate>
	if ((rv == 0)
    9cf0:	b910      	cbnz	r0, 9cf8 <validate_args+0x16>
	    && ((cli->notify.flags
    9cf2:	68a3      	ldr	r3, [r4, #8]
    9cf4:	2b03      	cmp	r3, #3
    9cf6:	d806      	bhi.n	9d06 <validate_args+0x24>
}
    9cf8:	bd10      	pop	{r4, pc}
		return -EINVAL;
    9cfa:	f06f 0015 	mvn.w	r0, #21
}
    9cfe:	4770      	bx	lr
		return -EINVAL;
    9d00:	f06f 0015 	mvn.w	r0, #21
    9d04:	e7f8      	b.n	9cf8 <validate_args+0x16>
		rv = -EINVAL;
    9d06:	f06f 0015 	mvn.w	r0, #21
    9d0a:	e7f5      	b.n	9cf8 <validate_args+0x16>

00009d0c <notify_one>:
{
    9d0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9d10:	4607      	mov	r7, r0
    9d12:	460c      	mov	r4, r1
    9d14:	4616      	mov	r6, r2
    9d16:	461d      	mov	r5, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    9d18:	4619      	mov	r1, r3
    9d1a:	1d20      	adds	r0, r4, #4
    9d1c:	f000 f8c3 	bl	9ea6 <sys_notify_finalize>
	if (cb) {
    9d20:	b128      	cbz	r0, 9d2e <notify_one+0x22>
    9d22:	4680      	mov	r8, r0
		cb(mgr, cli, state, res);
    9d24:	462b      	mov	r3, r5
    9d26:	4632      	mov	r2, r6
    9d28:	4621      	mov	r1, r4
    9d2a:	4638      	mov	r0, r7
    9d2c:	47c0      	blx	r8
}
    9d2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00009d32 <notify_all>:
{
    9d32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9d36:	4680      	mov	r8, r0
    9d38:	460c      	mov	r4, r1
    9d3a:	4617      	mov	r7, r2
    9d3c:	461e      	mov	r6, r3
	while (!sys_slist_is_empty(list)) {
    9d3e:	e004      	b.n	9d4a <notify_all+0x18>
		notify_one(mgr, cli, state, res);
    9d40:	4633      	mov	r3, r6
    9d42:	463a      	mov	r2, r7
    9d44:	4640      	mov	r0, r8
    9d46:	f7ff ffe1 	bl	9d0c <notify_one>
	return list->head;
    9d4a:	6821      	ldr	r1, [r4, #0]
	while (!sys_slist_is_empty(list)) {
    9d4c:	b131      	cbz	r1, 9d5c <notify_all+0x2a>
	return node->next;
    9d4e:	680d      	ldr	r5, [r1, #0]
	list->head = node;
    9d50:	6025      	str	r5, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    9d52:	6863      	ldr	r3, [r4, #4]
    9d54:	428b      	cmp	r3, r1
    9d56:	d1f3      	bne.n	9d40 <notify_all+0xe>
	list->tail = node;
    9d58:	6065      	str	r5, [r4, #4]
}
    9d5a:	e7f1      	b.n	9d40 <notify_all+0xe>
}
    9d5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00009d60 <transition_complete>:
{
    9d60:	b508      	push	{r3, lr}
	__asm__ volatile(
    9d62:	f04f 0c20 	mov.w	ip, #32
    9d66:	f3ef 8211 	mrs	r2, BASEPRI
    9d6a:	f38c 8812 	msr	BASEPRI_MAX, ip
    9d6e:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
    9d72:	6141      	str	r1, [r0, #20]
	process_event(mgr, EVT_COMPLETE, key);
    9d74:	2101      	movs	r1, #1
    9d76:	f7f6 fddf 	bl	938 <process_event>
}
    9d7a:	bd08      	pop	{r3, pc}

00009d7c <onoff_manager_init>:
	if ((mgr == NULL)
    9d7c:	4603      	mov	r3, r0
    9d7e:	b170      	cbz	r0, 9d9e <onoff_manager_init+0x22>
	    || (transitions == NULL)
    9d80:	b181      	cbz	r1, 9da4 <onoff_manager_init+0x28>
	    || (transitions->start == NULL)
    9d82:	680a      	ldr	r2, [r1, #0]
    9d84:	b18a      	cbz	r2, 9daa <onoff_manager_init+0x2e>
	    || (transitions->stop == NULL)) {
    9d86:	684a      	ldr	r2, [r1, #4]
    9d88:	b192      	cbz	r2, 9db0 <onoff_manager_init+0x34>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    9d8a:	2000      	movs	r0, #0
    9d8c:	6018      	str	r0, [r3, #0]
    9d8e:	6058      	str	r0, [r3, #4]
    9d90:	6098      	str	r0, [r3, #8]
    9d92:	60d8      	str	r0, [r3, #12]
    9d94:	6118      	str	r0, [r3, #16]
    9d96:	6158      	str	r0, [r3, #20]
    9d98:	6198      	str	r0, [r3, #24]
    9d9a:	6119      	str	r1, [r3, #16]
	return 0;
    9d9c:	4770      	bx	lr
		return -EINVAL;
    9d9e:	f06f 0015 	mvn.w	r0, #21
    9da2:	4770      	bx	lr
    9da4:	f06f 0015 	mvn.w	r0, #21
    9da8:	4770      	bx	lr
    9daa:	f06f 0015 	mvn.w	r0, #21
    9dae:	4770      	bx	lr
    9db0:	f06f 0015 	mvn.w	r0, #21
}
    9db4:	4770      	bx	lr

00009db6 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
    9db6:	b570      	push	{r4, r5, r6, lr}
    9db8:	4605      	mov	r5, r0
    9dba:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
    9dbc:	f7ff ff91 	bl	9ce2 <validate_args>

	if (rv < 0) {
    9dc0:	1e04      	subs	r4, r0, #0
    9dc2:	db30      	blt.n	9e26 <onoff_request+0x70>
    9dc4:	f04f 0320 	mov.w	r3, #32
    9dc8:	f3ef 8211 	mrs	r2, BASEPRI
    9dcc:	f383 8812 	msr	BASEPRI_MAX, r3
    9dd0:	f3bf 8f6f 	isb	sy
    9dd4:	4696      	mov	lr, r2
		return rv;
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    9dd6:	f8b5 c018 	ldrh.w	ip, [r5, #24]
    9dda:	f00c 0c07 	and.w	ip, ip, #7

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
    9dde:	8b6b      	ldrh	r3, [r5, #26]
    9de0:	f64f 71ff 	movw	r1, #65535	; 0xffff
    9de4:	428b      	cmp	r3, r1
    9de6:	d02c      	beq.n	9e42 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
    9de8:	4664      	mov	r4, ip
	if (state == ONOFF_STATE_ON) {
    9dea:	f1bc 0f02 	cmp.w	ip, #2
    9dee:	d008      	beq.n	9e02 <onoff_request+0x4c>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
	} else if ((state == ONOFF_STATE_OFF)
    9df0:	f1bc 0f06 	cmp.w	ip, #6
    9df4:	d819      	bhi.n	9e2a <onoff_request+0x74>
    9df6:	e8df f00c 	tbb	[pc, ip]
    9dfa:	181e      	.short	0x181e
    9dfc:	2a1e1818 	.word	0x2a1e1818
    9e00:	1e          	.byte	0x1e
    9e01:	00          	.byte	0x00
		mgr->refs += 1U;
    9e02:	3301      	adds	r3, #1
    9e04:	836b      	strh	r3, [r5, #26]
		notify = true;
    9e06:	2301      	movs	r3, #1
	bool start = false;             /* trigger a start transition */
    9e08:	2100      	movs	r1, #0
	bool add_client = false;        /* add client to pending list */
    9e0a:	4608      	mov	r0, r1
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
		rv = -EIO;
	}

out:
	if (add_client) {
    9e0c:	b128      	cbz	r0, 9e1a <onoff_request+0x64>
	parent->next = child;
    9e0e:	2000      	movs	r0, #0
    9e10:	6030      	str	r0, [r6, #0]
	return list->tail;
    9e12:	6868      	ldr	r0, [r5, #4]
Z_GENLIST_APPEND(slist, snode)
    9e14:	b308      	cbz	r0, 9e5a <onoff_request+0xa4>
	parent->next = child;
    9e16:	6006      	str	r6, [r0, #0]
	list->tail = node;
    9e18:	606e      	str	r6, [r5, #4]
		sys_slist_append(&mgr->clients, &cli->node);
	}

	if (start) {
    9e1a:	bb09      	cbnz	r1, 9e60 <onoff_request+0xaa>
	__asm__ volatile(
    9e1c:	f38e 8811 	msr	BASEPRI, lr
    9e20:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
    9e24:	bb0b      	cbnz	r3, 9e6a <onoff_request+0xb4>
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
    9e26:	4620      	mov	r0, r4
    9e28:	bd70      	pop	{r4, r5, r6, pc}
	if (state == ONOFF_STATE_ON) {
    9e2a:	f06f 0404 	mvn.w	r4, #4
    9e2e:	2300      	movs	r3, #0
    9e30:	4619      	mov	r1, r3
    9e32:	4618      	mov	r0, r3
    9e34:	e7ea      	b.n	9e0c <onoff_request+0x56>
		start = (state == ONOFF_STATE_OFF);
    9e36:	fabc f18c 	clz	r1, ip
    9e3a:	0949      	lsrs	r1, r1, #5
	bool notify = false;            /* do client notification */
    9e3c:	2300      	movs	r3, #0
		add_client = true;
    9e3e:	2001      	movs	r0, #1
    9e40:	e7e4      	b.n	9e0c <onoff_request+0x56>
		rv = -EAGAIN;
    9e42:	f06f 040a 	mvn.w	r4, #10
	bool notify = false;            /* do client notification */
    9e46:	2300      	movs	r3, #0
	bool start = false;             /* trigger a start transition */
    9e48:	4619      	mov	r1, r3
	bool add_client = false;        /* add client to pending list */
    9e4a:	4618      	mov	r0, r3
    9e4c:	e7de      	b.n	9e0c <onoff_request+0x56>
	if (state == ONOFF_STATE_ON) {
    9e4e:	f06f 0485 	mvn.w	r4, #133	; 0x85
    9e52:	2300      	movs	r3, #0
    9e54:	4619      	mov	r1, r3
    9e56:	4618      	mov	r0, r3
    9e58:	e7d8      	b.n	9e0c <onoff_request+0x56>
    9e5a:	606e      	str	r6, [r5, #4]
	list->head = node;
    9e5c:	602e      	str	r6, [r5, #0]
}
    9e5e:	e7dc      	b.n	9e1a <onoff_request+0x64>
		process_event(mgr, EVT_RECHECK, key);
    9e60:	2102      	movs	r1, #2
    9e62:	4628      	mov	r0, r5
    9e64:	f7f6 fd68 	bl	938 <process_event>
    9e68:	e7dd      	b.n	9e26 <onoff_request+0x70>
			notify_one(mgr, cli, state, 0);
    9e6a:	2300      	movs	r3, #0
    9e6c:	4662      	mov	r2, ip
    9e6e:	4631      	mov	r1, r6
    9e70:	4628      	mov	r0, r5
    9e72:	f7ff ff4b 	bl	9d0c <notify_one>
    9e76:	e7d6      	b.n	9e26 <onoff_request+0x70>

00009e78 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    9e78:	4602      	mov	r2, r0
    9e7a:	b158      	cbz	r0, 9e94 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    9e7c:	6843      	ldr	r3, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    9e7e:	f003 0303 	and.w	r3, r3, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    9e82:	2b01      	cmp	r3, #1
    9e84:	d003      	beq.n	9e8e <sys_notify_validate+0x16>
    9e86:	2b03      	cmp	r3, #3
    9e88:	d107      	bne.n	9e9a <sys_notify_validate+0x22>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
    9e8a:	6803      	ldr	r3, [r0, #0]
    9e8c:	b143      	cbz	r3, 9ea0 <sys_notify_validate+0x28>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
    9e8e:	2000      	movs	r0, #0
    9e90:	6090      	str	r0, [r2, #8]
    9e92:	4770      	bx	lr
		return -EINVAL;
    9e94:	f06f 0015 	mvn.w	r0, #21
    9e98:	4770      	bx	lr
	switch (sys_notify_get_method(notify)) {
    9e9a:	f06f 0015 	mvn.w	r0, #21
    9e9e:	4770      	bx	lr
			rv = -EINVAL;
    9ea0:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
    9ea4:	4770      	bx	lr

00009ea6 <sys_notify_finalize>:

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
    9ea6:	4603      	mov	r3, r0
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    9ea8:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    9eaa:	f002 0203 	and.w	r2, r2, #3
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
    9eae:	6081      	str	r1, [r0, #8]
	switch (method) {
    9eb0:	2a03      	cmp	r2, #3
    9eb2:	d103      	bne.n	9ebc <sys_notify_finalize+0x16>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    9eb4:	6800      	ldr	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    9eb6:	2200      	movs	r2, #0
    9eb8:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    9eba:	4770      	bx	lr
	sys_notify_generic_callback rv = NULL;
    9ebc:	2000      	movs	r0, #0
    9ebe:	e7fa      	b.n	9eb6 <sys_notify_finalize+0x10>

00009ec0 <extract_decimal>:
{
    9ec0:	4684      	mov	ip, r0
	const char *sp = *str;
    9ec2:	6802      	ldr	r2, [r0, #0]
	size_t val = 0;
    9ec4:	2000      	movs	r0, #0
	while (isdigit((int)(unsigned char)*sp) != 0) {
    9ec6:	e006      	b.n	9ed6 <extract_decimal+0x16>
		val = 10U * val + *sp++ - '0';
    9ec8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    9ecc:	3201      	adds	r2, #1
    9ece:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    9ed2:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
    9ed6:	7813      	ldrb	r3, [r2, #0]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    9ed8:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    9edc:	2909      	cmp	r1, #9
    9ede:	d9f3      	bls.n	9ec8 <extract_decimal+0x8>
	*str = sp;
    9ee0:	f8cc 2000 	str.w	r2, [ip]
}
    9ee4:	4770      	bx	lr

00009ee6 <extract_width>:
{
    9ee6:	b530      	push	{r4, r5, lr}
    9ee8:	b083      	sub	sp, #12
    9eea:	4604      	mov	r4, r0
    9eec:	9101      	str	r1, [sp, #4]
	conv->width_present = true;
    9eee:	7803      	ldrb	r3, [r0, #0]
    9ef0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    9ef4:	7003      	strb	r3, [r0, #0]
	if (*sp == '*') {
    9ef6:	460d      	mov	r5, r1
    9ef8:	780b      	ldrb	r3, [r1, #0]
    9efa:	2b2a      	cmp	r3, #42	; 0x2a
    9efc:	d018      	beq.n	9f30 <extract_width+0x4a>
	size_t width = extract_decimal(&sp);
    9efe:	a801      	add	r0, sp, #4
    9f00:	f7ff ffde 	bl	9ec0 <extract_decimal>
	if (sp != wp) {
    9f04:	9b01      	ldr	r3, [sp, #4]
    9f06:	429d      	cmp	r5, r3
    9f08:	d00f      	beq.n	9f2a <extract_width+0x44>
		conv->width_present = true;
    9f0a:	7823      	ldrb	r3, [r4, #0]
    9f0c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    9f10:	7023      	strb	r3, [r4, #0]
		conv->width_value = width;
    9f12:	6060      	str	r0, [r4, #4]
		conv->unsupported |= ((conv->width_value < 0)
    9f14:	b2db      	uxtb	r3, r3
    9f16:	f3c3 0340 	ubfx	r3, r3, #1, #1
				      || (width != (size_t)conv->width_value));
    9f1a:	2800      	cmp	r0, #0
    9f1c:	db10      	blt.n	9f40 <extract_width+0x5a>
    9f1e:	2200      	movs	r2, #0
		conv->unsupported |= ((conv->width_value < 0)
    9f20:	4313      	orrs	r3, r2
    9f22:	7822      	ldrb	r2, [r4, #0]
    9f24:	f363 0241 	bfi	r2, r3, #1, #1
    9f28:	7022      	strb	r2, [r4, #0]
	return sp;
    9f2a:	9801      	ldr	r0, [sp, #4]
}
    9f2c:	b003      	add	sp, #12
    9f2e:	bd30      	pop	{r4, r5, pc}
		conv->width_star = true;
    9f30:	7843      	ldrb	r3, [r0, #1]
    9f32:	f043 0301 	orr.w	r3, r3, #1
    9f36:	7043      	strb	r3, [r0, #1]
		return ++sp;
    9f38:	4608      	mov	r0, r1
    9f3a:	3001      	adds	r0, #1
    9f3c:	9001      	str	r0, [sp, #4]
    9f3e:	e7f5      	b.n	9f2c <extract_width+0x46>
				      || (width != (size_t)conv->width_value));
    9f40:	2201      	movs	r2, #1
    9f42:	e7ed      	b.n	9f20 <extract_width+0x3a>

00009f44 <extract_prec>:
{
    9f44:	b510      	push	{r4, lr}
    9f46:	b082      	sub	sp, #8
    9f48:	9101      	str	r1, [sp, #4]
	conv->prec_present = (*sp == '.');
    9f4a:	780b      	ldrb	r3, [r1, #0]
    9f4c:	2b2e      	cmp	r3, #46	; 0x2e
    9f4e:	bf14      	ite	ne
    9f50:	2300      	movne	r3, #0
    9f52:	2301      	moveq	r3, #1
    9f54:	7842      	ldrb	r2, [r0, #1]
    9f56:	f363 0241 	bfi	r2, r3, #1, #1
    9f5a:	7042      	strb	r2, [r0, #1]
	if (!conv->prec_present) {
    9f5c:	b1c3      	cbz	r3, 9f90 <extract_prec+0x4c>
    9f5e:	4604      	mov	r4, r0
	++sp;
    9f60:	9b01      	ldr	r3, [sp, #4]
    9f62:	1c5a      	adds	r2, r3, #1
    9f64:	9201      	str	r2, [sp, #4]
	if (*sp == '*') {
    9f66:	785b      	ldrb	r3, [r3, #1]
    9f68:	2b2a      	cmp	r3, #42	; 0x2a
    9f6a:	d013      	beq.n	9f94 <extract_prec+0x50>
	size_t prec = extract_decimal(&sp);
    9f6c:	a801      	add	r0, sp, #4
    9f6e:	f7ff ffa7 	bl	9ec0 <extract_decimal>
	conv->prec_value = prec;
    9f72:	60a0      	str	r0, [r4, #8]
	conv->unsupported |= ((conv->prec_value < 0)
    9f74:	7823      	ldrb	r3, [r4, #0]
    9f76:	f3c3 0340 	ubfx	r3, r3, #1, #1
			      || (prec != (size_t)conv->prec_value));
    9f7a:	2800      	cmp	r0, #0
    9f7c:	db12      	blt.n	9fa4 <extract_prec+0x60>
    9f7e:	2200      	movs	r2, #0
	conv->unsupported |= ((conv->prec_value < 0)
    9f80:	4313      	orrs	r3, r2
    9f82:	7822      	ldrb	r2, [r4, #0]
    9f84:	f363 0241 	bfi	r2, r3, #1, #1
    9f88:	7022      	strb	r2, [r4, #0]
	return sp;
    9f8a:	9801      	ldr	r0, [sp, #4]
}
    9f8c:	b002      	add	sp, #8
    9f8e:	bd10      	pop	{r4, pc}
		return sp;
    9f90:	4608      	mov	r0, r1
    9f92:	e7fb      	b.n	9f8c <extract_prec+0x48>
		conv->prec_star = true;
    9f94:	7843      	ldrb	r3, [r0, #1]
    9f96:	f043 0304 	orr.w	r3, r3, #4
    9f9a:	7043      	strb	r3, [r0, #1]
		return ++sp;
    9f9c:	4610      	mov	r0, r2
    9f9e:	3001      	adds	r0, #1
    9fa0:	9001      	str	r0, [sp, #4]
    9fa2:	e7f3      	b.n	9f8c <extract_prec+0x48>
			      || (prec != (size_t)conv->prec_value));
    9fa4:	2201      	movs	r2, #1
    9fa6:	e7eb      	b.n	9f80 <extract_prec+0x3c>

00009fa8 <extract_length>:
{
    9fa8:	4602      	mov	r2, r0
	switch (*sp) {
    9faa:	780b      	ldrb	r3, [r1, #0]
    9fac:	3b4c      	subs	r3, #76	; 0x4c
    9fae:	2b2e      	cmp	r3, #46	; 0x2e
    9fb0:	d85b      	bhi.n	a06a <extract_length+0xc2>
    9fb2:	e8df f003 	tbb	[pc, r3]
    9fb6:	5a4f      	.short	0x5a4f
    9fb8:	5a5a5a5a 	.word	0x5a5a5a5a
    9fbc:	5a5a5a5a 	.word	0x5a5a5a5a
    9fc0:	5a5a5a5a 	.word	0x5a5a5a5a
    9fc4:	5a5a5a5a 	.word	0x5a5a5a5a
    9fc8:	5a5a5a5a 	.word	0x5a5a5a5a
    9fcc:	5a5a5a5a 	.word	0x5a5a5a5a
    9fd0:	5a185a5a 	.word	0x5a185a5a
    9fd4:	5a295a3a 	.word	0x5a295a3a
    9fd8:	5a5a5a5a 	.word	0x5a5a5a5a
    9fdc:	5a485a5a 	.word	0x5a485a5a
    9fe0:	5a5a5a5a 	.word	0x5a5a5a5a
    9fe4:	41          	.byte	0x41
    9fe5:	00          	.byte	0x00
		if (*++sp == 'h') {
    9fe6:	1c48      	adds	r0, r1, #1
    9fe8:	784b      	ldrb	r3, [r1, #1]
    9fea:	2b68      	cmp	r3, #104	; 0x68
    9fec:	d005      	beq.n	9ffa <extract_length+0x52>
			conv->length_mod = LENGTH_H;
    9fee:	7853      	ldrb	r3, [r2, #1]
    9ff0:	2102      	movs	r1, #2
    9ff2:	f361 03c6 	bfi	r3, r1, #3, #4
    9ff6:	7053      	strb	r3, [r2, #1]
    9ff8:	4770      	bx	lr
			conv->length_mod = LENGTH_HH;
    9ffa:	7853      	ldrb	r3, [r2, #1]
    9ffc:	2001      	movs	r0, #1
    9ffe:	f360 03c6 	bfi	r3, r0, #3, #4
    a002:	7053      	strb	r3, [r2, #1]
			++sp;
    a004:	1c88      	adds	r0, r1, #2
    a006:	4770      	bx	lr
		if (*++sp == 'l') {
    a008:	1c48      	adds	r0, r1, #1
    a00a:	784b      	ldrb	r3, [r1, #1]
    a00c:	2b6c      	cmp	r3, #108	; 0x6c
    a00e:	d005      	beq.n	a01c <extract_length+0x74>
			conv->length_mod = LENGTH_L;
    a010:	7853      	ldrb	r3, [r2, #1]
    a012:	2103      	movs	r1, #3
    a014:	f361 03c6 	bfi	r3, r1, #3, #4
    a018:	7053      	strb	r3, [r2, #1]
    a01a:	4770      	bx	lr
			conv->length_mod = LENGTH_LL;
    a01c:	7853      	ldrb	r3, [r2, #1]
    a01e:	2004      	movs	r0, #4
    a020:	f360 03c6 	bfi	r3, r0, #3, #4
    a024:	7053      	strb	r3, [r2, #1]
			++sp;
    a026:	1c88      	adds	r0, r1, #2
    a028:	4770      	bx	lr
		conv->length_mod = LENGTH_J;
    a02a:	7853      	ldrb	r3, [r2, #1]
    a02c:	2005      	movs	r0, #5
    a02e:	f360 03c6 	bfi	r3, r0, #3, #4
    a032:	7053      	strb	r3, [r2, #1]
		++sp;
    a034:	1c48      	adds	r0, r1, #1
		break;
    a036:	4770      	bx	lr
		conv->length_mod = LENGTH_Z;
    a038:	7853      	ldrb	r3, [r2, #1]
    a03a:	2006      	movs	r0, #6
    a03c:	f360 03c6 	bfi	r3, r0, #3, #4
    a040:	7053      	strb	r3, [r2, #1]
		++sp;
    a042:	1c48      	adds	r0, r1, #1
		break;
    a044:	4770      	bx	lr
		conv->length_mod = LENGTH_T;
    a046:	7853      	ldrb	r3, [r2, #1]
    a048:	2007      	movs	r0, #7
    a04a:	f360 03c6 	bfi	r3, r0, #3, #4
    a04e:	7053      	strb	r3, [r2, #1]
		++sp;
    a050:	1c48      	adds	r0, r1, #1
		break;
    a052:	4770      	bx	lr
		conv->length_mod = LENGTH_UPPER_L;
    a054:	7853      	ldrb	r3, [r2, #1]
    a056:	2008      	movs	r0, #8
    a058:	f360 03c6 	bfi	r3, r0, #3, #4
    a05c:	7053      	strb	r3, [r2, #1]
		++sp;
    a05e:	1c48      	adds	r0, r1, #1
		conv->unsupported = true;
    a060:	7813      	ldrb	r3, [r2, #0]
    a062:	f043 0302 	orr.w	r3, r3, #2
    a066:	7013      	strb	r3, [r2, #0]
		break;
    a068:	4770      	bx	lr
		conv->length_mod = LENGTH_NONE;
    a06a:	7853      	ldrb	r3, [r2, #1]
    a06c:	f36f 03c6 	bfc	r3, #3, #4
    a070:	7053      	strb	r3, [r2, #1]
		break;
    a072:	4608      	mov	r0, r1
}
    a074:	4770      	bx	lr

0000a076 <extract_specifier>:
{
    a076:	b500      	push	{lr}
    a078:	4602      	mov	r2, r0
	conv->specifier = *sp++;
    a07a:	4608      	mov	r0, r1
    a07c:	f810 3b01 	ldrb.w	r3, [r0], #1
    a080:	70d3      	strb	r3, [r2, #3]
	switch (conv->specifier) {
    a082:	2b78      	cmp	r3, #120	; 0x78
    a084:	d817      	bhi.n	a0b6 <extract_specifier+0x40>
    a086:	2b6e      	cmp	r3, #110	; 0x6e
    a088:	d229      	bcs.n	a0de <extract_specifier+0x68>
    a08a:	2b69      	cmp	r3, #105	; 0x69
    a08c:	d813      	bhi.n	a0b6 <extract_specifier+0x40>
    a08e:	2b58      	cmp	r3, #88	; 0x58
    a090:	d317      	bcc.n	a0c2 <extract_specifier+0x4c>
    a092:	f1a3 0c58 	sub.w	ip, r3, #88	; 0x58
    a096:	fa5f fc8c 	uxtb.w	ip, ip
    a09a:	2101      	movs	r1, #1
    a09c:	fa01 f10c 	lsl.w	r1, r1, ip
    a0a0:	f411 4f62 	tst.w	r1, #57856	; 0xe200
    a0a4:	d114      	bne.n	a0d0 <extract_specifier+0x5a>
    a0a6:	f640 0c01 	movw	ip, #2049	; 0x801
    a0aa:	ea11 0f0c 	tst.w	r1, ip
    a0ae:	d155      	bne.n	a15c <extract_specifier+0xe6>
    a0b0:	f411 3f04 	tst.w	r1, #135168	; 0x21000
    a0b4:	d13a      	bne.n	a12c <extract_specifier+0xb6>
		conv->invalid = true;
    a0b6:	7813      	ldrb	r3, [r2, #0]
    a0b8:	f043 0301 	orr.w	r3, r3, #1
    a0bc:	7013      	strb	r3, [r2, #0]
	bool unsupported = false;
    a0be:	2100      	movs	r1, #0
		break;
    a0c0:	e042      	b.n	a148 <extract_specifier+0xd2>
	switch (conv->specifier) {
    a0c2:	2b41      	cmp	r3, #65	; 0x41
    a0c4:	d004      	beq.n	a0d0 <extract_specifier+0x5a>
    a0c6:	d3f6      	bcc.n	a0b6 <extract_specifier+0x40>
    a0c8:	3b45      	subs	r3, #69	; 0x45
    a0ca:	b2db      	uxtb	r3, r3
    a0cc:	2b02      	cmp	r3, #2
    a0ce:	d8f2      	bhi.n	a0b6 <extract_specifier+0x40>
		conv->specifier_cat = SPECIFIER_FP;
    a0d0:	7893      	ldrb	r3, [r2, #2]
    a0d2:	2104      	movs	r1, #4
    a0d4:	f361 0302 	bfi	r3, r1, #0, #3
    a0d8:	7093      	strb	r3, [r2, #2]
			unsupported = true;
    a0da:	2101      	movs	r1, #1
			break;
    a0dc:	e034      	b.n	a148 <extract_specifier+0xd2>
	switch (conv->specifier) {
    a0de:	f1a3 016e 	sub.w	r1, r3, #110	; 0x6e
    a0e2:	b2c9      	uxtb	r1, r1
    a0e4:	f04f 0c01 	mov.w	ip, #1
    a0e8:	fa0c fc01 	lsl.w	ip, ip, r1
    a0ec:	f240 4182 	movw	r1, #1154	; 0x482
    a0f0:	ea1c 0f01 	tst.w	ip, r1
    a0f4:	bf14      	ite	ne
    a0f6:	f04f 0e01 	movne.w	lr, #1
    a0fa:	f04f 0e00 	moveq.w	lr, #0
    a0fe:	d12d      	bne.n	a15c <extract_specifier+0xe6>
    a100:	f01c 0f24 	tst.w	ip, #36	; 0x24
    a104:	bf14      	ite	ne
    a106:	2101      	movne	r1, #1
    a108:	2100      	moveq	r1, #0
    a10a:	d139      	bne.n	a180 <extract_specifier+0x10a>
    a10c:	f01c 0c01 	ands.w	ip, ip, #1
    a110:	d0d1      	beq.n	a0b6 <extract_specifier+0x40>
		conv->specifier_cat = SPECIFIER_PTR;
    a112:	7893      	ldrb	r3, [r2, #2]
    a114:	f04f 0e03 	mov.w	lr, #3
    a118:	f36e 0302 	bfi	r3, lr, #0, #3
    a11c:	7093      	strb	r3, [r2, #2]
		if (conv->length_mod == LENGTH_UPPER_L) {
    a11e:	7853      	ldrb	r3, [r2, #1]
    a120:	f003 0378 	and.w	r3, r3, #120	; 0x78
    a124:	2b40      	cmp	r3, #64	; 0x40
    a126:	d10f      	bne.n	a148 <extract_specifier+0xd2>
			unsupported = true;
    a128:	4661      	mov	r1, ip
    a12a:	e00d      	b.n	a148 <extract_specifier+0xd2>
		conv->specifier_cat = SPECIFIER_SINT;
    a12c:	7891      	ldrb	r1, [r2, #2]
    a12e:	f04f 0c01 	mov.w	ip, #1
    a132:	f36c 0102 	bfi	r1, ip, #0, #3
    a136:	7091      	strb	r1, [r2, #2]
		if (conv->length_mod == LENGTH_UPPER_L) {
    a138:	7851      	ldrb	r1, [r2, #1]
    a13a:	f001 0178 	and.w	r1, r1, #120	; 0x78
    a13e:	2940      	cmp	r1, #64	; 0x40
    a140:	d013      	beq.n	a16a <extract_specifier+0xf4>
		if (conv->specifier == 'c') {
    a142:	2b63      	cmp	r3, #99	; 0x63
    a144:	d018      	beq.n	a178 <extract_specifier+0x102>
	bool unsupported = false;
    a146:	2100      	movs	r1, #0
	conv->unsupported |= unsupported;
    a148:	7813      	ldrb	r3, [r2, #0]
    a14a:	f3c3 0c40 	ubfx	ip, r3, #1, #1
    a14e:	ea41 010c 	orr.w	r1, r1, ip
    a152:	f361 0341 	bfi	r3, r1, #1, #1
    a156:	7013      	strb	r3, [r2, #0]
}
    a158:	f85d fb04 	ldr.w	pc, [sp], #4
		conv->specifier_cat = SPECIFIER_UINT;
    a15c:	7891      	ldrb	r1, [r2, #2]
    a15e:	f04f 0c02 	mov.w	ip, #2
    a162:	f36c 0102 	bfi	r1, ip, #0, #3
    a166:	7091      	strb	r1, [r2, #2]
    a168:	e7e6      	b.n	a138 <extract_specifier+0xc2>
			conv->invalid = true;
    a16a:	f892 c000 	ldrb.w	ip, [r2]
    a16e:	f04c 0c01 	orr.w	ip, ip, #1
    a172:	f882 c000 	strb.w	ip, [r2]
    a176:	e7e4      	b.n	a142 <extract_specifier+0xcc>
			unsupported = (conv->length_mod != LENGTH_NONE);
    a178:	3900      	subs	r1, #0
    a17a:	bf18      	it	ne
    a17c:	2101      	movne	r1, #1
    a17e:	e7e3      	b.n	a148 <extract_specifier+0xd2>
		conv->specifier_cat = SPECIFIER_PTR;
    a180:	7893      	ldrb	r3, [r2, #2]
    a182:	f04f 0c03 	mov.w	ip, #3
    a186:	f36c 0302 	bfi	r3, ip, #0, #3
    a18a:	7093      	strb	r3, [r2, #2]
		if (conv->length_mod != LENGTH_NONE) {
    a18c:	7853      	ldrb	r3, [r2, #1]
    a18e:	f013 0f78 	tst.w	r3, #120	; 0x78
    a192:	d1d9      	bne.n	a148 <extract_specifier+0xd2>
	bool unsupported = false;
    a194:	4671      	mov	r1, lr
    a196:	e7d7      	b.n	a148 <extract_specifier+0xd2>

0000a198 <extract_conversion>:
{
    a198:	b510      	push	{r4, lr}
    a19a:	4604      	mov	r4, r0
    a19c:	4608      	mov	r0, r1
	*conv = (struct conversion) {
    a19e:	2300      	movs	r3, #0
    a1a0:	6023      	str	r3, [r4, #0]
    a1a2:	6063      	str	r3, [r4, #4]
    a1a4:	60a3      	str	r3, [r4, #8]
	if (*sp == '%') {
    a1a6:	784b      	ldrb	r3, [r1, #1]
    a1a8:	2b25      	cmp	r3, #37	; 0x25
    a1aa:	d014      	beq.n	a1d6 <extract_conversion+0x3e>
    a1ac:	3101      	adds	r1, #1
	sp = extract_flags(conv, sp);
    a1ae:	4620      	mov	r0, r4
    a1b0:	f7f6 fc78 	bl	aa4 <extract_flags>
    a1b4:	4601      	mov	r1, r0
	sp = extract_width(conv, sp);
    a1b6:	4620      	mov	r0, r4
    a1b8:	f7ff fe95 	bl	9ee6 <extract_width>
    a1bc:	4601      	mov	r1, r0
	sp = extract_prec(conv, sp);
    a1be:	4620      	mov	r0, r4
    a1c0:	f7ff fec0 	bl	9f44 <extract_prec>
    a1c4:	4601      	mov	r1, r0
	sp = extract_length(conv, sp);
    a1c6:	4620      	mov	r0, r4
    a1c8:	f7ff feee 	bl	9fa8 <extract_length>
    a1cc:	4601      	mov	r1, r0
	sp = extract_specifier(conv, sp);
    a1ce:	4620      	mov	r0, r4
    a1d0:	f7ff ff51 	bl	a076 <extract_specifier>
}
    a1d4:	bd10      	pop	{r4, pc}
		conv->specifier = *sp++;
    a1d6:	3002      	adds	r0, #2
    a1d8:	70e3      	strb	r3, [r4, #3]
		return sp;
    a1da:	e7fb      	b.n	a1d4 <extract_conversion+0x3c>

0000a1dc <conversion_radix>:
	switch (specifier) {
    a1dc:	286f      	cmp	r0, #111	; 0x6f
    a1de:	d00c      	beq.n	a1fa <conversion_radix+0x1e>
    a1e0:	d905      	bls.n	a1ee <conversion_radix+0x12>
    a1e2:	2870      	cmp	r0, #112	; 0x70
    a1e4:	d00b      	beq.n	a1fe <conversion_radix+0x22>
    a1e6:	2878      	cmp	r0, #120	; 0x78
    a1e8:	d10b      	bne.n	a202 <conversion_radix+0x26>
		return 16;
    a1ea:	2010      	movs	r0, #16
    a1ec:	4770      	bx	lr
	switch (specifier) {
    a1ee:	2858      	cmp	r0, #88	; 0x58
    a1f0:	d001      	beq.n	a1f6 <conversion_radix+0x1a>
    a1f2:	200a      	movs	r0, #10
    a1f4:	4770      	bx	lr
		return 16;
    a1f6:	2010      	movs	r0, #16
    a1f8:	4770      	bx	lr
		return 8;
    a1fa:	2008      	movs	r0, #8
    a1fc:	4770      	bx	lr
		return 16;
    a1fe:	2010      	movs	r0, #16
    a200:	4770      	bx	lr
	switch (specifier) {
    a202:	200a      	movs	r0, #10
}
    a204:	4770      	bx	lr

0000a206 <encode_uint>:
{
    a206:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a20a:	4605      	mov	r5, r0
    a20c:	460c      	mov	r4, r1
    a20e:	4693      	mov	fp, r2
    a210:	4699      	mov	r9, r3
    a212:	9f0a      	ldr	r7, [sp, #40]	; 0x28
	bool upcase = isupper((int)conv->specifier) != 0;
    a214:	78d0      	ldrb	r0, [r2, #3]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    a216:	f1a0 0a41 	sub.w	sl, r0, #65	; 0x41
	const unsigned int radix = conversion_radix(conv->specifier);
    a21a:	f7ff ffdf 	bl	a1dc <conversion_radix>
    a21e:	4606      	mov	r6, r0
	char *bp = bps + (bpe - bps);
    a220:	e015      	b.n	a24e <encode_uint+0x48>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    a222:	f1ba 0f19 	cmp.w	sl, #25
    a226:	d820      	bhi.n	a26a <encode_uint+0x64>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    a228:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    a22a:	3237      	adds	r2, #55	; 0x37
    a22c:	b2d2      	uxtb	r2, r2
    a22e:	f807 2d01 	strb.w	r2, [r7, #-1]!
		value /= radix;
    a232:	4632      	mov	r2, r6
    a234:	4643      	mov	r3, r8
    a236:	4628      	mov	r0, r5
    a238:	4621      	mov	r1, r4
    a23a:	f7f5 ff8b 	bl	154 <__aeabi_uldivmod>
	} while ((value != 0) && (bps < bp));
    a23e:	42b5      	cmp	r5, r6
    a240:	f174 0400 	sbcs.w	r4, r4, #0
    a244:	d315      	bcc.n	a272 <encode_uint+0x6c>
    a246:	454f      	cmp	r7, r9
    a248:	d913      	bls.n	a272 <encode_uint+0x6c>
		value /= radix;
    a24a:	4605      	mov	r5, r0
    a24c:	460c      	mov	r4, r1
		unsigned int lsv = (unsigned int)(value % radix);
    a24e:	f04f 0800 	mov.w	r8, #0
    a252:	4632      	mov	r2, r6
    a254:	4643      	mov	r3, r8
    a256:	4628      	mov	r0, r5
    a258:	4621      	mov	r1, r4
    a25a:	f7f5 ff7b 	bl	154 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    a25e:	2a09      	cmp	r2, #9
    a260:	d8df      	bhi.n	a222 <encode_uint+0x1c>
    a262:	b2d2      	uxtb	r2, r2
    a264:	3230      	adds	r2, #48	; 0x30
    a266:	b2d2      	uxtb	r2, r2
    a268:	e7e1      	b.n	a22e <encode_uint+0x28>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    a26a:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    a26c:	3257      	adds	r2, #87	; 0x57
    a26e:	b2d2      	uxtb	r2, r2
    a270:	e7dd      	b.n	a22e <encode_uint+0x28>
	if (conv->flag_hash) {
    a272:	f89b 3000 	ldrb.w	r3, [fp]
    a276:	f013 0f20 	tst.w	r3, #32
    a27a:	d003      	beq.n	a284 <encode_uint+0x7e>
		if (radix == 8) {
    a27c:	2e08      	cmp	r6, #8
    a27e:	d004      	beq.n	a28a <encode_uint+0x84>
		} else if (radix == 16) {
    a280:	2e10      	cmp	r6, #16
    a282:	d009      	beq.n	a298 <encode_uint+0x92>
}
    a284:	4638      	mov	r0, r7
    a286:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			conv->altform_0 = true;
    a28a:	f89b 3002 	ldrb.w	r3, [fp, #2]
    a28e:	f043 0308 	orr.w	r3, r3, #8
    a292:	f88b 3002 	strb.w	r3, [fp, #2]
    a296:	e7f5      	b.n	a284 <encode_uint+0x7e>
			conv->altform_0c = true;
    a298:	f89b 3002 	ldrb.w	r3, [fp, #2]
    a29c:	f043 0310 	orr.w	r3, r3, #16
    a2a0:	f88b 3002 	strb.w	r3, [fp, #2]
    a2a4:	e7ee      	b.n	a284 <encode_uint+0x7e>

0000a2a6 <store_count>:
	switch ((enum length_mod_enum)conv->length_mod) {
    a2a6:	7843      	ldrb	r3, [r0, #1]
    a2a8:	f3c3 03c3 	ubfx	r3, r3, #3, #4
    a2ac:	2b07      	cmp	r3, #7
    a2ae:	d818      	bhi.n	a2e2 <store_count+0x3c>
    a2b0:	e8df f003 	tbb	[pc, r3]
    a2b4:	0a080604 	.word	0x0a080604
    a2b8:	1614100c 	.word	0x1614100c
		*(int *)dp = count;
    a2bc:	600a      	str	r2, [r1, #0]
		break;
    a2be:	4770      	bx	lr
		*(signed char *)dp = (signed char)count;
    a2c0:	700a      	strb	r2, [r1, #0]
		break;
    a2c2:	4770      	bx	lr
		*(short *)dp = (short)count;
    a2c4:	800a      	strh	r2, [r1, #0]
		break;
    a2c6:	4770      	bx	lr
		*(long *)dp = (long)count;
    a2c8:	600a      	str	r2, [r1, #0]
		break;
    a2ca:	4770      	bx	lr
		*(long long *)dp = (long long)count;
    a2cc:	17d3      	asrs	r3, r2, #31
    a2ce:	600a      	str	r2, [r1, #0]
    a2d0:	604b      	str	r3, [r1, #4]
		break;
    a2d2:	4770      	bx	lr
		*(intmax_t *)dp = (intmax_t)count;
    a2d4:	17d3      	asrs	r3, r2, #31
    a2d6:	600a      	str	r2, [r1, #0]
    a2d8:	604b      	str	r3, [r1, #4]
		break;
    a2da:	4770      	bx	lr
		*(size_t *)dp = (size_t)count;
    a2dc:	600a      	str	r2, [r1, #0]
		break;
    a2de:	4770      	bx	lr
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    a2e0:	600a      	str	r2, [r1, #0]
}
    a2e2:	4770      	bx	lr

0000a2e4 <outs>:
{
    a2e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a2e8:	4607      	mov	r7, r0
    a2ea:	460e      	mov	r6, r1
    a2ec:	4614      	mov	r4, r2
    a2ee:	4698      	mov	r8, r3
	size_t count = 0;
    a2f0:	2500      	movs	r5, #0
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    a2f2:	e006      	b.n	a302 <outs+0x1e>
		int rc = out((int)*sp++, ctx);
    a2f4:	4631      	mov	r1, r6
    a2f6:	f814 0b01 	ldrb.w	r0, [r4], #1
    a2fa:	47b8      	blx	r7
		if (rc < 0) {
    a2fc:	2800      	cmp	r0, #0
    a2fe:	db09      	blt.n	a314 <outs+0x30>
		++count;
    a300:	3501      	adds	r5, #1
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    a302:	4544      	cmp	r4, r8
    a304:	d3f6      	bcc.n	a2f4 <outs+0x10>
    a306:	f1b8 0f00 	cmp.w	r8, #0
    a30a:	d102      	bne.n	a312 <outs+0x2e>
    a30c:	7823      	ldrb	r3, [r4, #0]
    a30e:	2b00      	cmp	r3, #0
    a310:	d1f0      	bne.n	a2f4 <outs+0x10>
	return (int)count;
    a312:	4628      	mov	r0, r5
}
    a314:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000a318 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    a318:	4770      	bx	lr

0000a31a <arch_busy_wait>:

void arch_busy_wait(uint32_t time_us)
{
    a31a:	b508      	push	{r3, lr}
	nrfx_coredep_delay_us(time_us);
    a31c:	f7f6 fef0 	bl	1100 <nrfx_coredep_delay_us>
}
    a320:	bd08      	pop	{r3, pc}

0000a322 <nrf_regulators_system_off>:
#endif
}

NRF_STATIC_INLINE void nrf_regulators_system_off(NRF_REGULATORS_Type * p_reg)
{
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
    a322:	2301      	movs	r3, #1
    a324:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
    a328:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
    a32c:	bf20      	wfe
    while (true)
    a32e:	e7fd      	b.n	a32c <nrf_regulators_system_off+0xa>

0000a330 <pm_state_exit_post_ops>:
    a330:	2300      	movs	r3, #0
    a332:	f383 8811 	msr	BASEPRI, r3
    a336:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    a33a:	4770      	bx	lr

0000a33c <z_log_minimal_printk>:
#include <zephyr/sys/printk.h>

#define HEXDUMP_BYTES_IN_LINE 8U

void z_log_minimal_printk(const char *fmt, ...)
{
    a33c:	b40f      	push	{r0, r1, r2, r3}
    a33e:	b500      	push	{lr}
    a340:	b083      	sub	sp, #12
    a342:	a904      	add	r1, sp, #16
    a344:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
    a348:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
    a34a:	f7f6 fae7 	bl	91c <vprintk>
	va_end(ap);
}
    a34e:	b003      	add	sp, #12
    a350:	f85d eb04 	ldr.w	lr, [sp], #4
    a354:	b004      	add	sp, #16
    a356:	4770      	bx	lr

0000a358 <atomic_test_and_clear_bit>:
 * @param bit Bit number (starting from 0).
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
    a358:	b500      	push	{lr}
	atomic_val_t mask = ATOMIC_MASK(bit);
    a35a:	f001 021f 	and.w	r2, r1, #31
    a35e:	2301      	movs	r3, #1
    a360:	4093      	lsls	r3, r2
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    a362:	0949      	lsrs	r1, r1, #5
    a364:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    a368:	43d9      	mvns	r1, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    a36a:	e8d0 2fef 	ldaex	r2, [r0]
    a36e:	ea02 0c01 	and.w	ip, r2, r1
    a372:	e8c0 cfee 	stlex	lr, ip, [r0]
    a376:	f1be 0f00 	cmp.w	lr, #0
    a37a:	d1f6      	bne.n	a36a <atomic_test_and_clear_bit+0x12>

	return (old & mask) != 0;
    a37c:	4213      	tst	r3, r2
}
    a37e:	bf14      	ite	ne
    a380:	2001      	movne	r0, #1
    a382:	2000      	moveq	r0, #0
    a384:	f85d fb04 	ldr.w	pc, [sp], #4

0000a388 <atomic_set_bit>:
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    a388:	f001 021f 	and.w	r2, r1, #31
    a38c:	2301      	movs	r3, #1
    a38e:	4093      	lsls	r3, r2

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    a390:	0949      	lsrs	r1, r1, #5
    a392:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    a396:	e8d0 2fef 	ldaex	r2, [r0]
    a39a:	431a      	orrs	r2, r3
    a39c:	e8c0 2fe1 	stlex	r1, r2, [r0]
    a3a0:	2900      	cmp	r1, #0
    a3a2:	d1f8      	bne.n	a396 <atomic_set_bit+0xe>
}
    a3a4:	4770      	bx	lr

0000a3a6 <pm_policy_state_lock_is_active>:
			return (atomic_get(&substate_lock_t[i].lock) != 0);
		}
	}

	return false;
}
    a3a6:	2000      	movs	r0, #0
    a3a8:	4770      	bx	lr

0000a3aa <flash_area_close>:

void flash_area_close(const struct flash_area *fa)
{
	/* nothing to do for now */
}
    a3aa:	4770      	bx	lr

0000a3ac <flash_area_read>:

int flash_area_read(const struct flash_area *fa, off_t off, void *dst,
		    size_t len)
{
    a3ac:	b510      	push	{r4, lr}
    a3ae:	4684      	mov	ip, r0


static inline bool is_in_flash_area_bounds(const struct flash_area *fa,
					   off_t off, size_t len)
{
	return (off >= 0) && ((off + len) <= fa->fa_size);
    a3b0:	2900      	cmp	r1, #0
    a3b2:	db06      	blt.n	a3c2 <flash_area_read+0x16>
    a3b4:	18c8      	adds	r0, r1, r3
    a3b6:	f8dc 4008 	ldr.w	r4, [ip, #8]
    a3ba:	42a0      	cmp	r0, r4
    a3bc:	d90c      	bls.n	a3d8 <flash_area_read+0x2c>
    a3be:	2000      	movs	r0, #0
    a3c0:	e000      	b.n	a3c4 <flash_area_read+0x18>
    a3c2:	2000      	movs	r0, #0
	if (!is_in_flash_area_bounds(fa, off, len)) {
    a3c4:	b150      	cbz	r0, a3dc <flash_area_read+0x30>
		return -EINVAL;
	}

	return flash_read(fa->fa_dev, fa->fa_off + off, dst, len);
    a3c6:	f8dc 000c 	ldr.w	r0, [ip, #12]
    a3ca:	f8dc 4004 	ldr.w	r4, [ip, #4]
    a3ce:	4421      	add	r1, r4

static inline int z_impl_flash_read(const struct device *dev, off_t offset,
				    void *data,
				    size_t len)
{
	const struct flash_driver_api *api =
    a3d0:	6884      	ldr	r4, [r0, #8]
		(const struct flash_driver_api *)dev->api;

	return api->read(dev, offset, data, len);
    a3d2:	6824      	ldr	r4, [r4, #0]
    a3d4:	47a0      	blx	r4
}
    a3d6:	bd10      	pop	{r4, pc}
    a3d8:	2001      	movs	r0, #1
    a3da:	e7f3      	b.n	a3c4 <flash_area_read+0x18>
		return -EINVAL;
    a3dc:	f06f 0015 	mvn.w	r0, #21
    a3e0:	e7f9      	b.n	a3d6 <flash_area_read+0x2a>

0000a3e2 <flash_area_write>:

int flash_area_write(const struct flash_area *fa, off_t off, const void *src,
		     size_t len)
{
    a3e2:	b510      	push	{r4, lr}
    a3e4:	4684      	mov	ip, r0
    a3e6:	2900      	cmp	r1, #0
    a3e8:	db06      	blt.n	a3f8 <flash_area_write+0x16>
    a3ea:	18c8      	adds	r0, r1, r3
    a3ec:	f8dc 4008 	ldr.w	r4, [ip, #8]
    a3f0:	42a0      	cmp	r0, r4
    a3f2:	d90c      	bls.n	a40e <flash_area_write+0x2c>
    a3f4:	2000      	movs	r0, #0
    a3f6:	e000      	b.n	a3fa <flash_area_write+0x18>
    a3f8:	2000      	movs	r0, #0
	if (!is_in_flash_area_bounds(fa, off, len)) {
    a3fa:	b150      	cbz	r0, a412 <flash_area_write+0x30>
		return -EINVAL;
	}

	return flash_write(fa->fa_dev, fa->fa_off + off, (void *)src, len);
    a3fc:	f8dc 000c 	ldr.w	r0, [ip, #12]
    a400:	f8dc 4004 	ldr.w	r4, [ip, #4]
    a404:	4421      	add	r1, r4
			  size_t len);

static inline int z_impl_flash_write(const struct device *dev, off_t offset,
				     const void *data, size_t len)
{
	const struct flash_driver_api *api =
    a406:	6884      	ldr	r4, [r0, #8]
		(const struct flash_driver_api *)dev->api;
	int rc;

	rc = api->write(dev, offset, data, len);
    a408:	6864      	ldr	r4, [r4, #4]
    a40a:	47a0      	blx	r4
}
    a40c:	bd10      	pop	{r4, pc}
    a40e:	2001      	movs	r0, #1
    a410:	e7f3      	b.n	a3fa <flash_area_write+0x18>
		return -EINVAL;
    a412:	f06f 0015 	mvn.w	r0, #21
    a416:	e7f9      	b.n	a40c <flash_area_write+0x2a>

0000a418 <flash_area_erase>:

int flash_area_erase(const struct flash_area *fa, off_t off, size_t len)
{
    a418:	b508      	push	{r3, lr}
    a41a:	4603      	mov	r3, r0
    a41c:	2900      	cmp	r1, #0
    a41e:	db06      	blt.n	a42e <flash_area_erase+0x16>
    a420:	1888      	adds	r0, r1, r2
    a422:	f8d3 c008 	ldr.w	ip, [r3, #8]
    a426:	4560      	cmp	r0, ip
    a428:	d90a      	bls.n	a440 <flash_area_erase+0x28>
    a42a:	2000      	movs	r0, #0
    a42c:	e000      	b.n	a430 <flash_area_erase+0x18>
    a42e:	2000      	movs	r0, #0
	if (!is_in_flash_area_bounds(fa, off, len)) {
    a430:	b140      	cbz	r0, a444 <flash_area_erase+0x2c>
		return -EINVAL;
	}

	return flash_erase(fa->fa_dev, fa->fa_off + off, len);
    a432:	68d8      	ldr	r0, [r3, #12]
    a434:	685b      	ldr	r3, [r3, #4]
    a436:	4419      	add	r1, r3
__syscall int flash_erase(const struct device *dev, off_t offset, size_t size);

static inline int z_impl_flash_erase(const struct device *dev, off_t offset,
				     size_t size)
{
	const struct flash_driver_api *api =
    a438:	6883      	ldr	r3, [r0, #8]
		(const struct flash_driver_api *)dev->api;
	int rc;

	rc = api->erase(dev, offset, size);
    a43a:	689b      	ldr	r3, [r3, #8]
    a43c:	4798      	blx	r3
}
    a43e:	bd08      	pop	{r3, pc}
    a440:	2001      	movs	r0, #1
    a442:	e7f5      	b.n	a430 <flash_area_erase+0x18>
		return -EINVAL;
    a444:	f06f 0015 	mvn.w	r0, #21
    a448:	e7f9      	b.n	a43e <flash_area_erase+0x26>

0000a44a <flash_area_get_device>:
}

const struct device *flash_area_get_device(const struct flash_area *fa)
{
	return fa->fa_dev;
}
    a44a:	68c0      	ldr	r0, [r0, #12]
    a44c:	4770      	bx	lr

0000a44e <abort_function>:
	while(1);
    a44e:	e7fe      	b.n	a44e <abort_function>

0000a450 <z_arm_fatal_error>:

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    a450:	b538      	push	{r3, r4, r5, lr}
    a452:	4604      	mov	r4, r0

	if (esf != NULL) {
    a454:	460d      	mov	r5, r1
    a456:	b111      	cbz	r1, a45e <z_arm_fatal_error+0xe>
		esf_dump(esf);
    a458:	4608      	mov	r0, r1
    a45a:	f7f7 f951 	bl	1700 <esf_dump>
	}
	z_fatal_error(reason, esf);
    a45e:	4629      	mov	r1, r5
    a460:	4620      	mov	r0, r4
    a462:	f7fd fd95 	bl	7f90 <z_fatal_error>
}
    a466:	bd38      	pop	{r3, r4, r5, pc}

0000a468 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
    a468:	b508      	push	{r3, lr}
    a46a:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
    a46c:	6800      	ldr	r0, [r0, #0]
    a46e:	f7ff ffef 	bl	a450 <z_arm_fatal_error>
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
    a472:	bd08      	pop	{r3, pc}

0000a474 <arch_irq_enable>:
{
    a474:	b508      	push	{r3, lr}
	NVIC_EnableIRQ((IRQn_Type)irq);
    a476:	b240      	sxtb	r0, r0
    a478:	f7f7 f96a 	bl	1750 <__NVIC_EnableIRQ>
}
    a47c:	bd08      	pop	{r3, pc}

0000a47e <arch_irq_disable>:
{
    a47e:	b508      	push	{r3, lr}
	NVIC_DisableIRQ((IRQn_Type)irq);
    a480:	b240      	sxtb	r0, r0
    a482:	f7f7 f973 	bl	176c <__NVIC_DisableIRQ>
}
    a486:	bd08      	pop	{r3, pc}

0000a488 <z_arm_irq_priority_set>:
 * The priority is verified if ASSERT_ON is enabled. The maximum number
 * of priority levels is a little complex, as there are some hardware
 * priority levels which are reserved.
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    a488:	b508      	push	{r3, lr}
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    a48a:	3101      	adds	r1, #1
    a48c:	b240      	sxtb	r0, r0
    a48e:	f7f7 f97f 	bl	1790 <__NVIC_SetPriority>
}
    a492:	bd08      	pop	{r3, pc}

0000a494 <z_irq_spurious>:
 * Installed in all _sw_isr_table slots at boot time. Throws an error if
 * called.
 *
 */
void z_irq_spurious(const void *unused)
{
    a494:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    a496:	2100      	movs	r1, #0
    a498:	2001      	movs	r0, #1
    a49a:	f7ff ffd9 	bl	a450 <z_arm_fatal_error>
}
    a49e:	bd08      	pop	{r3, pc}

0000a4a0 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
    a4a0:	b508      	push	{r3, lr}
	handler();
    a4a2:	f7f7 f997 	bl	17d4 <z_SysNmiOnReset>
	z_arm_int_exit();
    a4a6:	f7f7 fa5f 	bl	1968 <z_arm_exc_exit>
}
    a4aa:	bd08      	pop	{r3, pc}

0000a4ac <configure_builtin_stack_guard>:
	uint32_t guard_start = thread->stack_info.start;
    a4ac:	6e43      	ldr	r3, [r0, #100]	; 0x64
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
    a4ae:	f383 880b 	msr	PSPLIM, r3
}
    a4b2:	4770      	bx	lr

0000a4b4 <memory_fault_recoverable>:
}
    a4b4:	2000      	movs	r0, #0
    a4b6:	4770      	bx	lr

0000a4b8 <fault_handle>:
{
    a4b8:	b508      	push	{r3, lr}
	*recoverable = false;
    a4ba:	2300      	movs	r3, #0
    a4bc:	7013      	strb	r3, [r2, #0]
	switch (fault) {
    a4be:	1ecb      	subs	r3, r1, #3
    a4c0:	2b09      	cmp	r3, #9
    a4c2:	d81a      	bhi.n	a4fa <fault_handle+0x42>
    a4c4:	e8df f003 	tbb	[pc, r3]
    a4c8:	110d0905 	.word	0x110d0905
    a4cc:	19191919 	.word	0x19191919
    a4d0:	1419      	.short	0x1419
		reason = hard_fault(esf, recoverable);
    a4d2:	4611      	mov	r1, r2
    a4d4:	f7f7 fc04 	bl	1ce0 <hard_fault>
}
    a4d8:	bd08      	pop	{r3, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    a4da:	2100      	movs	r1, #0
    a4dc:	f7f7 fa92 	bl	1a04 <mem_manage_fault>
		break;
    a4e0:	e7fa      	b.n	a4d8 <fault_handle+0x20>
		reason = bus_fault(esf, 0, recoverable);
    a4e2:	2100      	movs	r1, #0
    a4e4:	f7f7 fb10 	bl	1b08 <bus_fault>
		break;
    a4e8:	e7f6      	b.n	a4d8 <fault_handle+0x20>
		reason = usage_fault(esf);
    a4ea:	f7f7 fb8b 	bl	1c04 <usage_fault>
		break;
    a4ee:	e7f3      	b.n	a4d8 <fault_handle+0x20>
		debug_monitor(esf, recoverable);
    a4f0:	4611      	mov	r1, r2
    a4f2:	f7f7 fc57 	bl	1da4 <debug_monitor>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    a4f6:	2000      	movs	r0, #0
		break;
    a4f8:	e7ee      	b.n	a4d8 <fault_handle+0x20>
		reserved_exception(esf, fault);
    a4fa:	f7f7 fc5d 	bl	1db8 <reserved_exception>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    a4fe:	2000      	movs	r0, #0
	return reason;
    a500:	e7ea      	b.n	a4d8 <fault_handle+0x20>

0000a502 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
    a502:	e840 f000 	tt	r0, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
    a506:	f410 3f80 	tst.w	r0, #65536	; 0x10000
    a50a:	d001      	beq.n	a510 <arm_cmse_mpu_region_get+0xe>
		return addr_info.flags.mpu_region;
    a50c:	b2c0      	uxtb	r0, r0
    a50e:	4770      	bx	lr
	}

	return -EINVAL;
    a510:	f06f 0015 	mvn.w	r0, #21
}
    a514:	4770      	bx	lr

0000a516 <region_init>:
{
    a516:	b508      	push	{r3, lr}
		(region_conf->base & MPU_RBAR_BASE_Msk)
    a518:	680b      	ldr	r3, [r1, #0]
    a51a:	f023 0c1f 	bic.w	ip, r3, #31
		| (region_conf->attr.rbar &
    a51e:	7a0b      	ldrb	r3, [r1, #8]
    a520:	f003 0e1f 	and.w	lr, r3, #31
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    a524:	68ca      	ldr	r2, [r1, #12]
    a526:	f022 021f 	bic.w	r2, r2, #31
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    a52a:	095b      	lsrs	r3, r3, #5
    a52c:	ea42 0243 	orr.w	r2, r2, r3, lsl #1
	mpu_set_region(
    a530:	f042 0201 	orr.w	r2, r2, #1
    a534:	ea4c 010e 	orr.w	r1, ip, lr
    a538:	f7f7 fd6e 	bl	2018 <mpu_set_region>
}
    a53c:	bd08      	pop	{r3, pc}

0000a53e <mpu_partition_is_valid>:
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
    a53e:	6843      	ldr	r3, [r0, #4]
		&&
    a540:	2b1f      	cmp	r3, #31
    a542:	d908      	bls.n	a556 <mpu_partition_is_valid+0x18>
		&&
    a544:	f013 0f1f 	tst.w	r3, #31
    a548:	d107      	bne.n	a55a <mpu_partition_is_valid+0x1c>
		((part->start &
    a54a:	6803      	ldr	r3, [r0, #0]
		&&
    a54c:	f013 0f1f 	tst.w	r3, #31
    a550:	d005      	beq.n	a55e <mpu_partition_is_valid+0x20>
    a552:	2000      	movs	r0, #0
    a554:	4770      	bx	lr
    a556:	2000      	movs	r0, #0
    a558:	4770      	bx	lr
    a55a:	2000      	movs	r0, #0
    a55c:	4770      	bx	lr
    a55e:	2001      	movs	r0, #1
}
    a560:	4770      	bx	lr

0000a562 <mpu_configure_region>:
{
    a562:	b510      	push	{r4, lr}
    a564:	b084      	sub	sp, #16
	region_conf.base = new_region->start;
    a566:	680b      	ldr	r3, [r1, #0]
    a568:	9300      	str	r3, [sp, #0]
		&new_region->attr, new_region->start, new_region->size);
    a56a:	684c      	ldr	r4, [r1, #4]
	p_attr->rbar = attr->rbar &
    a56c:	f8b1 c008 	ldrh.w	ip, [r1, #8]
    a570:	f89d 2008 	ldrb.w	r2, [sp, #8]
    a574:	f36c 0204 	bfi	r2, ip, #0, #5
    a578:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->mair_idx = attr->mair_idx;
    a57c:	8949      	ldrh	r1, [r1, #10]
    a57e:	b2d2      	uxtb	r2, r2
    a580:	f361 1247 	bfi	r2, r1, #5, #3
    a584:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    a588:	f023 031f 	bic.w	r3, r3, #31
    a58c:	4423      	add	r3, r4
    a58e:	3b01      	subs	r3, #1
    a590:	f023 031f 	bic.w	r3, r3, #31
    a594:	9303      	str	r3, [sp, #12]
	return region_allocate_and_init(index,
    a596:	4669      	mov	r1, sp
    a598:	f7f7 fd68 	bl	206c <region_allocate_and_init>
}
    a59c:	b004      	add	sp, #16
    a59e:	bd10      	pop	{r4, pc}

0000a5a0 <get_region_index>:
{
    a5a0:	b570      	push	{r4, r5, r6, lr}
    a5a2:	4604      	mov	r4, r0
    a5a4:	460e      	mov	r6, r1
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    a5a6:	f7ff ffac 	bl	a502 <arm_cmse_mpu_region_get>
    a5aa:	4605      	mov	r5, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    a5ac:	4434      	add	r4, r6
    a5ae:	1e60      	subs	r0, r4, #1
    a5b0:	f7ff ffa7 	bl	a502 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    a5b4:	4285      	cmp	r5, r0
    a5b6:	d101      	bne.n	a5bc <get_region_index+0x1c>
}
    a5b8:	4628      	mov	r0, r5
    a5ba:	bd70      	pop	{r4, r5, r6, pc}
	return -EINVAL;
    a5bc:	f06f 0515 	mvn.w	r5, #21
    a5c0:	e7fa      	b.n	a5b8 <get_region_index+0x18>

0000a5c2 <arm_core_mpu_configure_static_mpu_regions>:
{
    a5c2:	b508      	push	{r3, lr}
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
    a5c4:	f7f7 fe36 	bl	2234 <mpu_configure_static_mpu_regions>
}
    a5c8:	bd08      	pop	{r3, pc}

0000a5ca <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
    a5ca:	b508      	push	{r3, lr}
	if (mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    a5cc:	f7f7 fe3c 	bl	2248 <mpu_mark_areas_for_dynamic_regions>
}
    a5d0:	bd08      	pop	{r3, pc}

0000a5d2 <free>:

void free(void *ptr)
{
	ARG_UNUSED(ptr);
}
    a5d2:	4770      	bx	lr

0000a5d4 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    a5d4:	4602      	mov	r2, r0
    a5d6:	e002      	b.n	a5de <strcpy+0xa>
		*d = *s;
    a5d8:	f802 3b01 	strb.w	r3, [r2], #1
		d++;
		s++;
    a5dc:	3101      	adds	r1, #1
	while (*s != '\0') {
    a5de:	780b      	ldrb	r3, [r1, #0]
    a5e0:	2b00      	cmp	r3, #0
    a5e2:	d1f9      	bne.n	a5d8 <strcpy+0x4>
	}

	*d = '\0';
    a5e4:	7013      	strb	r3, [r2, #0]

	return dest;
}
    a5e6:	4770      	bx	lr

0000a5e8 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    a5e8:	4603      	mov	r3, r0
    a5ea:	b1a2      	cbz	r2, a616 <strncpy+0x2e>
{
    a5ec:	b410      	push	{r4}
	while ((n > 0) && *s != '\0') {
    a5ee:	780c      	ldrb	r4, [r1, #0]
    a5f0:	b12c      	cbz	r4, a5fe <strncpy+0x16>
		*d = *s;
    a5f2:	f803 4b01 	strb.w	r4, [r3], #1
		s++;
    a5f6:	3101      	adds	r1, #1
		d++;
		n--;
    a5f8:	3a01      	subs	r2, #1
	while ((n > 0) && *s != '\0') {
    a5fa:	2a00      	cmp	r2, #0
    a5fc:	d1f7      	bne.n	a5ee <strncpy+0x6>
	}

	while (n > 0) {
    a5fe:	b122      	cbz	r2, a60a <strncpy+0x22>
		*d = '\0';
    a600:	2100      	movs	r1, #0
    a602:	f803 1b01 	strb.w	r1, [r3], #1
		d++;
		n--;
    a606:	3a01      	subs	r2, #1
    a608:	e7f9      	b.n	a5fe <strncpy+0x16>
	}

	return dest;
}
    a60a:	bc10      	pop	{r4}
    a60c:	4770      	bx	lr
		*d = '\0';
    a60e:	2100      	movs	r1, #0
    a610:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    a614:	3a01      	subs	r2, #1
	while (n > 0) {
    a616:	2a00      	cmp	r2, #0
    a618:	d1f9      	bne.n	a60e <strncpy+0x26>
    a61a:	4770      	bx	lr

0000a61c <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
    a61c:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
    a61e:	e000      	b.n	a622 <strchr+0x6>
		s++;
    a620:	3001      	adds	r0, #1
	while ((*s != tmp) && (*s != '\0')) {
    a622:	7803      	ldrb	r3, [r0, #0]
    a624:	428b      	cmp	r3, r1
    a626:	d001      	beq.n	a62c <strchr+0x10>
    a628:	2b00      	cmp	r3, #0
    a62a:	d1f9      	bne.n	a620 <strchr+0x4>
	}

	return (*s == tmp) ? (char *) s : NULL;
    a62c:	428b      	cmp	r3, r1
    a62e:	d100      	bne.n	a632 <strchr+0x16>
}
    a630:	4770      	bx	lr
	return (*s == tmp) ? (char *) s : NULL;
    a632:	2000      	movs	r0, #0
    a634:	e7fc      	b.n	a630 <strchr+0x14>

0000a636 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    a636:	4603      	mov	r3, r0
	size_t n = 0;
    a638:	2000      	movs	r0, #0

	while (*s != '\0') {
    a63a:	e001      	b.n	a640 <strlen+0xa>
		s++;
    a63c:	3301      	adds	r3, #1
		n++;
    a63e:	3001      	adds	r0, #1
	while (*s != '\0') {
    a640:	781a      	ldrb	r2, [r3, #0]
    a642:	2a00      	cmp	r2, #0
    a644:	d1fa      	bne.n	a63c <strlen+0x6>
	}

	return n;
}
    a646:	4770      	bx	lr

0000a648 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    a648:	4603      	mov	r3, r0
	size_t n = 0;
    a64a:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    a64c:	e001      	b.n	a652 <strnlen+0xa>
		s++;
    a64e:	3301      	adds	r3, #1
		n++;
    a650:	3001      	adds	r0, #1
	while (*s != '\0' && n < maxlen) {
    a652:	781a      	ldrb	r2, [r3, #0]
    a654:	b10a      	cbz	r2, a65a <strnlen+0x12>
    a656:	4288      	cmp	r0, r1
    a658:	d3f9      	bcc.n	a64e <strnlen+0x6>
	}

	return n;
}
    a65a:	4770      	bx	lr

0000a65c <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    a65c:	e001      	b.n	a662 <strcmp+0x6>
		s1++;
    a65e:	3001      	adds	r0, #1
		s2++;
    a660:	3101      	adds	r1, #1
	while ((*s1 == *s2) && (*s1 != '\0')) {
    a662:	7803      	ldrb	r3, [r0, #0]
    a664:	780a      	ldrb	r2, [r1, #0]
    a666:	4293      	cmp	r3, r2
    a668:	d101      	bne.n	a66e <strcmp+0x12>
    a66a:	2b00      	cmp	r3, #0
    a66c:	d1f7      	bne.n	a65e <strcmp+0x2>
	}

	return *s1 - *s2;
}
    a66e:	1a98      	subs	r0, r3, r2
    a670:	4770      	bx	lr

0000a672 <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    a672:	e002      	b.n	a67a <strncmp+0x8>
		s1++;
    a674:	3001      	adds	r0, #1
		s2++;
    a676:	3101      	adds	r1, #1
		n--;
    a678:	3a01      	subs	r2, #1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    a67a:	b132      	cbz	r2, a68a <strncmp+0x18>
    a67c:	7803      	ldrb	r3, [r0, #0]
    a67e:	f891 c000 	ldrb.w	ip, [r1]
    a682:	4563      	cmp	r3, ip
    a684:	d101      	bne.n	a68a <strncmp+0x18>
    a686:	2b00      	cmp	r3, #0
    a688:	d1f4      	bne.n	a674 <strncmp+0x2>
	}

	return (n == 0) ? 0 : (*s1 - *s2);
    a68a:	b11a      	cbz	r2, a694 <strncmp+0x22>
    a68c:	7800      	ldrb	r0, [r0, #0]
    a68e:	780b      	ldrb	r3, [r1, #0]
    a690:	1ac0      	subs	r0, r0, r3
    a692:	4770      	bx	lr
    a694:	2000      	movs	r0, #0
}
    a696:	4770      	bx	lr

0000a698 <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    a698:	4613      	mov	r3, r2
    a69a:	b16a      	cbz	r2, a6b8 <memcmp+0x20>
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    a69c:	3b01      	subs	r3, #1
    a69e:	d007      	beq.n	a6b0 <memcmp+0x18>
    a6a0:	f890 c000 	ldrb.w	ip, [r0]
    a6a4:	780a      	ldrb	r2, [r1, #0]
    a6a6:	4594      	cmp	ip, r2
    a6a8:	d102      	bne.n	a6b0 <memcmp+0x18>
		c1++;
    a6aa:	3001      	adds	r0, #1
		c2++;
    a6ac:	3101      	adds	r1, #1
    a6ae:	e7f5      	b.n	a69c <memcmp+0x4>
	}

	return *c1 - *c2;
    a6b0:	7800      	ldrb	r0, [r0, #0]
    a6b2:	780b      	ldrb	r3, [r1, #0]
    a6b4:	1ac0      	subs	r0, r0, r3
    a6b6:	4770      	bx	lr
		return 0;
    a6b8:	2000      	movs	r0, #0
}
    a6ba:	4770      	bx	lr

0000a6bc <memcpy>:
	const unsigned char *s_byte = (const unsigned char *)s;

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    a6bc:	ea80 0301 	eor.w	r3, r0, r1
    a6c0:	f013 0f03 	tst.w	r3, #3
    a6c4:	d001      	beq.n	a6ca <memcpy+0xe>
	unsigned char *d_byte = (unsigned char *)d;
    a6c6:	4603      	mov	r3, r0
    a6c8:	e023      	b.n	a712 <memcpy+0x56>
    a6ca:	4603      	mov	r3, r0

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
    a6cc:	f013 0f03 	tst.w	r3, #3
    a6d0:	d00f      	beq.n	a6f2 <memcpy+0x36>
			if (n == 0) {
    a6d2:	b30a      	cbz	r2, a718 <memcpy+0x5c>
				return d;
			}
			*(d_byte++) = *(s_byte++);
    a6d4:	f811 cb01 	ldrb.w	ip, [r1], #1
    a6d8:	f803 cb01 	strb.w	ip, [r3], #1
			n--;
    a6dc:	3a01      	subs	r2, #1
    a6de:	e7f5      	b.n	a6cc <memcpy+0x10>
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
    a6e0:	f811 cb01 	ldrb.w	ip, [r1], #1
    a6e4:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
    a6e8:	3a01      	subs	r2, #1
	while (n > 0) {
    a6ea:	2a00      	cmp	r2, #0
    a6ec:	d1f8      	bne.n	a6e0 <memcpy+0x24>
	}

	return d;
}
    a6ee:	bc10      	pop	{r4}
    a6f0:	4770      	bx	lr
		while (n >= sizeof(mem_word_t)) {
    a6f2:	2a03      	cmp	r2, #3
    a6f4:	d90d      	bls.n	a712 <memcpy+0x56>
{
    a6f6:	b410      	push	{r4}
			*(d_word++) = *(s_word++);
    a6f8:	f851 4b04 	ldr.w	r4, [r1], #4
    a6fc:	f843 4b04 	str.w	r4, [r3], #4
			n -= sizeof(mem_word_t);
    a700:	3a04      	subs	r2, #4
		while (n >= sizeof(mem_word_t)) {
    a702:	2a03      	cmp	r2, #3
    a704:	d8f8      	bhi.n	a6f8 <memcpy+0x3c>
    a706:	e7f0      	b.n	a6ea <memcpy+0x2e>
		*(d_byte++) = *(s_byte++);
    a708:	f811 cb01 	ldrb.w	ip, [r1], #1
    a70c:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
    a710:	3a01      	subs	r2, #1
	while (n > 0) {
    a712:	2a00      	cmp	r2, #0
    a714:	d1f8      	bne.n	a708 <memcpy+0x4c>
    a716:	4770      	bx	lr
}
    a718:	4770      	bx	lr

0000a71a <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    a71a:	fa5f fc81 	uxtb.w	ip, r1
	unsigned char *d_byte = (unsigned char *)buf;
    a71e:	4603      	mov	r3, r0

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    a720:	e002      	b.n	a728 <memset+0xe>
		if (n == 0) {
			return buf;
		}
		*(d_byte++) = c_byte;
    a722:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
    a726:	3a01      	subs	r2, #1
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    a728:	f013 0f03 	tst.w	r3, #3
    a72c:	d002      	beq.n	a734 <memset+0x1a>
		if (n == 0) {
    a72e:	2a00      	cmp	r2, #0
    a730:	d1f7      	bne.n	a722 <memset+0x8>
    a732:	e00f      	b.n	a754 <memset+0x3a>
	}

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
    a734:	b2c9      	uxtb	r1, r1

	c_word |= c_word << 8;
    a736:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
	c_word |= c_word << 16;
    a73a:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    a73e:	2a03      	cmp	r2, #3
    a740:	d906      	bls.n	a750 <memset+0x36>
		*(d_word++) = c_word;
    a742:	f843 1b04 	str.w	r1, [r3], #4
		n -= sizeof(mem_word_t);
    a746:	3a04      	subs	r2, #4
    a748:	e7f9      	b.n	a73e <memset+0x24>

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
		*(d_byte++) = c_byte;
    a74a:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
    a74e:	3a01      	subs	r2, #1
	while (n > 0) {
    a750:	2a00      	cmp	r2, #0
    a752:	d1fa      	bne.n	a74a <memset+0x30>
	}

	return buf;
}
    a754:	4770      	bx	lr

0000a756 <strspn>:
#include <string.h>
#include <string.h>

size_t strspn(const char *s,
	      const char *accept)
{
    a756:	b570      	push	{r4, r5, r6, lr}
    a758:	4606      	mov	r6, r0
    a75a:	460d      	mov	r5, r1
	const char *ins = s;

	while ((*s != '\0') && (strchr(accept, *s) != NULL)) {
    a75c:	4604      	mov	r4, r0
    a75e:	e000      	b.n	a762 <strspn+0xc>
		++s;
    a760:	3401      	adds	r4, #1
	while ((*s != '\0') && (strchr(accept, *s) != NULL)) {
    a762:	7821      	ldrb	r1, [r4, #0]
    a764:	b121      	cbz	r1, a770 <strspn+0x1a>
    a766:	4628      	mov	r0, r5
    a768:	f7ff ff58 	bl	a61c <strchr>
    a76c:	2800      	cmp	r0, #0
    a76e:	d1f7      	bne.n	a760 <strspn+0xa>
	}

	return s - ins;
}
    a770:	1ba0      	subs	r0, r4, r6
    a772:	bd70      	pop	{r4, r5, r6, pc}

0000a774 <strcspn>:

size_t strcspn(const char *s,
	       const char *reject)
{
    a774:	b570      	push	{r4, r5, r6, lr}
    a776:	4606      	mov	r6, r0
    a778:	460d      	mov	r5, r1
	const char *ins = s;

	while ((*s != '\0') && (strchr(reject, *s) == NULL)) {
    a77a:	4604      	mov	r4, r0
    a77c:	e000      	b.n	a780 <strcspn+0xc>
		++s;
    a77e:	3401      	adds	r4, #1
	while ((*s != '\0') && (strchr(reject, *s) == NULL)) {
    a780:	7821      	ldrb	r1, [r4, #0]
    a782:	b121      	cbz	r1, a78e <strcspn+0x1a>
    a784:	4628      	mov	r0, r5
    a786:	f7ff ff49 	bl	a61c <strchr>
    a78a:	2800      	cmp	r0, #0
    a78c:	d0f7      	beq.n	a77e <strcspn+0xa>
	}

	return s - ins;
}
    a78e:	1ba0      	subs	r0, r4, r6
    a790:	bd70      	pop	{r4, r5, r6, pc}

0000a792 <_stdout_hook_default>:
}
    a792:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a796:	4770      	bx	lr

0000a798 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
    a798:	684b      	ldr	r3, [r1, #4]
    a79a:	2b01      	cmp	r3, #1
    a79c:	dd07      	ble.n	a7ae <sprintf_out+0x16>
		*(p->ptr) = c;
    a79e:	680b      	ldr	r3, [r1, #0]
    a7a0:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
    a7a2:	680b      	ldr	r3, [r1, #0]
    a7a4:	3301      	adds	r3, #1
    a7a6:	600b      	str	r3, [r1, #0]
		p->len -= 1;
    a7a8:	684b      	ldr	r3, [r1, #4]
    a7aa:	3b01      	subs	r3, #1
    a7ac:	604b      	str	r3, [r1, #4]
}
    a7ae:	2000      	movs	r0, #0
    a7b0:	4770      	bx	lr

0000a7b2 <fs_type_get>:
{
    a7b2:	b508      	push	{r3, lr}
	struct registry_entry *ep = registry_find(type);
    a7b4:	f7f7 fdf8 	bl	23a8 <registry_find>
	return (ep != NULL) ? ep->fstp : NULL;
    a7b8:	4603      	mov	r3, r0
    a7ba:	b100      	cbz	r0, a7be <fs_type_get+0xc>
    a7bc:	6843      	ldr	r3, [r0, #4]
}
    a7be:	4618      	mov	r0, r3
    a7c0:	bd08      	pop	{r3, pc}

0000a7c2 <lfs_to_errno>:
	if (error >= 0) {
    a7c2:	2800      	cmp	r0, #0
    a7c4:	da37      	bge.n	a836 <lfs_to_errno+0x74>
	switch (error) {
    a7c6:	f100 0354 	add.w	r3, r0, #84	; 0x54
    a7ca:	2b52      	cmp	r3, #82	; 0x52
    a7cc:	d82b      	bhi.n	a826 <lfs_to_errno+0x64>
    a7ce:	e8df f003 	tbb	[pc, r3]
    a7d2:	2a30      	.short	0x2a30
    a7d4:	2a2a2a2a 	.word	0x2a2a2a2a
    a7d8:	2a2a2a2a 	.word	0x2a2a2a2a
    a7dc:	2a2a2a2a 	.word	0x2a2a2a2a
    a7e0:	2a2a2a2a 	.word	0x2a2a2a2a
    a7e4:	2a2a2a2a 	.word	0x2a2a2a2a
    a7e8:	2a2a2a2a 	.word	0x2a2a2a2a
    a7ec:	2a2a2a2a 	.word	0x2a2a2a2a
    a7f0:	2a2a2a2a 	.word	0x2a2a2a2a
    a7f4:	2a2a2a2a 	.word	0x2a2a2a2a
    a7f8:	2a2a2a2a 	.word	0x2a2a2a2a
    a7fc:	2d2a2a2a 	.word	0x2d2a2a2a
    a800:	2a2a2a2a 	.word	0x2a2a2a2a
    a804:	2a2a2a2a 	.word	0x2a2a2a2a
    a808:	32322a2a 	.word	0x32322a2a
    a80c:	2a2a2a2a 	.word	0x2a2a2a2a
    a810:	2a323232 	.word	0x2a323232
    a814:	2a2a322a 	.word	0x2a2a322a
    a818:	2a322a2a 	.word	0x2a322a2a
    a81c:	2a2a322a 	.word	0x2a2a322a
    a820:	2a2a2a2a 	.word	0x2a2a2a2a
    a824:	32          	.byte	0x32
    a825:	00          	.byte	0x00
    a826:	f06f 0004 	mvn.w	r0, #4
    a82a:	4770      	bx	lr
		return -ENOTEMPTY;
    a82c:	f06f 0059 	mvn.w	r0, #89	; 0x59
    a830:	4770      	bx	lr
		return -EFAULT;
    a832:	f06f 000d 	mvn.w	r0, #13
}
    a836:	4770      	bx	lr

0000a838 <errno_to_lfs>:
	if (error >= 0) {
    a838:	2800      	cmp	r0, #0
    a83a:	da20      	bge.n	a87e <errno_to_lfs+0x46>
	switch (error) {
    a83c:	f110 0f5a 	cmn.w	r0, #90	; 0x5a
    a840:	d01f      	beq.n	a882 <errno_to_lfs+0x4a>
    a842:	db21      	blt.n	a888 <errno_to_lfs+0x50>
    a844:	f110 0f02 	cmn.w	r0, #2
    a848:	dc21      	bgt.n	a88e <errno_to_lfs+0x56>
    a84a:	f110 0f1c 	cmn.w	r0, #28
    a84e:	db21      	blt.n	a894 <errno_to_lfs+0x5c>
    a850:	f100 031c 	add.w	r3, r0, #28
    a854:	2b1a      	cmp	r3, #26
    a856:	d80f      	bhi.n	a878 <errno_to_lfs+0x40>
    a858:	e8df f003 	tbb	[pc, r3]
    a85c:	0e0e2121 	.word	0x0e0e2121
    a860:	21210e0e 	.word	0x21210e0e
    a864:	210e0e21 	.word	0x210e0e21
    a868:	0e1f0e0e 	.word	0x0e1f0e0e
    a86c:	210e0e21 	.word	0x210e0e21
    a870:	0e0e0e0e 	.word	0x0e0e0e0e
    a874:	0e0e      	.short	0x0e0e
    a876:	21          	.byte	0x21
    a877:	00          	.byte	0x00
    a878:	f06f 0004 	mvn.w	r0, #4
    a87c:	4770      	bx	lr
		return LFS_ERR_OK;
    a87e:	2000      	movs	r0, #0
    a880:	4770      	bx	lr
		return LFS_ERR_NOTEMPTY;
    a882:	f06f 0026 	mvn.w	r0, #38	; 0x26
    a886:	4770      	bx	lr
	switch (error) {
    a888:	f06f 0004 	mvn.w	r0, #4
    a88c:	4770      	bx	lr
    a88e:	f06f 0004 	mvn.w	r0, #4
    a892:	4770      	bx	lr
    a894:	f06f 0004 	mvn.w	r0, #4
    a898:	4770      	bx	lr
		return LFS_ERR_CORRUPT;
    a89a:	f06f 0053 	mvn.w	r0, #83	; 0x53
}
    a89e:	4770      	bx	lr

0000a8a0 <lfs_api_sync>:
}
    a8a0:	2000      	movs	r0, #0
    a8a2:	4770      	bx	lr

0000a8a4 <lfs_flags_from_zephyr>:
	int flags = (zflags & FS_O_CREATE) ? LFS_O_CREAT : 0;
    a8a4:	0103      	lsls	r3, r0, #4
    a8a6:	f403 7380 	and.w	r3, r3, #256	; 0x100
	flags |= (zflags & FS_O_READ) ? LFS_O_RDONLY : 0;
    a8aa:	f000 0201 	and.w	r2, r0, #1
    a8ae:	431a      	orrs	r2, r3
	flags |= (zflags & FS_O_WRITE) ? LFS_O_WRONLY : 0;
    a8b0:	f000 0302 	and.w	r3, r0, #2
    a8b4:	4313      	orrs	r3, r2
	flags |= (zflags & FS_O_APPEND) ? LFS_O_APPEND : 0;
    a8b6:	0180      	lsls	r0, r0, #6
    a8b8:	f400 6000 	and.w	r0, r0, #2048	; 0x800
}
    a8bc:	4318      	orrs	r0, r3
    a8be:	4770      	bx	lr

0000a8c0 <get_page_cb>:
{
    a8c0:	b430      	push	{r4, r5}
	size_t info_start = info->start_offset;
    a8c2:	6804      	ldr	r4, [r0, #0]
	size_t info_end = info_start + info->size - 1U;
    a8c4:	6845      	ldr	r5, [r0, #4]
    a8c6:	192a      	adds	r2, r5, r4
    a8c8:	3a01      	subs	r2, #1
	size_t area_start = ctx->area->fa_off;
    a8ca:	680b      	ldr	r3, [r1, #0]
    a8cc:	6858      	ldr	r0, [r3, #4]
	size_t area_end = area_start + ctx->area->fa_size - 1U;
    a8ce:	689b      	ldr	r3, [r3, #8]
    a8d0:	4403      	add	r3, r0
	if (info_end < area_start) {
    a8d2:	4282      	cmp	r2, r0
    a8d4:	d308      	bcc.n	a8e8 <get_page_cb+0x28>
    a8d6:	3b01      	subs	r3, #1
	if (info_start > area_end) {
    a8d8:	429c      	cmp	r4, r3
    a8da:	d808      	bhi.n	a8ee <get_page_cb+0x2e>
	if (info->size > ctx->max_size) {
    a8dc:	684b      	ldr	r3, [r1, #4]
    a8de:	429d      	cmp	r5, r3
    a8e0:	d907      	bls.n	a8f2 <get_page_cb+0x32>
		ctx->max_size = info->size;
    a8e2:	604d      	str	r5, [r1, #4]
	return true;
    a8e4:	2001      	movs	r0, #1
    a8e6:	e000      	b.n	a8ea <get_page_cb+0x2a>
		return true;
    a8e8:	2001      	movs	r0, #1
}
    a8ea:	bc30      	pop	{r4, r5}
    a8ec:	4770      	bx	lr
		return false;
    a8ee:	2000      	movs	r0, #0
    a8f0:	e7fb      	b.n	a8ea <get_page_cb+0x2a>
	return true;
    a8f2:	2001      	movs	r0, #1
    a8f4:	e7f9      	b.n	a8ea <get_page_cb+0x2a>

0000a8f6 <fs_lock>:
{
    a8f6:	b508      	push	{r3, lr}
	k_mutex_lock(&fs->mutex, K_FOREVER);
    a8f8:	30f0      	adds	r0, #240	; 0xf0
	return z_impl_k_mutex_lock(mutex, timeout);
    a8fa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    a8fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    a902:	f7fd fd9d 	bl	8440 <z_impl_k_mutex_lock>
}
    a906:	bd08      	pop	{r3, pc}

0000a908 <littlefs_statvfs>:
{
    a908:	b570      	push	{r4, r5, r6, lr}
    a90a:	4603      	mov	r3, r0
    a90c:	4608      	mov	r0, r1
    a90e:	4615      	mov	r5, r2
	struct fs_littlefs *fs = mountp->fs_data;
    a910:	691c      	ldr	r4, [r3, #16]
	struct lfs *lfs = &fs->lfs;
    a912:	f104 0674 	add.w	r6, r4, #116	; 0x74
	stat->f_bsize = lfs->cfg->prog_size;
    a916:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
    a91a:	6992      	ldr	r2, [r2, #24]
    a91c:	602a      	str	r2, [r5, #0]
	stat->f_frsize = lfs->cfg->block_size;
    a91e:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
    a922:	69d2      	ldr	r2, [r2, #28]
    a924:	606a      	str	r2, [r5, #4]
	stat->f_blocks = lfs->cfg->block_count;
    a926:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
    a92a:	6a12      	ldr	r2, [r2, #32]
    a92c:	60aa      	str	r2, [r5, #8]
	path = fs_impl_strip_prefix(path, mountp);
    a92e:	4619      	mov	r1, r3
    a930:	f7f8 f8f0 	bl	2b14 <fs_impl_strip_prefix>
	fs_lock(fs);
    a934:	4620      	mov	r0, r4
    a936:	f7ff ffde 	bl	a8f6 <fs_lock>
	ssize_t ret = lfs_fs_size(lfs);
    a93a:	4630      	mov	r0, r6
    a93c:	f002 fe21 	bl	d582 <lfs_fs_size>
    a940:	4606      	mov	r6, r0
	k_mutex_unlock(&fs->mutex);
    a942:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
	return z_impl_k_mutex_unlock(mutex);
    a946:	f7fd fdff 	bl	8548 <z_impl_k_mutex_unlock>
	if (ret >= 0) {
    a94a:	2e00      	cmp	r6, #0
    a94c:	db03      	blt.n	a956 <littlefs_statvfs+0x4e>
		stat->f_bfree = stat->f_blocks - ret;
    a94e:	68ab      	ldr	r3, [r5, #8]
    a950:	1b9b      	subs	r3, r3, r6
    a952:	60eb      	str	r3, [r5, #12]
		ret = 0;
    a954:	2600      	movs	r6, #0
	return lfs_to_errno(ret);
    a956:	4630      	mov	r0, r6
    a958:	f7ff ff33 	bl	a7c2 <lfs_to_errno>
}
    a95c:	bd70      	pop	{r4, r5, r6, pc}

0000a95e <info_to_dirent>:
{
    a95e:	b510      	push	{r4, lr}
    a960:	460c      	mov	r4, r1
	entry->type = ((info->type == LFS_TYPE_DIR) ?
    a962:	7803      	ldrb	r3, [r0, #0]
		       FS_DIR_ENTRY_DIR : FS_DIR_ENTRY_FILE);
    a964:	2b02      	cmp	r3, #2
    a966:	bf14      	ite	ne
    a968:	2300      	movne	r3, #0
    a96a:	2301      	moveq	r3, #1
	entry->type = ((info->type == LFS_TYPE_DIR) ?
    a96c:	700b      	strb	r3, [r1, #0]
	entry->size = info->size;
    a96e:	6843      	ldr	r3, [r0, #4]
    a970:	f8c1 3104 	str.w	r3, [r1, #260]	; 0x104
	strncpy(entry->name, info->name, sizeof(entry->name));
    a974:	f240 1201 	movw	r2, #257	; 0x101
    a978:	f100 0108 	add.w	r1, r0, #8
    a97c:	1c60      	adds	r0, r4, #1
    a97e:	f7ff fe33 	bl	a5e8 <strncpy>
	entry->name[sizeof(entry->name) - 1] = '\0';
    a982:	2300      	movs	r3, #0
    a984:	f884 3101 	strb.w	r3, [r4, #257]	; 0x101
}
    a988:	bd10      	pop	{r4, pc}

0000a98a <littlefs_stat>:
{
    a98a:	b570      	push	{r4, r5, r6, lr}
    a98c:	b0c2      	sub	sp, #264	; 0x108
    a98e:	4603      	mov	r3, r0
    a990:	4608      	mov	r0, r1
    a992:	4616      	mov	r6, r2
	struct fs_littlefs *fs = mountp->fs_data;
    a994:	691c      	ldr	r4, [r3, #16]
	path = fs_impl_strip_prefix(path, mountp);
    a996:	4619      	mov	r1, r3
    a998:	f7f8 f8bc 	bl	2b14 <fs_impl_strip_prefix>
    a99c:	4605      	mov	r5, r0
	fs_lock(fs);
    a99e:	4620      	mov	r0, r4
    a9a0:	f7ff ffa9 	bl	a8f6 <fs_lock>
	int ret = lfs_stat(&fs->lfs, path, &info);
    a9a4:	466a      	mov	r2, sp
    a9a6:	4629      	mov	r1, r5
    a9a8:	f104 0074 	add.w	r0, r4, #116	; 0x74
    a9ac:	f002 fdae 	bl	d50c <lfs_stat>
    a9b0:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    a9b2:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    a9b6:	f7fd fdc7 	bl	8548 <z_impl_k_mutex_unlock>
	if (ret >= 0) {
    a9ba:	2d00      	cmp	r5, #0
    a9bc:	da04      	bge.n	a9c8 <littlefs_stat+0x3e>
	return lfs_to_errno(ret);
    a9be:	4628      	mov	r0, r5
    a9c0:	f7ff feff 	bl	a7c2 <lfs_to_errno>
}
    a9c4:	b042      	add	sp, #264	; 0x108
    a9c6:	bd70      	pop	{r4, r5, r6, pc}
		info_to_dirent(&info, entry);
    a9c8:	4631      	mov	r1, r6
    a9ca:	4668      	mov	r0, sp
    a9cc:	f7ff ffc7 	bl	a95e <info_to_dirent>
		ret = 0;
    a9d0:	2500      	movs	r5, #0
    a9d2:	e7f4      	b.n	a9be <littlefs_stat+0x34>

0000a9d4 <littlefs_mkdir>:
{
    a9d4:	b538      	push	{r3, r4, r5, lr}
    a9d6:	4603      	mov	r3, r0
    a9d8:	4608      	mov	r0, r1
	struct fs_littlefs *fs = mountp->fs_data;
    a9da:	691c      	ldr	r4, [r3, #16]
	path = fs_impl_strip_prefix(path, mountp);
    a9dc:	4619      	mov	r1, r3
    a9de:	f7f8 f899 	bl	2b14 <fs_impl_strip_prefix>
    a9e2:	4605      	mov	r5, r0
	fs_lock(fs);
    a9e4:	4620      	mov	r0, r4
    a9e6:	f7ff ff86 	bl	a8f6 <fs_lock>
	int ret = lfs_mkdir(&fs->lfs, path);
    a9ea:	4629      	mov	r1, r5
    a9ec:	f104 0074 	add.w	r0, r4, #116	; 0x74
    a9f0:	f002 fdb7 	bl	d562 <lfs_mkdir>
    a9f4:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    a9f6:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    a9fa:	f7fd fda5 	bl	8548 <z_impl_k_mutex_unlock>
	return lfs_to_errno(ret);
    a9fe:	4628      	mov	r0, r5
    aa00:	f7ff fedf 	bl	a7c2 <lfs_to_errno>
}
    aa04:	bd38      	pop	{r3, r4, r5, pc}

0000aa06 <littlefs_rename>:
{
    aa06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aa08:	4605      	mov	r5, r0
    aa0a:	4608      	mov	r0, r1
    aa0c:	4617      	mov	r7, r2
	struct fs_littlefs *fs = mountp->fs_data;
    aa0e:	692c      	ldr	r4, [r5, #16]
	from = fs_impl_strip_prefix(from, mountp);
    aa10:	4629      	mov	r1, r5
    aa12:	f7f8 f87f 	bl	2b14 <fs_impl_strip_prefix>
    aa16:	4606      	mov	r6, r0
	to = fs_impl_strip_prefix(to, mountp);
    aa18:	4629      	mov	r1, r5
    aa1a:	4638      	mov	r0, r7
    aa1c:	f7f8 f87a 	bl	2b14 <fs_impl_strip_prefix>
    aa20:	4605      	mov	r5, r0
	fs_lock(fs);
    aa22:	4620      	mov	r0, r4
    aa24:	f7ff ff67 	bl	a8f6 <fs_lock>
	int ret = lfs_rename(&fs->lfs, from, to);
    aa28:	462a      	mov	r2, r5
    aa2a:	4631      	mov	r1, r6
    aa2c:	f104 0074 	add.w	r0, r4, #116	; 0x74
    aa30:	f002 fd68 	bl	d504 <lfs_rename>
    aa34:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    aa36:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    aa3a:	f7fd fd85 	bl	8548 <z_impl_k_mutex_unlock>
	return lfs_to_errno(ret);
    aa3e:	4628      	mov	r0, r5
    aa40:	f7ff febf 	bl	a7c2 <lfs_to_errno>
}
    aa44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000aa46 <littlefs_unlink>:
{
    aa46:	b538      	push	{r3, r4, r5, lr}
    aa48:	4603      	mov	r3, r0
    aa4a:	4608      	mov	r0, r1
	struct fs_littlefs *fs = mountp->fs_data;
    aa4c:	691c      	ldr	r4, [r3, #16]
	path = fs_impl_strip_prefix(path, mountp);
    aa4e:	4619      	mov	r1, r3
    aa50:	f7f8 f860 	bl	2b14 <fs_impl_strip_prefix>
    aa54:	4605      	mov	r5, r0
	fs_lock(fs);
    aa56:	4620      	mov	r0, r4
    aa58:	f7ff ff4d 	bl	a8f6 <fs_lock>
	int ret = lfs_remove(&fs->lfs, path);
    aa5c:	4629      	mov	r1, r5
    aa5e:	f104 0074 	add.w	r0, r4, #116	; 0x74
    aa62:	f002 fd4b 	bl	d4fc <lfs_remove>
    aa66:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    aa68:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    aa6c:	f7fd fd6c 	bl	8548 <z_impl_k_mutex_unlock>
	return lfs_to_errno(ret);
    aa70:	4628      	mov	r0, r5
    aa72:	f7ff fea6 	bl	a7c2 <lfs_to_errno>
}
    aa76:	bd38      	pop	{r3, r4, r5, pc}

0000aa78 <littlefs_init_backend>:
{
    aa78:	b508      	push	{r3, lr}
		ret = littlefs_flash_init(fs, dev_id);
    aa7a:	f7f8 f87f 	bl	2b7c <littlefs_flash_init>
		if (ret < 0) {
    aa7e:	2800      	cmp	r0, #0
    aa80:	db00      	blt.n	aa84 <littlefs_init_backend+0xc>
	return 0;
    aa82:	2000      	movs	r0, #0
}
    aa84:	bd08      	pop	{r3, pc}

0000aa86 <lfs_api_erase>:
{
    aa86:	b508      	push	{r3, lr}
	size_t offset = block * c->block_size;
    aa88:	69c2      	ldr	r2, [r0, #28]
	int rc = flash_area_erase(fa, offset, c->block_size);
    aa8a:	fb02 f101 	mul.w	r1, r2, r1
    aa8e:	6800      	ldr	r0, [r0, #0]
    aa90:	f7ff fcc2 	bl	a418 <flash_area_erase>
	return errno_to_lfs(rc);
    aa94:	f7ff fed0 	bl	a838 <errno_to_lfs>
}
    aa98:	bd08      	pop	{r3, pc}

0000aa9a <lfs_api_prog>:
{
    aa9a:	b508      	push	{r3, lr}
    aa9c:	4694      	mov	ip, r2
    aa9e:	461a      	mov	r2, r3
	int rc = flash_area_write(fa, offset, buffer, size);
    aaa0:	9b02      	ldr	r3, [sp, #8]
    aaa2:	f8d0 e01c 	ldr.w	lr, [r0, #28]
    aaa6:	fb01 c10e 	mla	r1, r1, lr, ip
    aaaa:	6800      	ldr	r0, [r0, #0]
    aaac:	f7ff fc99 	bl	a3e2 <flash_area_write>
	return errno_to_lfs(rc);
    aab0:	f7ff fec2 	bl	a838 <errno_to_lfs>
}
    aab4:	bd08      	pop	{r3, pc}

0000aab6 <lfs_api_read>:
{
    aab6:	b508      	push	{r3, lr}
    aab8:	4694      	mov	ip, r2
    aaba:	461a      	mov	r2, r3
	int rc = flash_area_read(fa, offset, buffer, size);
    aabc:	9b02      	ldr	r3, [sp, #8]
    aabe:	f8d0 e01c 	ldr.w	lr, [r0, #28]
    aac2:	fb01 c10e 	mla	r1, r1, lr, ip
    aac6:	6800      	ldr	r0, [r0, #0]
    aac8:	f7ff fc70 	bl	a3ac <flash_area_read>
	return errno_to_lfs(rc);
    aacc:	f7ff feb4 	bl	a838 <errno_to_lfs>
}
    aad0:	bd08      	pop	{r3, pc}

0000aad2 <littlefs_readdir>:
{
    aad2:	b570      	push	{r4, r5, r6, lr}
    aad4:	b0c2      	sub	sp, #264	; 0x108
    aad6:	4605      	mov	r5, r0
    aad8:	460e      	mov	r6, r1
	struct fs_littlefs *fs = dp->mp->fs_data;
    aada:	6843      	ldr	r3, [r0, #4]
    aadc:	691c      	ldr	r4, [r3, #16]
	fs_lock(fs);
    aade:	4620      	mov	r0, r4
    aae0:	f7ff ff09 	bl	a8f6 <fs_lock>
	int ret = lfs_dir_read(&fs->lfs, dp->dirp, &info);
    aae4:	466a      	mov	r2, sp
    aae6:	6829      	ldr	r1, [r5, #0]
    aae8:	f104 0074 	add.w	r0, r4, #116	; 0x74
    aaec:	f002 fd45 	bl	d57a <lfs_dir_read>
    aaf0:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    aaf2:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    aaf6:	f7fd fd27 	bl	8548 <z_impl_k_mutex_unlock>
	if (ret > 0) {
    aafa:	2d00      	cmp	r5, #0
    aafc:	dc03      	bgt.n	ab06 <littlefs_readdir+0x34>
	} else if (ret == 0) {
    aafe:	b93d      	cbnz	r5, ab10 <littlefs_readdir+0x3e>
		entry->name[0] = 0;
    ab00:	2300      	movs	r3, #0
    ab02:	7073      	strb	r3, [r6, #1]
    ab04:	e004      	b.n	ab10 <littlefs_readdir+0x3e>
		info_to_dirent(&info, entry);
    ab06:	4631      	mov	r1, r6
    ab08:	4668      	mov	r0, sp
    ab0a:	f7ff ff28 	bl	a95e <info_to_dirent>
		ret = 0;
    ab0e:	2500      	movs	r5, #0
	return lfs_to_errno(ret);
    ab10:	4628      	mov	r0, r5
    ab12:	f7ff fe56 	bl	a7c2 <lfs_to_errno>
}
    ab16:	b042      	add	sp, #264	; 0x108
    ab18:	bd70      	pop	{r4, r5, r6, pc}

0000ab1a <littlefs_close>:
{
    ab1a:	b570      	push	{r4, r5, r6, lr}
    ab1c:	4604      	mov	r4, r0
	struct fs_littlefs *fs = fp->mp->fs_data;
    ab1e:	6843      	ldr	r3, [r0, #4]
    ab20:	691d      	ldr	r5, [r3, #16]
	fs_lock(fs);
    ab22:	4628      	mov	r0, r5
    ab24:	f7ff fee7 	bl	a8f6 <fs_lock>
	int ret = lfs_file_close(&fs->lfs, LFS_FILEP(fp));
    ab28:	6821      	ldr	r1, [r4, #0]
    ab2a:	f105 0074 	add.w	r0, r5, #116	; 0x74
    ab2e:	f002 fcfc 	bl	d52a <lfs_file_close>
    ab32:	4606      	mov	r6, r0
	k_mutex_unlock(&fs->mutex);
    ab34:	f105 00f0 	add.w	r0, r5, #240	; 0xf0
    ab38:	f7fd fd06 	bl	8548 <z_impl_k_mutex_unlock>
	release_file_data(fp);
    ab3c:	4620      	mov	r0, r4
    ab3e:	f7f8 f9b7 	bl	2eb0 <release_file_data>
	return lfs_to_errno(ret);
    ab42:	4630      	mov	r0, r6
    ab44:	f7ff fe3d 	bl	a7c2 <lfs_to_errno>
}
    ab48:	bd70      	pop	{r4, r5, r6, pc}

0000ab4a <littlefs_sync>:
{
    ab4a:	b538      	push	{r3, r4, r5, lr}
    ab4c:	4605      	mov	r5, r0
	struct fs_littlefs *fs = fp->mp->fs_data;
    ab4e:	6843      	ldr	r3, [r0, #4]
    ab50:	691c      	ldr	r4, [r3, #16]
	fs_lock(fs);
    ab52:	4620      	mov	r0, r4
    ab54:	f7ff fecf 	bl	a8f6 <fs_lock>
	int ret = lfs_file_sync(&fs->lfs, LFS_FILEP(fp));
    ab58:	6829      	ldr	r1, [r5, #0]
    ab5a:	f104 0074 	add.w	r0, r4, #116	; 0x74
    ab5e:	f002 fce8 	bl	d532 <lfs_file_sync>
    ab62:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    ab64:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    ab68:	f7fd fcee 	bl	8548 <z_impl_k_mutex_unlock>
	return lfs_to_errno(ret);
    ab6c:	4628      	mov	r0, r5
    ab6e:	f7ff fe28 	bl	a7c2 <lfs_to_errno>
}
    ab72:	bd38      	pop	{r3, r4, r5, pc}

0000ab74 <littlefs_truncate>:
{
    ab74:	b570      	push	{r4, r5, r6, lr}
    ab76:	4605      	mov	r5, r0
    ab78:	460e      	mov	r6, r1
	struct fs_littlefs *fs = fp->mp->fs_data;
    ab7a:	6843      	ldr	r3, [r0, #4]
    ab7c:	691c      	ldr	r4, [r3, #16]
	fs_lock(fs);
    ab7e:	4620      	mov	r0, r4
    ab80:	f7ff feb9 	bl	a8f6 <fs_lock>
	int ret = lfs_file_truncate(&fs->lfs, LFS_FILEP(fp), length);
    ab84:	4632      	mov	r2, r6
    ab86:	6829      	ldr	r1, [r5, #0]
    ab88:	f104 0074 	add.w	r0, r4, #116	; 0x74
    ab8c:	f002 fce1 	bl	d552 <lfs_file_truncate>
    ab90:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    ab92:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    ab96:	f7fd fcd7 	bl	8548 <z_impl_k_mutex_unlock>
	return lfs_to_errno(ret);
    ab9a:	4628      	mov	r0, r5
    ab9c:	f7ff fe11 	bl	a7c2 <lfs_to_errno>
}
    aba0:	bd70      	pop	{r4, r5, r6, pc}

0000aba2 <littlefs_tell>:
{
    aba2:	b538      	push	{r3, r4, r5, lr}
    aba4:	4605      	mov	r5, r0
	struct fs_littlefs *fs = fp->mp->fs_data;
    aba6:	6843      	ldr	r3, [r0, #4]
    aba8:	691c      	ldr	r4, [r3, #16]
	fs_lock(fs);
    abaa:	4620      	mov	r0, r4
    abac:	f7ff fea3 	bl	a8f6 <fs_lock>
	off_t ret = lfs_file_tell(&fs->lfs, LFS_FILEP(fp));
    abb0:	6829      	ldr	r1, [r5, #0]
    abb2:	f104 0074 	add.w	r0, r4, #116	; 0x74
    abb6:	f002 fcd0 	bl	d55a <lfs_file_tell>
    abba:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    abbc:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    abc0:	f7fd fcc2 	bl	8548 <z_impl_k_mutex_unlock>
}
    abc4:	4628      	mov	r0, r5
    abc6:	bd38      	pop	{r3, r4, r5, pc}

0000abc8 <littlefs_seek>:
{
    abc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    abca:	4605      	mov	r5, r0
    abcc:	460e      	mov	r6, r1
    abce:	4617      	mov	r7, r2
	struct fs_littlefs *fs = fp->mp->fs_data;
    abd0:	6843      	ldr	r3, [r0, #4]
    abd2:	691c      	ldr	r4, [r3, #16]
	fs_lock(fs);
    abd4:	4620      	mov	r0, r4
    abd6:	f7ff fe8e 	bl	a8f6 <fs_lock>
	off_t ret = lfs_file_seek(&fs->lfs, LFS_FILEP(fp), off, whence);
    abda:	463b      	mov	r3, r7
    abdc:	4632      	mov	r2, r6
    abde:	6829      	ldr	r1, [r5, #0]
    abe0:	f104 0074 	add.w	r0, r4, #116	; 0x74
    abe4:	f002 fcb1 	bl	d54a <lfs_file_seek>
    abe8:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    abea:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    abee:	f7fd fcab 	bl	8548 <z_impl_k_mutex_unlock>
	if (ret >= 0) {
    abf2:	2d00      	cmp	r5, #0
    abf4:	db00      	blt.n	abf8 <littlefs_seek+0x30>
		ret = 0;
    abf6:	2500      	movs	r5, #0
	return lfs_to_errno(ret);
    abf8:	4628      	mov	r0, r5
    abfa:	f7ff fde2 	bl	a7c2 <lfs_to_errno>
}
    abfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000ac00 <littlefs_write>:
{
    ac00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ac02:	4605      	mov	r5, r0
    ac04:	460e      	mov	r6, r1
    ac06:	4617      	mov	r7, r2
	struct fs_littlefs *fs = fp->mp->fs_data;
    ac08:	6843      	ldr	r3, [r0, #4]
    ac0a:	691c      	ldr	r4, [r3, #16]
	fs_lock(fs);
    ac0c:	4620      	mov	r0, r4
    ac0e:	f7ff fe72 	bl	a8f6 <fs_lock>
	ssize_t ret = lfs_file_write(&fs->lfs, LFS_FILEP(fp), ptr, len);
    ac12:	463b      	mov	r3, r7
    ac14:	4632      	mov	r2, r6
    ac16:	6829      	ldr	r1, [r5, #0]
    ac18:	f104 0074 	add.w	r0, r4, #116	; 0x74
    ac1c:	f002 fc91 	bl	d542 <lfs_file_write>
    ac20:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    ac22:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    ac26:	f7fd fc8f 	bl	8548 <z_impl_k_mutex_unlock>
	return lfs_to_errno(ret);
    ac2a:	4628      	mov	r0, r5
    ac2c:	f7ff fdc9 	bl	a7c2 <lfs_to_errno>
}
    ac30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000ac32 <littlefs_read>:
{
    ac32:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ac34:	4605      	mov	r5, r0
    ac36:	460e      	mov	r6, r1
    ac38:	4617      	mov	r7, r2
	struct fs_littlefs *fs = fp->mp->fs_data;
    ac3a:	6843      	ldr	r3, [r0, #4]
    ac3c:	691c      	ldr	r4, [r3, #16]
	fs_lock(fs);
    ac3e:	4620      	mov	r0, r4
    ac40:	f7ff fe59 	bl	a8f6 <fs_lock>
	ssize_t ret = lfs_file_read(&fs->lfs, LFS_FILEP(fp), ptr, len);
    ac44:	463b      	mov	r3, r7
    ac46:	4632      	mov	r2, r6
    ac48:	6829      	ldr	r1, [r5, #0]
    ac4a:	f104 0074 	add.w	r0, r4, #116	; 0x74
    ac4e:	f002 fc74 	bl	d53a <lfs_file_read>
    ac52:	4605      	mov	r5, r0
	k_mutex_unlock(&fs->mutex);
    ac54:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
    ac58:	f7fd fc76 	bl	8548 <z_impl_k_mutex_unlock>
	return lfs_to_errno(ret);
    ac5c:	4628      	mov	r0, r5
    ac5e:	f7ff fdb0 	bl	a7c2 <lfs_to_errno>
}
    ac62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000ac64 <nrf_clock_is_running>:
    switch (domain)
    ac64:	2903      	cmp	r1, #3
    ac66:	d82f      	bhi.n	acc8 <nrf_clock_is_running+0x64>
    ac68:	e8df f001 	tbb	[pc, r1]
    ac6c:	291c0f02 	.word	0x291c0f02
            if (p_clk_src != NULL)
    ac70:	b122      	cbz	r2, ac7c <nrf_clock_is_running+0x18>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    ac72:	f8d0 3418 	ldr.w	r3, [r0, #1048]	; 0x418
    ac76:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    ac7a:	7013      	strb	r3, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    ac7c:	f8d0 3418 	ldr.w	r3, [r0, #1048]	; 0x418
    ac80:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    ac84:	d122      	bne.n	accc <nrf_clock_is_running+0x68>
    return false;
    ac86:	2000      	movs	r0, #0
    ac88:	4770      	bx	lr
            if (p_clk_src != NULL)
    ac8a:	b122      	cbz	r2, ac96 <nrf_clock_is_running+0x32>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    ac8c:	f8d0 340c 	ldr.w	r3, [r0, #1036]	; 0x40c
    ac90:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    ac94:	7013      	strb	r3, [r2, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    ac96:	f8d0 340c 	ldr.w	r3, [r0, #1036]	; 0x40c
    ac9a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    ac9e:	d117      	bne.n	acd0 <nrf_clock_is_running+0x6c>
    return false;
    aca0:	2000      	movs	r0, #0
    aca2:	4770      	bx	lr
            if (p_clk_src != NULL)
    aca4:	b122      	cbz	r2, acb0 <nrf_clock_is_running+0x4c>
                    (nrf_clock_hfclk_t)((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
    aca6:	f8d0 345c 	ldr.w	r3, [r0, #1116]	; 0x45c
    acaa:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    acae:	7013      	strb	r3, [r2, #0]
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
    acb0:	f8d0 345c 	ldr.w	r3, [r0, #1116]	; 0x45c
    acb4:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    acb8:	d10c      	bne.n	acd4 <nrf_clock_is_running+0x70>
    return false;
    acba:	2000      	movs	r0, #0
    acbc:	4770      	bx	lr
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
    acbe:	f8d0 0454 	ldr.w	r0, [r0, #1108]	; 0x454
    acc2:	f3c0 4000 	ubfx	r0, r0, #16, #1
    acc6:	4770      	bx	lr
    switch (domain)
    acc8:	2000      	movs	r0, #0
    acca:	4770      	bx	lr
                return true;
    accc:	2001      	movs	r0, #1
    acce:	4770      	bx	lr
                return true;
    acd0:	2001      	movs	r0, #1
    acd2:	4770      	bx	lr
                return true;
    acd4:	2001      	movs	r0, #1
}
    acd6:	4770      	bx	lr

0000acd8 <get_sub_data>:
	struct nrf_clock_control_data *data = dev->data;
    acd8:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
    acda:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    acde:	0089      	lsls	r1, r1, #2
    ace0:	3170      	adds	r1, #112	; 0x70
}
    ace2:	4408      	add	r0, r1
    ace4:	4770      	bx	lr

0000ace6 <get_sub_config>:
	const struct nrf_clock_control_config *config =
    ace6:	6840      	ldr	r0, [r0, #4]
	return &config->subsys[type];
    ace8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
}
    acec:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    acf0:	4770      	bx	lr

0000acf2 <get_onoff_manager>:
	struct nrf_clock_control_data *data = dev->data;
    acf2:	6900      	ldr	r0, [r0, #16]
	return &data->mgr[type];
    acf4:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
}
    acf8:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    acfc:	4770      	bx	lr

0000acfe <get_status>:
{
    acfe:	b508      	push	{r3, lr}
	return GET_STATUS(get_sub_data(dev, type)->flags);
    ad00:	b2c9      	uxtb	r1, r1
    ad02:	f7ff ffe9 	bl	acd8 <get_sub_data>
    ad06:	6880      	ldr	r0, [r0, #8]
}
    ad08:	f000 0007 	and.w	r0, r0, #7
    ad0c:	bd08      	pop	{r3, pc}

0000ad0e <set_off_state>:
	__asm__ volatile(
    ad0e:	f04f 0320 	mov.w	r3, #32
    ad12:	f3ef 8211 	mrs	r2, BASEPRI
    ad16:	f383 8812 	msr	BASEPRI_MAX, r3
    ad1a:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    ad1e:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    ad20:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
    ad24:	d001      	beq.n	ad2a <set_off_state+0x1c>
    ad26:	428b      	cmp	r3, r1
    ad28:	d107      	bne.n	ad3a <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
    ad2a:	2301      	movs	r3, #1
    ad2c:	6003      	str	r3, [r0, #0]
	int err = 0;
    ad2e:	2000      	movs	r0, #0
	__asm__ volatile(
    ad30:	f382 8811 	msr	BASEPRI, r2
    ad34:	f3bf 8f6f 	isb	sy
}
    ad38:	4770      	bx	lr
		err = -EPERM;
    ad3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ad3e:	e7f7      	b.n	ad30 <set_off_state+0x22>

0000ad40 <set_starting_state>:
	__asm__ volatile(
    ad40:	f04f 0320 	mov.w	r3, #32
    ad44:	f3ef 8211 	mrs	r2, BASEPRI
    ad48:	f383 8812 	msr	BASEPRI_MAX, r3
    ad4c:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    ad50:	6803      	ldr	r3, [r0, #0]
    ad52:	f003 0cc0 	and.w	ip, r3, #192	; 0xc0
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    ad56:	f003 0307 	and.w	r3, r3, #7
    ad5a:	2b01      	cmp	r3, #1
    ad5c:	d008      	beq.n	ad70 <set_starting_state+0x30>
	} else if (current_ctx != ctx) {
    ad5e:	458c      	cmp	ip, r1
    ad60:	d009      	beq.n	ad76 <set_starting_state+0x36>
		err = -EPERM;
    ad62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	__asm__ volatile(
    ad66:	f382 8811 	msr	BASEPRI, r2
    ad6a:	f3bf 8f6f 	isb	sy
}
    ad6e:	4770      	bx	lr
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    ad70:	6001      	str	r1, [r0, #0]
	int err = 0;
    ad72:	2000      	movs	r0, #0
    ad74:	e7f7      	b.n	ad66 <set_starting_state+0x26>
		err = -EALREADY;
    ad76:	f06f 0077 	mvn.w	r0, #119	; 0x77
    ad7a:	e7f4      	b.n	ad66 <set_starting_state+0x26>

0000ad7c <set_on_state>:
	__asm__ volatile(
    ad7c:	f04f 0320 	mov.w	r3, #32
    ad80:	f3ef 8211 	mrs	r2, BASEPRI
    ad84:	f383 8812 	msr	BASEPRI_MAX, r3
    ad88:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    ad8c:	6803      	ldr	r3, [r0, #0]
    ad8e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    ad92:	f043 0302 	orr.w	r3, r3, #2
    ad96:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
    ad98:	f382 8811 	msr	BASEPRI, r2
    ad9c:	f3bf 8f6f 	isb	sy
}
    ada0:	4770      	bx	lr

0000ada2 <clkstarted_handle>:
{
    ada2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ada4:	4606      	mov	r6, r0
    ada6:	460c      	mov	r4, r1
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    ada8:	f7ff ff96 	bl	acd8 <get_sub_data>
	clock_control_cb_t callback = sub_data->cb;
    adac:	6805      	ldr	r5, [r0, #0]
	void *user_data = sub_data->user_data;
    adae:	6847      	ldr	r7, [r0, #4]
	sub_data->cb = NULL;
    adb0:	2300      	movs	r3, #0
    adb2:	f840 3b08 	str.w	r3, [r0], #8
	set_on_state(&sub_data->flags);
    adb6:	f7ff ffe1 	bl	ad7c <set_on_state>
	if (callback) {
    adba:	b11d      	cbz	r5, adc4 <clkstarted_handle+0x22>
		callback(dev, (clock_control_subsys_t)type, user_data);
    adbc:	463a      	mov	r2, r7
    adbe:	4621      	mov	r1, r4
    adc0:	4630      	mov	r0, r6
    adc2:	47a8      	blx	r5
}
    adc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000adc6 <stop>:
{
    adc6:	b570      	push	{r4, r5, r6, lr}
    adc8:	4606      	mov	r6, r0
    adca:	4615      	mov	r5, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    adcc:	b2cc      	uxtb	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    adce:	4621      	mov	r1, r4
    add0:	f7ff ff82 	bl	acd8 <get_sub_data>
	err = set_off_state(&subdata->flags, ctx);
    add4:	4629      	mov	r1, r5
    add6:	3008      	adds	r0, #8
    add8:	f7ff ff99 	bl	ad0e <set_off_state>
	if (err < 0) {
    addc:	2800      	cmp	r0, #0
    adde:	db06      	blt.n	adee <stop+0x28>
	get_sub_config(dev, type)->stop();
    ade0:	4621      	mov	r1, r4
    ade2:	4630      	mov	r0, r6
    ade4:	f7ff ff7f 	bl	ace6 <get_sub_config>
    ade8:	6843      	ldr	r3, [r0, #4]
    adea:	4798      	blx	r3
	return 0;
    adec:	2000      	movs	r0, #0
}
    adee:	bd70      	pop	{r4, r5, r6, pc}

0000adf0 <api_stop>:
{
    adf0:	b508      	push	{r3, lr}
	return stop(dev, subsys, CTX_API);
    adf2:	2280      	movs	r2, #128	; 0x80
    adf4:	f7ff ffe7 	bl	adc6 <stop>
}
    adf8:	bd08      	pop	{r3, pc}

0000adfa <async_start>:
{
    adfa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    adfe:	4606      	mov	r6, r0
    ae00:	4690      	mov	r8, r2
    ae02:	461f      	mov	r7, r3
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    ae04:	b2cd      	uxtb	r5, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    ae06:	4629      	mov	r1, r5
    ae08:	f7ff ff66 	bl	acd8 <get_sub_data>
    ae0c:	4604      	mov	r4, r0
	err = set_starting_state(&subdata->flags, ctx);
    ae0e:	9906      	ldr	r1, [sp, #24]
    ae10:	3008      	adds	r0, #8
    ae12:	f7ff ff95 	bl	ad40 <set_starting_state>
	if (err < 0) {
    ae16:	2800      	cmp	r0, #0
    ae18:	db09      	blt.n	ae2e <async_start+0x34>
	subdata->cb = cb;
    ae1a:	f8c4 8000 	str.w	r8, [r4]
	subdata->user_data = user_data;
    ae1e:	6067      	str	r7, [r4, #4]
	 get_sub_config(dev, type)->start();
    ae20:	4629      	mov	r1, r5
    ae22:	4630      	mov	r0, r6
    ae24:	f7ff ff5f 	bl	ace6 <get_sub_config>
    ae28:	6803      	ldr	r3, [r0, #0]
    ae2a:	4798      	blx	r3
	return 0;
    ae2c:	2000      	movs	r0, #0
}
    ae2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000ae32 <api_start>:
{
    ae32:	b510      	push	{r4, lr}
    ae34:	b082      	sub	sp, #8
	return async_start(dev, subsys, cb, user_data, CTX_API);
    ae36:	2480      	movs	r4, #128	; 0x80
    ae38:	9400      	str	r4, [sp, #0]
    ae3a:	f7ff ffde 	bl	adfa <async_start>
}
    ae3e:	b002      	add	sp, #8
    ae40:	bd10      	pop	{r4, pc}

0000ae42 <onoff_started_callback>:
{
    ae42:	b510      	push	{r4, lr}
    ae44:	4614      	mov	r4, r2
	struct onoff_manager *mgr = get_onoff_manager(dev, type);
    ae46:	b2c9      	uxtb	r1, r1
    ae48:	f7ff ff53 	bl	acf2 <get_onoff_manager>
	notify(mgr, 0);
    ae4c:	2100      	movs	r1, #0
    ae4e:	47a0      	blx	r4
}
    ae50:	bd10      	pop	{r4, pc}

0000ae52 <hfclk_start>:
{
    ae52:	b508      	push	{r3, lr}
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    ae54:	2001      	movs	r0, #1
    ae56:	f000 ff26 	bl	bca6 <nrfx_clock_start>
}
    ae5a:	bd08      	pop	{r3, pc}

0000ae5c <hfclkaudio_start>:
{
    ae5c:	b508      	push	{r3, lr}
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
    ae5e:	2003      	movs	r0, #3
    ae60:	f000 ff21 	bl	bca6 <nrfx_clock_start>
}
    ae64:	bd08      	pop	{r3, pc}

0000ae66 <hfclk192m_start>:
{
    ae66:	b508      	push	{r3, lr}
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK192M);
    ae68:	2002      	movs	r0, #2
    ae6a:	f000 ff1c 	bl	bca6 <nrfx_clock_start>
}
    ae6e:	bd08      	pop	{r3, pc}

0000ae70 <lfclk_start>:
{
    ae70:	b508      	push	{r3, lr}
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    ae72:	2000      	movs	r0, #0
    ae74:	f000 ff17 	bl	bca6 <nrfx_clock_start>
}
    ae78:	bd08      	pop	{r3, pc}

0000ae7a <hfclk_stop>:
{
    ae7a:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    ae7c:	2001      	movs	r0, #1
    ae7e:	f000 ff87 	bl	bd90 <nrfx_clock_stop>
}
    ae82:	bd08      	pop	{r3, pc}

0000ae84 <hfclkaudio_stop>:
{
    ae84:	b508      	push	{r3, lr}
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
    ae86:	2003      	movs	r0, #3
    ae88:	f000 ff82 	bl	bd90 <nrfx_clock_stop>
}
    ae8c:	bd08      	pop	{r3, pc}

0000ae8e <hfclk192m_stop>:
{
    ae8e:	b508      	push	{r3, lr}
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
    ae90:	2002      	movs	r0, #2
    ae92:	f000 ff7d 	bl	bd90 <nrfx_clock_stop>
}
    ae96:	bd08      	pop	{r3, pc}

0000ae98 <lfclk_stop>:
{
    ae98:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    ae9a:	2000      	movs	r0, #0
    ae9c:	f000 ff78 	bl	bd90 <nrfx_clock_stop>
}
    aea0:	bd08      	pop	{r3, pc}

0000aea2 <k_msleep>:
{
    aea2:	b508      	push	{r3, lr}
	return k_sleep(Z_TIMEOUT_MS(ms));
    aea4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    aea8:	17c1      	asrs	r1, r0, #31
    aeaa:	03c9      	lsls	r1, r1, #15
    aeac:	ea41 4150 	orr.w	r1, r1, r0, lsr #17
    aeb0:	03c0      	lsls	r0, r0, #15
    aeb2:	f240 33e7 	movw	r3, #999	; 0x3e7
    aeb6:	18c0      	adds	r0, r0, r3
    aeb8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    aebc:	f04f 0300 	mov.w	r3, #0
    aec0:	f141 0100 	adc.w	r1, r1, #0
    aec4:	f7f5 f946 	bl	154 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
    aec8:	f7fd ff3e 	bl	8d48 <z_impl_k_sleep>
}
    aecc:	bd08      	pop	{r3, pc}

0000aece <blocking_start_callback>:
{
    aece:	b508      	push	{r3, lr}
    aed0:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
    aed2:	f7fd fb77 	bl	85c4 <z_impl_k_sem_give>
}
    aed6:	bd08      	pop	{r3, pc}

0000aed8 <k_msleep>:
{
    aed8:	b508      	push	{r3, lr}
	return k_sleep(Z_TIMEOUT_MS(ms));
    aeda:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    aede:	17c1      	asrs	r1, r0, #31
    aee0:	03c9      	lsls	r1, r1, #15
    aee2:	ea41 4150 	orr.w	r1, r1, r0, lsr #17
    aee6:	03c0      	lsls	r0, r0, #15
    aee8:	f240 33e7 	movw	r3, #999	; 0x3e7
    aeec:	18c0      	adds	r0, r0, r3
    aeee:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    aef2:	f04f 0300 	mov.w	r3, #0
    aef6:	f141 0100 	adc.w	r1, r1, #0
    aefa:	f7f5 f92b 	bl	154 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
    aefe:	f7fd ff23 	bl	8d48 <z_impl_k_sleep>
}
    af02:	bd08      	pop	{r3, pc}

0000af04 <wait>:
{
    af04:	b508      	push	{r3, lr}
	if (!IS_ENABLED(CONFIG_MULTITHREADING) || k_is_in_isr()) {
    af06:	f002 fcaf 	bl	d868 <k_is_in_isr>
    af0a:	b100      	cbz	r0, af0e <wait+0xa>
}
    af0c:	bd08      	pop	{r3, pc}
		k_msleep(CONFIG_RTT_TX_RETRY_DELAY_MS);
    af0e:	2002      	movs	r0, #2
    af10:	f7ff ffe2 	bl	aed8 <k_msleep>
}
    af14:	e7fa      	b.n	af0c <wait+0x8>

0000af16 <spi_transceive_dt>:
 * @return a value from spi_transceive().
 */
static inline int spi_transceive_dt(const struct spi_dt_spec *spec,
				    const struct spi_buf_set *tx_bufs,
				    const struct spi_buf_set *rx_bufs)
{
    af16:	b510      	push	{r4, lr}
    af18:	468c      	mov	ip, r1
    af1a:	4613      	mov	r3, r2
	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
    af1c:	4601      	mov	r1, r0
    af1e:	f851 0b04 	ldr.w	r0, [r1], #4
	const struct spi_driver_api *api =
    af22:	6882      	ldr	r2, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
    af24:	6814      	ldr	r4, [r2, #0]
    af26:	4662      	mov	r2, ip
    af28:	47a0      	blx	r4
}
    af2a:	bd10      	pop	{r4, pc}

0000af2c <spi_write_dt>:
 *
 * @return a value from spi_write().
 */
static inline int spi_write_dt(const struct spi_dt_spec *spec,
			       const struct spi_buf_set *tx_bufs)
{
    af2c:	b510      	push	{r4, lr}
    af2e:	460a      	mov	r2, r1
	return spi_write(spec->bus, &spec->config, tx_bufs);
    af30:	4601      	mov	r1, r0
    af32:	f851 0b04 	ldr.w	r0, [r1], #4
	const struct spi_driver_api *api =
    af36:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
    af38:	681c      	ldr	r4, [r3, #0]
    af3a:	2300      	movs	r3, #0
    af3c:	47a0      	blx	r4
}
    af3e:	bd10      	pop	{r4, pc}

0000af40 <spi_nor_pages_layout>:
	const struct spi_nor_config *cfg = dev->config;
    af40:	6843      	ldr	r3, [r0, #4]
	*layout = &cfg->layout;
    af42:	3314      	adds	r3, #20
    af44:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
    af46:	2301      	movs	r3, #1
    af48:	6013      	str	r3, [r2, #0]
}
    af4a:	4770      	bx	lr

0000af4c <acquire_device>:
{
    af4c:	b508      	push	{r3, lr}
		struct spi_nor_data *const driver_data = dev->data;
    af4e:	6900      	ldr	r0, [r0, #16]
	return z_impl_k_sem_take(sem, timeout);
    af50:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    af54:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    af58:	f7fd fb56 	bl	8608 <z_impl_k_sem_take>
}
    af5c:	bd08      	pop	{r3, pc}

0000af5e <spi_nor_access>:
{
    af5e:	b5f0      	push	{r4, r5, r6, r7, lr}
    af60:	b08d      	sub	sp, #52	; 0x34
    af62:	9c13      	ldr	r4, [sp, #76]	; 0x4c
	const struct spi_nor_config *const driver_cfg = dev->config;
    af64:	6845      	ldr	r5, [r0, #4]
	struct spi_nor_data *const driver_data = dev->data;
    af66:	6907      	ldr	r7, [r0, #16]
	bool is_write = (access & NOR_ACCESS_WRITE) != 0U;
    af68:	f002 0680 	and.w	r6, r2, #128	; 0x80
	uint8_t buf[5] = { 0 };
    af6c:	2000      	movs	r0, #0
    af6e:	900a      	str	r0, [sp, #40]	; 0x28
    af70:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
	struct spi_buf spi_buf[2] = {
    af74:	a80a      	add	r0, sp, #40	; 0x28
    af76:	9006      	str	r0, [sp, #24]
    af78:	2001      	movs	r0, #1
    af7a:	9007      	str	r0, [sp, #28]
    af7c:	9812      	ldr	r0, [sp, #72]	; 0x48
    af7e:	9008      	str	r0, [sp, #32]
    af80:	9409      	str	r4, [sp, #36]	; 0x24
	buf[0] = opcode;
    af82:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
	if (is_addressed) {
    af86:	f012 0f01 	tst.w	r2, #1
    af8a:	d023      	beq.n	afd4 <spi_nor_access+0x76>
		bool access_24bit = (access & NOR_ACCESS_24BIT_ADDR) != 0;
    af8c:	f002 0102 	and.w	r1, r2, #2
				  || (!access_24bit
    af90:	f012 0f04 	tst.w	r2, #4
    af94:	d106      	bne.n	afa4 <spi_nor_access+0x46>
    af96:	bb71      	cbnz	r1, aff6 <spi_nor_access+0x98>
				      && driver_data->flag_access_32bit));
    af98:	7d3a      	ldrb	r2, [r7, #20]
    af9a:	f012 0f01 	tst.w	r2, #1
    af9e:	d12c      	bne.n	affa <spi_nor_access+0x9c>
				  || (!access_24bit
    afa0:	2000      	movs	r0, #0
    afa2:	e000      	b.n	afa6 <spi_nor_access+0x48>
    afa4:	2001      	movs	r0, #1
			.u32 = sys_cpu_to_be32(addr),
    afa6:	121a      	asrs	r2, r3, #8
    afa8:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
    afac:	ea42 6213 	orr.w	r2, r2, r3, lsr #24
    afb0:	0219      	lsls	r1, r3, #8
    afb2:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    afb6:	430a      	orrs	r2, r1
    afb8:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
		} addr32 = {
    afbc:	9301      	str	r3, [sp, #4]
		if (use_32bit) {
    afbe:	b1f0      	cbz	r0, affe <spi_nor_access+0xa0>
			memcpy(&buf[1], &addr32.u8[0], 4);
    afc0:	2204      	movs	r2, #4
    afc2:	eb0d 0102 	add.w	r1, sp, r2
    afc6:	f10d 0029 	add.w	r0, sp, #41	; 0x29
    afca:	f7ff fb77 	bl	a6bc <memcpy>
			spi_buf[0].len += 4;
    afce:	9b07      	ldr	r3, [sp, #28]
    afd0:	3304      	adds	r3, #4
    afd2:	9307      	str	r3, [sp, #28]
	const struct spi_buf_set tx_set = {
    afd4:	ab06      	add	r3, sp, #24
    afd6:	9304      	str	r3, [sp, #16]
		.count = (length != 0) ? 2 : 1,
    afd8:	b1e4      	cbz	r4, b014 <spi_nor_access+0xb6>
    afda:	2302      	movs	r3, #2
	const struct spi_buf_set tx_set = {
    afdc:	9305      	str	r3, [sp, #20]
	const struct spi_buf_set rx_set = {
    afde:	ab06      	add	r3, sp, #24
    afe0:	9302      	str	r3, [sp, #8]
    afe2:	2302      	movs	r3, #2
    afe4:	9303      	str	r3, [sp, #12]
	if (is_write) {
    afe6:	b9be      	cbnz	r6, b018 <spi_nor_access+0xba>
	return spi_transceive_dt(&driver_cfg->spi, &tx_set, &rx_set);
    afe8:	aa02      	add	r2, sp, #8
    afea:	a904      	add	r1, sp, #16
    afec:	4628      	mov	r0, r5
    afee:	f7ff ff92 	bl	af16 <spi_transceive_dt>
}
    aff2:	b00d      	add	sp, #52	; 0x34
    aff4:	bdf0      	pop	{r4, r5, r6, r7, pc}
				  || (!access_24bit
    aff6:	2000      	movs	r0, #0
    aff8:	e7d5      	b.n	afa6 <spi_nor_access+0x48>
    affa:	2001      	movs	r0, #1
    affc:	e7d3      	b.n	afa6 <spi_nor_access+0x48>
			memcpy(&buf[1], &addr32.u8[1], 3);
    affe:	2203      	movs	r2, #3
    b000:	f10d 0105 	add.w	r1, sp, #5
    b004:	f10d 0029 	add.w	r0, sp, #41	; 0x29
    b008:	f7ff fb58 	bl	a6bc <memcpy>
			spi_buf[0].len += 3;
    b00c:	9b07      	ldr	r3, [sp, #28]
    b00e:	3303      	adds	r3, #3
    b010:	9307      	str	r3, [sp, #28]
    b012:	e7df      	b.n	afd4 <spi_nor_access+0x76>
		.count = (length != 0) ? 2 : 1,
    b014:	2301      	movs	r3, #1
    b016:	e7e1      	b.n	afdc <spi_nor_access+0x7e>
		return spi_write_dt(&driver_cfg->spi, &tx_set);
    b018:	a904      	add	r1, sp, #16
    b01a:	4628      	mov	r0, r5
    b01c:	f7ff ff86 	bl	af2c <spi_write_dt>
    b020:	e7e7      	b.n	aff2 <spi_nor_access+0x94>

0000b022 <spi_nor_wait_until_ready>:
{
    b022:	b510      	push	{r4, lr}
    b024:	b084      	sub	sp, #16
    b026:	4604      	mov	r4, r0
		ret = spi_nor_cmd_read(dev, SPI_NOR_CMD_RDSR, &reg, sizeof(reg));
    b028:	2301      	movs	r3, #1
    b02a:	9301      	str	r3, [sp, #4]
    b02c:	f10d 030f 	add.w	r3, sp, #15
    b030:	9300      	str	r3, [sp, #0]
    b032:	2300      	movs	r3, #0
    b034:	461a      	mov	r2, r3
    b036:	2105      	movs	r1, #5
    b038:	4620      	mov	r0, r4
    b03a:	f7ff ff90 	bl	af5e <spi_nor_access>
	} while (!ret && (reg & SPI_NOR_WIP_BIT));
    b03e:	4602      	mov	r2, r0
    b040:	b920      	cbnz	r0, b04c <spi_nor_wait_until_ready+0x2a>
    b042:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b046:	f013 0f01 	tst.w	r3, #1
    b04a:	d1ed      	bne.n	b028 <spi_nor_wait_until_ready+0x6>
}
    b04c:	4610      	mov	r0, r2
    b04e:	b004      	add	sp, #16
    b050:	bd10      	pop	{r4, pc}

0000b052 <spi_nor_write_protection_set>:
{
    b052:	b500      	push	{lr}
    b054:	b083      	sub	sp, #12
	ret = spi_nor_cmd_write(dev, (write_protect) ?
    b056:	b149      	cbz	r1, b06c <spi_nor_write_protection_set+0x1a>
    b058:	2104      	movs	r1, #4
    b05a:	2300      	movs	r3, #0
    b05c:	9301      	str	r3, [sp, #4]
    b05e:	9300      	str	r3, [sp, #0]
    b060:	2280      	movs	r2, #128	; 0x80
    b062:	f7ff ff7c 	bl	af5e <spi_nor_access>
}
    b066:	b003      	add	sp, #12
    b068:	f85d fb04 	ldr.w	pc, [sp], #4
	ret = spi_nor_cmd_write(dev, (write_protect) ?
    b06c:	2106      	movs	r1, #6
    b06e:	e7f4      	b.n	b05a <spi_nor_write_protection_set+0x8>

0000b070 <spi_nor_rdsr>:
{
    b070:	b500      	push	{lr}
    b072:	b085      	sub	sp, #20
	int ret = spi_nor_cmd_read(dev, SPI_NOR_CMD_RDSR, &reg, sizeof(reg));
    b074:	2301      	movs	r3, #1
    b076:	9301      	str	r3, [sp, #4]
    b078:	f10d 030f 	add.w	r3, sp, #15
    b07c:	9300      	str	r3, [sp, #0]
    b07e:	2300      	movs	r3, #0
    b080:	461a      	mov	r2, r3
    b082:	2105      	movs	r1, #5
    b084:	f7ff ff6b 	bl	af5e <spi_nor_access>
	if (ret == 0) {
    b088:	b908      	cbnz	r0, b08e <spi_nor_rdsr+0x1e>
		ret = reg;
    b08a:	f89d 000f 	ldrb.w	r0, [sp, #15]
}
    b08e:	b005      	add	sp, #20
    b090:	f85d fb04 	ldr.w	pc, [sp], #4

0000b094 <spi_nor_wrsr>:
{
    b094:	b530      	push	{r4, r5, lr}
    b096:	b085      	sub	sp, #20
    b098:	4604      	mov	r4, r0
    b09a:	f88d 100f 	strb.w	r1, [sp, #15]
	int ret = spi_nor_cmd_write(dev, SPI_NOR_CMD_WREN);
    b09e:	2300      	movs	r3, #0
    b0a0:	9301      	str	r3, [sp, #4]
    b0a2:	9300      	str	r3, [sp, #0]
    b0a4:	2280      	movs	r2, #128	; 0x80
    b0a6:	2106      	movs	r1, #6
    b0a8:	f7ff ff59 	bl	af5e <spi_nor_access>
	if (ret == 0) {
    b0ac:	4605      	mov	r5, r0
    b0ae:	b110      	cbz	r0, b0b6 <spi_nor_wrsr+0x22>
}
    b0b0:	4628      	mov	r0, r5
    b0b2:	b005      	add	sp, #20
    b0b4:	bd30      	pop	{r4, r5, pc}
		ret = spi_nor_access(dev, SPI_NOR_CMD_WRSR, NOR_ACCESS_WRITE, 0, &sr,
    b0b6:	2101      	movs	r1, #1
    b0b8:	9101      	str	r1, [sp, #4]
    b0ba:	f10d 030f 	add.w	r3, sp, #15
    b0be:	9300      	str	r3, [sp, #0]
    b0c0:	2300      	movs	r3, #0
    b0c2:	2280      	movs	r2, #128	; 0x80
    b0c4:	4620      	mov	r0, r4
    b0c6:	f7ff ff4a 	bl	af5e <spi_nor_access>
    b0ca:	4605      	mov	r5, r0
		spi_nor_wait_until_ready(dev);
    b0cc:	4620      	mov	r0, r4
    b0ce:	f7ff ffa8 	bl	b022 <spi_nor_wait_until_ready>
	return ret;
    b0d2:	e7ed      	b.n	b0b0 <spi_nor_wrsr+0x1c>

0000b0d4 <release_device>:
{
    b0d4:	b508      	push	{r3, lr}
		struct spi_nor_data *const driver_data = dev->data;
    b0d6:	6900      	ldr	r0, [r0, #16]
	z_impl_k_sem_give(sem);
    b0d8:	f7fd fa74 	bl	85c4 <z_impl_k_sem_give>
}
    b0dc:	bd08      	pop	{r3, pc}

0000b0de <spi_nor_write>:
{
    b0de:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b0e2:	b082      	sub	sp, #8
    b0e4:	461e      	mov	r6, r3
	const struct spi_nor_config *cfg = dev->config;
    b0e6:	6843      	ldr	r3, [r0, #4]
	return cfg->flash_size;
    b0e8:	691b      	ldr	r3, [r3, #16]
	if ((addr < 0) || ((size + addr) > flash_size)) {
    b0ea:	1e0c      	subs	r4, r1, #0
    b0ec:	db54      	blt.n	b198 <spi_nor_write+0xba>
    b0ee:	4607      	mov	r7, r0
    b0f0:	4690      	mov	r8, r2
    b0f2:	19a2      	adds	r2, r4, r6
    b0f4:	429a      	cmp	r2, r3
    b0f6:	d852      	bhi.n	b19e <spi_nor_write+0xc0>
	acquire_device(dev);
    b0f8:	f7ff ff28 	bl	af4c <acquire_device>
	ret = spi_nor_write_protection_set(dev, false);
    b0fc:	2100      	movs	r1, #0
    b0fe:	4638      	mov	r0, r7
    b100:	f7ff ffa7 	bl	b052 <spi_nor_write_protection_set>
	if (ret == 0) {
    b104:	4682      	mov	sl, r0
    b106:	2800      	cmp	r0, #0
    b108:	d03d      	beq.n	b186 <spi_nor_write+0xa8>
	int ret2 = spi_nor_write_protection_set(dev, true);
    b10a:	2101      	movs	r1, #1
    b10c:	4638      	mov	r0, r7
    b10e:	f7ff ffa0 	bl	b052 <spi_nor_write_protection_set>
    b112:	4604      	mov	r4, r0
	if (!ret) {
    b114:	f1ba 0f00 	cmp.w	sl, #0
    b118:	d000      	beq.n	b11c <spi_nor_write+0x3e>
    b11a:	4654      	mov	r4, sl
	release_device(dev);
    b11c:	4638      	mov	r0, r7
    b11e:	f7ff ffd9 	bl	b0d4 <release_device>
}
    b122:	4620      	mov	r0, r4
    b124:	b002      	add	sp, #8
    b126:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				to_write = page_size;
    b12a:	f44f 7580 	mov.w	r5, #256	; 0x100
			if (((addr + to_write - 1U) / page_size)
    b12e:	46a1      	mov	r9, r4
    b130:	1961      	adds	r1, r4, r5
    b132:	3901      	subs	r1, #1
    b134:	0a09      	lsrs	r1, r1, #8
			!= (addr / page_size)) {
    b136:	4623      	mov	r3, r4
    b138:	2c00      	cmp	r4, #0
    b13a:	db2a      	blt.n	b192 <spi_nor_write+0xb4>
			if (((addr + to_write - 1U) / page_size)
    b13c:	ebb1 2f23 	cmp.w	r1, r3, asr #8
    b140:	d006      	beq.n	b150 <spi_nor_write+0x72>
				to_write = page_size - (addr % page_size);
    b142:	4263      	negs	r3, r4
    b144:	b2e5      	uxtb	r5, r4
    b146:	b2db      	uxtb	r3, r3
    b148:	bf58      	it	pl
    b14a:	425d      	negpl	r5, r3
    b14c:	f5c5 7580 	rsb	r5, r5, #256	; 0x100
			spi_nor_cmd_write(dev, SPI_NOR_CMD_WREN);
    b150:	2300      	movs	r3, #0
    b152:	9301      	str	r3, [sp, #4]
    b154:	9300      	str	r3, [sp, #0]
    b156:	2280      	movs	r2, #128	; 0x80
    b158:	2106      	movs	r1, #6
    b15a:	4638      	mov	r0, r7
    b15c:	f7ff feff 	bl	af5e <spi_nor_access>
			ret = spi_nor_cmd_addr_write(dev, SPI_NOR_CMD_PP, addr,
    b160:	9501      	str	r5, [sp, #4]
    b162:	f8cd 8000 	str.w	r8, [sp]
    b166:	4623      	mov	r3, r4
    b168:	2281      	movs	r2, #129	; 0x81
    b16a:	2102      	movs	r1, #2
    b16c:	4638      	mov	r0, r7
    b16e:	f7ff fef6 	bl	af5e <spi_nor_access>
			if (ret != 0) {
    b172:	4682      	mov	sl, r0
    b174:	2800      	cmp	r0, #0
    b176:	d1c8      	bne.n	b10a <spi_nor_write+0x2c>
			size -= to_write;
    b178:	1b76      	subs	r6, r6, r5
			src = (const uint8_t *)src + to_write;
    b17a:	44a8      	add	r8, r5
			addr += to_write;
    b17c:	eb09 0405 	add.w	r4, r9, r5
			spi_nor_wait_until_ready(dev);
    b180:	4638      	mov	r0, r7
    b182:	f7ff ff4e 	bl	b022 <spi_nor_wait_until_ready>
		while (size > 0) {
    b186:	2e00      	cmp	r6, #0
    b188:	d0bf      	beq.n	b10a <spi_nor_write+0x2c>
			if (to_write >= page_size) {
    b18a:	2eff      	cmp	r6, #255	; 0xff
    b18c:	d8cd      	bhi.n	b12a <spi_nor_write+0x4c>
			size_t to_write = size;
    b18e:	4635      	mov	r5, r6
    b190:	e7cd      	b.n	b12e <spi_nor_write+0x50>
			!= (addr / page_size)) {
    b192:	f104 03ff 	add.w	r3, r4, #255	; 0xff
    b196:	e7d1      	b.n	b13c <spi_nor_write+0x5e>
		return -EINVAL;
    b198:	f06f 0415 	mvn.w	r4, #21
    b19c:	e7c1      	b.n	b122 <spi_nor_write+0x44>
    b19e:	f06f 0415 	mvn.w	r4, #21
    b1a2:	e7be      	b.n	b122 <spi_nor_write+0x44>

0000b1a4 <spi_nor_read>:
{
    b1a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    b1a6:	b083      	sub	sp, #12
    b1a8:	461e      	mov	r6, r3
	const struct spi_nor_config *cfg = dev->config;
    b1aa:	6843      	ldr	r3, [r0, #4]
	return cfg->flash_size;
    b1ac:	691b      	ldr	r3, [r3, #16]
	if ((addr < 0) || ((addr + size) > flash_size)) {
    b1ae:	1e0d      	subs	r5, r1, #0
    b1b0:	db15      	blt.n	b1de <spi_nor_read+0x3a>
    b1b2:	4604      	mov	r4, r0
    b1b4:	4617      	mov	r7, r2
    b1b6:	19aa      	adds	r2, r5, r6
    b1b8:	429a      	cmp	r2, r3
    b1ba:	d813      	bhi.n	b1e4 <spi_nor_read+0x40>
	acquire_device(dev);
    b1bc:	f7ff fec6 	bl	af4c <acquire_device>
	ret = spi_nor_cmd_addr_read(dev, SPI_NOR_CMD_READ, addr, dest, size);
    b1c0:	9601      	str	r6, [sp, #4]
    b1c2:	9700      	str	r7, [sp, #0]
    b1c4:	462b      	mov	r3, r5
    b1c6:	2201      	movs	r2, #1
    b1c8:	2103      	movs	r1, #3
    b1ca:	4620      	mov	r0, r4
    b1cc:	f7ff fec7 	bl	af5e <spi_nor_access>
    b1d0:	4605      	mov	r5, r0
	release_device(dev);
    b1d2:	4620      	mov	r0, r4
    b1d4:	f7ff ff7e 	bl	b0d4 <release_device>
}
    b1d8:	4628      	mov	r0, r5
    b1da:	b003      	add	sp, #12
    b1dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -EINVAL;
    b1de:	f06f 0515 	mvn.w	r5, #21
    b1e2:	e7f9      	b.n	b1d8 <spi_nor_read+0x34>
    b1e4:	f06f 0515 	mvn.w	r5, #21
    b1e8:	e7f6      	b.n	b1d8 <spi_nor_read+0x34>

0000b1ea <spi_nor_read_jedec_id>:
{
    b1ea:	b530      	push	{r4, r5, lr}
    b1ec:	b083      	sub	sp, #12
	if (id == NULL) {
    b1ee:	b199      	cbz	r1, b218 <spi_nor_read_jedec_id+0x2e>
    b1f0:	4604      	mov	r4, r0
    b1f2:	460d      	mov	r5, r1
	acquire_device(dev);
    b1f4:	f7ff feaa 	bl	af4c <acquire_device>
	int ret = spi_nor_cmd_read(dev, SPI_NOR_CMD_RDID, id, SPI_NOR_MAX_ID_LEN);
    b1f8:	2303      	movs	r3, #3
    b1fa:	9301      	str	r3, [sp, #4]
    b1fc:	9500      	str	r5, [sp, #0]
    b1fe:	2300      	movs	r3, #0
    b200:	461a      	mov	r2, r3
    b202:	219f      	movs	r1, #159	; 0x9f
    b204:	4620      	mov	r0, r4
    b206:	f7ff feaa 	bl	af5e <spi_nor_access>
    b20a:	4605      	mov	r5, r0
	release_device(dev);
    b20c:	4620      	mov	r0, r4
    b20e:	f7ff ff61 	bl	b0d4 <release_device>
}
    b212:	4628      	mov	r0, r5
    b214:	b003      	add	sp, #12
    b216:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    b218:	f06f 0515 	mvn.w	r5, #21
    b21c:	e7f9      	b.n	b212 <spi_nor_read_jedec_id+0x28>

0000b21e <spi_nor_set_address_mode>:
{
    b21e:	b530      	push	{r4, r5, lr}
    b220:	b083      	sub	sp, #12
	    || (enter_4byte_addr == 0xff)) {
    b222:	1e4b      	subs	r3, r1, #1
    b224:	b2db      	uxtb	r3, r3
	if ((enter_4byte_addr == 0)
    b226:	2bfd      	cmp	r3, #253	; 0xfd
    b228:	d828      	bhi.n	b27c <spi_nor_set_address_mode+0x5e>
    b22a:	4604      	mov	r4, r0
    b22c:	460d      	mov	r5, r1
	if ((enter_4byte_addr & 0x03) == 0) {
    b22e:	f011 0f03 	tst.w	r1, #3
    b232:	d025      	beq.n	b280 <spi_nor_set_address_mode+0x62>
	acquire_device(dev);
    b234:	f7ff fe8a 	bl	af4c <acquire_device>
	if ((enter_4byte_addr & 0x02) != 0) {
    b238:	f015 0f02 	tst.w	r5, #2
    b23c:	d009      	beq.n	b252 <spi_nor_set_address_mode+0x34>
		ret = spi_nor_cmd_write(dev, SPI_NOR_CMD_WREN);
    b23e:	2300      	movs	r3, #0
    b240:	9301      	str	r3, [sp, #4]
    b242:	9300      	str	r3, [sp, #0]
    b244:	2280      	movs	r2, #128	; 0x80
    b246:	2106      	movs	r1, #6
    b248:	4620      	mov	r0, r4
    b24a:	f7ff fe88 	bl	af5e <spi_nor_access>
	if (ret == 0) {
    b24e:	4605      	mov	r5, r0
    b250:	b970      	cbnz	r0, b270 <spi_nor_set_address_mode+0x52>
		ret = spi_nor_cmd_write(dev, SPI_NOR_CMD_4BA);
    b252:	2300      	movs	r3, #0
    b254:	9301      	str	r3, [sp, #4]
    b256:	9300      	str	r3, [sp, #0]
    b258:	2280      	movs	r2, #128	; 0x80
    b25a:	21b7      	movs	r1, #183	; 0xb7
    b25c:	4620      	mov	r0, r4
    b25e:	f7ff fe7e 	bl	af5e <spi_nor_access>
	if (ret == 0) {
    b262:	4605      	mov	r5, r0
    b264:	b920      	cbnz	r0, b270 <spi_nor_set_address_mode+0x52>
		struct spi_nor_data *data = dev->data;
    b266:	6922      	ldr	r2, [r4, #16]
		data->flag_access_32bit = true;
    b268:	7d13      	ldrb	r3, [r2, #20]
    b26a:	f043 0301 	orr.w	r3, r3, #1
    b26e:	7513      	strb	r3, [r2, #20]
	release_device(dev);
    b270:	4620      	mov	r0, r4
    b272:	f7ff ff2f 	bl	b0d4 <release_device>
}
    b276:	4628      	mov	r0, r5
    b278:	b003      	add	sp, #12
    b27a:	bd30      	pop	{r4, r5, pc}
		return 0;
    b27c:	2500      	movs	r5, #0
    b27e:	e7fa      	b.n	b276 <spi_nor_set_address_mode+0x58>
		return -ENOTSUP;
    b280:	f06f 0585 	mvn.w	r5, #133	; 0x85
    b284:	e7f7      	b.n	b276 <spi_nor_set_address_mode+0x58>

0000b286 <spi_is_ready_dt>:
{
    b286:	b510      	push	{r4, lr}
    b288:	4604      	mov	r4, r0
	if (!device_is_ready(spec->bus)) {
    b28a:	6800      	ldr	r0, [r0, #0]
    b28c:	f002 f9e9 	bl	d662 <z_device_is_ready>
    b290:	b120      	cbz	r0, b29c <spi_is_ready_dt+0x16>
	if (spec->config.cs &&
    b292:	68e3      	ldr	r3, [r4, #12]
    b294:	b113      	cbz	r3, b29c <spi_is_ready_dt+0x16>
	    !device_is_ready(spec->config.cs->gpio.port)) {
    b296:	6818      	ldr	r0, [r3, #0]
    b298:	f002 f9e3 	bl	d662 <z_device_is_ready>
}
    b29c:	bd10      	pop	{r4, pc}

0000b29e <spi_nor_init>:
{
    b29e:	b510      	push	{r4, lr}
    b2a0:	4604      	mov	r4, r0
		struct spi_nor_data *const driver_data = dev->data;
    b2a2:	6900      	ldr	r0, [r0, #16]
	return z_impl_k_sem_init(sem, initial_count, limit);
    b2a4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    b2a8:	2101      	movs	r1, #1
    b2aa:	f002 fb17 	bl	d8dc <z_impl_k_sem_init>
	return spi_nor_configure(dev);
    b2ae:	4620      	mov	r0, r4
    b2b0:	f7f8 f8c0 	bl	3434 <spi_nor_configure>
}
    b2b4:	bd10      	pop	{r4, pc}

0000b2b6 <shift_write_context>:
	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
}

static void shift_write_context(uint32_t shift, struct flash_context *w_ctx)
{
	w_ctx->flash_addr += shift;
    b2b6:	684b      	ldr	r3, [r1, #4]
    b2b8:	4403      	add	r3, r0
    b2ba:	604b      	str	r3, [r1, #4]
	w_ctx->data_addr += shift;
    b2bc:	680b      	ldr	r3, [r1, #0]
    b2be:	4403      	add	r3, r0
    b2c0:	600b      	str	r3, [r1, #0]
	w_ctx->len -= shift;
    b2c2:	688b      	ldr	r3, [r1, #8]
    b2c4:	1a1b      	subs	r3, r3, r0
    b2c6:	608b      	str	r3, [r1, #8]
}
    b2c8:	4770      	bx	lr

0000b2ca <is_regular_addr_valid>:
{
    b2ca:	b538      	push	{r3, r4, r5, lr}
    b2cc:	4604      	mov	r4, r0
    b2ce:	460d      	mov	r5, r1
	return is_within_bounds(addr, len, 0, nrfx_nvmc_flash_size_get());
    b2d0:	f000 fe01 	bl	bed6 <nrfx_nvmc_flash_size_get>
			(addr < (boundary_start + boundary_size)) &&
    b2d4:	2c00      	cmp	r4, #0
    b2d6:	db06      	blt.n	b2e6 <is_regular_addr_valid+0x1c>
	return (addr >= boundary_start &&
    b2d8:	42a0      	cmp	r0, r4
    b2da:	d906      	bls.n	b2ea <is_regular_addr_valid+0x20>
			(len <= (boundary_start + boundary_size - addr)));
    b2dc:	1b00      	subs	r0, r0, r4
			(addr < (boundary_start + boundary_size)) &&
    b2de:	4285      	cmp	r5, r0
    b2e0:	d905      	bls.n	b2ee <is_regular_addr_valid+0x24>
    b2e2:	2000      	movs	r0, #0
    b2e4:	e000      	b.n	b2e8 <is_regular_addr_valid+0x1e>
    b2e6:	2000      	movs	r0, #0
}
    b2e8:	bd38      	pop	{r3, r4, r5, pc}
			(addr < (boundary_start + boundary_size)) &&
    b2ea:	2000      	movs	r0, #0
    b2ec:	e7fc      	b.n	b2e8 <is_regular_addr_valid+0x1e>
    b2ee:	2001      	movs	r0, #1
    b2f0:	e7fa      	b.n	b2e8 <is_regular_addr_valid+0x1e>

0000b2f2 <erase_op>:
{
    b2f2:	b538      	push	{r3, r4, r5, lr}
    b2f4:	4604      	mov	r4, r0
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
    b2f6:	f000 fdf2 	bl	bede <nrfx_nvmc_flash_page_size_get>
    b2fa:	4605      	mov	r5, r0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
    b2fc:	6860      	ldr	r0, [r4, #4]
    b2fe:	f7f9 fe4d 	bl	4f9c <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
    b302:	68a3      	ldr	r3, [r4, #8]
    b304:	1b5b      	subs	r3, r3, r5
    b306:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
    b308:	6862      	ldr	r2, [r4, #4]
    b30a:	442a      	add	r2, r5
    b30c:	6062      	str	r2, [r4, #4]
	} while (e_ctx->len > 0);
    b30e:	2b00      	cmp	r3, #0
    b310:	d1f4      	bne.n	b2fc <erase_op+0xa>
}
    b312:	2000      	movs	r0, #0
    b314:	bd38      	pop	{r3, r4, r5, pc}

0000b316 <erase>:

	return FLASH_OP_DONE;
}

static int erase(uint32_t addr, uint32_t size)
{
    b316:	b500      	push	{lr}
    b318:	b085      	sub	sp, #20
	struct flash_context context = {
    b31a:	2300      	movs	r3, #0
    b31c:	9301      	str	r3, [sp, #4]
    b31e:	9302      	str	r3, [sp, #8]
    b320:	9303      	str	r3, [sp, #12]
    b322:	9002      	str	r0, [sp, #8]
    b324:	9103      	str	r1, [sp, #12]
#if defined(CONFIG_SOC_FLASH_NRF_PARTIAL_ERASE)
		.flash_addr_next = addr
#endif
	};

	return	erase_op(&context);
    b326:	a801      	add	r0, sp, #4
    b328:	f7ff ffe3 	bl	b2f2 <erase_op>
}
    b32c:	b005      	add	sp, #20
    b32e:	f85d fb04 	ldr.w	pc, [sp], #4

0000b332 <write_op>:
{
    b332:	b510      	push	{r4, lr}
    b334:	4604      	mov	r4, r0
	while (w_ctx->len >= sizeof(uint32_t)) {
    b336:	e008      	b.n	b34a <write_op+0x18>
				     UNALIGNED_GET((uint32_t *)w_ctx->data_addr));
    b338:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
    b33a:	6819      	ldr	r1, [r3, #0]
    b33c:	6860      	ldr	r0, [r4, #4]
    b33e:	f000 fdbe 	bl	bebe <nrfx_nvmc_word_write>
		shift_write_context(sizeof(uint32_t), w_ctx);
    b342:	4621      	mov	r1, r4
    b344:	2004      	movs	r0, #4
    b346:	f7ff ffb6 	bl	b2b6 <shift_write_context>
	while (w_ctx->len >= sizeof(uint32_t)) {
    b34a:	68a3      	ldr	r3, [r4, #8]
    b34c:	2b03      	cmp	r3, #3
    b34e:	d8f3      	bhi.n	b338 <write_op+0x6>
	nvmc_wait_ready();
    b350:	f7f8 f8fa 	bl	3548 <nvmc_wait_ready>
}
    b354:	2000      	movs	r0, #0
    b356:	bd10      	pop	{r4, pc}

0000b358 <write>:

static int write(off_t addr, const void *data, size_t len)
{
    b358:	b500      	push	{lr}
    b35a:	b085      	sub	sp, #20
	struct flash_context context = {
    b35c:	9101      	str	r1, [sp, #4]
    b35e:	9002      	str	r0, [sp, #8]
    b360:	9203      	str	r2, [sp, #12]
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
		.enable_time_limit = 0 /* disable time limit */
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */
	};

	return write_op(&context);
    b362:	a801      	add	r0, sp, #4
    b364:	f7ff ffe5 	bl	b332 <write_op>
}
    b368:	b005      	add	sp, #20
    b36a:	f85d fb04 	ldr.w	pc, [sp], #4

0000b36e <flash_page_foreach>:
	return count;
}

void flash_page_foreach(const struct device *dev, flash_page_cb cb,
			void *data)
{
    b36e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b372:	b086      	sub	sp, #24
    b374:	4689      	mov	r9, r1
    b376:	4690      	mov	r8, r2
	const struct flash_driver_api *api = dev->api;
    b378:	6883      	ldr	r3, [r0, #8]
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
    b37a:	691b      	ldr	r3, [r3, #16]
    b37c:	aa01      	add	r2, sp, #4
    b37e:	a905      	add	r1, sp, #20
    b380:	4798      	blx	r3
	off_t off = 0;
    b382:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
    b384:	4626      	mov	r6, r4

	for (block = 0; block < num_blocks; block++) {
    b386:	46a2      	mov	sl, r4
    b388:	9b01      	ldr	r3, [sp, #4]
    b38a:	4553      	cmp	r3, sl
    b38c:	d914      	bls.n	b3b8 <flash_page_foreach+0x4a>
		const struct flash_pages_layout *l = &layout[block];
    b38e:	9f05      	ldr	r7, [sp, #20]
    b390:	eb07 07ca 	add.w	r7, r7, sl, lsl #3
		page_info.size = l->pages_size;
    b394:	687b      	ldr	r3, [r7, #4]
    b396:	9303      	str	r3, [sp, #12]

		for (i = 0; i < l->pages_count; i++) {
    b398:	2500      	movs	r5, #0
    b39a:	e003      	b.n	b3a4 <flash_page_foreach+0x36>

			if (!cb(&page_info, data)) {
				return;
			}

			off += page_info.size;
    b39c:	9b03      	ldr	r3, [sp, #12]
    b39e:	441c      	add	r4, r3
			page++;
    b3a0:	3601      	adds	r6, #1
		for (i = 0; i < l->pages_count; i++) {
    b3a2:	3501      	adds	r5, #1
    b3a4:	683b      	ldr	r3, [r7, #0]
    b3a6:	42ab      	cmp	r3, r5
    b3a8:	d909      	bls.n	b3be <flash_page_foreach+0x50>
			page_info.start_offset = off;
    b3aa:	9402      	str	r4, [sp, #8]
			page_info.index = page;
    b3ac:	9604      	str	r6, [sp, #16]
			if (!cb(&page_info, data)) {
    b3ae:	4641      	mov	r1, r8
    b3b0:	a802      	add	r0, sp, #8
    b3b2:	47c8      	blx	r9
    b3b4:	2800      	cmp	r0, #0
    b3b6:	d1f1      	bne.n	b39c <flash_page_foreach+0x2e>
		}
	}
}
    b3b8:	b006      	add	sp, #24
    b3ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for (block = 0; block < num_blocks; block++) {
    b3be:	f10a 0a01 	add.w	sl, sl, #1
    b3c2:	e7e1      	b.n	b388 <flash_page_foreach+0x1a>

0000b3c4 <sys_slist_remove>:
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    b3c4:	460b      	mov	r3, r1
    b3c6:	b139      	cbz	r1, b3d8 <sys_slist_remove+0x14>
	return node->next;
    b3c8:	6811      	ldr	r1, [r2, #0]
	parent->next = child;
    b3ca:	6019      	str	r1, [r3, #0]
	return list->tail;
    b3cc:	6841      	ldr	r1, [r0, #4]
Z_GENLIST_REMOVE(slist, snode)
    b3ce:	428a      	cmp	r2, r1
    b3d0:	d009      	beq.n	b3e6 <sys_slist_remove+0x22>
	parent->next = child;
    b3d2:	2300      	movs	r3, #0
    b3d4:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
    b3d6:	4770      	bx	lr
	return node->next;
    b3d8:	6813      	ldr	r3, [r2, #0]
	list->head = node;
    b3da:	6003      	str	r3, [r0, #0]
	return list->tail;
    b3dc:	6841      	ldr	r1, [r0, #4]
Z_GENLIST_REMOVE(slist, snode)
    b3de:	428a      	cmp	r2, r1
    b3e0:	d1f7      	bne.n	b3d2 <sys_slist_remove+0xe>
	list->tail = node;
    b3e2:	6043      	str	r3, [r0, #4]
}
    b3e4:	e7f5      	b.n	b3d2 <sys_slist_remove+0xe>
	list->tail = node;
    b3e6:	6043      	str	r3, [r0, #4]
}
    b3e8:	e7f3      	b.n	b3d2 <sys_slist_remove+0xe>

0000b3ea <sys_slist_find_and_remove>:
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    b3ea:	b508      	push	{r3, lr}
    b3ec:	460a      	mov	r2, r1
	return list->head;
    b3ee:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    b3f0:	2100      	movs	r1, #0
    b3f2:	e001      	b.n	b3f8 <sys_slist_find_and_remove+0xe>
    b3f4:	4619      	mov	r1, r3
    b3f6:	681b      	ldr	r3, [r3, #0]
    b3f8:	b12b      	cbz	r3, b406 <sys_slist_find_and_remove+0x1c>
    b3fa:	4293      	cmp	r3, r2
    b3fc:	d1fa      	bne.n	b3f4 <sys_slist_find_and_remove+0xa>
    b3fe:	f7ff ffe1 	bl	b3c4 <sys_slist_remove>
    b402:	2001      	movs	r0, #1
    b404:	e000      	b.n	b408 <sys_slist_find_and_remove+0x1e>
    b406:	2000      	movs	r0, #0
    b408:	bd08      	pop	{r3, pc}

0000b40a <gpio_manage_callback>:
 * @return 0 on success, negative errno otherwise.
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
    b40a:	b570      	push	{r4, r5, r6, lr}
    b40c:	4604      	mov	r4, r0
    b40e:	460d      	mov	r5, r1
    b410:	4616      	mov	r6, r2
	return list->head;
    b412:	6803      	ldr	r3, [r0, #0]
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
    b414:	b133      	cbz	r3, b424 <gpio_manage_callback+0x1a>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
    b416:	f7ff ffe8 	bl	b3ea <sys_slist_find_and_remove>
    b41a:	b970      	cbnz	r0, b43a <gpio_manage_callback+0x30>
			if (!set) {
    b41c:	b91e      	cbnz	r6, b426 <gpio_manage_callback+0x1c>
				return -EINVAL;
    b41e:	f06f 0015 	mvn.w	r0, #21
    b422:	e006      	b.n	b432 <gpio_manage_callback+0x28>
			}
		}
	} else if (!set) {
    b424:	b132      	cbz	r2, b434 <gpio_manage_callback+0x2a>
    b426:	6823      	ldr	r3, [r4, #0]
	parent->next = child;
    b428:	602b      	str	r3, [r5, #0]
	list->head = node;
    b42a:	6025      	str	r5, [r4, #0]
	return list->tail;
    b42c:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_PREPEND(slist, snode)
    b42e:	b143      	cbz	r3, b442 <gpio_manage_callback+0x38>

	if (set) {
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
    b430:	2000      	movs	r0, #0
}
    b432:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    b434:	f06f 0015 	mvn.w	r0, #21
    b438:	e7fb      	b.n	b432 <gpio_manage_callback+0x28>
	if (set) {
    b43a:	2e00      	cmp	r6, #0
    b43c:	d1f3      	bne.n	b426 <gpio_manage_callback+0x1c>
	return 0;
    b43e:	2000      	movs	r0, #0
    b440:	e7f7      	b.n	b432 <gpio_manage_callback+0x28>
	list->tail = node;
    b442:	6065      	str	r5, [r4, #4]
    b444:	2000      	movs	r0, #0
}
    b446:	e7f4      	b.n	b432 <gpio_manage_callback+0x28>

0000b448 <gpio_fire_callbacks>:
 * @param pins The actual pin mask that triggered the interrupt
 */
static inline void gpio_fire_callbacks(sys_slist_t *list,
					const struct device *port,
					uint32_t pins)
{
    b448:	b570      	push	{r4, r5, r6, lr}
    b44a:	460e      	mov	r6, r1
    b44c:	4615      	mov	r5, r2
	return list->head;
    b44e:	6801      	ldr	r1, [r0, #0]
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    b450:	b121      	cbz	r1, b45c <gpio_fire_callbacks+0x14>
	return node->next;
    b452:	680c      	ldr	r4, [r1, #0]
    b454:	b13c      	cbz	r4, b466 <gpio_fire_callbacks+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
    b456:	b931      	cbnz	r1, b466 <gpio_fire_callbacks+0x1e>
    b458:	460c      	mov	r4, r1
    b45a:	e004      	b.n	b466 <gpio_fire_callbacks+0x1e>
    b45c:	460c      	mov	r4, r1
    b45e:	e002      	b.n	b466 <gpio_fire_callbacks+0x1e>
    b460:	4623      	mov	r3, r4
    b462:	4621      	mov	r1, r4
    b464:	461c      	mov	r4, r3
    b466:	b171      	cbz	r1, b486 <gpio_fire_callbacks+0x3e>
		if (cb->pin_mask & pins) {
    b468:	688a      	ldr	r2, [r1, #8]
    b46a:	402a      	ands	r2, r5
    b46c:	d002      	beq.n	b474 <gpio_fire_callbacks+0x2c>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
    b46e:	684b      	ldr	r3, [r1, #4]
    b470:	4630      	mov	r0, r6
    b472:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    b474:	2c00      	cmp	r4, #0
    b476:	d0f3      	beq.n	b460 <gpio_fire_callbacks+0x18>
	return node->next;
    b478:	6823      	ldr	r3, [r4, #0]
    b47a:	2b00      	cmp	r3, #0
    b47c:	d0f1      	beq.n	b462 <gpio_fire_callbacks+0x1a>
Z_GENLIST_PEEK_NEXT(slist, snode)
    b47e:	2c00      	cmp	r4, #0
    b480:	d1ef      	bne.n	b462 <gpio_fire_callbacks+0x1a>
    b482:	4623      	mov	r3, r4
    b484:	e7ed      	b.n	b462 <gpio_fire_callbacks+0x1a>
		}
	}
}
    b486:	bd70      	pop	{r4, r5, r6, pc}

0000b488 <get_drive>:
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    b488:	f020 00f9 	bic.w	r0, r0, #249	; 0xf9
    b48c:	0580      	lsls	r0, r0, #22
    b48e:	0d80      	lsrs	r0, r0, #22
    b490:	f5b0 7f83 	cmp.w	r0, #262	; 0x106
    b494:	d033      	beq.n	b4fe <get_drive+0x76>
    b496:	d816      	bhi.n	b4c6 <get_drive+0x3e>
    b498:	2806      	cmp	r0, #6
    b49a:	d02c      	beq.n	b4f6 <get_drive+0x6e>
    b49c:	d906      	bls.n	b4ac <get_drive+0x24>
    b49e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    b4a2:	d10d      	bne.n	b4c0 <get_drive+0x38>
		*drive = NRF_GPIO_PIN_H0S1;
    b4a4:	2301      	movs	r3, #1
    b4a6:	700b      	strb	r3, [r1, #0]
	return 0;
    b4a8:	2000      	movs	r0, #0
		break;
    b4aa:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    b4ac:	b300      	cbz	r0, b4f0 <get_drive+0x68>
    b4ae:	2802      	cmp	r0, #2
    b4b0:	d103      	bne.n	b4ba <get_drive+0x32>
		*drive = NRF_GPIO_PIN_D0S1;
    b4b2:	2304      	movs	r3, #4
    b4b4:	700b      	strb	r3, [r1, #0]
	return 0;
    b4b6:	2000      	movs	r0, #0
		break;
    b4b8:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    b4ba:	f06f 0015 	mvn.w	r0, #21
    b4be:	4770      	bx	lr
    b4c0:	f06f 0015 	mvn.w	r0, #21
    b4c4:	4770      	bx	lr
    b4c6:	f240 2302 	movw	r3, #514	; 0x202
    b4ca:	4298      	cmp	r0, r3
    b4cc:	d01b      	beq.n	b506 <get_drive+0x7e>
    b4ce:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
    b4d2:	d103      	bne.n	b4dc <get_drive+0x54>
		*drive = NRF_GPIO_PIN_H0H1;
    b4d4:	2303      	movs	r3, #3
    b4d6:	700b      	strb	r3, [r1, #0]
	return 0;
    b4d8:	2000      	movs	r0, #0
		break;
    b4da:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    b4dc:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    b4e0:	d103      	bne.n	b4ea <get_drive+0x62>
		*drive = NRF_GPIO_PIN_S0H1;
    b4e2:	2302      	movs	r3, #2
    b4e4:	700b      	strb	r3, [r1, #0]
	return 0;
    b4e6:	2000      	movs	r0, #0
		break;
    b4e8:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
    b4ea:	f06f 0015 	mvn.w	r0, #21
    b4ee:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0S1;
    b4f0:	2000      	movs	r0, #0
    b4f2:	7008      	strb	r0, [r1, #0]
		break;
    b4f4:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0D1;
    b4f6:	2306      	movs	r3, #6
    b4f8:	700b      	strb	r3, [r1, #0]
	return 0;
    b4fa:	2000      	movs	r0, #0
		break;
    b4fc:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_H0D1;
    b4fe:	2307      	movs	r3, #7
    b500:	700b      	strb	r3, [r1, #0]
	return 0;
    b502:	2000      	movs	r0, #0
		break;
    b504:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_D0H1;
    b506:	2305      	movs	r3, #5
    b508:	700b      	strb	r3, [r1, #0]
	return 0;
    b50a:	2000      	movs	r0, #0
}
    b50c:	4770      	bx	lr

0000b50e <get_pull>:
	if (flags & GPIO_PULL_UP) {
    b50e:	f010 0f10 	tst.w	r0, #16
    b512:	d104      	bne.n	b51e <get_pull+0x10>
	} else if (flags & GPIO_PULL_DOWN) {
    b514:	f010 0f20 	tst.w	r0, #32
    b518:	d103      	bne.n	b522 <get_pull+0x14>
	return NRF_GPIO_PIN_NOPULL;
    b51a:	2000      	movs	r0, #0
    b51c:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLUP;
    b51e:	2003      	movs	r0, #3
    b520:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLDOWN;
    b522:	2001      	movs	r0, #1
}
    b524:	4770      	bx	lr

0000b526 <gpio_nrfx_port_get_raw>:
	return port->config;
    b526:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    b528:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
    b52a:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
    b52c:	600b      	str	r3, [r1, #0]
}
    b52e:	2000      	movs	r0, #0
    b530:	4770      	bx	lr

0000b532 <gpio_nrfx_port_set_masked_raw>:
	return port->config;
    b532:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    b534:	685b      	ldr	r3, [r3, #4]
	const uint32_t set_mask = value & mask;
    b536:	ea02 0001 	and.w	r0, r2, r1
	const uint32_t clear_mask = (~set_mask) & mask;
    b53a:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
    b53e:	6098      	str	r0, [r3, #8]
    p_reg->OUTCLR = clr_mask;
    b540:	60d9      	str	r1, [r3, #12]
}
    b542:	2000      	movs	r0, #0
    b544:	4770      	bx	lr

0000b546 <gpio_nrfx_port_set_bits_raw>:
	return port->config;
    b546:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    b548:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
    b54a:	6099      	str	r1, [r3, #8]
}
    b54c:	2000      	movs	r0, #0
    b54e:	4770      	bx	lr

0000b550 <gpio_nrfx_port_clear_bits_raw>:
	return port->config;
    b550:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    b552:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
    b554:	60d9      	str	r1, [r3, #12]
}
    b556:	2000      	movs	r0, #0
    b558:	4770      	bx	lr

0000b55a <gpio_nrfx_port_toggle_bits>:
	return port->config;
    b55a:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    b55c:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
    b55e:	6853      	ldr	r3, [r2, #4]
	const uint32_t set_mask = value & mask;
    b560:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
    b564:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
    b566:	6090      	str	r0, [r2, #8]
    p_reg->OUTCLR = clr_mask;
    b568:	60d3      	str	r3, [r2, #12]
}
    b56a:	2000      	movs	r0, #0
    b56c:	4770      	bx	lr

0000b56e <get_trigger>:
	if (mode == GPIO_INT_MODE_LEVEL) {
    b56e:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
    b572:	d007      	beq.n	b584 <get_trigger+0x16>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    b574:	f1b1 6fc0 	cmp.w	r1, #100663296	; 0x6000000
    b578:	d00d      	beq.n	b596 <get_trigger+0x28>
    b57a:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
    b57e:	d008      	beq.n	b592 <get_trigger+0x24>
    b580:	2001      	movs	r0, #1
}
    b582:	4770      	bx	lr
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
    b584:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
    b588:	d001      	beq.n	b58e <get_trigger+0x20>
    b58a:	2005      	movs	r0, #5
    b58c:	4770      	bx	lr
    b58e:	2004      	movs	r0, #4
    b590:	4770      	bx	lr
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    b592:	2002      	movs	r0, #2
    b594:	4770      	bx	lr
    b596:	2003      	movs	r0, #3
    b598:	4770      	bx	lr

0000b59a <gpio_nrfx_manage_callback>:
{
    b59a:	b508      	push	{r3, lr}
	return port->data;
    b59c:	6900      	ldr	r0, [r0, #16]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    b59e:	3004      	adds	r0, #4
    b5a0:	f7ff ff33 	bl	b40a <gpio_manage_callback>
}
    b5a4:	bd08      	pop	{r3, pc}

0000b5a6 <nrfx_gpio_handler>:
{
    b5a6:	b510      	push	{r4, lr}
    *p_pin = pin_number & 0x1F;
    b5a8:	f000 041f 	and.w	r4, r0, #31
	const struct device *port = get_dev(port_id);
    b5ac:	0940      	lsrs	r0, r0, #5
    b5ae:	f7f8 f897 	bl	36e0 <get_dev>
	if (port == NULL) {
    b5b2:	b130      	cbz	r0, b5c2 <nrfx_gpio_handler+0x1c>
    b5b4:	4601      	mov	r1, r0
	return port->data;
    b5b6:	6900      	ldr	r0, [r0, #16]
	gpio_fire_callbacks(list, port, BIT(pin));
    b5b8:	2201      	movs	r2, #1
    b5ba:	40a2      	lsls	r2, r4
    b5bc:	3004      	adds	r0, #4
    b5be:	f7ff ff43 	bl	b448 <gpio_fire_callbacks>
}
    b5c2:	bd10      	pop	{r4, pc}

0000b5c4 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
    b5c4:	b500      	push	{lr}
	*state = &config->states[0];
    b5c6:	6843      	ldr	r3, [r0, #4]
    b5c8:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
    b5ca:	e001      	b.n	b5d0 <pinctrl_lookup_state+0xc>
		if (id == (*state)->id) {
			return 0;
		}

		(*state)++;
    b5cc:	3308      	adds	r3, #8
    b5ce:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
    b5d0:	6813      	ldr	r3, [r2, #0]
    b5d2:	f890 c008 	ldrb.w	ip, [r0, #8]
    b5d6:	f8d0 e004 	ldr.w	lr, [r0, #4]
    b5da:	eb0e 0ccc 	add.w	ip, lr, ip, lsl #3
    b5de:	4563      	cmp	r3, ip
    b5e0:	d205      	bcs.n	b5ee <pinctrl_lookup_state+0x2a>
		if (id == (*state)->id) {
    b5e2:	f893 c005 	ldrb.w	ip, [r3, #5]
    b5e6:	458c      	cmp	ip, r1
    b5e8:	d1f0      	bne.n	b5cc <pinctrl_lookup_state+0x8>
			return 0;
    b5ea:	2000      	movs	r0, #0
    b5ec:	e001      	b.n	b5f2 <pinctrl_lookup_state+0x2e>
	}

	return -ENOENT;
    b5ee:	f06f 0001 	mvn.w	r0, #1
}
    b5f2:	f85d fb04 	ldr.w	pc, [sp], #4

0000b5f6 <z_impl_gpio_pin_configure>:
				 gpio_flags_t flags);

static inline int z_impl_gpio_pin_configure(const struct device *port,
					    gpio_pin_t pin,
					    gpio_flags_t flags)
{
    b5f6:	b538      	push	{r3, r4, r5, lr}
    b5f8:	4613      	mov	r3, r2
	const struct gpio_driver_api *api =
    b5fa:	6885      	ldr	r5, [r0, #8]
		(const struct gpio_driver_api *)port->api;
	__unused const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
    b5fc:	6904      	ldr	r4, [r0, #16]

	__ASSERT((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH))
		 != (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH),
		 "Output cannot be initialized low and high");

	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
    b5fe:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
    b602:	d007      	beq.n	b614 <z_impl_gpio_pin_configure+0x1e>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
    b604:	f412 2f40 	tst.w	r2, #786432	; 0xc0000
    b608:	d004      	beq.n	b614 <z_impl_gpio_pin_configure+0x1e>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    b60a:	f012 0f01 	tst.w	r2, #1
    b60e:	d001      	beq.n	b614 <z_impl_gpio_pin_configure+0x1e>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
    b610:	f482 2340 	eor.w	r3, r2, #786432	; 0xc0000
	}

	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
    b614:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    b618:	f013 0f01 	tst.w	r3, #1
    b61c:	d00a      	beq.n	b634 <z_impl_gpio_pin_configure+0x3e>
		data->invert |= (gpio_port_pins_t)BIT(pin);
    b61e:	6823      	ldr	r3, [r4, #0]
    b620:	f04f 0c01 	mov.w	ip, #1
    b624:	fa0c fc01 	lsl.w	ip, ip, r1
    b628:	ea43 030c 	orr.w	r3, r3, ip
    b62c:	6023      	str	r3, [r4, #0]
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
	}

	return api->pin_configure(port, pin, flags);
    b62e:	682b      	ldr	r3, [r5, #0]
    b630:	4798      	blx	r3
}
    b632:	bd38      	pop	{r3, r4, r5, pc}
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    b634:	6823      	ldr	r3, [r4, #0]
    b636:	f04f 0c01 	mov.w	ip, #1
    b63a:	fa0c fc01 	lsl.w	ip, ip, r1
    b63e:	ea23 030c 	bic.w	r3, r3, ip
    b642:	6023      	str	r3, [r4, #0]
    b644:	e7f3      	b.n	b62e <z_impl_gpio_pin_configure+0x38>

0000b646 <gpio_pin_configure_dt>:
 * @param extra_flags additional flags
 * @return a value from gpio_pin_configure()
 */
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
{
    b646:	b508      	push	{r3, lr}
    b648:	4603      	mov	r3, r0
    b64a:	468c      	mov	ip, r1
	return gpio_pin_configure(spec->port,
    b64c:	6800      	ldr	r0, [r0, #0]
				  spec->pin,
    b64e:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
    b650:	88da      	ldrh	r2, [r3, #6]
	return gpio_pin_configure(spec->port,
    b652:	ea42 020c 	orr.w	r2, r2, ip
		union { uintptr_t x; gpio_flags_t val; } parm2 = { .val = flags };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_GPIO_PIN_CONFIGURE);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_pin_configure(port, pin, flags);
    b656:	f7ff ffce 	bl	b5f6 <z_impl_gpio_pin_configure>
}
    b65a:	bd08      	pop	{r3, pc}

0000b65c <gpio_pin_set_raw>:
 * @retval -EIO I/O error when accessing an external GPIO chip.
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_pin_set_raw(const struct device *port, gpio_pin_t pin,
				   int value)
{
    b65c:	b508      	push	{r3, lr}
	int ret;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (value != 0)	{
    b65e:	b132      	cbz	r2, b66e <gpio_pin_set_raw+0x12>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    b660:	2301      	movs	r3, #1
    b662:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    b666:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    b668:	68db      	ldr	r3, [r3, #12]
    b66a:	4798      	blx	r3
	} else {
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
	}

	return ret;
}
    b66c:	bd08      	pop	{r3, pc}
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    b66e:	2301      	movs	r3, #1
    b670:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    b674:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    b676:	691b      	ldr	r3, [r3, #16]
    b678:	4798      	blx	r3
	return ret;
    b67a:	e7f7      	b.n	b66c <gpio_pin_set_raw+0x10>

0000b67c <gpio_pin_set>:
 * @retval -EIO I/O error when accessing an external GPIO chip.
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_pin_set(const struct device *port, gpio_pin_t pin,
			       int value)
{
    b67c:	b510      	push	{r4, lr}
	__unused const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	const struct gpio_driver_data *const data =
    b67e:	6903      	ldr	r3, [r0, #16]
			(const struct gpio_driver_data *)port->data;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    b680:	681c      	ldr	r4, [r3, #0]
    b682:	2301      	movs	r3, #1
    b684:	408b      	lsls	r3, r1
    b686:	421c      	tst	r4, r3
    b688:	d002      	beq.n	b690 <gpio_pin_set+0x14>
		value = (value != 0) ? 0 : 1;
    b68a:	fab2 f282 	clz	r2, r2
    b68e:	0952      	lsrs	r2, r2, #5
	}

	return gpio_pin_set_raw(port, pin, value);
    b690:	f7ff ffe4 	bl	b65c <gpio_pin_set_raw>
}
    b694:	bd10      	pop	{r4, pc}

0000b696 <spi_context_get_next_buf>:
{
    b696:	b430      	push	{r4, r5}
	while (*count) {
    b698:	e004      	b.n	b6a4 <spi_context_get_next_buf+0xe>
		++(*current);
    b69a:	3408      	adds	r4, #8
    b69c:	6004      	str	r4, [r0, #0]
		--(*count);
    b69e:	680c      	ldr	r4, [r1, #0]
    b6a0:	3c01      	subs	r4, #1
    b6a2:	600c      	str	r4, [r1, #0]
	while (*count) {
    b6a4:	680c      	ldr	r4, [r1, #0]
    b6a6:	b14c      	cbz	r4, b6bc <spi_context_get_next_buf+0x26>
		if (((*current)->len / dfs) != 0) {
    b6a8:	6804      	ldr	r4, [r0, #0]
    b6aa:	6865      	ldr	r5, [r4, #4]
    b6ac:	429d      	cmp	r5, r3
    b6ae:	d3f4      	bcc.n	b69a <spi_context_get_next_buf+0x4>
			*buf_len = (*current)->len / dfs;
    b6b0:	fbb5 f5f3 	udiv	r5, r5, r3
    b6b4:	6015      	str	r5, [r2, #0]
			return (*current)->buf;
    b6b6:	6803      	ldr	r3, [r0, #0]
    b6b8:	6818      	ldr	r0, [r3, #0]
    b6ba:	e001      	b.n	b6c0 <spi_context_get_next_buf+0x2a>
	*buf_len = 0;
    b6bc:	2000      	movs	r0, #0
    b6be:	6010      	str	r0, [r2, #0]
}
    b6c0:	bc30      	pop	{r4, r5}
    b6c2:	4770      	bx	lr

0000b6c4 <spi_context_buffers_setup>:
{
    b6c4:	b570      	push	{r4, r5, r6, lr}
    b6c6:	4604      	mov	r4, r0
    b6c8:	4615      	mov	r5, r2
    b6ca:	461e      	mov	r6, r3
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
    b6cc:	460a      	mov	r2, r1
    b6ce:	b309      	cbz	r1, b714 <spi_context_buffers_setup+0x50>
    b6d0:	680b      	ldr	r3, [r1, #0]
    b6d2:	6363      	str	r3, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
    b6d4:	b303      	cbz	r3, b718 <spi_context_buffers_setup+0x54>
    b6d6:	6853      	ldr	r3, [r2, #4]
    b6d8:	63a3      	str	r3, [r4, #56]	; 0x38
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
    b6da:	4633      	mov	r3, r6
    b6dc:	f104 0248 	add.w	r2, r4, #72	; 0x48
    b6e0:	f104 0138 	add.w	r1, r4, #56	; 0x38
    b6e4:	f104 0034 	add.w	r0, r4, #52	; 0x34
    b6e8:	f7ff ffd5 	bl	b696 <spi_context_get_next_buf>
	ctx->tx_buf = (const uint8_t *)
    b6ec:	6460      	str	r0, [r4, #68]	; 0x44
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
    b6ee:	b1ad      	cbz	r5, b71c <spi_context_buffers_setup+0x58>
    b6f0:	682b      	ldr	r3, [r5, #0]
    b6f2:	63e3      	str	r3, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
    b6f4:	b1a3      	cbz	r3, b720 <spi_context_buffers_setup+0x5c>
    b6f6:	686b      	ldr	r3, [r5, #4]
    b6f8:	6423      	str	r3, [r4, #64]	; 0x40
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
    b6fa:	4633      	mov	r3, r6
    b6fc:	f104 0250 	add.w	r2, r4, #80	; 0x50
    b700:	f104 0140 	add.w	r1, r4, #64	; 0x40
    b704:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    b708:	f7ff ffc5 	bl	b696 <spi_context_get_next_buf>
	ctx->rx_buf = (uint8_t *)
    b70c:	64e0      	str	r0, [r4, #76]	; 0x4c
	ctx->sync_status = 0;
    b70e:	2300      	movs	r3, #0
    b710:	6323      	str	r3, [r4, #48]	; 0x30
}
    b712:	bd70      	pop	{r4, r5, r6, pc}
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
    b714:	460b      	mov	r3, r1
    b716:	e7dc      	b.n	b6d2 <spi_context_buffers_setup+0xe>
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
    b718:	2300      	movs	r3, #0
    b71a:	e7dd      	b.n	b6d8 <spi_context_buffers_setup+0x14>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
    b71c:	462b      	mov	r3, r5
    b71e:	e7e8      	b.n	b6f2 <spi_context_buffers_setup+0x2e>
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
    b720:	2300      	movs	r3, #0
    b722:	e7e9      	b.n	b6f8 <spi_context_buffers_setup+0x34>

0000b724 <_spi_context_cs_control>:
{
    b724:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
    b726:	6803      	ldr	r3, [r0, #0]
    b728:	b1a3      	cbz	r3, b754 <_spi_context_cs_control+0x30>
    b72a:	4604      	mov	r4, r0
    b72c:	689d      	ldr	r5, [r3, #8]
    b72e:	b18d      	cbz	r5, b754 <_spi_context_cs_control+0x30>
    b730:	6828      	ldr	r0, [r5, #0]
    b732:	b178      	cbz	r0, b754 <_spi_context_cs_control+0x30>
		if (on) {
    b734:	b979      	cbnz	r1, b756 <_spi_context_cs_control+0x32>
			if (!force_off &&
    b736:	b91a      	cbnz	r2, b740 <_spi_context_cs_control+0x1c>
			    ctx->config->operation & SPI_HOLD_ON_CS) {
    b738:	889b      	ldrh	r3, [r3, #4]
			if (!force_off &&
    b73a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    b73e:	d109      	bne.n	b754 <_spi_context_cs_control+0x30>
			k_busy_wait(ctx->config->cs->delay);
    b740:	68a8      	ldr	r0, [r5, #8]
	z_impl_k_busy_wait(usec_to_wait);
    b742:	f002 fa77 	bl	dc34 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
    b746:	6823      	ldr	r3, [r4, #0]
    b748:	689b      	ldr	r3, [r3, #8]
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
{
	return gpio_pin_set(spec->port, spec->pin, value);
    b74a:	2200      	movs	r2, #0
    b74c:	7919      	ldrb	r1, [r3, #4]
    b74e:	6818      	ldr	r0, [r3, #0]
    b750:	f7ff ff94 	bl	b67c <gpio_pin_set>
}
    b754:	bd38      	pop	{r3, r4, r5, pc}
    b756:	2201      	movs	r2, #1
    b758:	7929      	ldrb	r1, [r5, #4]
    b75a:	f7ff ff8f 	bl	b67c <gpio_pin_set>
			k_busy_wait(ctx->config->cs->delay);
    b75e:	6823      	ldr	r3, [r4, #0]
    b760:	689b      	ldr	r3, [r3, #8]
    b762:	6898      	ldr	r0, [r3, #8]
    b764:	f002 fa66 	bl	dc34 <z_impl_k_busy_wait>
}
    b768:	e7f4      	b.n	b754 <_spi_context_cs_control+0x30>

0000b76a <spi_context_unlock_unconditionally>:
{
    b76a:	b510      	push	{r4, lr}
    b76c:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
    b76e:	2201      	movs	r2, #1
    b770:	2100      	movs	r1, #0
    b772:	f7ff ffd7 	bl	b724 <_spi_context_cs_control>
	return sem->count;
    b776:	69a3      	ldr	r3, [r4, #24]
	if (!k_sem_count_get(&ctx->lock)) {
    b778:	b103      	cbz	r3, b77c <spi_context_unlock_unconditionally+0x12>
}
    b77a:	bd10      	pop	{r4, pc}
		ctx->owner = NULL;
    b77c:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
    b77e:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
    b782:	f7fc ff1f 	bl	85c4 <z_impl_k_sem_give>
}
    b786:	e7f8      	b.n	b77a <spi_context_unlock_unconditionally+0x10>

0000b788 <spi_nrfx_release>:
}
#endif /* CONFIG_SPI_ASYNC */

static int spi_nrfx_release(const struct device *dev,
			    const struct spi_config *spi_cfg)
{
    b788:	b508      	push	{r3, lr}
	struct spi_nrfx_data *dev_data = dev->data;
    b78a:	6900      	ldr	r0, [r0, #16]
	return !!(ctx->config == config);
    b78c:	6803      	ldr	r3, [r0, #0]

	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
    b78e:	428b      	cmp	r3, r1
    b790:	d106      	bne.n	b7a0 <spi_nrfx_release+0x18>
		return -EINVAL;
	}

	if (dev_data->busy) {
    b792:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
    b796:	b933      	cbnz	r3, b7a6 <spi_nrfx_release+0x1e>
		return -EBUSY;
	}

	spi_context_unlock_unconditionally(&dev_data->ctx);
    b798:	f7ff ffe7 	bl	b76a <spi_context_unlock_unconditionally>

	return 0;
    b79c:	2000      	movs	r0, #0
}
    b79e:	bd08      	pop	{r3, pc}
		return -EINVAL;
    b7a0:	f06f 0015 	mvn.w	r0, #21
    b7a4:	e7fb      	b.n	b79e <spi_nrfx_release+0x16>
		return -EBUSY;
    b7a6:	f06f 000f 	mvn.w	r0, #15
    b7aa:	e7f8      	b.n	b79e <spi_nrfx_release+0x16>

0000b7ac <finish_transaction>:
{
    b7ac:	b538      	push	{r3, r4, r5, lr}
    b7ae:	460d      	mov	r5, r1
	struct spi_nrfx_data *dev_data = dev->data;
    b7b0:	6904      	ldr	r4, [r0, #16]
	_spi_context_cs_control(ctx, on, false);
    b7b2:	2200      	movs	r2, #0
    b7b4:	4611      	mov	r1, r2
    b7b6:	4620      	mov	r0, r4
    b7b8:	f7ff ffb4 	bl	b724 <_spi_context_cs_control>
	ctx->sync_status = status;
    b7bc:	6325      	str	r5, [r4, #48]	; 0x30
	k_sem_give(&ctx->sync);
    b7be:	f104 0020 	add.w	r0, r4, #32
    b7c2:	f7fc feff 	bl	85c4 <z_impl_k_sem_give>
	dev_data->busy = false;
    b7c6:	2300      	movs	r3, #0
    b7c8:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
    b7cc:	bd38      	pop	{r3, r4, r5, pc}

0000b7ce <spi_context_release>:
{
    b7ce:	b508      	push	{r3, lr}
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
    b7d0:	6803      	ldr	r3, [r0, #0]
    b7d2:	889b      	ldrh	r3, [r3, #4]
    b7d4:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    b7d8:	d000      	beq.n	b7dc <spi_context_release+0xe>
}
    b7da:	bd08      	pop	{r3, pc}
		ctx->owner = NULL;
    b7dc:	2300      	movs	r3, #0
    b7de:	6043      	str	r3, [r0, #4]
		k_sem_give(&ctx->lock);
    b7e0:	3010      	adds	r0, #16
    b7e2:	f7fc feef 	bl	85c4 <z_impl_k_sem_give>
}
    b7e6:	e7f8      	b.n	b7da <spi_context_release+0xc>

0000b7e8 <spi_context_lock>:
{
    b7e8:	b538      	push	{r3, r4, r5, lr}
    b7ea:	4604      	mov	r4, r0
    b7ec:	9d04      	ldr	r5, [sp, #16]
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
    b7ee:	88ab      	ldrh	r3, [r5, #4]
    b7f0:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    b7f4:	d004      	beq.n	b800 <spi_context_lock+0x18>
    b7f6:	6983      	ldr	r3, [r0, #24]
    b7f8:	b913      	cbnz	r3, b800 <spi_context_lock+0x18>
		(ctx->owner == spi_cfg)) {
    b7fa:	6843      	ldr	r3, [r0, #4]
		(k_sem_count_get(&ctx->lock) == 0) &&
    b7fc:	42ab      	cmp	r3, r5
    b7fe:	d008      	beq.n	b812 <spi_context_lock+0x2a>
	k_sem_take(&ctx->lock, K_FOREVER);
    b800:	f104 0010 	add.w	r0, r4, #16
	return z_impl_k_sem_take(sem, timeout);
    b804:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    b808:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    b80c:	f7fc fefc 	bl	8608 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
    b810:	6065      	str	r5, [r4, #4]
}
    b812:	bd38      	pop	{r3, r4, r5, pc}

0000b814 <transceive>:
{
    b814:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b818:	b083      	sub	sp, #12
    b81a:	4604      	mov	r4, r0
    b81c:	460d      	mov	r5, r1
    b81e:	4690      	mov	r8, r2
    b820:	461f      	mov	r7, r3
	struct spi_nrfx_data *dev_data = dev->data;
    b822:	6906      	ldr	r6, [r0, #16]
	const struct spi_nrfx_config *dev_config = dev->config;
    b824:	f8d0 9004 	ldr.w	r9, [r0, #4]
	spi_context_lock(&dev_data->ctx, asynchronous, cb, userdata, spi_cfg);
    b828:	9100      	str	r1, [sp, #0]
    b82a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b82c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    b82e:	f89d 1028 	ldrb.w	r1, [sp, #40]	; 0x28
    b832:	4630      	mov	r0, r6
    b834:	f7ff ffd8 	bl	b7e8 <spi_context_lock>
	error = configure(dev, spi_cfg);
    b838:	4629      	mov	r1, r5
    b83a:	4620      	mov	r0, r4
    b83c:	f7f8 f9b2 	bl	3ba4 <configure>
	if (error == 0) {
    b840:	4605      	mov	r5, r0
    b842:	b138      	cbz	r0, b854 <transceive+0x40>
	spi_context_release(&dev_data->ctx, error);
    b844:	4629      	mov	r1, r5
    b846:	4630      	mov	r0, r6
    b848:	f7ff ffc1 	bl	b7ce <spi_context_release>
}
    b84c:	4628      	mov	r0, r5
    b84e:	b003      	add	sp, #12
    b850:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		dev_data->busy = true;
    b854:	2501      	movs	r5, #1
    b856:	f886 505c 	strb.w	r5, [r6, #92]	; 0x5c
		spi_context_buffers_setup(&dev_data->ctx, tx_bufs, rx_bufs, 1);
    b85a:	462b      	mov	r3, r5
    b85c:	463a      	mov	r2, r7
    b85e:	4641      	mov	r1, r8
    b860:	4630      	mov	r0, r6
    b862:	f7ff ff2f 	bl	b6c4 <spi_context_buffers_setup>
	_spi_context_cs_control(ctx, on, false);
    b866:	2200      	movs	r2, #0
    b868:	4629      	mov	r1, r5
    b86a:	4630      	mov	r0, r6
    b86c:	f7ff ff5a 	bl	b724 <_spi_context_cs_control>
		transfer_next_chunk(dev);
    b870:	4620      	mov	r0, r4
    b872:	f7f8 fa4f 	bl	3d14 <transfer_next_chunk>
		error = spi_context_wait_for_completion(&dev_data->ctx);
    b876:	4630      	mov	r0, r6
    b878:	f7f8 f94e 	bl	3b18 <spi_context_wait_for_completion>
    b87c:	4605      	mov	r5, r0
		if (error == -ETIMEDOUT) {
    b87e:	f110 0f74 	cmn.w	r0, #116	; 0x74
    b882:	d1df      	bne.n	b844 <transceive+0x30>
			dev_data->chunk_len = 0;
    b884:	2700      	movs	r7, #0
    b886:	65b7      	str	r7, [r6, #88]	; 0x58
			nrfx_spim_uninit(&dev_config->spim);
    b888:	4648      	mov	r0, r9
    b88a:	f7f9 fdc1 	bl	5410 <nrfx_spim_uninit>
			dev_data->initialized = false;
    b88e:	f886 705d 	strb.w	r7, [r6, #93]	; 0x5d
			finish_transaction(dev, -ETIMEDOUT);
    b892:	f06f 0173 	mvn.w	r1, #115	; 0x73
    b896:	4620      	mov	r0, r4
    b898:	f7ff ff88 	bl	b7ac <finish_transaction>
			k_sem_reset(&dev_data->ctx.sync);
    b89c:	f106 0020 	add.w	r0, r6, #32
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_RESET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_reset(sem);
    b8a0:	f7fc feda 	bl	8658 <z_impl_k_sem_reset>
}
    b8a4:	e7ce      	b.n	b844 <transceive+0x30>

0000b8a6 <spi_nrfx_transceive>:
{
    b8a6:	b510      	push	{r4, lr}
    b8a8:	b084      	sub	sp, #16
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL, NULL);
    b8aa:	2400      	movs	r4, #0
    b8ac:	9402      	str	r4, [sp, #8]
    b8ae:	9401      	str	r4, [sp, #4]
    b8b0:	9400      	str	r4, [sp, #0]
    b8b2:	f7ff ffaf 	bl	b814 <transceive>
}
    b8b6:	b004      	add	sp, #16
    b8b8:	bd10      	pop	{r4, pc}

0000b8ba <irq_connect4>:
#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(3);
#endif

#ifdef CONFIG_SPI_4_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(4);
    b8ba:	b508      	push	{r3, lr}
    b8bc:	2200      	movs	r2, #0
    b8be:	2101      	movs	r1, #1
    b8c0:	200a      	movs	r0, #10
    b8c2:	f7fe fde1 	bl	a488 <z_arm_irq_priority_set>
    b8c6:	bd08      	pop	{r3, pc}

0000b8c8 <pinctrl_apply_state>:
 * @retval -ENOENT If given state id does not exist.
 * @retval -errno Negative errno for other failures.
 */
static inline int pinctrl_apply_state(const struct pinctrl_dev_config *config,
				      uint8_t id)
{
    b8c8:	b510      	push	{r4, lr}
    b8ca:	b082      	sub	sp, #8
    b8cc:	4604      	mov	r4, r0
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
    b8ce:	aa01      	add	r2, sp, #4
    b8d0:	f7ff fe78 	bl	b5c4 <pinctrl_lookup_state>
	if (ret < 0) {
    b8d4:	2800      	cmp	r0, #0
    b8d6:	db05      	blt.n	b8e4 <pinctrl_apply_state+0x1c>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
    b8d8:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
    b8da:	6822      	ldr	r2, [r4, #0]
    b8dc:	7919      	ldrb	r1, [r3, #4]
    b8de:	6818      	ldr	r0, [r3, #0]
    b8e0:	f7f8 f858 	bl	3994 <pinctrl_configure_pins>
}
    b8e4:	b002      	add	sp, #8
    b8e6:	bd10      	pop	{r4, pc}

0000b8e8 <spi_nrfx_init>:
{
    b8e8:	b538      	push	{r3, r4, r5, lr}
	const struct spi_nrfx_config *dev_config = dev->config;
    b8ea:	6844      	ldr	r4, [r0, #4]
	struct spi_nrfx_data *dev_data = dev->data;
    b8ec:	6905      	ldr	r5, [r0, #16]
	err = pinctrl_apply_state(dev_config->pcfg, PINCTRL_STATE_DEFAULT);
    b8ee:	2100      	movs	r1, #0
    b8f0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    b8f2:	f7ff ffe9 	bl	b8c8 <pinctrl_apply_state>
	if (err < 0) {
    b8f6:	2800      	cmp	r0, #0
    b8f8:	db0a      	blt.n	b910 <spi_nrfx_init+0x28>
	dev_config->irq_connect();
    b8fa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    b8fc:	4798      	blx	r3
	err = spi_context_cs_configure_all(&dev_data->ctx);
    b8fe:	4628      	mov	r0, r5
    b900:	f7f8 faae 	bl	3e60 <spi_context_cs_configure_all>
	if (err < 0) {
    b904:	2800      	cmp	r0, #0
    b906:	db03      	blt.n	b910 <spi_nrfx_init+0x28>
	spi_context_unlock_unconditionally(&dev_data->ctx);
    b908:	4628      	mov	r0, r5
    b90a:	f7ff ff2e 	bl	b76a <spi_context_unlock_unconditionally>
	return 0;
    b90e:	2000      	movs	r0, #0
}
    b910:	bd38      	pop	{r3, r4, r5, pc}

0000b912 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
    b912:	4770      	bx	lr

0000b914 <counter_sub>:
	return (a - b) & COUNTER_MAX;
    b914:	1a40      	subs	r0, r0, r1
}
    b916:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    b91a:	4770      	bx	lr

0000b91c <event_check>:
	return nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    b91c:	f100 0350 	add.w	r3, r0, #80	; 0x50
    b920:	009b      	lsls	r3, r3, #2
    b922:	b29b      	uxth	r3, r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    b924:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    b928:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    b92c:	6818      	ldr	r0, [r3, #0]
}
    b92e:	3800      	subs	r0, #0
    b930:	bf18      	it	ne
    b932:	2001      	movne	r0, #1
    b934:	4770      	bx	lr

0000b936 <event_clear>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    b936:	f100 0350 	add.w	r3, r0, #80	; 0x50
    b93a:	009b      	lsls	r3, r3, #2
    b93c:	b29b      	uxth	r3, r3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    b93e:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    b942:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    b946:	2200      	movs	r2, #0
    b948:	601a      	str	r2, [r3, #0]
    b94a:	681b      	ldr	r3, [r3, #0]
}
    b94c:	4770      	bx	lr

0000b94e <absolute_time_to_cc>:
}
    b94e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    b952:	4770      	bx	lr

0000b954 <full_int_lock>:
	__asm__ volatile(
    b954:	f04f 0320 	mov.w	r3, #32
    b958:	f3ef 8011 	mrs	r0, BASEPRI
    b95c:	f383 8812 	msr	BASEPRI_MAX, r3
    b960:	f3bf 8f6f 	isb	sy
}
    b964:	4770      	bx	lr

0000b966 <full_int_unlock>:
	__asm__ volatile(
    b966:	f380 8811 	msr	BASEPRI, r0
    b96a:	f3bf 8f6f 	isb	sy
}
    b96e:	4770      	bx	lr

0000b970 <compare_set>:
{
    b970:	b5f0      	push	{r4, r5, r6, r7, lr}
    b972:	b083      	sub	sp, #12
    b974:	4604      	mov	r4, r0
    b976:	4617      	mov	r7, r2
    b978:	461d      	mov	r5, r3
	key = compare_int_lock(chan);
    b97a:	f7f8 fafd 	bl	3f78 <compare_int_lock>
    b97e:	4606      	mov	r6, r0
	int ret = compare_set_nolocks(chan, target_time, handler, user_data);
    b980:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b982:	9301      	str	r3, [sp, #4]
    b984:	9b08      	ldr	r3, [sp, #32]
    b986:	9300      	str	r3, [sp, #0]
    b988:	463a      	mov	r2, r7
    b98a:	462b      	mov	r3, r5
    b98c:	4620      	mov	r0, r4
    b98e:	f7f8 fbb1 	bl	40f4 <compare_set_nolocks>
    b992:	4605      	mov	r5, r0
	compare_int_unlock(chan, key);
    b994:	4631      	mov	r1, r6
    b996:	4620      	mov	r0, r4
    b998:	f7f8 fb3c 	bl	4014 <compare_int_unlock>
}
    b99c:	4628      	mov	r0, r5
    b99e:	b003      	add	sp, #12
    b9a0:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000b9a2 <hw_cc3xx_init_internal>:
#include <nrf_cc3xx_platform.h>

#if CONFIG_HW_CC3XX

static int hw_cc3xx_init_internal(void)
{
    b9a2:	b508      	push	{r3, lr}

	/* Initialize the cc3xx HW with or without RNG support */
#if CONFIG_ENTROPY_CC3XX
	res = nrf_cc3xx_platform_init();
#else
	res = nrf_cc3xx_platform_init_no_rng();
    b9a4:	f7fd fb80 	bl	90a8 <nrf_cc3xx_platform_init_no_rng>
#endif

	return res;
}
    b9a8:	bd08      	pop	{r3, pc}

0000b9aa <hw_cc3xx_init>:

static int hw_cc3xx_init(void)
{
    b9aa:	b508      	push	{r3, lr}
	int res;

	/* Set the RTOS abort APIs */
	nrf_cc3xx_platform_abort_init();
    b9ac:	f7f5 fd62 	bl	1474 <nrf_cc3xx_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc3xx_platform_mutex_init();
    b9b0:	f7f5 fe72 	bl	1698 <nrf_cc3xx_platform_mutex_init>

	/* Enable the hardware */
	res = hw_cc3xx_init_internal();
    b9b4:	f7ff fff5 	bl	b9a2 <hw_cc3xx_init_internal>
	return res;
}
    b9b8:	bd08      	pop	{r3, pc}

0000b9ba <nrf53_errata_42>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    b9ba:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    b9be:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    b9c2:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    b9c6:	2a07      	cmp	r2, #7
    b9c8:	d001      	beq.n	b9ce <nrf53_errata_42+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    b9ca:	2000      	movs	r0, #0
    b9cc:	4770      	bx	lr
                    switch(var2)
    b9ce:	3b02      	subs	r3, #2
    b9d0:	2b00      	cmp	r3, #0
    b9d2:	d804      	bhi.n	b9de <nrf53_errata_42+0x24>
    b9d4:	e8df f003 	tbb	[pc, r3]
    b9d8:	01          	.byte	0x01
    b9d9:	00          	.byte	0x00
    b9da:	2001      	movs	r0, #1
    b9dc:	4770      	bx	lr
                            return false;
    b9de:	2000      	movs	r0, #0
    #endif
}
    b9e0:	4770      	bx	lr

0000b9e2 <nrf53_errata_46>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    b9e2:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    b9e6:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    b9ea:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    b9ee:	2a07      	cmp	r2, #7
    b9f0:	d001      	beq.n	b9f6 <nrf53_errata_46+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    b9f2:	2000      	movs	r0, #0
    b9f4:	4770      	bx	lr
                    switch(var2)
    b9f6:	2b04      	cmp	r3, #4
    b9f8:	d007      	beq.n	ba0a <nrf53_errata_46+0x28>
    b9fa:	d808      	bhi.n	ba0e <nrf53_errata_46+0x2c>
    b9fc:	3b02      	subs	r3, #2
    b9fe:	2b01      	cmp	r3, #1
    ba00:	d801      	bhi.n	ba06 <nrf53_errata_46+0x24>
    ba02:	2001      	movs	r0, #1
    #endif
}
    ba04:	4770      	bx	lr
                            return false;
    ba06:	2000      	movs	r0, #0
    ba08:	4770      	bx	lr
                            return false;
    ba0a:	2000      	movs	r0, #0
    ba0c:	4770      	bx	lr
                            return false;
    ba0e:	2000      	movs	r0, #0
    ba10:	4770      	bx	lr

0000ba12 <nrf53_errata_49>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    ba12:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    ba16:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    ba1a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
    ba1e:	2a07      	cmp	r2, #7
    ba20:	d001      	beq.n	ba26 <nrf53_errata_49+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    ba22:	2000      	movs	r0, #0
    ba24:	4770      	bx	lr
                    switch(var2)
    ba26:	3b02      	subs	r3, #2
    ba28:	2b00      	cmp	r3, #0
    ba2a:	d804      	bhi.n	ba36 <nrf53_errata_49+0x24>
    ba2c:	e8df f003 	tbb	[pc, r3]
    ba30:	01          	.byte	0x01
    ba31:	00          	.byte	0x00
    ba32:	2001      	movs	r0, #1
    ba34:	4770      	bx	lr
                            return false;
    ba36:	2000      	movs	r0, #0
    #endif
}
    ba38:	4770      	bx	lr

0000ba3a <nrf53_errata_55>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    ba3a:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    ba3e:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    ba42:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
    ba46:	2a07      	cmp	r2, #7
    ba48:	d001      	beq.n	ba4e <nrf53_errata_55+0x14>
                            return true;
                    }
                }
            #endif
        #endif
        return false;
    ba4a:	2000      	movs	r0, #0
    ba4c:	4770      	bx	lr
                            return true;
    ba4e:	2001      	movs	r0, #1
    #endif
}
    ba50:	4770      	bx	lr

0000ba52 <nrf53_errata_64>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    ba52:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    ba56:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    ba5a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    ba5e:	2a07      	cmp	r2, #7
    ba60:	d001      	beq.n	ba66 <nrf53_errata_64+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    ba62:	2000      	movs	r0, #0
    ba64:	4770      	bx	lr
                    switch(var2)
    ba66:	3b02      	subs	r3, #2
    ba68:	2b00      	cmp	r3, #0
    ba6a:	d804      	bhi.n	ba76 <nrf53_errata_64+0x24>
    ba6c:	e8df f003 	tbb	[pc, r3]
    ba70:	01          	.byte	0x01
    ba71:	00          	.byte	0x00
    ba72:	2001      	movs	r0, #1
    ba74:	4770      	bx	lr
                            return false;
    ba76:	2000      	movs	r0, #0
    #endif
}
    ba78:	4770      	bx	lr

0000ba7a <nrf53_errata_69>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    ba7a:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    ba7e:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    ba82:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    ba86:	2a07      	cmp	r2, #7
    ba88:	d001      	beq.n	ba8e <nrf53_errata_69+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    ba8a:	2000      	movs	r0, #0
    ba8c:	4770      	bx	lr
                    switch(var2)
    ba8e:	3b02      	subs	r3, #2
    ba90:	2b00      	cmp	r3, #0
    ba92:	d804      	bhi.n	ba9e <nrf53_errata_69+0x24>
    ba94:	e8df f003 	tbb	[pc, r3]
    ba98:	01          	.byte	0x01
    ba99:	00          	.byte	0x00
    ba9a:	2001      	movs	r0, #1
    ba9c:	4770      	bx	lr
                            return false;
    ba9e:	2000      	movs	r0, #0
    #endif
}
    baa0:	4770      	bx	lr

0000baa2 <nrf53_errata_97>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    baa2:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    baa6:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    baaa:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
    baae:	2a07      	cmp	r2, #7
    bab0:	d001      	beq.n	bab6 <nrf53_errata_97+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    bab2:	2000      	movs	r0, #0
    bab4:	4770      	bx	lr
                    switch(var2)
    bab6:	3b02      	subs	r3, #2
    bab8:	2b00      	cmp	r3, #0
    baba:	d804      	bhi.n	bac6 <nrf53_errata_97+0x24>
    babc:	e8df f003 	tbb	[pc, r3]
    bac0:	01          	.byte	0x01
    bac1:	00          	.byte	0x00
    bac2:	2001      	movs	r0, #1
    bac4:	4770      	bx	lr
                            return false;
    bac6:	2000      	movs	r0, #0
    #endif
}
    bac8:	4770      	bx	lr

0000baca <nrf53_errata_140>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    baca:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    bace:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    bad2:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    bad6:	2a07      	cmp	r2, #7
    bad8:	d001      	beq.n	bade <nrf53_errata_140+0x14>
                            return true;
                    }
                }
            #endif
        #endif
        return false;
    bada:	2000      	movs	r0, #0
    badc:	4770      	bx	lr
                            return true;
    bade:	2001      	movs	r0, #1
    #endif
}
    bae0:	4770      	bx	lr

0000bae2 <nrf53_errata_160>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
    bae2:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    bae6:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
    baea:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
    baee:	2a07      	cmp	r2, #7
    baf0:	d001      	beq.n	baf6 <nrf53_errata_160+0x14>
                            return true;
                    }
                }
            #endif
        #endif
        return false;
    baf2:	2000      	movs	r0, #0
    baf4:	4770      	bx	lr
                    switch(var2)
    baf6:	2b04      	cmp	r3, #4
    baf8:	d803      	bhi.n	bb02 <nrf53_errata_160+0x20>
    bafa:	2b02      	cmp	r3, #2
    bafc:	d303      	bcc.n	bb06 <nrf53_errata_160+0x24>
    bafe:	2000      	movs	r0, #0
    bb00:	4770      	bx	lr
                            return true;
    bb02:	2001      	movs	r0, #1
    bb04:	4770      	bx	lr
                            return true;
    bb06:	2001      	movs	r0, #1
    #endif
}
    bb08:	4770      	bx	lr

0000bb0a <nrfx_isr>:
#include <nrfx.h>
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
    bb0a:	b508      	push	{r3, lr}
	((nrfx_irq_handler_t)irq_handler)();
    bb0c:	4780      	blx	r0
}
    bb0e:	bd08      	pop	{r3, pc}

0000bb10 <nrfx_busy_wait>:

void nrfx_busy_wait(uint32_t usec_to_wait)
{
    bb10:	b508      	push	{r3, lr}
	z_impl_k_busy_wait(usec_to_wait);
    bb12:	f002 f88f 	bl	dc34 <z_impl_k_busy_wait>
	if (IS_ENABLED(CONFIG_SYS_CLOCK_EXISTS)) {
		k_busy_wait(usec_to_wait);
	} else {
		nrfx_coredep_delay_us(usec_to_wait);
	}
}
    bb16:	bd08      	pop	{r3, pc}

0000bb18 <nrf_clock_is_running>:
    switch (domain)
    bb18:	2903      	cmp	r1, #3
    bb1a:	d82f      	bhi.n	bb7c <nrf_clock_is_running+0x64>
    bb1c:	e8df f001 	tbb	[pc, r1]
    bb20:	291c0f02 	.word	0x291c0f02
            if (p_clk_src != NULL)
    bb24:	b122      	cbz	r2, bb30 <nrf_clock_is_running+0x18>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    bb26:	f8d0 3418 	ldr.w	r3, [r0, #1048]	; 0x418
    bb2a:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    bb2e:	7013      	strb	r3, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    bb30:	f8d0 3418 	ldr.w	r3, [r0, #1048]	; 0x418
    bb34:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    bb38:	d122      	bne.n	bb80 <nrf_clock_is_running+0x68>
    return false;
    bb3a:	2000      	movs	r0, #0
    bb3c:	4770      	bx	lr
            if (p_clk_src != NULL)
    bb3e:	b122      	cbz	r2, bb4a <nrf_clock_is_running+0x32>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    bb40:	f8d0 340c 	ldr.w	r3, [r0, #1036]	; 0x40c
    bb44:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    bb48:	7013      	strb	r3, [r2, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    bb4a:	f8d0 340c 	ldr.w	r3, [r0, #1036]	; 0x40c
    bb4e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    bb52:	d117      	bne.n	bb84 <nrf_clock_is_running+0x6c>
    return false;
    bb54:	2000      	movs	r0, #0
    bb56:	4770      	bx	lr
            if (p_clk_src != NULL)
    bb58:	b122      	cbz	r2, bb64 <nrf_clock_is_running+0x4c>
                    (nrf_clock_hfclk_t)((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
    bb5a:	f8d0 345c 	ldr.w	r3, [r0, #1116]	; 0x45c
    bb5e:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    bb62:	7013      	strb	r3, [r2, #0]
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
    bb64:	f8d0 345c 	ldr.w	r3, [r0, #1116]	; 0x45c
    bb68:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    bb6c:	d10c      	bne.n	bb88 <nrf_clock_is_running+0x70>
    return false;
    bb6e:	2000      	movs	r0, #0
    bb70:	4770      	bx	lr
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
    bb72:	f8d0 0454 	ldr.w	r0, [r0, #1108]	; 0x454
    bb76:	f3c0 4000 	ubfx	r0, r0, #16, #1
    bb7a:	4770      	bx	lr
    switch (domain)
    bb7c:	2000      	movs	r0, #0
    bb7e:	4770      	bx	lr
                return true;
    bb80:	2001      	movs	r0, #1
    bb82:	4770      	bx	lr
                return true;
    bb84:	2001      	movs	r0, #1
    bb86:	4770      	bx	lr
                return true;
    bb88:	2001      	movs	r0, #1
}
    bb8a:	4770      	bx	lr

0000bb8c <clock_initial_lfclksrc_get>:
}
    bb8c:	2001      	movs	r0, #1
    bb8e:	4770      	bx	lr

0000bb90 <nrfx_power_clock_irq_init>:
extern "C" {
#endif


__STATIC_INLINE void nrfx_power_clock_irq_init(void)
{
    bb90:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    bb92:	2005      	movs	r0, #5
    bb94:	f7f5 fe10 	bl	17b8 <arch_irq_is_enabled>
    bb98:	b100      	cbz	r0, bb9c <nrfx_power_clock_irq_init+0xc>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    }
}
    bb9a:	bd08      	pop	{r3, pc}
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    bb9c:	2005      	movs	r0, #5
    bb9e:	f7fe fc69 	bl	a474 <arch_irq_enable>
}
    bba2:	e7fa      	b.n	bb9a <nrfx_power_clock_irq_init+0xa>

0000bba4 <clock_stop>:
{
    bba4:	b570      	push	{r4, r5, r6, lr}
    bba6:	b082      	sub	sp, #8
    bba8:	4606      	mov	r6, r0
    switch (domain)
    bbaa:	2803      	cmp	r0, #3
    bbac:	d855      	bhi.n	bc5a <clock_stop+0xb6>
    bbae:	e8df f000 	tbb	[pc, r0]
    bbb2:	1702      	.short	0x1702
    bbb4:	3123      	.short	0x3123
    p_reg->INTENCLR = mask;
    bbb6:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bbba:	2202      	movs	r2, #2
    bbbc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bbc0:	2200      	movs	r2, #0
    bbc2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    bbc6:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bbca:	2201      	movs	r2, #1
    bbcc:	60da      	str	r2, [r3, #12]
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    bbce:	2301      	movs	r3, #1
    bbd0:	f88d 3007 	strb.w	r3, [sp, #7]
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
    bbd4:	429e      	cmp	r6, r3
    bbd6:	d02b      	beq.n	bc30 <clock_stop+0x8c>
    bbd8:	2500      	movs	r5, #0
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
    bbda:	f242 7410 	movw	r4, #10000	; 0x2710
    bbde:	e02f      	b.n	bc40 <clock_stop+0x9c>
    p_reg->INTENCLR = mask;
    bbe0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bbe4:	2201      	movs	r2, #1
    bbe6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bbea:	2100      	movs	r1, #0
    bbec:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    bbf0:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bbf4:	605a      	str	r2, [r3, #4]
}
    bbf6:	e7ea      	b.n	bbce <clock_stop+0x2a>
    p_reg->INTENCLR = mask;
    bbf8:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bbfc:	f44f 7200 	mov.w	r2, #512	; 0x200
    bc00:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bc04:	2200      	movs	r2, #0
    bc06:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    bc0a:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bc0e:	2201      	movs	r2, #1
    bc10:	625a      	str	r2, [r3, #36]	; 0x24
}
    bc12:	e7dc      	b.n	bbce <clock_stop+0x2a>
    p_reg->INTENCLR = mask;
    bc14:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bc18:	f44f 7280 	mov.w	r2, #256	; 0x100
    bc1c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bc20:	2200      	movs	r2, #0
    bc22:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    bc26:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bc2a:	2201      	movs	r2, #1
    bc2c:	61da      	str	r2, [r3, #28]
}
    bc2e:	e7ce      	b.n	bbce <clock_stop+0x2a>
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
    bc30:	f10d 0507 	add.w	r5, sp, #7
    bc34:	e7d1      	b.n	bbda <clock_stop+0x36>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
    bc36:	2001      	movs	r0, #1
    bc38:	f7ff ff6a 	bl	bb10 <nrfx_busy_wait>
    bc3c:	3c01      	subs	r4, #1
    bc3e:	d00c      	beq.n	bc5a <clock_stop+0xb6>
    return nrf_clock_is_running(NRF_CLOCK, domain, p_clk_src);
    bc40:	462a      	mov	r2, r5
    bc42:	4631      	mov	r1, r6
    bc44:	f04f 2050 	mov.w	r0, #1342197760	; 0x50005000
    bc48:	f7ff ff66 	bl	bb18 <nrf_clock_is_running>
    bc4c:	b128      	cbz	r0, bc5a <clock_stop+0xb6>
    bc4e:	2d00      	cmp	r5, #0
    bc50:	d0f1      	beq.n	bc36 <clock_stop+0x92>
    bc52:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bc56:	2b01      	cmp	r3, #1
    bc58:	d0ed      	beq.n	bc36 <clock_stop+0x92>
}
    bc5a:	b002      	add	sp, #8
    bc5c:	bd70      	pop	{r4, r5, r6, pc}

0000bc5e <clock_lfclksrc_tweak>:
{
    bc5e:	b538      	push	{r3, r4, r5, lr}
    bc60:	4604      	mov	r4, r0
    bool is_correct_clk = (*p_lfclksrc == NRFX_CLOCK_CONFIG_LF_SRC);
    bc62:	7803      	ldrb	r3, [r0, #0]
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
    bc64:	2b02      	cmp	r3, #2
    bc66:	d006      	beq.n	bc76 <clock_lfclksrc_tweak+0x18>
    bc68:	2b01      	cmp	r3, #1
    bc6a:	d000      	beq.n	bc6e <clock_lfclksrc_tweak+0x10>
    bc6c:	2300      	movs	r3, #0
    if (!is_correct_clk)
    bc6e:	461d      	mov	r5, r3
    bc70:	b11b      	cbz	r3, bc7a <clock_lfclksrc_tweak+0x1c>
}
    bc72:	4628      	mov	r0, r5
    bc74:	bd38      	pop	{r3, r4, r5, pc}
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
    bc76:	2301      	movs	r3, #1
    bc78:	e7f9      	b.n	bc6e <clock_lfclksrc_tweak+0x10>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    bc7a:	2000      	movs	r0, #0
    bc7c:	f7ff ff92 	bl	bba4 <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
    bc80:	f7ff ff84 	bl	bb8c <clock_initial_lfclksrc_get>
    bc84:	7020      	strb	r0, [r4, #0]
    bc86:	e7f4      	b.n	bc72 <clock_lfclksrc_tweak+0x14>

0000bc88 <nrfx_clock_enable>:
{
    bc88:	b508      	push	{r3, lr}
    nrfx_power_clock_irq_init();
    bc8a:	f7ff ff81 	bl	bb90 <nrfx_power_clock_irq_init>
    nrf_clock_lf_src_set(NRF_CLOCK, clock_initial_lfclksrc_get());
    bc8e:	f7ff ff7d 	bl	bb8c <clock_initial_lfclksrc_get>
    p_reg->LFCLKSRC = (uint32_t)(source);
    bc92:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bc96:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518
    p_reg->HFCLKSRC = (uint32_t)(source);
    bc9a:	2201      	movs	r2, #1
    bc9c:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
                                   >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
}

NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLK192MSRC = (uint32_t)(source);
    bca0:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
}
    bca4:	bd08      	pop	{r3, pc}

0000bca6 <nrfx_clock_start>:
    switch (domain)
    bca6:	2803      	cmp	r0, #3
    bca8:	d871      	bhi.n	bd8e <nrfx_clock_start+0xe8>
    bcaa:	e8df f000 	tbb	[pc, r0]
    bcae:	4802      	.short	0x4802
    bcb0:	6254      	.short	0x6254
{
    bcb2:	b500      	push	{lr}
    bcb4:	b083      	sub	sp, #12
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    bcb6:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    bcba:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
    bcbe:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    bcc2:	f88d 3007 	strb.w	r3, [sp, #7]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    bcc6:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
    bcca:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    bcce:	d11d      	bne.n	bd0c <nrfx_clock_start+0x66>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
    bcd0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bcd4:	f8d3 3414 	ldr.w	r3, [r3, #1044]	; 0x414
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
    bcd8:	f013 0f01 	tst.w	r3, #1
    bcdc:	d11b      	bne.n	bd16 <nrfx_clock_start+0x70>
                    lfclksrc = clock_initial_lfclksrc_get();
    bcde:	f7ff ff55 	bl	bb8c <clock_initial_lfclksrc_get>
    bce2:	f88d 0007 	strb.w	r0, [sp, #7]
                nrf_clock_lf_src_set(NRF_CLOCK, lfclksrc);
    bce6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    p_reg->LFCLKSRC = (uint32_t)(source);
    bcea:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bcee:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bcf2:	2200      	movs	r2, #0
    bcf4:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    bcf8:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->INTENSET = mask;
    bcfc:	2202      	movs	r2, #2
    bcfe:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bd02:	2201      	movs	r2, #1
    bd04:	609a      	str	r2, [r3, #8]
}
    bd06:	b003      	add	sp, #12
    bd08:	f85d fb04 	ldr.w	pc, [sp], #4
                    (void)clock_lfclksrc_tweak(&lfclksrc);
    bd0c:	f10d 0007 	add.w	r0, sp, #7
    bd10:	f7ff ffa5 	bl	bc5e <clock_lfclksrc_tweak>
    bd14:	e7e7      	b.n	bce6 <nrfx_clock_start+0x40>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    bd16:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bd1a:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    bd1e:	f003 0303 	and.w	r3, r3, #3
                    lfclksrc = nrf_clock_lf_srccopy_get(NRF_CLOCK);
    bd22:	f88d 3007 	strb.w	r3, [sp, #7]
                    if (clock_lfclksrc_tweak(&lfclksrc))
    bd26:	f10d 0007 	add.w	r0, sp, #7
    bd2a:	f7ff ff98 	bl	bc5e <clock_lfclksrc_tweak>
    bd2e:	2800      	cmp	r0, #0
    bd30:	d0d9      	beq.n	bce6 <nrfx_clock_start+0x40>
    p_reg->INTENSET = mask;
    bd32:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bd36:	2202      	movs	r2, #2
    bd38:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
                        break;
    bd3c:	e7e3      	b.n	bd06 <nrfx_clock_start+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bd3e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bd42:	2200      	movs	r2, #0
    bd44:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    bd48:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
    bd4c:	2201      	movs	r2, #1
    bd4e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bd52:	601a      	str	r2, [r3, #0]
}
    bd54:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bd56:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bd5a:	2200      	movs	r2, #0
    bd5c:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    bd60:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENSET = mask;
    bd64:	f44f 7200 	mov.w	r2, #512	; 0x200
    bd68:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bd6c:	2201      	movs	r2, #1
    bd6e:	621a      	str	r2, [r3, #32]
}
    bd70:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bd72:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    bd76:	2200      	movs	r2, #0
    bd78:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    bd7c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENSET = mask;
    bd80:	f44f 7280 	mov.w	r2, #256	; 0x100
    bd84:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bd88:	2201      	movs	r2, #1
    bd8a:	619a      	str	r2, [r3, #24]
}
    bd8c:	4770      	bx	lr
    bd8e:	4770      	bx	lr

0000bd90 <nrfx_clock_stop>:
{
    bd90:	b508      	push	{r3, lr}
    clock_stop(domain);
    bd92:	f7ff ff07 	bl	bba4 <clock_stop>
}
    bd96:	bd08      	pop	{r3, pc}

0000bd98 <nrf_gpiote_event_configure>:
{
    bd98:	b410      	push	{r4}
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    bd9a:	f501 71a2 	add.w	r1, r1, #324	; 0x144
    bd9e:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
    bda2:	f424 344f 	bic.w	r4, r4, #211968	; 0x33c00
    bda6:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    bdaa:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    bdae:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
    bdb2:	0212      	lsls	r2, r2, #8
    bdb4:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
    bdb8:	041b      	lsls	r3, r3, #16
    bdba:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    bdbe:	431a      	orrs	r2, r3
    bdc0:	4314      	orrs	r4, r2
    bdc2:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
}
    bdc6:	bc10      	pop	{r4}
    bdc8:	4770      	bx	lr

0000bdca <nrf_gpiote_task_configure>:
{
    bdca:	b410      	push	{r4}
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    bdcc:	f501 71a2 	add.w	r1, r1, #324	; 0x144
    bdd0:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
    bdd4:	f424 1499 	bic.w	r4, r4, #1253376	; 0x132000
    bdd8:	f424 54f8 	bic.w	r4, r4, #7936	; 0x1f00
    bddc:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    bde0:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
    bde4:	0212      	lsls	r2, r2, #8
    bde6:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    bdea:	041b      	lsls	r3, r3, #16
    bdec:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    bdf0:	431a      	orrs	r2, r3
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    bdf2:	f89d 3004 	ldrb.w	r3, [sp, #4]
    bdf6:	051b      	lsls	r3, r3, #20
    bdf8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    bdfc:	431a      	orrs	r2, r3
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    bdfe:	4314      	orrs	r4, r2
    be00:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
}
    be04:	bc10      	pop	{r4}
    be06:	4770      	bx	lr

0000be08 <nrf_gpio_cfg_sense_set>:
{
    be08:	b500      	push	{lr}
    be0a:	b085      	sub	sp, #20
    be0c:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
    be10:	f10d 030f 	add.w	r3, sp, #15
    be14:	9301      	str	r3, [sp, #4]
    be16:	2100      	movs	r1, #0
    be18:	9100      	str	r1, [sp, #0]
    be1a:	460b      	mov	r3, r1
    be1c:	460a      	mov	r2, r1
    be1e:	f7f8 fc27 	bl	4670 <nrf_gpio_reconfigure>
}
    be22:	b005      	add	sp, #20
    be24:	f85d fb04 	ldr.w	pc, [sp], #4

0000be28 <pin_is_task_output>:
{
    be28:	b510      	push	{r4, lr}
    be2a:	4604      	mov	r4, r0
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    be2c:	f7f8 fcd2 	bl	47d4 <pin_is_output>
    be30:	b128      	cbz	r0, be3e <pin_is_task_output+0x16>
    be32:	4620      	mov	r0, r4
    be34:	f7f8 fcb8 	bl	47a8 <pin_in_use_by_te>
    be38:	b118      	cbz	r0, be42 <pin_is_task_output+0x1a>
    be3a:	2001      	movs	r0, #1
    be3c:	e000      	b.n	be40 <pin_is_task_output+0x18>
    be3e:	2000      	movs	r0, #0
}
    be40:	bd10      	pop	{r4, pc}
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    be42:	2000      	movs	r0, #0
    be44:	e7fc      	b.n	be40 <pin_is_task_output+0x18>

0000be46 <pin_is_input>:
{
    be46:	b508      	push	{r3, lr}
    return !pin_is_output(pin);
    be48:	f7f8 fcc4 	bl	47d4 <pin_is_output>
    be4c:	f080 0001 	eor.w	r0, r0, #1
}
    be50:	b2c0      	uxtb	r0, r0
    be52:	bd08      	pop	{r3, pc}

0000be54 <gpiote_polarity_to_trigger>:
}
    be54:	4770      	bx	lr

0000be56 <gpiote_trigger_to_polarity>:
}
    be56:	4770      	bx	lr

0000be58 <is_level>:
}
    be58:	2803      	cmp	r0, #3
    be5a:	bf94      	ite	ls
    be5c:	2000      	movls	r0, #0
    be5e:	2001      	movhi	r0, #1
    be60:	4770      	bx	lr

0000be62 <latch_pending_read_and_check>:
{
    be62:	b510      	push	{r4, lr}
    be64:	4604      	mov	r4, r0
    nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, latch);
    be66:	4602      	mov	r2, r0
    be68:	2102      	movs	r1, #2
    be6a:	2000      	movs	r0, #0
    be6c:	f7f8 fc72 	bl	4754 <nrf_gpio_latches_read_and_clear>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
    be70:	2300      	movs	r3, #0
    be72:	2b01      	cmp	r3, #1
    be74:	d804      	bhi.n	be80 <latch_pending_read_and_check+0x1e>
        if (latch[port_idx])
    be76:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
    be7a:	b91a      	cbnz	r2, be84 <latch_pending_read_and_check+0x22>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
    be7c:	3301      	adds	r3, #1
    be7e:	e7f8      	b.n	be72 <latch_pending_read_and_check+0x10>
    return false;
    be80:	2000      	movs	r0, #0
}
    be82:	bd10      	pop	{r4, pc}
            return true;
    be84:	2001      	movs	r0, #1
    be86:	e7fc      	b.n	be82 <latch_pending_read_and_check+0x20>

0000be88 <flash_page_size_get>:
}
    be88:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    be8c:	4770      	bx	lr

0000be8e <flash_page_count_get>:
}
    be8e:	f44f 7080 	mov.w	r0, #256	; 0x100
    be92:	4770      	bx	lr

0000be94 <flash_total_size_get>:
{
    be94:	b510      	push	{r4, lr}
    return flash_page_size_get() * flash_page_count_get();
    be96:	f7ff fff7 	bl	be88 <flash_page_size_get>
    be9a:	4604      	mov	r4, r0
    be9c:	f7ff fff7 	bl	be8e <flash_page_count_get>
}
    bea0:	fb04 f000 	mul.w	r0, r4, r0
    bea4:	bd10      	pop	{r4, pc}

0000bea6 <is_page_aligned_check>:
{
    bea6:	b510      	push	{r4, lr}
    bea8:	4604      	mov	r4, r0
    return !(addr % flash_page_size_get());
    beaa:	f7ff ffed 	bl	be88 <flash_page_size_get>
    beae:	fbb4 f3f0 	udiv	r3, r4, r0
    beb2:	fb00 4013 	mls	r0, r0, r3, r4
}
    beb6:	fab0 f080 	clz	r0, r0
    beba:	0940      	lsrs	r0, r0, #5
    bebc:	bd10      	pop	{r4, pc}

0000bebe <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, (const uint8_t *)&value, 2));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
    bebe:	b538      	push	{r3, r4, r5, lr}
    bec0:	4604      	mov	r4, r0
    bec2:	460d      	mov	r5, r1
    NRFX_ASSERT(is_valid_address(addr, true));
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));

    nvmc_write_mode_set();
    bec4:	f7f9 f84a 	bl	4f5c <nvmc_write_mode_set>

    nvmc_word_write(addr, value);
    bec8:	4629      	mov	r1, r5
    beca:	4620      	mov	r0, r4
    becc:	f7f9 f85a 	bl	4f84 <nvmc_word_write>

    nvmc_readonly_mode_set();
    bed0:	f7f9 f83a 	bl	4f48 <nvmc_readonly_mode_set>
}
    bed4:	bd38      	pop	{r3, r4, r5, pc}

0000bed6 <nrfx_nvmc_flash_size_get>:
    return (nrfx_is_word_aligned((void const *)addr) ? (uint16_t)(val32)
                                                     : (uint16_t)(val32 >> 16));
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    bed6:	b508      	push	{r3, lr}
    return flash_total_size_get();
    bed8:	f7ff ffdc 	bl	be94 <flash_total_size_get>
}
    bedc:	bd08      	pop	{r3, pc}

0000bede <nrfx_nvmc_flash_page_size_get>:

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    bede:	b508      	push	{r3, lr}
    return flash_page_size_get();
    bee0:	f7ff ffd2 	bl	be88 <flash_page_size_get>
}
    bee4:	bd08      	pop	{r3, pc}

0000bee6 <nrfx_nvmc_flash_page_count_get>:

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    bee6:	b508      	push	{r3, lr}
    return flash_page_count_get();
    bee8:	f7ff ffd1 	bl	be8e <flash_page_count_get>
}
    beec:	bd08      	pop	{r3, pc}

0000beee <nrf_spim_configure>:
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    beee:	3a00      	subs	r2, #0
    bef0:	bf18      	it	ne
    bef2:	2201      	movne	r2, #1
    switch (spi_mode)
    bef4:	2902      	cmp	r1, #2
    bef6:	d009      	beq.n	bf0c <nrf_spim_configure+0x1e>
    bef8:	2903      	cmp	r1, #3
    befa:	d00a      	beq.n	bf12 <nrf_spim_configure+0x24>
    befc:	2901      	cmp	r1, #1
    befe:	d002      	beq.n	bf06 <nrf_spim_configure+0x18>
    p_reg->CONFIG = config;
    bf00:	f8c0 2554 	str.w	r2, [r0, #1364]	; 0x554
}
    bf04:	4770      	bx	lr
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
    bf06:	f042 0202 	orr.w	r2, r2, #2
        break;
    bf0a:	e7f9      	b.n	bf00 <nrf_spim_configure+0x12>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    bf0c:	f042 0204 	orr.w	r2, r2, #4
        break;
    bf10:	e7f6      	b.n	bf00 <nrf_spim_configure+0x12>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    bf12:	f042 0206 	orr.w	r2, r2, #6
        break;
    bf16:	e7f3      	b.n	bf00 <nrf_spim_configure+0x12>

0000bf18 <spim_pin_uninit>:
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
    bf18:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    bf1c:	d003      	beq.n	bf26 <spim_pin_uninit+0xe>
{
    bf1e:	b508      	push	{r3, lr}
    nrf_gpio_cfg_default(pin);
    bf20:	f7f9 f87e 	bl	5020 <nrf_gpio_cfg_default>
}
    bf24:	bd08      	pop	{r3, pc}
    bf26:	4770      	bx	lr

0000bf28 <set_ss_pin_state>:
{
    bf28:	b508      	push	{r3, lr}
    if (p_cb->use_hw_ss)
    bf2a:	7f83      	ldrb	r3, [r0, #30]
    bf2c:	f013 0f04 	tst.w	r3, #4
    bf30:	d109      	bne.n	bf46 <set_ss_pin_state+0x1e>
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
    bf32:	7fc0      	ldrb	r0, [r0, #31]
    bf34:	28ff      	cmp	r0, #255	; 0xff
    bf36:	d006      	beq.n	bf46 <set_ss_pin_state+0x1e>
        nrf_gpio_pin_write(p_cb->ss_pin,
    bf38:	f013 0f02 	tst.w	r3, #2
    bf3c:	d101      	bne.n	bf42 <set_ss_pin_state+0x1a>
                           p_cb->ss_active_high ? active : !active);
    bf3e:	f081 0101 	eor.w	r1, r1, #1
        nrf_gpio_pin_write(p_cb->ss_pin,
    bf42:	f7f9 f883 	bl	504c <nrf_gpio_pin_write>
}
    bf46:	bd08      	pop	{r3, pc}

0000bf48 <finish_transfer>:
{
    bf48:	b510      	push	{r4, lr}
    bf4a:	4604      	mov	r4, r0
    set_ss_pin_state(p_cb, false);
    bf4c:	2100      	movs	r1, #0
    bf4e:	f7ff ffeb 	bl	bf28 <set_ss_pin_state>
    p_cb->transfer_in_progress = false;
    bf52:	2300      	movs	r3, #0
    bf54:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
    bf56:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    bf58:	4620      	mov	r0, r4
    bf5a:	f850 3b08 	ldr.w	r3, [r0], #8
    bf5e:	6861      	ldr	r1, [r4, #4]
    bf60:	4798      	blx	r3
}
    bf62:	bd10      	pop	{r4, pc}

0000bf64 <spim_int_enable>:
    if (!enable)
    bf64:	b919      	cbnz	r1, bf6e <spim_int_enable+0xa>
    p_reg->INTENCLR = mask;
    bf66:	2340      	movs	r3, #64	; 0x40
    bf68:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
}
    bf6c:	4770      	bx	lr
    p_reg->INTENSET = mask;
    bf6e:	2340      	movs	r3, #64	; 0x40
    bf70:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
}
    bf74:	4770      	bx	lr

0000bf76 <spim_list_enable_handle>:
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
    bf76:	f011 0f01 	tst.w	r1, #1
    bf7a:	d009      	beq.n	bf90 <spim_list_enable_handle+0x1a>
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
    bf7c:	2301      	movs	r3, #1
    bf7e:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
    bf82:	f011 0f02 	tst.w	r1, #2
    bf86:	d007      	beq.n	bf98 <spim_list_enable_handle+0x22>
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
    bf88:	2301      	movs	r3, #1
    bf8a:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
    bf8e:	4770      	bx	lr
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
    bf90:	2300      	movs	r3, #0
    bf92:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
}
    bf96:	e7f4      	b.n	bf82 <spim_list_enable_handle+0xc>

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
    bf98:	2300      	movs	r3, #0
    bf9a:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
    bf9e:	4770      	bx	lr

0000bfa0 <irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    bfa0:	f8d0 2118 	ldr.w	r2, [r0, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
    bfa4:	b902      	cbnz	r2, bfa8 <irq_handler+0x8>
    bfa6:	4770      	bx	lr
{
    bfa8:	b508      	push	{r3, lr}
    bfaa:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    bfac:	2200      	movs	r2, #0
    bfae:	f8c0 2118 	str.w	r2, [r0, #280]	; 0x118
    bfb2:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        finish_transfer(p_cb);
    bfb6:	4608      	mov	r0, r1
    bfb8:	f7ff ffc6 	bl	bf48 <finish_transfer>
}
    bfbc:	bd08      	pop	{r3, pc}

0000bfbe <spim_abort>:
{
    bfbe:	b570      	push	{r4, r5, r6, lr}
    bfc0:	4605      	mov	r5, r0
    bfc2:	460e      	mov	r6, r1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    bfc4:	2301      	movs	r3, #1
    bfc6:	6143      	str	r3, [r0, #20]
    NRFX_WAIT_FOR(nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED), 100, 1, stopped);
    bfc8:	2464      	movs	r4, #100	; 0x64
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    bfca:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    bfce:	b923      	cbnz	r3, bfda <spim_abort+0x1c>
    bfd0:	2001      	movs	r0, #1
    bfd2:	f7ff fd9d 	bl	bb10 <nrfx_busy_wait>
    bfd6:	3c01      	subs	r4, #1
    bfd8:	d1f7      	bne.n	bfca <spim_abort+0xc>
    p_cb->transfer_in_progress = false;
    bfda:	2300      	movs	r3, #0
    bfdc:	7773      	strb	r3, [r6, #29]
}
    bfde:	bd70      	pop	{r4, r5, r6, pc}

0000bfe0 <lfs_bd_erase>:
static int lfs_bd_erase(lfs_t *lfs, lfs_block_t block) {
    bfe0:	b508      	push	{r3, lr}
    int err = lfs->cfg->erase(lfs->cfg, block);
    bfe2:	6e80      	ldr	r0, [r0, #104]	; 0x68
    bfe4:	68c3      	ldr	r3, [r0, #12]
    bfe6:	4798      	blx	r3
}
    bfe8:	bd08      	pop	{r3, pc}

0000bfea <lfs_pair_sync>:
    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
    bfea:	6803      	ldr	r3, [r0, #0]
    bfec:	680a      	ldr	r2, [r1, #0]
    bfee:	4293      	cmp	r3, r2
    bff0:	d004      	beq.n	bffc <lfs_pair_sync+0x12>
           (paira[0] == pairb[1] && paira[1] == pairb[0]);
    bff2:	6849      	ldr	r1, [r1, #4]
    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
    bff4:	428b      	cmp	r3, r1
    bff6:	d017      	beq.n	c028 <lfs_pair_sync+0x3e>
    bff8:	2000      	movs	r0, #0
    bffa:	4770      	bx	lr
        const lfs_block_t pairb[2]) {
    bffc:	b500      	push	{lr}
    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
    bffe:	f8d0 c004 	ldr.w	ip, [r0, #4]
    c002:	f8d1 e004 	ldr.w	lr, [r1, #4]
    c006:	45f4      	cmp	ip, lr
    c008:	d00a      	beq.n	c020 <lfs_pair_sync+0x36>
           (paira[0] == pairb[1] && paira[1] == pairb[0]);
    c00a:	6849      	ldr	r1, [r1, #4]
    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
    c00c:	428b      	cmp	r3, r1
    c00e:	d002      	beq.n	c016 <lfs_pair_sync+0x2c>
    c010:	2000      	movs	r0, #0
}
    c012:	f85d fb04 	ldr.w	pc, [sp], #4
           (paira[0] == pairb[1] && paira[1] == pairb[0]);
    c016:	6843      	ldr	r3, [r0, #4]
    c018:	429a      	cmp	r2, r3
    c01a:	d003      	beq.n	c024 <lfs_pair_sync+0x3a>
    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
    c01c:	2000      	movs	r0, #0
    c01e:	e7f8      	b.n	c012 <lfs_pair_sync+0x28>
    c020:	2001      	movs	r0, #1
    c022:	e7f6      	b.n	c012 <lfs_pair_sync+0x28>
    c024:	2001      	movs	r0, #1
    c026:	e7f4      	b.n	c012 <lfs_pair_sync+0x28>
           (paira[0] == pairb[1] && paira[1] == pairb[0]);
    c028:	6843      	ldr	r3, [r0, #4]
    c02a:	429a      	cmp	r2, r3
    c02c:	d001      	beq.n	c032 <lfs_pair_sync+0x48>
    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
    c02e:	2000      	movs	r0, #0
    c030:	4770      	bx	lr
    c032:	2001      	movs	r0, #1
}
    c034:	4770      	bx	lr

0000c036 <lfs_gstate_xor>:
    for (int i = 0; i < 3; i++) {
    c036:	2300      	movs	r3, #0
    c038:	2b02      	cmp	r3, #2
    c03a:	dc0c      	bgt.n	c056 <lfs_gstate_xor+0x20>
static inline void lfs_gstate_xor(lfs_gstate_t *a, const lfs_gstate_t *b) {
    c03c:	b410      	push	{r4}
        ((uint32_t*)a)[i] ^= ((const uint32_t*)b)[i];
    c03e:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    c042:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
    c046:	4062      	eors	r2, r4
    c048:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    for (int i = 0; i < 3; i++) {
    c04c:	3301      	adds	r3, #1
    c04e:	2b02      	cmp	r3, #2
    c050:	ddf5      	ble.n	c03e <lfs_gstate_xor+0x8>
}
    c052:	bc10      	pop	{r4}
    c054:	4770      	bx	lr
    c056:	4770      	bx	lr

0000c058 <lfs_gstate_hasmovehere>:
    return lfs_tag_type1(a->tag) && lfs_pair_cmp(a->pair, pair) == 0;
    c058:	6803      	ldr	r3, [r0, #0]
    return (tag & 0x70000000) >> 20;
    c05a:	0d1b      	lsrs	r3, r3, #20
    return lfs_tag_type1(a->tag) && lfs_pair_cmp(a->pair, pair) == 0;
    c05c:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    c060:	d00f      	beq.n	c082 <lfs_gstate_hasmovehere+0x2a>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    c062:	6843      	ldr	r3, [r0, #4]
    c064:	680a      	ldr	r2, [r1, #0]
    c066:	4293      	cmp	r3, r2
    c068:	d00d      	beq.n	c086 <lfs_gstate_hasmovehere+0x2e>
    c06a:	6880      	ldr	r0, [r0, #8]
    c06c:	6849      	ldr	r1, [r1, #4]
    c06e:	4288      	cmp	r0, r1
    c070:	d00b      	beq.n	c08a <lfs_gstate_hasmovehere+0x32>
    c072:	428b      	cmp	r3, r1
    c074:	d00b      	beq.n	c08e <lfs_gstate_hasmovehere+0x36>
    c076:	4282      	cmp	r2, r0
    c078:	d001      	beq.n	c07e <lfs_gstate_hasmovehere+0x26>
    return lfs_tag_type1(a->tag) && lfs_pair_cmp(a->pair, pair) == 0;
    c07a:	2000      	movs	r0, #0
}
    c07c:	4770      	bx	lr
    return lfs_tag_type1(a->tag) && lfs_pair_cmp(a->pair, pair) == 0;
    c07e:	2001      	movs	r0, #1
    c080:	4770      	bx	lr
    c082:	2000      	movs	r0, #0
    c084:	4770      	bx	lr
    c086:	2001      	movs	r0, #1
    c088:	4770      	bx	lr
    c08a:	2001      	movs	r0, #1
    c08c:	4770      	bx	lr
    c08e:	2001      	movs	r0, #1
    c090:	4770      	bx	lr

0000c092 <lfs_mlist_remove>:
    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {
    c092:	3028      	adds	r0, #40	; 0x28
    c094:	e000      	b.n	c098 <lfs_mlist_remove+0x6>
    c096:	4618      	mov	r0, r3
    c098:	6803      	ldr	r3, [r0, #0]
    c09a:	b123      	cbz	r3, c0a6 <lfs_mlist_remove+0x14>
        if (*p == mlist) {
    c09c:	428b      	cmp	r3, r1
    c09e:	d1fa      	bne.n	c096 <lfs_mlist_remove+0x4>
            *p = (*p)->next;
    c0a0:	681b      	ldr	r3, [r3, #0]
    c0a2:	6003      	str	r3, [r0, #0]
            break;
    c0a4:	4770      	bx	lr
}
    c0a6:	4770      	bx	lr

0000c0a8 <lfs_mlist_append>:
    mlist->next = lfs->mlist;
    c0a8:	6a83      	ldr	r3, [r0, #40]	; 0x28
    c0aa:	600b      	str	r3, [r1, #0]
    lfs->mlist = mlist;
    c0ac:	6281      	str	r1, [r0, #40]	; 0x28
}
    c0ae:	4770      	bx	lr

0000c0b0 <lfs_alloc_lookahead>:
    lfs_block_t off = ((block - lfs->free.off)
    c0b0:	6d43      	ldr	r3, [r0, #84]	; 0x54
    c0b2:	1ac9      	subs	r1, r1, r3
            + lfs->cfg->block_count) % lfs->cfg->block_count;
    c0b4:	6e83      	ldr	r3, [r0, #104]	; 0x68
    c0b6:	6a1b      	ldr	r3, [r3, #32]
    c0b8:	4419      	add	r1, r3
    lfs_block_t off = ((block - lfs->free.off)
    c0ba:	fbb1 f2f3 	udiv	r2, r1, r3
    c0be:	fb03 1112 	mls	r1, r3, r2, r1
    if (off < lfs->free.size) {
    c0c2:	6d83      	ldr	r3, [r0, #88]	; 0x58
    c0c4:	428b      	cmp	r3, r1
    c0c6:	d90b      	bls.n	c0e0 <lfs_alloc_lookahead+0x30>
        lfs->free.buffer[off / 32] |= 1U << (off % 32);
    c0c8:	6e40      	ldr	r0, [r0, #100]	; 0x64
    c0ca:	ea4f 1c51 	mov.w	ip, r1, lsr #5
    c0ce:	f850 302c 	ldr.w	r3, [r0, ip, lsl #2]
    c0d2:	f001 011f 	and.w	r1, r1, #31
    c0d6:	2201      	movs	r2, #1
    c0d8:	408a      	lsls	r2, r1
    c0da:	4313      	orrs	r3, r2
    c0dc:	f840 302c 	str.w	r3, [r0, ip, lsl #2]
}
    c0e0:	2000      	movs	r0, #0
    c0e2:	4770      	bx	lr

0000c0e4 <lfs_alloc_ack>:
    lfs->free.ack = lfs->cfg->block_count;
    c0e4:	6e83      	ldr	r3, [r0, #104]	; 0x68
    c0e6:	6a1b      	ldr	r3, [r3, #32]
    c0e8:	6603      	str	r3, [r0, #96]	; 0x60
}
    c0ea:	4770      	bx	lr

0000c0ec <lfs_alloc_drop>:
static void lfs_alloc_drop(lfs_t *lfs) {
    c0ec:	b508      	push	{r3, lr}
    lfs->free.size = 0;
    c0ee:	2200      	movs	r2, #0
    c0f0:	6582      	str	r2, [r0, #88]	; 0x58
    lfs->free.i = 0;
    c0f2:	65c2      	str	r2, [r0, #92]	; 0x5c
    lfs_alloc_ack(lfs);
    c0f4:	f7ff fff6 	bl	c0e4 <lfs_alloc_ack>
}
    c0f8:	bd08      	pop	{r3, pc}

0000c0fa <lfs_dir_commit_size>:
    return ((int32_t)(tag << 22) >> 22) == -1;
    c0fa:	f341 0309 	sbfx	r3, r1, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    c0fe:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    c102:	bf08      	it	eq
    c104:	3101      	addeq	r1, #1
    return tag & 0x000003ff;
    c106:	f3c1 0109 	ubfx	r1, r1, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    c10a:	3104      	adds	r1, #4
    *size += lfs_tag_dsize(tag);
    c10c:	6803      	ldr	r3, [r0, #0]
    c10e:	440b      	add	r3, r1
    c110:	6003      	str	r3, [r0, #0]
}
    c112:	2000      	movs	r0, #0
    c114:	4770      	bx	lr

0000c116 <lfs_dir_needsrelocation>:
    return (lfs->cfg->block_cycles > 0
    c116:	6e83      	ldr	r3, [r0, #104]	; 0x68
    c118:	6a5b      	ldr	r3, [r3, #36]	; 0x24
            && ((dir->rev + 1) % ((lfs->cfg->block_cycles+1)|1) == 0));
    c11a:	2b00      	cmp	r3, #0
    c11c:	dd0b      	ble.n	c136 <lfs_dir_needsrelocation+0x20>
    c11e:	688a      	ldr	r2, [r1, #8]
    c120:	3201      	adds	r2, #1
    c122:	3301      	adds	r3, #1
    c124:	f043 0301 	orr.w	r3, r3, #1
    c128:	fbb2 f1f3 	udiv	r1, r2, r3
    c12c:	fb03 2211 	mls	r2, r3, r1, r2
    c130:	b11a      	cbz	r2, c13a <lfs_dir_needsrelocation+0x24>
    c132:	2000      	movs	r0, #0
    c134:	4770      	bx	lr
    c136:	2000      	movs	r0, #0
    c138:	4770      	bx	lr
    c13a:	2001      	movs	r0, #1
}
    c13c:	4770      	bx	lr

0000c13e <lfs_dir_rawclose>:
static int lfs_dir_rawclose(lfs_t *lfs, lfs_dir_t *dir) {
    c13e:	b508      	push	{r3, lr}
    lfs_mlist_remove(lfs, (struct lfs_mlist *)dir);
    c140:	f7ff ffa7 	bl	c092 <lfs_mlist_remove>
}
    c144:	2000      	movs	r0, #0
    c146:	bd08      	pop	{r3, pc}

0000c148 <lfs_file_rawtell>:
}
    c148:	6b48      	ldr	r0, [r1, #52]	; 0x34
    c14a:	4770      	bx	lr

0000c14c <lfs_file_rawsize>:
    if (file->flags & LFS_F_WRITING) {
    c14c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    c14e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    c152:	d101      	bne.n	c158 <lfs_file_rawsize+0xc>
    return file->ctz.size;
    c154:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
}
    c156:	4770      	bx	lr
        return lfs_max(file->pos, file->ctz.size);
    c158:	6b48      	ldr	r0, [r1, #52]	; 0x34
    c15a:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    c15c:	4298      	cmp	r0, r3
    c15e:	bf38      	it	cc
    c160:	4618      	movcc	r0, r3
    c162:	4770      	bx	lr

0000c164 <lfs_fs_preporphans>:
    lfs->gstate.tag += orphans;
    c164:	6b03      	ldr	r3, [r0, #48]	; 0x30
    c166:	4419      	add	r1, r3
    c168:	6301      	str	r1, [r0, #48]	; 0x30
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x800, 0, 0)) |
    c16a:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
    return tag & 0x000003ff;
    c16e:	f3c1 0109 	ubfx	r1, r1, #0, #10
    return lfs_tag_size(a->tag);
    c172:	3900      	subs	r1, #0
    c174:	bf18      	it	ne
    c176:	2101      	movne	r1, #1
    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x800, 0, 0)) |
    c178:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
    c17c:	6303      	str	r3, [r0, #48]	; 0x30
}
    c17e:	2000      	movs	r0, #0
    c180:	4770      	bx	lr

0000c182 <lfs_fs_size_count>:
    *size += 1;
    c182:	6803      	ldr	r3, [r0, #0]
    c184:	3301      	adds	r3, #1
    c186:	6003      	str	r3, [r0, #0]
}
    c188:	2000      	movs	r0, #0
    c18a:	4770      	bx	lr

0000c18c <lfs_cache_zero>:
static inline void lfs_cache_zero(lfs_t *lfs, lfs_cache_t *pcache) {
    c18c:	b510      	push	{r4, lr}
    c18e:	460c      	mov	r4, r1
    memset(pcache->buffer, 0xff, lfs->cfg->cache_size);
    c190:	6e83      	ldr	r3, [r0, #104]	; 0x68
    c192:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    c194:	21ff      	movs	r1, #255	; 0xff
    c196:	68e0      	ldr	r0, [r4, #12]
    c198:	f7fe fabf 	bl	a71a <memset>
    pcache->block = LFS_BLOCK_NULL;
    c19c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c1a0:	6023      	str	r3, [r4, #0]
}
    c1a2:	bd10      	pop	{r4, pc}

0000c1a4 <lfs_ctz_index>:
static int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {
    c1a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    lfs_off_t size = *off;
    c1a6:	680d      	ldr	r5, [r1, #0]
    lfs_off_t b = lfs->cfg->block_size - 2*4;
    c1a8:	6e83      	ldr	r3, [r0, #104]	; 0x68
    c1aa:	69df      	ldr	r7, [r3, #28]
    c1ac:	3f08      	subs	r7, #8
    lfs_off_t i = size / b;
    c1ae:	fbb5 f0f7 	udiv	r0, r5, r7
    if (i == 0) {
    c1b2:	42bd      	cmp	r5, r7
    c1b4:	d312      	bcc.n	c1dc <lfs_ctz_index+0x38>
    c1b6:	460e      	mov	r6, r1
	return __builtin_popcount(a);
    c1b8:	3801      	subs	r0, #1
    c1ba:	f7f3 ffe5 	bl	188 <__popcountsi2>
    i = (size - 4*(lfs_popc(i-1)+2)) / b;
    c1be:	1c84      	adds	r4, r0, #2
    c1c0:	eba5 0484 	sub.w	r4, r5, r4, lsl #2
    c1c4:	fbb4 f4f7 	udiv	r4, r4, r7
    *off = size - b*i - 4*lfs_popc(i);
    c1c8:	fb04 5517 	mls	r5, r4, r7, r5
    c1cc:	4620      	mov	r0, r4
    c1ce:	f7f3 ffdb 	bl	188 <__popcountsi2>
    c1d2:	eba5 0580 	sub.w	r5, r5, r0, lsl #2
    c1d6:	6035      	str	r5, [r6, #0]
    return i;
    c1d8:	4620      	mov	r0, r4
}
    c1da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
    c1dc:	2000      	movs	r0, #0
    c1de:	e7fc      	b.n	c1da <lfs_ctz_index+0x36>

0000c1e0 <lfs_bd_read>:
        void *buffer, lfs_size_t size) {
    c1e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c1e4:	b085      	sub	sp, #20
    c1e6:	4615      	mov	r5, r2
    c1e8:	469a      	mov	sl, r3
    c1ea:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    c1ec:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    c1ee:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
    if (block >= lfs->cfg->block_count ||
    c1f2:	6e82      	ldr	r2, [r0, #104]	; 0x68
    c1f4:	6a13      	ldr	r3, [r2, #32]
    c1f6:	42b3      	cmp	r3, r6
    c1f8:	f240 80ba 	bls.w	c370 <lfs_bd_read+0x190>
    c1fc:	4607      	mov	r7, r0
    c1fe:	4689      	mov	r9, r1
            off+size > lfs->cfg->block_size) {
    c200:	eb04 030b 	add.w	r3, r4, fp
    c204:	69d2      	ldr	r2, [r2, #28]
    if (block >= lfs->cfg->block_count ||
    c206:	4293      	cmp	r3, r2
    c208:	d97f      	bls.n	c30a <lfs_bd_read+0x12a>
        return LFS_ERR_CORRUPT;
    c20a:	f06f 0353 	mvn.w	r3, #83	; 0x53
    c20e:	e0a9      	b.n	c364 <lfs_bd_read+0x184>
                off < pcache->off + pcache->size) {
    c210:	f8d9 3004 	ldr.w	r3, [r9, #4]
    c214:	f8d9 2008 	ldr.w	r2, [r9, #8]
    c218:	1899      	adds	r1, r3, r2
        if (pcache && block == pcache->block &&
    c21a:	42a1      	cmp	r1, r4
    c21c:	d91e      	bls.n	c25c <lfs_bd_read+0x7c>
            if (off >= pcache->off) {
    c21e:	42a3      	cmp	r3, r4
    c220:	d905      	bls.n	c22e <lfs_bd_read+0x4e>
            diff = lfs_min(diff, pcache->off-off);
    c222:	1b1b      	subs	r3, r3, r4
	return (a < b) ? a : b;
    c224:	455b      	cmp	r3, fp
    c226:	bf28      	it	cs
    c228:	465b      	movcs	r3, fp
    c22a:	4698      	mov	r8, r3
    c22c:	e079      	b.n	c322 <lfs_bd_read+0x142>
                diff = lfs_min(diff, pcache->size - (off-pcache->off));
    c22e:	1b19      	subs	r1, r3, r4
    c230:	eb02 0801 	add.w	r8, r2, r1
    c234:	45d8      	cmp	r8, fp
    c236:	bf28      	it	cs
    c238:	46d8      	movcs	r8, fp
                memcpy(data, &pcache->buffer[off-pcache->off], diff);
    c23a:	f8d9 100c 	ldr.w	r1, [r9, #12]
    c23e:	1ae3      	subs	r3, r4, r3
    c240:	4642      	mov	r2, r8
    c242:	4419      	add	r1, r3
    c244:	9810      	ldr	r0, [sp, #64]	; 0x40
    c246:	f7fe fa39 	bl	a6bc <memcpy>
                data += diff;
    c24a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    c24c:	4443      	add	r3, r8
    c24e:	9310      	str	r3, [sp, #64]	; 0x40
                off += diff;
    c250:	4444      	add	r4, r8
                size -= diff;
    c252:	ebab 0b08 	sub.w	fp, fp, r8
                continue;
    c256:	e058      	b.n	c30a <lfs_bd_read+0x12a>
        lfs_size_t diff = size;
    c258:	46d8      	mov	r8, fp
    c25a:	e062      	b.n	c322 <lfs_bd_read+0x142>
    c25c:	46d8      	mov	r8, fp
    c25e:	e060      	b.n	c322 <lfs_bd_read+0x142>
                off < rcache->off + rcache->size) {
    c260:	686b      	ldr	r3, [r5, #4]
    c262:	68aa      	ldr	r2, [r5, #8]
    c264:	1899      	adds	r1, r3, r2
        if (block == rcache->block &&
    c266:	42a1      	cmp	r1, r4
    c268:	d95e      	bls.n	c328 <lfs_bd_read+0x148>
            if (off >= rcache->off) {
    c26a:	42a3      	cmp	r3, r4
    c26c:	d904      	bls.n	c278 <lfs_bd_read+0x98>
            diff = lfs_min(diff, rcache->off-off);
    c26e:	1b1b      	subs	r3, r3, r4
    c270:	4598      	cmp	r8, r3
    c272:	bf28      	it	cs
    c274:	4698      	movcs	r8, r3
    c276:	e057      	b.n	c328 <lfs_bd_read+0x148>
                diff = lfs_min(diff, rcache->size - (off-rcache->off));
    c278:	1b19      	subs	r1, r3, r4
    c27a:	440a      	add	r2, r1
    c27c:	4590      	cmp	r8, r2
    c27e:	bf28      	it	cs
    c280:	4690      	movcs	r8, r2
                memcpy(data, &rcache->buffer[off-rcache->off], diff);
    c282:	68e9      	ldr	r1, [r5, #12]
    c284:	1ae3      	subs	r3, r4, r3
    c286:	4642      	mov	r2, r8
    c288:	4419      	add	r1, r3
    c28a:	9810      	ldr	r0, [sp, #64]	; 0x40
    c28c:	f7fe fa16 	bl	a6bc <memcpy>
                data += diff;
    c290:	9b10      	ldr	r3, [sp, #64]	; 0x40
    c292:	4443      	add	r3, r8
    c294:	9310      	str	r3, [sp, #64]	; 0x40
                off += diff;
    c296:	4444      	add	r4, r8
                size -= diff;
    c298:	ebab 0b08 	sub.w	fp, fp, r8
                continue;
    c29c:	e035      	b.n	c30a <lfs_bd_read+0x12a>
            data += diff;
    c29e:	9a10      	ldr	r2, [sp, #64]	; 0x40
    c2a0:	9b02      	ldr	r3, [sp, #8]
    c2a2:	441a      	add	r2, r3
    c2a4:	9210      	str	r2, [sp, #64]	; 0x40
            off += diff;
    c2a6:	441c      	add	r4, r3
            size -= diff;
    c2a8:	9b03      	ldr	r3, [sp, #12]
    c2aa:	eba3 0308 	sub.w	r3, r3, r8
    c2ae:	449b      	add	fp, r3
            continue;
    c2b0:	e02b      	b.n	c30a <lfs_bd_read+0x12a>
        rcache->block = block;
    c2b2:	602e      	str	r6, [r5, #0]
        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
    c2b4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    c2b6:	695a      	ldr	r2, [r3, #20]
	return a - (a % alignment);
    c2b8:	fbb4 f3f2 	udiv	r3, r4, r2
    c2bc:	fb02 4313 	mls	r3, r2, r3, r4
    c2c0:	1ae2      	subs	r2, r4, r3
    c2c2:	606a      	str	r2, [r5, #4]
                lfs_min(
    c2c4:	eb04 010a 	add.w	r1, r4, sl
                    lfs_alignup(off+hint, lfs->cfg->read_size),
    c2c8:	f8d7 c068 	ldr.w	ip, [r7, #104]	; 0x68
    c2cc:	f8dc 0014 	ldr.w	r0, [ip, #20]
	return lfs_aligndown(a + alignment-1, alignment);
    c2d0:	4401      	add	r1, r0
    c2d2:	3901      	subs	r1, #1
	return a - (a % alignment);
    c2d4:	fbb1 fef0 	udiv	lr, r1, r0
    c2d8:	fb00 101e 	mls	r0, r0, lr, r1
    c2dc:	1a09      	subs	r1, r1, r0
                    lfs->cfg->block_size)
    c2de:	f8dc 001c 	ldr.w	r0, [ip, #28]
        rcache->size = lfs_min(
    c2e2:	1b1b      	subs	r3, r3, r4
    c2e4:	4288      	cmp	r0, r1
    c2e6:	bf94      	ite	ls
    c2e8:	181b      	addls	r3, r3, r0
    c2ea:	185b      	addhi	r3, r3, r1
                lfs->cfg->cache_size);
    c2ec:	f8dc 1028 	ldr.w	r1, [ip, #40]	; 0x28
	return (a < b) ? a : b;
    c2f0:	428b      	cmp	r3, r1
    c2f2:	bf28      	it	cs
    c2f4:	460b      	movcs	r3, r1
        rcache->size = lfs_min(
    c2f6:	60ab      	str	r3, [r5, #8]
        int err = lfs->cfg->read(lfs->cfg, rcache->block,
    c2f8:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    c2fa:	f8d0 8004 	ldr.w	r8, [r0, #4]
    c2fe:	9300      	str	r3, [sp, #0]
    c300:	68eb      	ldr	r3, [r5, #12]
    c302:	4631      	mov	r1, r6
    c304:	47c0      	blx	r8
        if (err) {
    c306:	4603      	mov	r3, r0
    c308:	bb60      	cbnz	r0, c364 <lfs_bd_read+0x184>
    while (size > 0) {
    c30a:	f1bb 0f00 	cmp.w	fp, #0
    c30e:	d02d      	beq.n	c36c <lfs_bd_read+0x18c>
        if (pcache && block == pcache->block &&
    c310:	f1b9 0f00 	cmp.w	r9, #0
    c314:	d0a0      	beq.n	c258 <lfs_bd_read+0x78>
    c316:	f8d9 3000 	ldr.w	r3, [r9]
    c31a:	42b3      	cmp	r3, r6
    c31c:	f43f af78 	beq.w	c210 <lfs_bd_read+0x30>
        lfs_size_t diff = size;
    c320:	46d8      	mov	r8, fp
        if (block == rcache->block &&
    c322:	682b      	ldr	r3, [r5, #0]
    c324:	42b3      	cmp	r3, r6
    c326:	d09b      	beq.n	c260 <lfs_bd_read+0x80>
        if (size >= hint && off % lfs->cfg->read_size == 0 &&
    c328:	45d3      	cmp	fp, sl
    c32a:	d3c2      	bcc.n	c2b2 <lfs_bd_read+0xd2>
    c32c:	6eb8      	ldr	r0, [r7, #104]	; 0x68
    c32e:	6942      	ldr	r2, [r0, #20]
    c330:	fbb4 f3f2 	udiv	r3, r4, r2
    c334:	fb02 4313 	mls	r3, r2, r3, r4
    c338:	2b00      	cmp	r3, #0
    c33a:	d1ba      	bne.n	c2b2 <lfs_bd_read+0xd2>
    c33c:	455a      	cmp	r2, fp
    c33e:	d8b8      	bhi.n	c2b2 <lfs_bd_read+0xd2>
	return a - (a % alignment);
    c340:	fbb8 f3f2 	udiv	r3, r8, r2
    c344:	fb02 8313 	mls	r3, r2, r3, r8
    c348:	9303      	str	r3, [sp, #12]
    c34a:	eba8 0303 	sub.w	r3, r8, r3
            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);
    c34e:	f8d0 c004 	ldr.w	ip, [r0, #4]
    c352:	9302      	str	r3, [sp, #8]
    c354:	9300      	str	r3, [sp, #0]
    c356:	9b10      	ldr	r3, [sp, #64]	; 0x40
    c358:	4622      	mov	r2, r4
    c35a:	4631      	mov	r1, r6
    c35c:	47e0      	blx	ip
            if (err) {
    c35e:	4603      	mov	r3, r0
    c360:	2800      	cmp	r0, #0
    c362:	d09c      	beq.n	c29e <lfs_bd_read+0xbe>
}
    c364:	4618      	mov	r0, r3
    c366:	b005      	add	sp, #20
    c368:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
    c36c:	2300      	movs	r3, #0
    c36e:	e7f9      	b.n	c364 <lfs_bd_read+0x184>
        return LFS_ERR_CORRUPT;
    c370:	f06f 0353 	mvn.w	r3, #83	; 0x53
    c374:	e7f6      	b.n	c364 <lfs_bd_read+0x184>

0000c376 <lfs_dir_get>:
        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {
    c376:	b510      	push	{r4, lr}
    c378:	b084      	sub	sp, #16
    return tag & 0x000003ff;
    c37a:	f3c3 0409 	ubfx	r4, r3, #0, #10
    return lfs_dir_getslice(lfs, dir,
    c37e:	9402      	str	r4, [sp, #8]
    c380:	9c06      	ldr	r4, [sp, #24]
    c382:	9401      	str	r4, [sp, #4]
    c384:	2400      	movs	r4, #0
    c386:	9400      	str	r4, [sp, #0]
    c388:	f7f9 f928 	bl	55dc <lfs_dir_getslice>
}
    c38c:	b004      	add	sp, #16
    c38e:	bd10      	pop	{r4, pc}

0000c390 <lfs_ctz_traverse>:
        int (*cb)(void*, lfs_block_t), void *data) {
    c390:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c394:	b089      	sub	sp, #36	; 0x24
    c396:	461c      	mov	r4, r3
    c398:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c39a:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    c39c:	9f14      	ldr	r7, [sp, #80]	; 0x50
    if (size == 0) {
    c39e:	b923      	cbnz	r3, c3aa <lfs_ctz_traverse+0x1a>
        return 0;
    c3a0:	2300      	movs	r3, #0
}
    c3a2:	4618      	mov	r0, r3
    c3a4:	b009      	add	sp, #36	; 0x24
    c3a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c3aa:	4680      	mov	r8, r0
    c3ac:	4689      	mov	r9, r1
    c3ae:	4692      	mov	sl, r2
    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
    c3b0:	3b01      	subs	r3, #1
    c3b2:	9307      	str	r3, [sp, #28]
    c3b4:	a907      	add	r1, sp, #28
    c3b6:	f7ff fef5 	bl	c1a4 <lfs_ctz_index>
    c3ba:	4605      	mov	r5, r0
        int err = cb(data, head);
    c3bc:	4621      	mov	r1, r4
    c3be:	4638      	mov	r0, r7
    c3c0:	47b0      	blx	r6
        if (err) {
    c3c2:	4603      	mov	r3, r0
    c3c4:	2800      	cmp	r0, #0
    c3c6:	d1ec      	bne.n	c3a2 <lfs_ctz_traverse+0x12>
        if (index == 0) {
    c3c8:	2d00      	cmp	r5, #0
    c3ca:	d0ea      	beq.n	c3a2 <lfs_ctz_traverse+0x12>
        int count = 2 - (index & 1);
    c3cc:	f005 0b01 	and.w	fp, r5, #1
    c3d0:	f1cb 0302 	rsb	r3, fp, #2
        err = lfs_bd_read(lfs,
    c3d4:	009b      	lsls	r3, r3, #2
    c3d6:	9303      	str	r3, [sp, #12]
    c3d8:	aa05      	add	r2, sp, #20
    c3da:	9202      	str	r2, [sp, #8]
    c3dc:	2200      	movs	r2, #0
    c3de:	9201      	str	r2, [sp, #4]
    c3e0:	9400      	str	r4, [sp, #0]
    c3e2:	4652      	mov	r2, sl
    c3e4:	4649      	mov	r1, r9
    c3e6:	4640      	mov	r0, r8
    c3e8:	f7ff fefa 	bl	c1e0 <lfs_bd_read>
        if (err) {
    c3ec:	4604      	mov	r4, r0
    c3ee:	b9c8      	cbnz	r0, c424 <lfs_ctz_traverse+0x94>
        for (int i = 0; i < count-1; i++) {
    c3f0:	43eb      	mvns	r3, r5
    c3f2:	f003 0301 	and.w	r3, r3, #1
    c3f6:	42a3      	cmp	r3, r4
    c3f8:	dd0b      	ble.n	c412 <lfs_ctz_traverse+0x82>
            err = cb(data, heads[i]);
    c3fa:	ab08      	add	r3, sp, #32
    c3fc:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    c400:	f853 1c0c 	ldr.w	r1, [r3, #-12]
    c404:	4638      	mov	r0, r7
    c406:	47b0      	blx	r6
            if (err) {
    c408:	4603      	mov	r3, r0
    c40a:	2800      	cmp	r0, #0
    c40c:	d1c9      	bne.n	c3a2 <lfs_ctz_traverse+0x12>
        for (int i = 0; i < count-1; i++) {
    c40e:	3401      	adds	r4, #1
    c410:	e7ee      	b.n	c3f0 <lfs_ctz_traverse+0x60>
        head = heads[count-1];
    c412:	aa08      	add	r2, sp, #32
    c414:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    c418:	f853 4c0c 	ldr.w	r4, [r3, #-12]
        index -= count;
    c41c:	f1ab 0b02 	sub.w	fp, fp, #2
    c420:	445d      	add	r5, fp
    while (true) {
    c422:	e7cb      	b.n	c3bc <lfs_ctz_traverse+0x2c>
            return err;
    c424:	4603      	mov	r3, r0
    c426:	e7bc      	b.n	c3a2 <lfs_ctz_traverse+0x12>

0000c428 <lfs_fs_parent_match>:
        lfs_tag_t tag, const void *buffer) {
    c428:	b530      	push	{r4, r5, lr}
    c42a:	b087      	sub	sp, #28
    c42c:	4604      	mov	r4, r0
    lfs_t *lfs = find->lfs;
    c42e:	6800      	ldr	r0, [r0, #0]
            &lfs->pcache, &lfs->rcache, lfs->cfg->block_size,
    c430:	6e83      	ldr	r3, [r0, #104]	; 0x68
    c432:	69db      	ldr	r3, [r3, #28]
            disk->block, disk->off, &child, sizeof(child));
    c434:	6811      	ldr	r1, [r2, #0]
    c436:	6852      	ldr	r2, [r2, #4]
    int err = lfs_bd_read(lfs,
    c438:	2508      	movs	r5, #8
    c43a:	9503      	str	r5, [sp, #12]
    c43c:	ad04      	add	r5, sp, #16
    c43e:	9502      	str	r5, [sp, #8]
    c440:	9201      	str	r2, [sp, #4]
    c442:	9100      	str	r1, [sp, #0]
    c444:	4602      	mov	r2, r0
    c446:	f100 0110 	add.w	r1, r0, #16
    c44a:	f7ff fec9 	bl	c1e0 <lfs_bd_read>
    if (err) {
    c44e:	4603      	mov	r3, r0
    c450:	b978      	cbnz	r0, c472 <lfs_fs_parent_match+0x4a>
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    c452:	9a04      	ldr	r2, [sp, #16]
    c454:	6861      	ldr	r1, [r4, #4]
    c456:	4291      	cmp	r1, r2
    c458:	d008      	beq.n	c46c <lfs_fs_parent_match+0x44>
    c45a:	9d05      	ldr	r5, [sp, #20]
    c45c:	68a0      	ldr	r0, [r4, #8]
    c45e:	4285      	cmp	r5, r0
    c460:	d004      	beq.n	c46c <lfs_fs_parent_match+0x44>
    c462:	4282      	cmp	r2, r0
    c464:	d002      	beq.n	c46c <lfs_fs_parent_match+0x44>
    c466:	42a9      	cmp	r1, r5
    c468:	d000      	beq.n	c46c <lfs_fs_parent_match+0x44>
    c46a:	2301      	movs	r3, #1
    return (lfs_pair_cmp(child, find->pair) == 0) ? LFS_CMP_EQ : LFS_CMP_LT;
    c46c:	3b00      	subs	r3, #0
    c46e:	bf18      	it	ne
    c470:	2301      	movne	r3, #1
}
    c472:	4618      	mov	r0, r3
    c474:	b007      	add	sp, #28
    c476:	bd30      	pop	{r4, r5, pc}

0000c478 <lfs_dir_getread>:
        lfs_off_t off, void *buffer, lfs_size_t size) {
    c478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c47c:	b087      	sub	sp, #28
    c47e:	4606      	mov	r6, r0
    c480:	468a      	mov	sl, r1
    c482:	4617      	mov	r7, r2
    c484:	461c      	mov	r4, r3
    c486:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
    c48a:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    c48e:	9d13      	ldr	r5, [sp, #76]	; 0x4c
    c490:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
    if (off+size > lfs->cfg->block_size) {
    c494:	eb05 0208 	add.w	r2, r5, r8
    c498:	6e83      	ldr	r3, [r0, #104]	; 0x68
    c49a:	69db      	ldr	r3, [r3, #28]
    c49c:	429a      	cmp	r2, r3
    c49e:	d94d      	bls.n	c53c <lfs_dir_getread+0xc4>
        return LFS_ERR_CORRUPT;
    c4a0:	f06f 0053 	mvn.w	r0, #83	; 0x53
    c4a4:	e076      	b.n	c594 <lfs_dir_getread+0x11c>
                off < pcache->off + pcache->size) {
    c4a6:	687b      	ldr	r3, [r7, #4]
    c4a8:	68ba      	ldr	r2, [r7, #8]
    c4aa:	1899      	adds	r1, r3, r2
        if (pcache && pcache->block == LFS_BLOCK_INLINE &&
    c4ac:	42a9      	cmp	r1, r5
    c4ae:	d91c      	bls.n	c4ea <lfs_dir_getread+0x72>
            if (off >= pcache->off) {
    c4b0:	42ab      	cmp	r3, r5
    c4b2:	d904      	bls.n	c4be <lfs_dir_getread+0x46>
            diff = lfs_min(diff, pcache->off-off);
    c4b4:	1b5b      	subs	r3, r3, r5
	return (a < b) ? a : b;
    c4b6:	4543      	cmp	r3, r8
    c4b8:	bf28      	it	cs
    c4ba:	4643      	movcs	r3, r8
    c4bc:	e048      	b.n	c550 <lfs_dir_getread+0xd8>
                diff = lfs_min(diff, pcache->size - (off-pcache->off));
    c4be:	1b59      	subs	r1, r3, r5
    c4c0:	440a      	add	r2, r1
    c4c2:	4542      	cmp	r2, r8
    c4c4:	bf28      	it	cs
    c4c6:	4642      	movcs	r2, r8
                memcpy(data, &pcache->buffer[off-pcache->off], diff);
    c4c8:	68f9      	ldr	r1, [r7, #12]
    c4ca:	1aeb      	subs	r3, r5, r3
    c4cc:	9205      	str	r2, [sp, #20]
    c4ce:	4419      	add	r1, r3
    c4d0:	9814      	ldr	r0, [sp, #80]	; 0x50
    c4d2:	f7fe f8f3 	bl	a6bc <memcpy>
                data += diff;
    c4d6:	9b14      	ldr	r3, [sp, #80]	; 0x50
    c4d8:	9a05      	ldr	r2, [sp, #20]
    c4da:	4413      	add	r3, r2
    c4dc:	9314      	str	r3, [sp, #80]	; 0x50
                off += diff;
    c4de:	4415      	add	r5, r2
                size -= diff;
    c4e0:	eba8 0802 	sub.w	r8, r8, r2
                continue;
    c4e4:	e02a      	b.n	c53c <lfs_dir_getread+0xc4>
        lfs_size_t diff = size;
    c4e6:	4643      	mov	r3, r8
    c4e8:	e032      	b.n	c550 <lfs_dir_getread+0xd8>
    c4ea:	4643      	mov	r3, r8
    c4ec:	e030      	b.n	c550 <lfs_dir_getread+0xd8>
        rcache->block = LFS_BLOCK_INLINE;
    c4ee:	f06f 0301 	mvn.w	r3, #1
    c4f2:	6023      	str	r3, [r4, #0]
        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
    c4f4:	6eb3      	ldr	r3, [r6, #104]	; 0x68
    c4f6:	695b      	ldr	r3, [r3, #20]
	return a - (a % alignment);
    c4f8:	fbb5 f2f3 	udiv	r2, r5, r3
    c4fc:	fb03 5212 	mls	r2, r3, r2, r5
    c500:	1aaa      	subs	r2, r5, r2
    c502:	6062      	str	r2, [r4, #4]
        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),
    c504:	eb05 030b 	add.w	r3, r5, fp
    c508:	6eb1      	ldr	r1, [r6, #104]	; 0x68
    c50a:	6948      	ldr	r0, [r1, #20]
	return lfs_aligndown(a + alignment-1, alignment);
    c50c:	4403      	add	r3, r0
    c50e:	3b01      	subs	r3, #1
	return a - (a % alignment);
    c510:	fbb3 fcf0 	udiv	ip, r3, r0
    c514:	fb00 301c 	mls	r0, r0, ip, r3
    c518:	1a1b      	subs	r3, r3, r0
                lfs->cfg->cache_size);
    c51a:	6a89      	ldr	r1, [r1, #40]	; 0x28
	return (a < b) ? a : b;
    c51c:	428b      	cmp	r3, r1
    c51e:	bf28      	it	cs
    c520:	460b      	movcs	r3, r1
        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),
    c522:	60a3      	str	r3, [r4, #8]
                rcache->off, rcache->buffer, rcache->size);
    c524:	68e1      	ldr	r1, [r4, #12]
        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,
    c526:	9302      	str	r3, [sp, #8]
    c528:	9101      	str	r1, [sp, #4]
    c52a:	9200      	str	r2, [sp, #0]
    c52c:	464b      	mov	r3, r9
    c52e:	9a11      	ldr	r2, [sp, #68]	; 0x44
    c530:	4651      	mov	r1, sl
    c532:	4630      	mov	r0, r6
    c534:	f7f9 f852 	bl	55dc <lfs_dir_getslice>
        if (err < 0) {
    c538:	2800      	cmp	r0, #0
    c53a:	db2b      	blt.n	c594 <lfs_dir_getread+0x11c>
    while (size > 0) {
    c53c:	f1b8 0f00 	cmp.w	r8, #0
    c540:	d027      	beq.n	c592 <lfs_dir_getread+0x11a>
        if (pcache && pcache->block == LFS_BLOCK_INLINE &&
    c542:	2f00      	cmp	r7, #0
    c544:	d0cf      	beq.n	c4e6 <lfs_dir_getread+0x6e>
    c546:	683b      	ldr	r3, [r7, #0]
    c548:	f113 0f02 	cmn.w	r3, #2
    c54c:	d0ab      	beq.n	c4a6 <lfs_dir_getread+0x2e>
        lfs_size_t diff = size;
    c54e:	4643      	mov	r3, r8
        if (rcache->block == LFS_BLOCK_INLINE &&
    c550:	6822      	ldr	r2, [r4, #0]
    c552:	f112 0f02 	cmn.w	r2, #2
    c556:	d1ca      	bne.n	c4ee <lfs_dir_getread+0x76>
                off < rcache->off + rcache->size) {
    c558:	6862      	ldr	r2, [r4, #4]
    c55a:	68a1      	ldr	r1, [r4, #8]
    c55c:	1850      	adds	r0, r2, r1
        if (rcache->block == LFS_BLOCK_INLINE &&
    c55e:	42a8      	cmp	r0, r5
    c560:	d9c5      	bls.n	c4ee <lfs_dir_getread+0x76>
            if (off >= rcache->off) {
    c562:	42aa      	cmp	r2, r5
    c564:	d8c3      	bhi.n	c4ee <lfs_dir_getread+0x76>
                diff = lfs_min(diff, rcache->size - (off-rcache->off));
    c566:	1b50      	subs	r0, r2, r5
    c568:	4401      	add	r1, r0
    c56a:	4299      	cmp	r1, r3
    c56c:	bf28      	it	cs
    c56e:	4619      	movcs	r1, r3
    c570:	4608      	mov	r0, r1
                memcpy(data, &rcache->buffer[off-rcache->off], diff);
    c572:	68e3      	ldr	r3, [r4, #12]
    c574:	1aa9      	subs	r1, r5, r2
    c576:	9005      	str	r0, [sp, #20]
    c578:	4602      	mov	r2, r0
    c57a:	4419      	add	r1, r3
    c57c:	9814      	ldr	r0, [sp, #80]	; 0x50
    c57e:	f7fe f89d 	bl	a6bc <memcpy>
                data += diff;
    c582:	9b14      	ldr	r3, [sp, #80]	; 0x50
    c584:	9805      	ldr	r0, [sp, #20]
    c586:	4403      	add	r3, r0
    c588:	9314      	str	r3, [sp, #80]	; 0x50
                off += diff;
    c58a:	4405      	add	r5, r0
                size -= diff;
    c58c:	eba8 0800 	sub.w	r8, r8, r0
                continue;
    c590:	e7d4      	b.n	c53c <lfs_dir_getread+0xc4>
    return 0;
    c592:	2000      	movs	r0, #0
}
    c594:	b007      	add	sp, #28
    c596:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000c59a <lfs_bd_cmp>:
        const void *buffer, lfs_size_t size) {
    c59a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c59e:	b089      	sub	sp, #36	; 0x24
    c5a0:	4682      	mov	sl, r0
    c5a2:	4689      	mov	r9, r1
    c5a4:	9205      	str	r2, [sp, #20]
    c5a6:	461f      	mov	r7, r3
    c5a8:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
    c5ac:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    c5b0:	9e15      	ldr	r6, [sp, #84]	; 0x54
    for (lfs_off_t i = 0; i < size; i += diff) {
    c5b2:	2400      	movs	r4, #0
    c5b4:	e002      	b.n	c5bc <lfs_bd_cmp+0x22>
            return res < 0 ? LFS_CMP_LT : LFS_CMP_GT;
    c5b6:	2301      	movs	r3, #1
    c5b8:	e023      	b.n	c602 <lfs_bd_cmp+0x68>
    for (lfs_off_t i = 0; i < size; i += diff) {
    c5ba:	442c      	add	r4, r5
    c5bc:	42b4      	cmp	r4, r6
    c5be:	d21f      	bcs.n	c600 <lfs_bd_cmp+0x66>
        diff = lfs_min(size-i, sizeof(dat));
    c5c0:	1b35      	subs	r5, r6, r4
    c5c2:	2d08      	cmp	r5, #8
    c5c4:	bf28      	it	cs
    c5c6:	2508      	movcs	r5, #8
        int res = lfs_bd_read(lfs,
    c5c8:	9503      	str	r5, [sp, #12]
    c5ca:	ab06      	add	r3, sp, #24
    c5cc:	9302      	str	r3, [sp, #8]
    c5ce:	eb04 0308 	add.w	r3, r4, r8
    c5d2:	9301      	str	r3, [sp, #4]
    c5d4:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c5d6:	9300      	str	r3, [sp, #0]
    c5d8:	1b3b      	subs	r3, r7, r4
    c5da:	9a05      	ldr	r2, [sp, #20]
    c5dc:	4649      	mov	r1, r9
    c5de:	4650      	mov	r0, sl
    c5e0:	f7ff fdfe 	bl	c1e0 <lfs_bd_read>
        if (res) {
    c5e4:	4603      	mov	r3, r0
    c5e6:	b960      	cbnz	r0, c602 <lfs_bd_cmp+0x68>
        res = memcmp(dat, data + i, diff);
    c5e8:	462a      	mov	r2, r5
    c5ea:	eb0b 0104 	add.w	r1, fp, r4
    c5ee:	a806      	add	r0, sp, #24
    c5f0:	f7fe f852 	bl	a698 <memcmp>
        if (res) {
    c5f4:	2800      	cmp	r0, #0
    c5f6:	d0e0      	beq.n	c5ba <lfs_bd_cmp+0x20>
            return res < 0 ? LFS_CMP_LT : LFS_CMP_GT;
    c5f8:	2800      	cmp	r0, #0
    c5fa:	dbdc      	blt.n	c5b6 <lfs_bd_cmp+0x1c>
    c5fc:	2302      	movs	r3, #2
    c5fe:	e000      	b.n	c602 <lfs_bd_cmp+0x68>
    return LFS_CMP_EQ;
    c600:	2300      	movs	r3, #0
}
    c602:	4618      	mov	r0, r3
    c604:	b009      	add	sp, #36	; 0x24
    c606:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000c60a <lfs_bd_flush>:
        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
    c60a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    c60e:	b085      	sub	sp, #20
    c610:	460c      	mov	r4, r1
    if (pcache->block != LFS_BLOCK_NULL && pcache->block != LFS_BLOCK_INLINE) {
    c612:	6809      	ldr	r1, [r1, #0]
    c614:	f111 0f03 	cmn.w	r1, #3
    c618:	d831      	bhi.n	c67e <lfs_bd_flush+0x74>
    c61a:	4606      	mov	r6, r0
    c61c:	4617      	mov	r7, r2
    c61e:	4698      	mov	r8, r3
        lfs_size_t diff = lfs_alignup(pcache->size, lfs->cfg->prog_size);
    c620:	68a5      	ldr	r5, [r4, #8]
    c622:	6e80      	ldr	r0, [r0, #104]	; 0x68
    c624:	6982      	ldr	r2, [r0, #24]
	return lfs_aligndown(a + alignment-1, alignment);
    c626:	4415      	add	r5, r2
    c628:	f105 3cff 	add.w	ip, r5, #4294967295	; 0xffffffff
	return a - (a % alignment);
    c62c:	fbbc f3f2 	udiv	r3, ip, r2
    c630:	fb02 c313 	mls	r3, r2, r3, ip
    c634:	ebac 0503 	sub.w	r5, ip, r3
        int err = lfs->cfg->prog(lfs->cfg, pcache->block,
    c638:	f8d0 9008 	ldr.w	r9, [r0, #8]
    c63c:	9500      	str	r5, [sp, #0]
    c63e:	68e3      	ldr	r3, [r4, #12]
    c640:	6862      	ldr	r2, [r4, #4]
    c642:	47c8      	blx	r9
        if (err) {
    c644:	4681      	mov	r9, r0
    c646:	b9e0      	cbnz	r0, c682 <lfs_bd_flush+0x78>
        if (validate) {
    c648:	f1b8 0f00 	cmp.w	r8, #0
    c64c:	d012      	beq.n	c674 <lfs_bd_flush+0x6a>
    rcache->block = LFS_BLOCK_NULL;
    c64e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c652:	603b      	str	r3, [r7, #0]
                    pcache->block, pcache->off, pcache->buffer, diff);
    c654:	68e3      	ldr	r3, [r4, #12]
            int res = lfs_bd_cmp(lfs,
    c656:	9503      	str	r5, [sp, #12]
    c658:	9302      	str	r3, [sp, #8]
    c65a:	6863      	ldr	r3, [r4, #4]
    c65c:	9301      	str	r3, [sp, #4]
    c65e:	6823      	ldr	r3, [r4, #0]
    c660:	9300      	str	r3, [sp, #0]
    c662:	462b      	mov	r3, r5
    c664:	463a      	mov	r2, r7
    c666:	2100      	movs	r1, #0
    c668:	4630      	mov	r0, r6
    c66a:	f7ff ff96 	bl	c59a <lfs_bd_cmp>
            if (res < 0) {
    c66e:	2800      	cmp	r0, #0
    c670:	db0b      	blt.n	c68a <lfs_bd_flush+0x80>
            if (res != LFS_CMP_EQ) {
    c672:	b960      	cbnz	r0, c68e <lfs_bd_flush+0x84>
        lfs_cache_zero(lfs, pcache);
    c674:	4621      	mov	r1, r4
    c676:	4630      	mov	r0, r6
    c678:	f7ff fd88 	bl	c18c <lfs_cache_zero>
    c67c:	e001      	b.n	c682 <lfs_bd_flush+0x78>
    return 0;
    c67e:	f04f 0900 	mov.w	r9, #0
}
    c682:	4648      	mov	r0, r9
    c684:	b005      	add	sp, #20
    c686:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                return res;
    c68a:	4681      	mov	r9, r0
    c68c:	e7f9      	b.n	c682 <lfs_bd_flush+0x78>
                return LFS_ERR_CORRUPT;
    c68e:	f06f 0953 	mvn.w	r9, #83	; 0x53
    c692:	e7f6      	b.n	c682 <lfs_bd_flush+0x78>

0000c694 <lfs_bd_prog>:
        const void *buffer, lfs_size_t size) {
    c694:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c698:	b083      	sub	sp, #12
    c69a:	4607      	mov	r7, r0
    c69c:	460c      	mov	r4, r1
    c69e:	4693      	mov	fp, r2
    c6a0:	9301      	str	r3, [sp, #4]
    c6a2:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    c6a4:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    c6a6:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
    c6aa:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    while (size > 0) {
    c6ae:	e00a      	b.n	c6c6 <lfs_bd_prog+0x32>
        pcache->block = block;
    c6b0:	6026      	str	r6, [r4, #0]
        pcache->off = lfs_aligndown(off, lfs->cfg->prog_size);
    c6b2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    c6b4:	699a      	ldr	r2, [r3, #24]
    c6b6:	fbb5 f3f2 	udiv	r3, r5, r2
    c6ba:	fb02 5313 	mls	r3, r2, r3, r5
    c6be:	1aeb      	subs	r3, r5, r3
    c6c0:	6063      	str	r3, [r4, #4]
        pcache->size = 0;
    c6c2:	2300      	movs	r3, #0
    c6c4:	60a3      	str	r3, [r4, #8]
    while (size > 0) {
    c6c6:	f1b8 0f00 	cmp.w	r8, #0
    c6ca:	d02e      	beq.n	c72a <lfs_bd_prog+0x96>
        if (block == pcache->block &&
    c6cc:	6823      	ldr	r3, [r4, #0]
    c6ce:	42b3      	cmp	r3, r6
    c6d0:	d1ee      	bne.n	c6b0 <lfs_bd_prog+0x1c>
                off >= pcache->off &&
    c6d2:	6860      	ldr	r0, [r4, #4]
        if (block == pcache->block &&
    c6d4:	42a8      	cmp	r0, r5
    c6d6:	d8eb      	bhi.n	c6b0 <lfs_bd_prog+0x1c>
                off < pcache->off + lfs->cfg->cache_size) {
    c6d8:	6eba      	ldr	r2, [r7, #104]	; 0x68
    c6da:	6a92      	ldr	r2, [r2, #40]	; 0x28
    c6dc:	1881      	adds	r1, r0, r2
                off >= pcache->off &&
    c6de:	42a9      	cmp	r1, r5
    c6e0:	d9e6      	bls.n	c6b0 <lfs_bd_prog+0x1c>
                    lfs->cfg->cache_size - (off-pcache->off));
    c6e2:	1b41      	subs	r1, r0, r5
            lfs_size_t diff = lfs_min(size,
    c6e4:	eb02 0901 	add.w	r9, r2, r1
	return (a < b) ? a : b;
    c6e8:	45c1      	cmp	r9, r8
    c6ea:	bf28      	it	cs
    c6ec:	46c1      	movcs	r9, r8
            memcpy(&pcache->buffer[off-pcache->off], data, diff);
    c6ee:	1a28      	subs	r0, r5, r0
    c6f0:	464a      	mov	r2, r9
    c6f2:	4651      	mov	r1, sl
    c6f4:	68e3      	ldr	r3, [r4, #12]
    c6f6:	4418      	add	r0, r3
    c6f8:	f7fd ffe0 	bl	a6bc <memcpy>
            data += diff;
    c6fc:	44ca      	add	sl, r9
            off += diff;
    c6fe:	444d      	add	r5, r9
            size -= diff;
    c700:	eba8 0809 	sub.w	r8, r8, r9
            pcache->size = lfs_max(pcache->size, off - pcache->off);
    c704:	68a2      	ldr	r2, [r4, #8]
    c706:	6863      	ldr	r3, [r4, #4]
    c708:	1aeb      	subs	r3, r5, r3
	return (a > b) ? a : b;
    c70a:	4293      	cmp	r3, r2
    c70c:	bf38      	it	cc
    c70e:	4613      	movcc	r3, r2
    c710:	60a3      	str	r3, [r4, #8]
            if (pcache->size == lfs->cfg->cache_size) {
    c712:	6eba      	ldr	r2, [r7, #104]	; 0x68
    c714:	6a92      	ldr	r2, [r2, #40]	; 0x28
    c716:	429a      	cmp	r2, r3
    c718:	d1d5      	bne.n	c6c6 <lfs_bd_prog+0x32>
                int err = lfs_bd_flush(lfs, pcache, rcache, validate);
    c71a:	9b01      	ldr	r3, [sp, #4]
    c71c:	465a      	mov	r2, fp
    c71e:	4621      	mov	r1, r4
    c720:	4638      	mov	r0, r7
    c722:	f7ff ff72 	bl	c60a <lfs_bd_flush>
                if (err) {
    c726:	b908      	cbnz	r0, c72c <lfs_bd_prog+0x98>
    c728:	e7cd      	b.n	c6c6 <lfs_bd_prog+0x32>
    return 0;
    c72a:	2000      	movs	r0, #0
}
    c72c:	b003      	add	sp, #12
    c72e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000c732 <lfs_bd_sync>:
        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
    c732:	b538      	push	{r3, r4, r5, lr}
    c734:	4604      	mov	r4, r0
    rcache->block = LFS_BLOCK_NULL;
    c736:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    c73a:	6015      	str	r5, [r2, #0]
    int err = lfs_bd_flush(lfs, pcache, rcache, validate);
    c73c:	f7ff ff65 	bl	c60a <lfs_bd_flush>
    if (err) {
    c740:	b910      	cbnz	r0, c748 <lfs_bd_sync+0x16>
    err = lfs->cfg->sync(lfs->cfg);
    c742:	6ea0      	ldr	r0, [r4, #104]	; 0x68
    c744:	6903      	ldr	r3, [r0, #16]
    c746:	4798      	blx	r3
}
    c748:	bd38      	pop	{r3, r4, r5, pc}

0000c74a <lfs_dir_find_match>:
        lfs_tag_t tag, const void *buffer) {
    c74a:	b530      	push	{r4, r5, lr}
    c74c:	b085      	sub	sp, #20
    c74e:	4604      	mov	r4, r0
    c750:	4694      	mov	ip, r2
    lfs_t *lfs = name->lfs;
    c752:	6800      	ldr	r0, [r0, #0]
    lfs_size_t diff = lfs_min(name->size, lfs_tag_size(tag));
    c754:	68a3      	ldr	r3, [r4, #8]
    return tag & 0x000003ff;
    c756:	f3c1 0509 	ubfx	r5, r1, #0, #10
	return (a < b) ? a : b;
    c75a:	42ab      	cmp	r3, r5
    c75c:	bf28      	it	cs
    c75e:	462b      	movcs	r3, r5
            disk->block, disk->off, name->name, diff);
    c760:	6812      	ldr	r2, [r2, #0]
    c762:	f8dc 1004 	ldr.w	r1, [ip, #4]
    int res = lfs_bd_cmp(lfs,
    c766:	9303      	str	r3, [sp, #12]
    c768:	f8d4 c004 	ldr.w	ip, [r4, #4]
    c76c:	f8cd c008 	str.w	ip, [sp, #8]
    c770:	9101      	str	r1, [sp, #4]
    c772:	9200      	str	r2, [sp, #0]
    c774:	4602      	mov	r2, r0
    c776:	2100      	movs	r1, #0
    c778:	f7ff ff0f 	bl	c59a <lfs_bd_cmp>
    if (res != LFS_CMP_EQ) {
    c77c:	b920      	cbnz	r0, c788 <lfs_dir_find_match+0x3e>
    if (name->size != lfs_tag_size(tag)) {
    c77e:	68a3      	ldr	r3, [r4, #8]
    c780:	42ab      	cmp	r3, r5
    c782:	d001      	beq.n	c788 <lfs_dir_find_match+0x3e>
        return (name->size < lfs_tag_size(tag)) ? LFS_CMP_LT : LFS_CMP_GT;
    c784:	d202      	bcs.n	c78c <lfs_dir_find_match+0x42>
    c786:	2001      	movs	r0, #1
}
    c788:	b005      	add	sp, #20
    c78a:	bd30      	pop	{r4, r5, pc}
        return (name->size < lfs_tag_size(tag)) ? LFS_CMP_LT : LFS_CMP_GT;
    c78c:	2002      	movs	r0, #2
    c78e:	e7fb      	b.n	c788 <lfs_dir_find_match+0x3e>

0000c790 <lfs_ctz_find>:
        lfs_size_t pos, lfs_block_t *block, lfs_off_t *off) {
    c790:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    c794:	b089      	sub	sp, #36	; 0x24
    c796:	9305      	str	r3, [sp, #20]
    c798:	9b10      	ldr	r3, [sp, #64]	; 0x40
    if (size == 0) {
    c79a:	b953      	cbnz	r3, c7b2 <lfs_ctz_find+0x22>
        *block = LFS_BLOCK_NULL;
    c79c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c7a0:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c7a2:	6013      	str	r3, [r2, #0]
        *off = 0;
    c7a4:	2300      	movs	r3, #0
    c7a6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    c7a8:	6013      	str	r3, [r2, #0]
}
    c7aa:	4618      	mov	r0, r3
    c7ac:	b009      	add	sp, #36	; 0x24
    c7ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    c7b2:	4607      	mov	r7, r0
    c7b4:	4688      	mov	r8, r1
    c7b6:	4691      	mov	r9, r2
    lfs_off_t current = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
    c7b8:	3b01      	subs	r3, #1
    c7ba:	9307      	str	r3, [sp, #28]
    c7bc:	a907      	add	r1, sp, #28
    c7be:	f7ff fcf1 	bl	c1a4 <lfs_ctz_index>
    c7c2:	4605      	mov	r5, r0
    lfs_off_t target = lfs_ctz_index(lfs, &pos);
    c7c4:	a911      	add	r1, sp, #68	; 0x44
    c7c6:	4638      	mov	r0, r7
    c7c8:	f7ff fcec 	bl	c1a4 <lfs_ctz_index>
    c7cc:	4606      	mov	r6, r0
    while (current > target) {
    c7ce:	42b5      	cmp	r5, r6
    c7d0:	d91f      	bls.n	c812 <lfs_ctz_find+0x82>
                lfs_npw2(current-target+1) - 1,
    c7d2:	1bac      	subs	r4, r5, r6
	return 32 - __builtin_clz(a-1);
    c7d4:	fab4 f484 	clz	r4, r4
        lfs_size_t skip = lfs_min(
    c7d8:	f1c4 041f 	rsb	r4, r4, #31
	return __builtin_ctz(a);
    c7dc:	fa95 f3a5 	rbit	r3, r5
    c7e0:	fab3 f383 	clz	r3, r3
	return (a < b) ? a : b;
    c7e4:	429c      	cmp	r4, r3
    c7e6:	bf28      	it	cs
    c7e8:	461c      	movcs	r4, r3
        int err = lfs_bd_read(lfs,
    c7ea:	2304      	movs	r3, #4
    c7ec:	9303      	str	r3, [sp, #12]
    c7ee:	aa05      	add	r2, sp, #20
    c7f0:	9202      	str	r2, [sp, #8]
    c7f2:	00a2      	lsls	r2, r4, #2
    c7f4:	9201      	str	r2, [sp, #4]
    c7f6:	9a05      	ldr	r2, [sp, #20]
    c7f8:	9200      	str	r2, [sp, #0]
    c7fa:	464a      	mov	r2, r9
    c7fc:	4641      	mov	r1, r8
    c7fe:	4638      	mov	r0, r7
    c800:	f7ff fcee 	bl	c1e0 <lfs_bd_read>
        if (err) {
    c804:	4603      	mov	r3, r0
    c806:	2800      	cmp	r0, #0
    c808:	d1cf      	bne.n	c7aa <lfs_ctz_find+0x1a>
        current -= 1 << skip;
    c80a:	2301      	movs	r3, #1
    c80c:	40a3      	lsls	r3, r4
    c80e:	1aed      	subs	r5, r5, r3
    c810:	e7dd      	b.n	c7ce <lfs_ctz_find+0x3e>
    *block = head;
    c812:	9b05      	ldr	r3, [sp, #20]
    c814:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c816:	6013      	str	r3, [r2, #0]
    *off = pos;
    c818:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c81a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    c81c:	6013      	str	r3, [r2, #0]
    return 0;
    c81e:	2300      	movs	r3, #0
    c820:	e7c3      	b.n	c7aa <lfs_ctz_find+0x1a>

0000c822 <lfs_dir_fetch>:
        lfs_mdir_t *dir, const lfs_block_t pair[2]) {
    c822:	b500      	push	{lr}
    c824:	b085      	sub	sp, #20
    return (int)lfs_dir_fetchmatch(lfs, dir, pair,
    c826:	2300      	movs	r3, #0
    c828:	9303      	str	r3, [sp, #12]
    c82a:	9302      	str	r3, [sp, #8]
    c82c:	9301      	str	r3, [sp, #4]
    c82e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c832:	9300      	str	r3, [sp, #0]
    c834:	f7f9 f998 	bl	5b68 <lfs_dir_fetchmatch>
}
    c838:	b005      	add	sp, #20
    c83a:	f85d fb04 	ldr.w	pc, [sp], #4

0000c83e <lfs_dir_alloc>:
static int lfs_dir_alloc(lfs_t *lfs, lfs_mdir_t *dir) {
    c83e:	b570      	push	{r4, r5, r6, lr}
    c840:	b084      	sub	sp, #16
    c842:	4606      	mov	r6, r0
    c844:	460c      	mov	r4, r1
    for (int i = 0; i < 2; i++) {
    c846:	2500      	movs	r5, #0
    c848:	2d01      	cmp	r5, #1
    c84a:	dc0d      	bgt.n	c868 <lfs_dir_alloc+0x2a>
        int err = lfs_alloc(lfs, &dir->pair[(i+1)%2]);
    c84c:	3501      	adds	r5, #1
    c84e:	f005 0101 	and.w	r1, r5, #1
    c852:	bf48      	it	mi
    c854:	4249      	negmi	r1, r1
    c856:	eb04 0181 	add.w	r1, r4, r1, lsl #2
    c85a:	4630      	mov	r0, r6
    c85c:	f7f9 fcd8 	bl	6210 <lfs_alloc>
        if (err) {
    c860:	4603      	mov	r3, r0
    c862:	2800      	cmp	r0, #0
    c864:	d0f0      	beq.n	c848 <lfs_dir_alloc+0xa>
    c866:	e02d      	b.n	c8c4 <lfs_dir_alloc+0x86>
    dir->rev = 0;
    c868:	2100      	movs	r1, #0
    c86a:	4622      	mov	r2, r4
    c86c:	f842 1f08 	str.w	r1, [r2, #8]!
    int err = lfs_bd_read(lfs,
    c870:	2304      	movs	r3, #4
    c872:	9303      	str	r3, [sp, #12]
    c874:	9202      	str	r2, [sp, #8]
    c876:	9101      	str	r1, [sp, #4]
    c878:	6822      	ldr	r2, [r4, #0]
    c87a:	9200      	str	r2, [sp, #0]
    c87c:	4632      	mov	r2, r6
    c87e:	4630      	mov	r0, r6
    c880:	f7ff fcae 	bl	c1e0 <lfs_bd_read>
    dir->rev = lfs_fromle32(dir->rev);
    c884:	68a2      	ldr	r2, [r4, #8]
    if (err && err != LFS_ERR_CORRUPT) {
    c886:	4603      	mov	r3, r0
    c888:	b110      	cbz	r0, c890 <lfs_dir_alloc+0x52>
    c88a:	f110 0f54 	cmn.w	r0, #84	; 0x54
    c88e:	d119      	bne.n	c8c4 <lfs_dir_alloc+0x86>
    if (lfs->cfg->block_cycles > 0) {
    c890:	6eb3      	ldr	r3, [r6, #104]	; 0x68
    c892:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    c894:	2b00      	cmp	r3, #0
    c896:	dd0a      	ble.n	c8ae <lfs_dir_alloc+0x70>
        dir->rev = lfs_alignup(dir->rev, ((lfs->cfg->block_cycles+1)|1));
    c898:	3301      	adds	r3, #1
    c89a:	f043 0101 	orr.w	r1, r3, #1
	return lfs_aligndown(a + alignment-1, alignment);
    c89e:	1853      	adds	r3, r2, r1
    c8a0:	3b01      	subs	r3, #1
	return a - (a % alignment);
    c8a2:	fbb3 f2f1 	udiv	r2, r3, r1
    c8a6:	fb01 3212 	mls	r2, r1, r2, r3
    c8aa:	1a9b      	subs	r3, r3, r2
    c8ac:	60a3      	str	r3, [r4, #8]
    dir->off = sizeof(dir->rev);
    c8ae:	2304      	movs	r3, #4
    c8b0:	60e3      	str	r3, [r4, #12]
    dir->etag = 0xffffffff;
    c8b2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    c8b6:	6122      	str	r2, [r4, #16]
    dir->count = 0;
    c8b8:	2300      	movs	r3, #0
    c8ba:	82a3      	strh	r3, [r4, #20]
    dir->tail[0] = LFS_BLOCK_NULL;
    c8bc:	61a2      	str	r2, [r4, #24]
    dir->tail[1] = LFS_BLOCK_NULL;
    c8be:	61e2      	str	r2, [r4, #28]
    dir->erased = false;
    c8c0:	75a3      	strb	r3, [r4, #22]
    dir->split = false;
    c8c2:	75e3      	strb	r3, [r4, #23]
}
    c8c4:	4618      	mov	r0, r3
    c8c6:	b004      	add	sp, #16
    c8c8:	bd70      	pop	{r4, r5, r6, pc}

0000c8ca <lfs_file_outline>:
static int lfs_file_outline(lfs_t *lfs, lfs_file_t *file) {
    c8ca:	b538      	push	{r3, r4, r5, lr}
    c8cc:	4605      	mov	r5, r0
    c8ce:	460c      	mov	r4, r1
    file->off = file->pos;
    c8d0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    c8d2:	63cb      	str	r3, [r1, #60]	; 0x3c
    lfs_alloc_ack(lfs);
    c8d4:	f7ff fc06 	bl	c0e4 <lfs_alloc_ack>
    int err = lfs_file_relocate(lfs, file);
    c8d8:	4621      	mov	r1, r4
    c8da:	4628      	mov	r0, r5
    c8dc:	f7f9 fd0a 	bl	62f4 <lfs_file_relocate>
    if (err) {
    c8e0:	b918      	cbnz	r0, c8ea <lfs_file_outline+0x20>
    file->flags &= ~LFS_F_INLINE;
    c8e2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    c8e4:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    c8e8:	6323      	str	r3, [r4, #48]	; 0x30
}
    c8ea:	bd38      	pop	{r3, r4, r5, pc}

0000c8ec <lfs_ctz_extend>:
        lfs_block_t *block, lfs_off_t *off) {
    c8ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c8f0:	b08b      	sub	sp, #44	; 0x2c
    c8f2:	4605      	mov	r5, r0
    c8f4:	460f      	mov	r7, r1
    c8f6:	4616      	mov	r6, r2
    c8f8:	9305      	str	r3, [sp, #20]
    c8fa:	e044      	b.n	c986 <lfs_ctz_extend+0x9a>
            if (size == 0) {
    c8fc:	9b14      	ldr	r3, [sp, #80]	; 0x50
    c8fe:	2b00      	cmp	r3, #0
    c900:	d032      	beq.n	c968 <lfs_ctz_extend+0x7c>
            lfs_size_t noff = size - 1;
    c902:	9b14      	ldr	r3, [sp, #80]	; 0x50
    c904:	3b01      	subs	r3, #1
    c906:	9308      	str	r3, [sp, #32]
            lfs_off_t index = lfs_ctz_index(lfs, &noff);
    c908:	a908      	add	r1, sp, #32
    c90a:	4628      	mov	r0, r5
    c90c:	f7ff fc4a 	bl	c1a4 <lfs_ctz_index>
            noff = noff + 1;
    c910:	9b08      	ldr	r3, [sp, #32]
    c912:	3301      	adds	r3, #1
    c914:	9308      	str	r3, [sp, #32]
            if (noff != lfs->cfg->block_size) {
    c916:	6eaa      	ldr	r2, [r5, #104]	; 0x68
    c918:	69d2      	ldr	r2, [r2, #28]
    c91a:	4293      	cmp	r3, r2
    c91c:	d052      	beq.n	c9c4 <lfs_ctz_extend+0xd8>
                for (lfs_off_t i = 0; i < noff; i++) {
    c91e:	2400      	movs	r4, #0
    c920:	46b9      	mov	r9, r7
    c922:	9f05      	ldr	r7, [sp, #20]
    c924:	9b08      	ldr	r3, [sp, #32]
    c926:	42a3      	cmp	r3, r4
    c928:	d941      	bls.n	c9ae <lfs_ctz_extend+0xc2>
                    err = lfs_bd_read(lfs,
    c92a:	2201      	movs	r2, #1
    c92c:	9203      	str	r2, [sp, #12]
    c92e:	aa09      	add	r2, sp, #36	; 0x24
    c930:	9202      	str	r2, [sp, #8]
    c932:	9401      	str	r4, [sp, #4]
    c934:	9700      	str	r7, [sp, #0]
    c936:	1b1b      	subs	r3, r3, r4
    c938:	4632      	mov	r2, r6
    c93a:	2100      	movs	r1, #0
    c93c:	4628      	mov	r0, r5
    c93e:	f7ff fc4f 	bl	c1e0 <lfs_bd_read>
                    if (err) {
    c942:	4603      	mov	r3, r0
    c944:	2800      	cmp	r0, #0
    c946:	d130      	bne.n	c9aa <lfs_ctz_extend+0xbe>
                    err = lfs_bd_prog(lfs,
    c948:	2301      	movs	r3, #1
    c94a:	9303      	str	r3, [sp, #12]
    c94c:	aa09      	add	r2, sp, #36	; 0x24
    c94e:	9202      	str	r2, [sp, #8]
    c950:	9401      	str	r4, [sp, #4]
    c952:	9a07      	ldr	r2, [sp, #28]
    c954:	9200      	str	r2, [sp, #0]
    c956:	4632      	mov	r2, r6
    c958:	4649      	mov	r1, r9
    c95a:	4628      	mov	r0, r5
    c95c:	f7ff fe9a 	bl	c694 <lfs_bd_prog>
                    if (err) {
    c960:	4603      	mov	r3, r0
    c962:	b948      	cbnz	r0, c978 <lfs_ctz_extend+0x8c>
                for (lfs_off_t i = 0; i < noff; i++) {
    c964:	3401      	adds	r4, #1
    c966:	e7dd      	b.n	c924 <lfs_ctz_extend+0x38>
                *block = nblock;
    c968:	4682      	mov	sl, r0
    c96a:	9b07      	ldr	r3, [sp, #28]
    c96c:	9a15      	ldr	r2, [sp, #84]	; 0x54
    c96e:	6013      	str	r3, [r2, #0]
                *off = 0;
    c970:	2300      	movs	r3, #0
    c972:	9a16      	ldr	r2, [sp, #88]	; 0x58
    c974:	6013      	str	r3, [r2, #0]
                return 0;
    c976:	e021      	b.n	c9bc <lfs_ctz_extend+0xd0>
                        if (err == LFS_ERR_CORRUPT) {
    c978:	464f      	mov	r7, r9
    c97a:	f110 0f54 	cmn.w	r0, #84	; 0x54
    c97e:	d114      	bne.n	c9aa <lfs_ctz_extend+0xbe>
    rcache->block = LFS_BLOCK_NULL;
    c980:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c984:	603b      	str	r3, [r7, #0]
        int err = lfs_alloc(lfs, &nblock);
    c986:	a907      	add	r1, sp, #28
    c988:	4628      	mov	r0, r5
    c98a:	f7f9 fc41 	bl	6210 <lfs_alloc>
        if (err) {
    c98e:	2800      	cmp	r0, #0
    c990:	d159      	bne.n	ca46 <lfs_ctz_extend+0x15a>
            err = lfs_bd_erase(lfs, nblock);
    c992:	9907      	ldr	r1, [sp, #28]
    c994:	4628      	mov	r0, r5
    c996:	f7ff fb23 	bl	bfe0 <lfs_bd_erase>
            if (err) {
    c99a:	4680      	mov	r8, r0
    c99c:	2800      	cmp	r0, #0
    c99e:	d0ad      	beq.n	c8fc <lfs_ctz_extend+0x10>
                if (err == LFS_ERR_CORRUPT) {
    c9a0:	f110 0f54 	cmn.w	r0, #84	; 0x54
    c9a4:	d0ec      	beq.n	c980 <lfs_ctz_extend+0x94>
    c9a6:	4682      	mov	sl, r0
    c9a8:	e008      	b.n	c9bc <lfs_ctz_extend+0xd0>
                        return err;
    c9aa:	469a      	mov	sl, r3
    c9ac:	e006      	b.n	c9bc <lfs_ctz_extend+0xd0>
                *block = nblock;
    c9ae:	46c2      	mov	sl, r8
    c9b0:	9b07      	ldr	r3, [sp, #28]
    c9b2:	9a15      	ldr	r2, [sp, #84]	; 0x54
    c9b4:	6013      	str	r3, [r2, #0]
                *off = noff;
    c9b6:	9b08      	ldr	r3, [sp, #32]
    c9b8:	9a16      	ldr	r2, [sp, #88]	; 0x58
    c9ba:	6013      	str	r3, [r2, #0]
}
    c9bc:	4650      	mov	r0, sl
    c9be:	b00b      	add	sp, #44	; 0x2c
    c9c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            index += 1;
    c9c4:	3001      	adds	r0, #1
	return __builtin_ctz(a);
    c9c6:	fa90 f9a0 	rbit	r9, r0
    c9ca:	fab9 f989 	clz	r9, r9
            lfs_size_t skips = lfs_ctz(index) + 1;
    c9ce:	f109 0a01 	add.w	sl, r9, #1
            lfs_block_t nhead = head;
    c9d2:	9b05      	ldr	r3, [sp, #20]
    c9d4:	9309      	str	r3, [sp, #36]	; 0x24
            for (lfs_off_t i = 0; i < skips; i++) {
    c9d6:	2400      	movs	r4, #0
    c9d8:	46ab      	mov	fp, r5
    c9da:	e006      	b.n	c9ea <lfs_ctz_extend+0xfe>
                    if (err == LFS_ERR_CORRUPT) {
    c9dc:	465d      	mov	r5, fp
    c9de:	f110 0f54 	cmn.w	r0, #84	; 0x54
    c9e2:	d0cd      	beq.n	c980 <lfs_ctz_extend+0x94>
                    return err;
    c9e4:	4682      	mov	sl, r0
    c9e6:	e7e9      	b.n	c9bc <lfs_ctz_extend+0xd0>
            for (lfs_off_t i = 0; i < skips; i++) {
    c9e8:	3401      	adds	r4, #1
    c9ea:	45a2      	cmp	sl, r4
    c9ec:	d921      	bls.n	ca32 <lfs_ctz_extend+0x146>
                err = lfs_bd_prog(lfs, pcache, rcache, true,
    c9ee:	00a5      	lsls	r5, r4, #2
    c9f0:	2304      	movs	r3, #4
    c9f2:	9303      	str	r3, [sp, #12]
    c9f4:	ab09      	add	r3, sp, #36	; 0x24
    c9f6:	9302      	str	r3, [sp, #8]
    c9f8:	9501      	str	r5, [sp, #4]
    c9fa:	9b07      	ldr	r3, [sp, #28]
    c9fc:	9300      	str	r3, [sp, #0]
    c9fe:	2301      	movs	r3, #1
    ca00:	4632      	mov	r2, r6
    ca02:	4639      	mov	r1, r7
    ca04:	4658      	mov	r0, fp
    ca06:	f7ff fe45 	bl	c694 <lfs_bd_prog>
                nhead = lfs_fromle32(nhead);
    ca0a:	9a09      	ldr	r2, [sp, #36]	; 0x24
                if (err) {
    ca0c:	2800      	cmp	r0, #0
    ca0e:	d1e5      	bne.n	c9dc <lfs_ctz_extend+0xf0>
                if (i != skips-1) {
    ca10:	45a1      	cmp	r9, r4
    ca12:	d0e9      	beq.n	c9e8 <lfs_ctz_extend+0xfc>
                    err = lfs_bd_read(lfs,
    ca14:	2304      	movs	r3, #4
    ca16:	9303      	str	r3, [sp, #12]
    ca18:	a909      	add	r1, sp, #36	; 0x24
    ca1a:	9102      	str	r1, [sp, #8]
    ca1c:	9501      	str	r5, [sp, #4]
    ca1e:	9200      	str	r2, [sp, #0]
    ca20:	4632      	mov	r2, r6
    ca22:	2100      	movs	r1, #0
    ca24:	4658      	mov	r0, fp
    ca26:	f7ff fbdb 	bl	c1e0 <lfs_bd_read>
                    if (err) {
    ca2a:	2800      	cmp	r0, #0
    ca2c:	d0dc      	beq.n	c9e8 <lfs_ctz_extend+0xfc>
                        return err;
    ca2e:	4682      	mov	sl, r0
    ca30:	e7c4      	b.n	c9bc <lfs_ctz_extend+0xd0>
            *block = nblock;
    ca32:	46d1      	mov	r9, sl
    ca34:	46c2      	mov	sl, r8
    ca36:	9b07      	ldr	r3, [sp, #28]
    ca38:	9a15      	ldr	r2, [sp, #84]	; 0x54
    ca3a:	6013      	str	r3, [r2, #0]
            *off = 4*skips;
    ca3c:	ea4f 0189 	mov.w	r1, r9, lsl #2
    ca40:	9b16      	ldr	r3, [sp, #88]	; 0x58
    ca42:	6019      	str	r1, [r3, #0]
            return 0;
    ca44:	e7ba      	b.n	c9bc <lfs_ctz_extend+0xd0>
    ca46:	4682      	mov	sl, r0
    ca48:	e7b8      	b.n	c9bc <lfs_ctz_extend+0xd0>

0000ca4a <lfs_file_flushedwrite>:
        const void *buffer, lfs_size_t size) {
    ca4a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ca4e:	b085      	sub	sp, #20
    ca50:	4605      	mov	r5, r0
    ca52:	460c      	mov	r4, r1
    ca54:	4617      	mov	r7, r2
    ca56:	4699      	mov	r9, r3
    if ((file->flags & LFS_F_INLINE) &&
    ca58:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    ca5a:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    ca5e:	d016      	beq.n	ca8e <lfs_file_flushedwrite+0x44>
            lfs_max(file->pos+nsize, file->ctz.size) >
    ca60:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    ca62:	eb03 0209 	add.w	r2, r3, r9
    ca66:	6acb      	ldr	r3, [r1, #44]	; 0x2c
	return (a > b) ? a : b;
    ca68:	429a      	cmp	r2, r3
    ca6a:	bf38      	it	cc
    ca6c:	461a      	movcc	r2, r3
                lfs->cfg->cache_size,
    ca6e:	6e81      	ldr	r1, [r0, #104]	; 0x68
    ca70:	6a88      	ldr	r0, [r1, #40]	; 0x28
                (lfs->cfg->metadata_max ?
    ca72:	6c8b      	ldr	r3, [r1, #72]	; 0x48
            lfs_min(0x3fe, lfs_min(
    ca74:	2b00      	cmp	r3, #0
    ca76:	d038      	beq.n	caea <lfs_file_flushedwrite+0xa0>
    ca78:	08db      	lsrs	r3, r3, #3
	return (a < b) ? a : b;
    ca7a:	4283      	cmp	r3, r0
    ca7c:	bf28      	it	cs
    ca7e:	4603      	movcs	r3, r0
    ca80:	f240 31fe 	movw	r1, #1022	; 0x3fe
    ca84:	428b      	cmp	r3, r1
    ca86:	bf28      	it	cs
    ca88:	460b      	movcs	r3, r1
    if ((file->flags & LFS_F_INLINE) &&
    ca8a:	4293      	cmp	r3, r2
    ca8c:	d330      	bcc.n	caf0 <lfs_file_flushedwrite+0xa6>
        const void *buffer, lfs_size_t size) {
    ca8e:	46c8      	mov	r8, r9
    while (nsize > 0) {
    ca90:	f1b8 0f00 	cmp.w	r8, #0
    ca94:	f000 8099 	beq.w	cbca <lfs_file_flushedwrite+0x180>
        if (!(file->flags & LFS_F_WRITING) ||
    ca98:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ca9a:	f413 3200 	ands.w	r2, r3, #131072	; 0x20000
    ca9e:	d004      	beq.n	caaa <lfs_file_flushedwrite+0x60>
                file->off == lfs->cfg->block_size) {
    caa0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    caa2:	6ea9      	ldr	r1, [r5, #104]	; 0x68
    caa4:	69c9      	ldr	r1, [r1, #28]
        if (!(file->flags & LFS_F_WRITING) ||
    caa6:	4288      	cmp	r0, r1
    caa8:	d155      	bne.n	cb56 <lfs_file_flushedwrite+0x10c>
            if (!(file->flags & LFS_F_INLINE)) {
    caaa:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    caae:	d149      	bne.n	cb44 <lfs_file_flushedwrite+0xfa>
                if (!(file->flags & LFS_F_WRITING) && file->pos > 0) {
    cab0:	b90a      	cbnz	r2, cab6 <lfs_file_flushedwrite+0x6c>
    cab2:	6b63      	ldr	r3, [r4, #52]	; 0x34
    cab4:	bb43      	cbnz	r3, cb08 <lfs_file_flushedwrite+0xbe>
                lfs_alloc_ack(lfs);
    cab6:	4628      	mov	r0, r5
    cab8:	f7ff fb14 	bl	c0e4 <lfs_alloc_ack>
                int err = lfs_ctz_extend(lfs, &file->cache, &lfs->rcache,
    cabc:	f104 033c 	add.w	r3, r4, #60	; 0x3c
    cac0:	9302      	str	r3, [sp, #8]
    cac2:	f104 0338 	add.w	r3, r4, #56	; 0x38
    cac6:	9301      	str	r3, [sp, #4]
    cac8:	6b63      	ldr	r3, [r4, #52]	; 0x34
    caca:	9300      	str	r3, [sp, #0]
    cacc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cace:	462a      	mov	r2, r5
    cad0:	f104 0140 	add.w	r1, r4, #64	; 0x40
    cad4:	4628      	mov	r0, r5
    cad6:	f7ff ff09 	bl	c8ec <lfs_ctz_extend>
                if (err) {
    cada:	4601      	mov	r1, r0
    cadc:	2800      	cmp	r0, #0
    cade:	d036      	beq.n	cb4e <lfs_file_flushedwrite+0x104>
                    file->flags |= LFS_F_ERRED;
    cae0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cae2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    cae6:	6323      	str	r3, [r4, #48]	; 0x30
                    return err;
    cae8:	e05e      	b.n	cba8 <lfs_file_flushedwrite+0x15e>
                    lfs->cfg->metadata_max : lfs->cfg->block_size) / 8))) {
    caea:	69cb      	ldr	r3, [r1, #28]
            lfs_min(0x3fe, lfs_min(
    caec:	08db      	lsrs	r3, r3, #3
    caee:	e7c4      	b.n	ca7a <lfs_file_flushedwrite+0x30>
        int err = lfs_file_outline(lfs, file);
    caf0:	4621      	mov	r1, r4
    caf2:	4628      	mov	r0, r5
    caf4:	f7ff fee9 	bl	c8ca <lfs_file_outline>
        if (err) {
    caf8:	4601      	mov	r1, r0
    cafa:	2800      	cmp	r0, #0
    cafc:	d0c7      	beq.n	ca8e <lfs_file_flushedwrite+0x44>
            file->flags |= LFS_F_ERRED;
    cafe:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cb00:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    cb04:	6323      	str	r3, [r4, #48]	; 0x30
            return err;
    cb06:	e04f      	b.n	cba8 <lfs_file_flushedwrite+0x15e>
                    int err = lfs_ctz_find(lfs, NULL, &file->cache,
    cb08:	f104 0640 	add.w	r6, r4, #64	; 0x40
    cb0c:	f104 023c 	add.w	r2, r4, #60	; 0x3c
    cb10:	9203      	str	r2, [sp, #12]
    cb12:	f104 0238 	add.w	r2, r4, #56	; 0x38
    cb16:	9202      	str	r2, [sp, #8]
    cb18:	3b01      	subs	r3, #1
    cb1a:	9301      	str	r3, [sp, #4]
    cb1c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    cb1e:	9300      	str	r3, [sp, #0]
    cb20:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    cb22:	4632      	mov	r2, r6
    cb24:	2100      	movs	r1, #0
    cb26:	4628      	mov	r0, r5
    cb28:	f7ff fe32 	bl	c790 <lfs_ctz_find>
                    if (err) {
    cb2c:	4601      	mov	r1, r0
    cb2e:	b920      	cbnz	r0, cb3a <lfs_file_flushedwrite+0xf0>
                    lfs_cache_zero(lfs, &file->cache);
    cb30:	4631      	mov	r1, r6
    cb32:	4628      	mov	r0, r5
    cb34:	f7ff fb2a 	bl	c18c <lfs_cache_zero>
    cb38:	e7bd      	b.n	cab6 <lfs_file_flushedwrite+0x6c>
                        file->flags |= LFS_F_ERRED;
    cb3a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cb3c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    cb40:	6323      	str	r3, [r4, #48]	; 0x30
                        return err;
    cb42:	e031      	b.n	cba8 <lfs_file_flushedwrite+0x15e>
                file->block = LFS_BLOCK_INLINE;
    cb44:	f06f 0301 	mvn.w	r3, #1
    cb48:	63a3      	str	r3, [r4, #56]	; 0x38
                file->off = file->pos;
    cb4a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    cb4c:	63e3      	str	r3, [r4, #60]	; 0x3c
            file->flags |= LFS_F_WRITING;
    cb4e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cb50:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    cb54:	6323      	str	r3, [r4, #48]	; 0x30
        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
    cb56:	6eab      	ldr	r3, [r5, #104]	; 0x68
    cb58:	69de      	ldr	r6, [r3, #28]
    cb5a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cb5c:	1af6      	subs	r6, r6, r3
    cb5e:	4546      	cmp	r6, r8
    cb60:	bf28      	it	cs
    cb62:	4646      	movcs	r6, r8
            int err = lfs_bd_prog(lfs, &file->cache, &lfs->rcache, true,
    cb64:	9603      	str	r6, [sp, #12]
    cb66:	9702      	str	r7, [sp, #8]
    cb68:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cb6a:	9301      	str	r3, [sp, #4]
    cb6c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cb6e:	9300      	str	r3, [sp, #0]
    cb70:	2301      	movs	r3, #1
    cb72:	462a      	mov	r2, r5
    cb74:	f104 0140 	add.w	r1, r4, #64	; 0x40
    cb78:	4628      	mov	r0, r5
    cb7a:	f7ff fd8b 	bl	c694 <lfs_bd_prog>
            if (err) {
    cb7e:	4601      	mov	r1, r0
    cb80:	b1b0      	cbz	r0, cbb0 <lfs_file_flushedwrite+0x166>
                if (err == LFS_ERR_CORRUPT) {
    cb82:	f110 0f54 	cmn.w	r0, #84	; 0x54
    cb86:	d10b      	bne.n	cba0 <lfs_file_flushedwrite+0x156>
            err = lfs_file_relocate(lfs, file);
    cb88:	4621      	mov	r1, r4
    cb8a:	4628      	mov	r0, r5
    cb8c:	f7f9 fbb2 	bl	62f4 <lfs_file_relocate>
            if (err) {
    cb90:	4601      	mov	r1, r0
    cb92:	2800      	cmp	r0, #0
    cb94:	d0e6      	beq.n	cb64 <lfs_file_flushedwrite+0x11a>
                file->flags |= LFS_F_ERRED;
    cb96:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cb98:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    cb9c:	6323      	str	r3, [r4, #48]	; 0x30
                return err;
    cb9e:	e003      	b.n	cba8 <lfs_file_flushedwrite+0x15e>
                file->flags |= LFS_F_ERRED;
    cba0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cba2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    cba6:	6323      	str	r3, [r4, #48]	; 0x30
}
    cba8:	4608      	mov	r0, r1
    cbaa:	b005      	add	sp, #20
    cbac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        file->pos += diff;
    cbb0:	6b63      	ldr	r3, [r4, #52]	; 0x34
    cbb2:	4433      	add	r3, r6
    cbb4:	6363      	str	r3, [r4, #52]	; 0x34
        file->off += diff;
    cbb6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cbb8:	4433      	add	r3, r6
    cbba:	63e3      	str	r3, [r4, #60]	; 0x3c
        data += diff;
    cbbc:	4437      	add	r7, r6
        nsize -= diff;
    cbbe:	eba8 0806 	sub.w	r8, r8, r6
        lfs_alloc_ack(lfs);
    cbc2:	4628      	mov	r0, r5
    cbc4:	f7ff fa8e 	bl	c0e4 <lfs_alloc_ack>
    cbc8:	e762      	b.n	ca90 <lfs_file_flushedwrite+0x46>
    return size;
    cbca:	4649      	mov	r1, r9
    cbcc:	e7ec      	b.n	cba8 <lfs_file_flushedwrite+0x15e>

0000cbce <lfs_file_flush>:
static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
    cbce:	b570      	push	{r4, r5, r6, lr}
    cbd0:	b096      	sub	sp, #88	; 0x58
    cbd2:	4605      	mov	r5, r0
    cbd4:	460c      	mov	r4, r1
    if (file->flags & LFS_F_READING) {
    cbd6:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    cbd8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    cbdc:	d008      	beq.n	cbf0 <lfs_file_flush+0x22>
        if (!(file->flags & LFS_F_INLINE)) {
    cbde:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    cbe2:	d102      	bne.n	cbea <lfs_file_flush+0x1c>
    rcache->block = LFS_BLOCK_NULL;
    cbe4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    cbe8:	640a      	str	r2, [r1, #64]	; 0x40
        file->flags &= ~LFS_F_READING;
    cbea:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    cbee:	6323      	str	r3, [r4, #48]	; 0x30
    if (file->flags & LFS_F_WRITING) {
    cbf0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cbf2:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    cbf6:	d05f      	beq.n	ccb8 <lfs_file_flush+0xea>
        lfs_off_t pos = file->pos;
    cbf8:	6b66      	ldr	r6, [r4, #52]	; 0x34
        if (!(file->flags & LFS_F_INLINE)) {
    cbfa:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    cbfe:	d148      	bne.n	cc92 <lfs_file_flush+0xc4>
            lfs_file_t orig = {
    cc00:	2254      	movs	r2, #84	; 0x54
    cc02:	2100      	movs	r1, #0
    cc04:	a801      	add	r0, sp, #4
    cc06:	f7fd fd88 	bl	a71a <memset>
                .ctz.head = file->ctz.head,
    cc0a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
            lfs_file_t orig = {
    cc0c:	930b      	str	r3, [sp, #44]	; 0x2c
                .ctz.size = file->ctz.size,
    cc0e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
            lfs_file_t orig = {
    cc10:	930c      	str	r3, [sp, #48]	; 0x30
    cc12:	2301      	movs	r3, #1
    cc14:	930d      	str	r3, [sp, #52]	; 0x34
                .pos = file->pos,
    cc16:	6b63      	ldr	r3, [r4, #52]	; 0x34
            lfs_file_t orig = {
    cc18:	930e      	str	r3, [sp, #56]	; 0x38
    cc1a:	f10d 0c44 	add.w	ip, sp, #68	; 0x44
    cc1e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    cc22:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    rcache->block = LFS_BLOCK_NULL;
    cc26:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cc2a:	602b      	str	r3, [r5, #0]
            while (file->pos < file->ctz.size) {
    cc2c:	6b62      	ldr	r2, [r4, #52]	; 0x34
    cc2e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    cc30:	429a      	cmp	r2, r3
    cc32:	d21a      	bcs.n	cc6a <lfs_file_flush+0x9c>
                lfs_ssize_t res = lfs_file_flushedread(lfs, &orig, &data, 1);
    cc34:	2301      	movs	r3, #1
    cc36:	f10d 0203 	add.w	r2, sp, #3
    cc3a:	a901      	add	r1, sp, #4
    cc3c:	4628      	mov	r0, r5
    cc3e:	f7f8 ff0f 	bl	5a60 <lfs_file_flushedread>
                if (res < 0) {
    cc42:	1e03      	subs	r3, r0, #0
    cc44:	db39      	blt.n	ccba <lfs_file_flush+0xec>
                res = lfs_file_flushedwrite(lfs, file, &data, 1);
    cc46:	2301      	movs	r3, #1
    cc48:	f10d 0203 	add.w	r2, sp, #3
    cc4c:	4621      	mov	r1, r4
    cc4e:	4628      	mov	r0, r5
    cc50:	f7ff fefb 	bl	ca4a <lfs_file_flushedwrite>
                if (res < 0) {
    cc54:	1e03      	subs	r3, r0, #0
    cc56:	db30      	blt.n	ccba <lfs_file_flush+0xec>
                if (lfs->rcache.block != LFS_BLOCK_NULL) {
    cc58:	682b      	ldr	r3, [r5, #0]
    cc5a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    cc5e:	d0e5      	beq.n	cc2c <lfs_file_flush+0x5e>
    rcache->block = LFS_BLOCK_NULL;
    cc60:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cc64:	9311      	str	r3, [sp, #68]	; 0x44
    cc66:	602b      	str	r3, [r5, #0]
}
    cc68:	e7e0      	b.n	cc2c <lfs_file_flush+0x5e>
                int err = lfs_bd_flush(lfs, &file->cache, &lfs->rcache, true);
    cc6a:	2301      	movs	r3, #1
    cc6c:	462a      	mov	r2, r5
    cc6e:	f104 0140 	add.w	r1, r4, #64	; 0x40
    cc72:	4628      	mov	r0, r5
    cc74:	f7ff fcc9 	bl	c60a <lfs_bd_flush>
                if (err) {
    cc78:	4603      	mov	r3, r0
    cc7a:	b178      	cbz	r0, cc9c <lfs_file_flush+0xce>
                    if (err == LFS_ERR_CORRUPT) {
    cc7c:	f110 0f54 	cmn.w	r0, #84	; 0x54
    cc80:	d11b      	bne.n	ccba <lfs_file_flush+0xec>
                err = lfs_file_relocate(lfs, file);
    cc82:	4621      	mov	r1, r4
    cc84:	4628      	mov	r0, r5
    cc86:	f7f9 fb35 	bl	62f4 <lfs_file_relocate>
                if (err) {
    cc8a:	4603      	mov	r3, r0
    cc8c:	2800      	cmp	r0, #0
    cc8e:	d0ec      	beq.n	cc6a <lfs_file_flush+0x9c>
    cc90:	e013      	b.n	ccba <lfs_file_flush+0xec>
            file->pos = lfs_max(file->pos, file->ctz.size);
    cc92:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	return (a > b) ? a : b;
    cc94:	42b3      	cmp	r3, r6
    cc96:	bf38      	it	cc
    cc98:	4633      	movcc	r3, r6
    cc9a:	6363      	str	r3, [r4, #52]	; 0x34
        file->ctz.head = file->block;
    cc9c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cc9e:	62a3      	str	r3, [r4, #40]	; 0x28
        file->ctz.size = file->pos;
    cca0:	6b63      	ldr	r3, [r4, #52]	; 0x34
    cca2:	62e3      	str	r3, [r4, #44]	; 0x2c
        file->flags &= ~LFS_F_WRITING;
    cca4:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cca6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    ccaa:	6323      	str	r3, [r4, #48]	; 0x30
        file->flags |= LFS_F_DIRTY;
    ccac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    ccb0:	6323      	str	r3, [r4, #48]	; 0x30
        file->pos = pos;
    ccb2:	6366      	str	r6, [r4, #52]	; 0x34
    return 0;
    ccb4:	2300      	movs	r3, #0
    ccb6:	e000      	b.n	ccba <lfs_file_flush+0xec>
    ccb8:	2300      	movs	r3, #0
}
    ccba:	4618      	mov	r0, r3
    ccbc:	b016      	add	sp, #88	; 0x58
    ccbe:	bd70      	pop	{r4, r5, r6, pc}

0000ccc0 <lfs_file_rawread>:
        void *buffer, lfs_size_t size) {
    ccc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ccc2:	4605      	mov	r5, r0
    ccc4:	460c      	mov	r4, r1
    ccc6:	4616      	mov	r6, r2
    ccc8:	461f      	mov	r7, r3
    if (file->flags & LFS_F_WRITING) {
    ccca:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    cccc:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    ccd0:	d002      	beq.n	ccd8 <lfs_file_rawread+0x18>
        int err = lfs_file_flush(lfs, file);
    ccd2:	f7ff ff7c 	bl	cbce <lfs_file_flush>
        if (err) {
    ccd6:	b928      	cbnz	r0, cce4 <lfs_file_rawread+0x24>
    return lfs_file_flushedread(lfs, file, buffer, size);
    ccd8:	463b      	mov	r3, r7
    ccda:	4632      	mov	r2, r6
    ccdc:	4621      	mov	r1, r4
    ccde:	4628      	mov	r0, r5
    cce0:	f7f8 febe 	bl	5a60 <lfs_file_flushedread>
}
    cce4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000cce6 <lfs_file_rawseek>:
        lfs_soff_t off, int whence) {
    cce6:	b5f0      	push	{r4, r5, r6, r7, lr}
    cce8:	b083      	sub	sp, #12
    ccea:	4606      	mov	r6, r0
    ccec:	460d      	mov	r5, r1
    ccee:	4614      	mov	r4, r2
    lfs_off_t npos = file->pos;
    ccf0:	6b4f      	ldr	r7, [r1, #52]	; 0x34
    if (whence == LFS_SEEK_SET) {
    ccf2:	b123      	cbz	r3, ccfe <lfs_file_rawseek+0x18>
    } else if (whence == LFS_SEEK_CUR) {
    ccf4:	2b01      	cmp	r3, #1
    ccf6:	d021      	beq.n	cd3c <lfs_file_rawseek+0x56>
    } else if (whence == LFS_SEEK_END) {
    ccf8:	2b02      	cmp	r3, #2
    ccfa:	d023      	beq.n	cd44 <lfs_file_rawseek+0x5e>
    lfs_off_t npos = file->pos;
    ccfc:	463c      	mov	r4, r7
    if (npos > lfs->file_max) {
    ccfe:	6f33      	ldr	r3, [r6, #112]	; 0x70
    cd00:	42a3      	cmp	r3, r4
    cd02:	d339      	bcc.n	cd78 <lfs_file_rawseek+0x92>
    if (file->pos == npos) {
    cd04:	42bc      	cmp	r4, r7
    cd06:	d023      	beq.n	cd50 <lfs_file_rawseek+0x6a>
        !(file->flags & LFS_F_WRITING)
    cd08:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    if (
    cd0a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    cd0e:	d10c      	bne.n	cd2a <lfs_file_rawseek+0x44>
        int oindex = lfs_ctz_index(lfs, &(lfs_off_t){file->pos});
    cd10:	9701      	str	r7, [sp, #4]
    cd12:	a901      	add	r1, sp, #4
    cd14:	4630      	mov	r0, r6
    cd16:	f7ff fa45 	bl	c1a4 <lfs_ctz_index>
    cd1a:	4607      	mov	r7, r0
        lfs_off_t noff = npos;
    cd1c:	9400      	str	r4, [sp, #0]
        int nindex = lfs_ctz_index(lfs, &noff);
    cd1e:	4669      	mov	r1, sp
    cd20:	4630      	mov	r0, r6
    cd22:	f7ff fa3f 	bl	c1a4 <lfs_ctz_index>
        if (oindex == nindex
    cd26:	4287      	cmp	r7, r0
    cd28:	d014      	beq.n	cd54 <lfs_file_rawseek+0x6e>
    int err = lfs_file_flush(lfs, file);
    cd2a:	4629      	mov	r1, r5
    cd2c:	4630      	mov	r0, r6
    cd2e:	f7ff ff4e 	bl	cbce <lfs_file_flush>
    if (err) {
    cd32:	b908      	cbnz	r0, cd38 <lfs_file_rawseek+0x52>
    file->pos = npos;
    cd34:	636c      	str	r4, [r5, #52]	; 0x34
    return npos;
    cd36:	4620      	mov	r0, r4
}
    cd38:	b003      	add	sp, #12
    cd3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if ((lfs_soff_t)file->pos + off < 0) {
    cd3c:	42e7      	cmn	r7, r4
    cd3e:	d415      	bmi.n	cd6c <lfs_file_rawseek+0x86>
            npos = file->pos + off;
    cd40:	443c      	add	r4, r7
    cd42:	e7dc      	b.n	ccfe <lfs_file_rawseek+0x18>
        lfs_soff_t res = lfs_file_rawsize(lfs, file) + off;
    cd44:	f7ff fa02 	bl	c14c <lfs_file_rawsize>
        if (res < 0) {
    cd48:	1900      	adds	r0, r0, r4
    cd4a:	d412      	bmi.n	cd72 <lfs_file_rawseek+0x8c>
            npos = res;
    cd4c:	4604      	mov	r4, r0
    cd4e:	e7d6      	b.n	ccfe <lfs_file_rawseek+0x18>
        return npos;
    cd50:	4620      	mov	r0, r4
    cd52:	e7f1      	b.n	cd38 <lfs_file_rawseek+0x52>
                && noff >= file->cache.off
    cd54:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    cd56:	9a00      	ldr	r2, [sp, #0]
    cd58:	4293      	cmp	r3, r2
    cd5a:	d8e6      	bhi.n	cd2a <lfs_file_rawseek+0x44>
                && noff < file->cache.off + file->cache.size) {
    cd5c:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    cd5e:	440b      	add	r3, r1
    cd60:	429a      	cmp	r2, r3
    cd62:	d2e2      	bcs.n	cd2a <lfs_file_rawseek+0x44>
            file->pos = npos;
    cd64:	636c      	str	r4, [r5, #52]	; 0x34
            file->off = noff;
    cd66:	63ea      	str	r2, [r5, #60]	; 0x3c
            return npos;
    cd68:	4620      	mov	r0, r4
    cd6a:	e7e5      	b.n	cd38 <lfs_file_rawseek+0x52>
            return LFS_ERR_INVAL;
    cd6c:	f06f 0015 	mvn.w	r0, #21
    cd70:	e7e2      	b.n	cd38 <lfs_file_rawseek+0x52>
            return LFS_ERR_INVAL;
    cd72:	f06f 0015 	mvn.w	r0, #21
    cd76:	e7df      	b.n	cd38 <lfs_file_rawseek+0x52>
        return LFS_ERR_INVAL;
    cd78:	f06f 0015 	mvn.w	r0, #21
    cd7c:	e7dc      	b.n	cd38 <lfs_file_rawseek+0x52>

0000cd7e <lfs_file_rawwrite>:
        const void *buffer, lfs_size_t size) {
    cd7e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cd82:	b082      	sub	sp, #8
    cd84:	4605      	mov	r5, r0
    cd86:	460c      	mov	r4, r1
    cd88:	4690      	mov	r8, r2
    cd8a:	461f      	mov	r7, r3
    if (file->flags & LFS_F_READING) {
    cd8c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    cd8e:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    cd92:	d124      	bne.n	cdde <lfs_file_rawwrite+0x60>
    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {
    cd94:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cd96:	f413 6f00 	tst.w	r3, #2048	; 0x800
    cd9a:	d004      	beq.n	cda6 <lfs_file_rawwrite+0x28>
    cd9c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    cd9e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    cda0:	4291      	cmp	r1, r2
    cda2:	d200      	bcs.n	cda6 <lfs_file_rawwrite+0x28>
        file->pos = file->ctz.size;
    cda4:	6362      	str	r2, [r4, #52]	; 0x34
    if (file->pos + size > lfs->file_max) {
    cda6:	6b66      	ldr	r6, [r4, #52]	; 0x34
    cda8:	19f1      	adds	r1, r6, r7
    cdaa:	6f2a      	ldr	r2, [r5, #112]	; 0x70
    cdac:	4291      	cmp	r1, r2
    cdae:	d82a      	bhi.n	ce06 <lfs_file_rawwrite+0x88>
    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {
    cdb0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    cdb4:	d118      	bne.n	cde8 <lfs_file_rawwrite+0x6a>
    cdb6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    cdb8:	429e      	cmp	r6, r3
    cdba:	d915      	bls.n	cde8 <lfs_file_rawwrite+0x6a>
        file->pos = file->ctz.size;
    cdbc:	6363      	str	r3, [r4, #52]	; 0x34
        while (file->pos < pos) {
    cdbe:	6b61      	ldr	r1, [r4, #52]	; 0x34
    cdc0:	428e      	cmp	r6, r1
    cdc2:	d911      	bls.n	cde8 <lfs_file_rawwrite+0x6a>
            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);
    cdc4:	2300      	movs	r3, #0
    cdc6:	f88d 3007 	strb.w	r3, [sp, #7]
    cdca:	2301      	movs	r3, #1
    cdcc:	f10d 0207 	add.w	r2, sp, #7
    cdd0:	4621      	mov	r1, r4
    cdd2:	4628      	mov	r0, r5
    cdd4:	f7ff fe39 	bl	ca4a <lfs_file_flushedwrite>
            if (res < 0) {
    cdd8:	2800      	cmp	r0, #0
    cdda:	daf0      	bge.n	cdbe <lfs_file_rawwrite+0x40>
    cddc:	e010      	b.n	ce00 <lfs_file_rawwrite+0x82>
        int err = lfs_file_flush(lfs, file);
    cdde:	f7ff fef6 	bl	cbce <lfs_file_flush>
        if (err) {
    cde2:	2800      	cmp	r0, #0
    cde4:	d0d6      	beq.n	cd94 <lfs_file_rawwrite+0x16>
    cde6:	e00b      	b.n	ce00 <lfs_file_rawwrite+0x82>
    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);
    cde8:	463b      	mov	r3, r7
    cdea:	4642      	mov	r2, r8
    cdec:	4621      	mov	r1, r4
    cdee:	4628      	mov	r0, r5
    cdf0:	f7ff fe2b 	bl	ca4a <lfs_file_flushedwrite>
    if (nsize < 0) {
    cdf4:	2800      	cmp	r0, #0
    cdf6:	db03      	blt.n	ce00 <lfs_file_rawwrite+0x82>
    file->flags &= ~LFS_F_ERRED;
    cdf8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    cdfa:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
    cdfe:	6323      	str	r3, [r4, #48]	; 0x30
}
    ce00:	b002      	add	sp, #8
    ce02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LFS_ERR_FBIG;
    ce06:	f06f 001a 	mvn.w	r0, #26
    ce0a:	e7f9      	b.n	ce00 <lfs_file_rawwrite+0x82>

0000ce0c <lfs_file_rawtruncate>:
static int lfs_file_rawtruncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
    ce0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    ce0e:	b087      	sub	sp, #28
    if (size > LFS_FILE_MAX) {
    ce10:	1e15      	subs	r5, r2, #0
    ce12:	db4c      	blt.n	ceae <lfs_file_rawtruncate+0xa2>
    ce14:	4606      	mov	r6, r0
    ce16:	460c      	mov	r4, r1
    lfs_off_t pos = file->pos;
    ce18:	6b4f      	ldr	r7, [r1, #52]	; 0x34
    lfs_off_t oldsize = lfs_file_rawsize(lfs, file);
    ce1a:	f7ff f997 	bl	c14c <lfs_file_rawsize>
    if (size < oldsize) {
    ce1e:	4285      	cmp	r5, r0
    ce20:	d30c      	bcc.n	ce3c <lfs_file_rawtruncate+0x30>
    } else if (size > oldsize) {
    ce22:	4285      	cmp	r5, r0
    ce24:	d82b      	bhi.n	ce7e <lfs_file_rawtruncate+0x72>
    lfs_soff_t res = lfs_file_rawseek(lfs, file, pos, LFS_SEEK_SET);
    ce26:	2300      	movs	r3, #0
    ce28:	463a      	mov	r2, r7
    ce2a:	4621      	mov	r1, r4
    ce2c:	4630      	mov	r0, r6
    ce2e:	f7ff ff5a 	bl	cce6 <lfs_file_rawseek>
    if (res < 0) {
    ce32:	2800      	cmp	r0, #0
    ce34:	db00      	blt.n	ce38 <lfs_file_rawtruncate+0x2c>
    return 0;
    ce36:	2000      	movs	r0, #0
}
    ce38:	b007      	add	sp, #28
    ce3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        int err = lfs_file_flush(lfs, file);
    ce3c:	4621      	mov	r1, r4
    ce3e:	4630      	mov	r0, r6
    ce40:	f7ff fec5 	bl	cbce <lfs_file_flush>
        if (err) {
    ce44:	2800      	cmp	r0, #0
    ce46:	d1f7      	bne.n	ce38 <lfs_file_rawtruncate+0x2c>
        err = lfs_ctz_find(lfs, NULL, &file->cache,
    ce48:	f104 033c 	add.w	r3, r4, #60	; 0x3c
    ce4c:	9303      	str	r3, [sp, #12]
    ce4e:	f104 0338 	add.w	r3, r4, #56	; 0x38
    ce52:	9302      	str	r3, [sp, #8]
    ce54:	9501      	str	r5, [sp, #4]
    ce56:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    ce58:	9300      	str	r3, [sp, #0]
    ce5a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    ce5c:	f104 0240 	add.w	r2, r4, #64	; 0x40
    ce60:	2100      	movs	r1, #0
    ce62:	4630      	mov	r0, r6
    ce64:	f7ff fc94 	bl	c790 <lfs_ctz_find>
        if (err) {
    ce68:	2800      	cmp	r0, #0
    ce6a:	d1e5      	bne.n	ce38 <lfs_file_rawtruncate+0x2c>
        file->pos = size;
    ce6c:	6365      	str	r5, [r4, #52]	; 0x34
        file->ctz.head = file->block;
    ce6e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    ce70:	62a3      	str	r3, [r4, #40]	; 0x28
        file->ctz.size = size;
    ce72:	62e5      	str	r5, [r4, #44]	; 0x2c
        file->flags |= LFS_F_DIRTY | LFS_F_READING;
    ce74:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ce76:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
    ce7a:	6323      	str	r3, [r4, #48]	; 0x30
    ce7c:	e7d3      	b.n	ce26 <lfs_file_rawtruncate+0x1a>
        lfs_soff_t res = lfs_file_rawseek(lfs, file, 0, LFS_SEEK_END);
    ce7e:	2302      	movs	r3, #2
    ce80:	2200      	movs	r2, #0
    ce82:	4621      	mov	r1, r4
    ce84:	4630      	mov	r0, r6
    ce86:	f7ff ff2e 	bl	cce6 <lfs_file_rawseek>
        if (res < 0) {
    ce8a:	2800      	cmp	r0, #0
    ce8c:	dbd4      	blt.n	ce38 <lfs_file_rawtruncate+0x2c>
        while (file->pos < size) {
    ce8e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    ce90:	42ab      	cmp	r3, r5
    ce92:	d2c8      	bcs.n	ce26 <lfs_file_rawtruncate+0x1a>
            res = lfs_file_rawwrite(lfs, file, &(uint8_t){0}, 1);
    ce94:	2300      	movs	r3, #0
    ce96:	f88d 3017 	strb.w	r3, [sp, #23]
    ce9a:	2301      	movs	r3, #1
    ce9c:	f10d 0217 	add.w	r2, sp, #23
    cea0:	4621      	mov	r1, r4
    cea2:	4630      	mov	r0, r6
    cea4:	f7ff ff6b 	bl	cd7e <lfs_file_rawwrite>
            if (res < 0) {
    cea8:	2800      	cmp	r0, #0
    ceaa:	daf0      	bge.n	ce8e <lfs_file_rawtruncate+0x82>
    ceac:	e7c4      	b.n	ce38 <lfs_file_rawtruncate+0x2c>
        return LFS_ERR_INVAL;
    ceae:	f06f 0015 	mvn.w	r0, #21
    ceb2:	e7c1      	b.n	ce38 <lfs_file_rawtruncate+0x2c>

0000ceb4 <lfs_fs_pred>:
        const lfs_block_t pair[2], lfs_mdir_t *pdir) {
    ceb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ceb6:	4607      	mov	r7, r0
    ceb8:	460e      	mov	r6, r1
    ceba:	4614      	mov	r4, r2
    pdir->tail[0] = 0;
    cebc:	2500      	movs	r5, #0
    cebe:	6195      	str	r5, [r2, #24]
    pdir->tail[1] = 1;
    cec0:	2301      	movs	r3, #1
    cec2:	61d3      	str	r3, [r2, #28]
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    cec4:	69a3      	ldr	r3, [r4, #24]
    cec6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    ceca:	d021      	beq.n	cf10 <lfs_fs_pred+0x5c>
    cecc:	69e2      	ldr	r2, [r4, #28]
    cece:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    ced2:	d01b      	beq.n	cf0c <lfs_fs_pred+0x58>
    ced4:	2200      	movs	r2, #0
    while (!lfs_pair_isnull(pdir->tail)) {
    ced6:	b9ea      	cbnz	r2, cf14 <lfs_fs_pred+0x60>
        if (cycle >= lfs->cfg->block_count/2) {
    ced8:	6eba      	ldr	r2, [r7, #104]	; 0x68
    ceda:	6a12      	ldr	r2, [r2, #32]
    cedc:	ebb5 0f52 	cmp.w	r5, r2, lsr #1
    cee0:	d21b      	bcs.n	cf1a <lfs_fs_pred+0x66>
        cycle += 1;
    cee2:	3501      	adds	r5, #1
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    cee4:	6832      	ldr	r2, [r6, #0]
    cee6:	429a      	cmp	r2, r3
    cee8:	d01a      	beq.n	cf20 <lfs_fs_pred+0x6c>
    ceea:	69e0      	ldr	r0, [r4, #28]
    ceec:	6871      	ldr	r1, [r6, #4]
    ceee:	4288      	cmp	r0, r1
    cef0:	d018      	beq.n	cf24 <lfs_fs_pred+0x70>
    cef2:	4299      	cmp	r1, r3
    cef4:	d018      	beq.n	cf28 <lfs_fs_pred+0x74>
    cef6:	4282      	cmp	r2, r0
    cef8:	d018      	beq.n	cf2c <lfs_fs_pred+0x78>
        int err = lfs_dir_fetch(lfs, pdir, pdir->tail);
    cefa:	f104 0218 	add.w	r2, r4, #24
    cefe:	4621      	mov	r1, r4
    cf00:	4638      	mov	r0, r7
    cf02:	f7ff fc8e 	bl	c822 <lfs_dir_fetch>
        if (err) {
    cf06:	2800      	cmp	r0, #0
    cf08:	d0dc      	beq.n	cec4 <lfs_fs_pred+0x10>
    cf0a:	e00a      	b.n	cf22 <lfs_fs_pred+0x6e>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    cf0c:	2201      	movs	r2, #1
    cf0e:	e7e2      	b.n	ced6 <lfs_fs_pred+0x22>
    cf10:	2201      	movs	r2, #1
    cf12:	e7e0      	b.n	ced6 <lfs_fs_pred+0x22>
    return LFS_ERR_NOENT;
    cf14:	f06f 0001 	mvn.w	r0, #1
    cf18:	e003      	b.n	cf22 <lfs_fs_pred+0x6e>
            return LFS_ERR_CORRUPT;
    cf1a:	f06f 0053 	mvn.w	r0, #83	; 0x53
    cf1e:	e000      	b.n	cf22 <lfs_fs_pred+0x6e>
            return 0;
    cf20:	2000      	movs	r0, #0
}
    cf22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return 0;
    cf24:	2000      	movs	r0, #0
    cf26:	e7fc      	b.n	cf22 <lfs_fs_pred+0x6e>
    cf28:	2000      	movs	r0, #0
    cf2a:	e7fa      	b.n	cf22 <lfs_fs_pred+0x6e>
    cf2c:	2000      	movs	r0, #0
    cf2e:	e7f8      	b.n	cf22 <lfs_fs_pred+0x6e>

0000cf30 <lfs_dir_commitprog>:
        const void *buffer, lfs_size_t size) {
    cf30:	b5f0      	push	{r4, r5, r6, r7, lr}
    cf32:	b085      	sub	sp, #20
    cf34:	460c      	mov	r4, r1
    cf36:	4616      	mov	r6, r2
    cf38:	461d      	mov	r5, r3
    int err = lfs_bd_prog(lfs,
    cf3a:	9303      	str	r3, [sp, #12]
    cf3c:	9202      	str	r2, [sp, #8]
    cf3e:	684b      	ldr	r3, [r1, #4]
    cf40:	9301      	str	r3, [sp, #4]
    cf42:	680b      	ldr	r3, [r1, #0]
    cf44:	9300      	str	r3, [sp, #0]
    cf46:	2300      	movs	r3, #0
    cf48:	4602      	mov	r2, r0
    cf4a:	f100 0110 	add.w	r1, r0, #16
    cf4e:	f7ff fba1 	bl	c694 <lfs_bd_prog>
    if (err) {
    cf52:	4607      	mov	r7, r0
    cf54:	b110      	cbz	r0, cf5c <lfs_dir_commitprog+0x2c>
}
    cf56:	4638      	mov	r0, r7
    cf58:	b005      	add	sp, #20
    cf5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    commit->crc = lfs_crc(commit->crc, buffer, size);
    cf5c:	462a      	mov	r2, r5
    cf5e:	4631      	mov	r1, r6
    cf60:	68e0      	ldr	r0, [r4, #12]
    cf62:	f7fa ff3b 	bl	7ddc <lfs_crc>
    cf66:	60e0      	str	r0, [r4, #12]
    commit->off += size;
    cf68:	6863      	ldr	r3, [r4, #4]
    cf6a:	442b      	add	r3, r5
    cf6c:	6063      	str	r3, [r4, #4]
    return 0;
    cf6e:	e7f2      	b.n	cf56 <lfs_dir_commitprog+0x26>

0000cf70 <lfs_dir_commitattr>:
        lfs_tag_t tag, const void *buffer) {
    cf70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cf74:	b087      	sub	sp, #28
    cf76:	4614      	mov	r4, r2
    cf78:	461f      	mov	r7, r3
    return ((int32_t)(tag << 22) >> 22) == -1;
    cf7a:	f342 0309 	sbfx	r3, r2, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    cf7e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    cf82:	bf14      	ite	ne
    cf84:	4690      	movne	r8, r2
    cf86:	f102 0801 	addeq.w	r8, r2, #1
    return tag & 0x000003ff;
    cf8a:	f3c8 0809 	ubfx	r8, r8, #0, #10
    return sizeof(tag) + lfs_tag_size(tag + lfs_tag_isdelete(tag));
    cf8e:	f108 0904 	add.w	r9, r8, #4
    if (commit->off + dsize > commit->end) {
    cf92:	684b      	ldr	r3, [r1, #4]
    cf94:	444b      	add	r3, r9
    cf96:	694a      	ldr	r2, [r1, #20]
    cf98:	4293      	cmp	r3, r2
    cf9a:	d841      	bhi.n	d020 <lfs_dir_commitattr+0xb0>
    cf9c:	4605      	mov	r5, r0
    cf9e:	460e      	mov	r6, r1
    lfs_tag_t ntag = lfs_tobe32((tag & 0x7fffffff) ^ commit->ptag);
    cfa0:	f024 4b00 	bic.w	fp, r4, #2147483648	; 0x80000000
    cfa4:	688b      	ldr	r3, [r1, #8]
    cfa6:	ea8b 0303 	eor.w	r3, fp, r3
	return __builtin_bswap32(a);
    cfaa:	ba1b      	rev	r3, r3
    cfac:	9305      	str	r3, [sp, #20]
    int err = lfs_dir_commitprog(lfs, commit, &ntag, sizeof(ntag));
    cfae:	2304      	movs	r3, #4
    cfb0:	aa05      	add	r2, sp, #20
    cfb2:	f7ff ffbd 	bl	cf30 <lfs_dir_commitprog>
    if (err) {
    cfb6:	4682      	mov	sl, r0
    cfb8:	bb60      	cbnz	r0, d014 <lfs_dir_commitattr+0xa4>
    if (!(tag & 0x80000000)) {
    cfba:	2c00      	cmp	r4, #0
    cfbc:	da21      	bge.n	d002 <lfs_dir_commitattr+0x92>
        for (lfs_off_t i = 0; i < dsize-sizeof(tag); i++) {
    cfbe:	2400      	movs	r4, #0
    cfc0:	4544      	cmp	r4, r8
    cfc2:	d225      	bcs.n	d010 <lfs_dir_commitattr+0xa0>
                    NULL, &lfs->rcache, dsize-sizeof(tag)-i,
    cfc4:	eba9 0304 	sub.w	r3, r9, r4
                    disk->block, disk->off+i, &dat, 1);
    cfc8:	6839      	ldr	r1, [r7, #0]
    cfca:	687a      	ldr	r2, [r7, #4]
            err = lfs_bd_read(lfs,
    cfcc:	2001      	movs	r0, #1
    cfce:	9003      	str	r0, [sp, #12]
    cfd0:	f10d 0013 	add.w	r0, sp, #19
    cfd4:	9002      	str	r0, [sp, #8]
    cfd6:	4422      	add	r2, r4
    cfd8:	9201      	str	r2, [sp, #4]
    cfda:	9100      	str	r1, [sp, #0]
    cfdc:	3b04      	subs	r3, #4
    cfde:	462a      	mov	r2, r5
    cfe0:	2100      	movs	r1, #0
    cfe2:	4628      	mov	r0, r5
    cfe4:	f7ff f8fc 	bl	c1e0 <lfs_bd_read>
            if (err) {
    cfe8:	4603      	mov	r3, r0
    cfea:	b9b8      	cbnz	r0, d01c <lfs_dir_commitattr+0xac>
            err = lfs_dir_commitprog(lfs, commit, &dat, 1);
    cfec:	2301      	movs	r3, #1
    cfee:	f10d 0213 	add.w	r2, sp, #19
    cff2:	4631      	mov	r1, r6
    cff4:	4628      	mov	r0, r5
    cff6:	f7ff ff9b 	bl	cf30 <lfs_dir_commitprog>
            if (err) {
    cffa:	4603      	mov	r3, r0
    cffc:	b970      	cbnz	r0, d01c <lfs_dir_commitattr+0xac>
        for (lfs_off_t i = 0; i < dsize-sizeof(tag); i++) {
    cffe:	3401      	adds	r4, #1
    d000:	e7de      	b.n	cfc0 <lfs_dir_commitattr+0x50>
        err = lfs_dir_commitprog(lfs, commit, buffer, dsize-sizeof(tag));
    d002:	4643      	mov	r3, r8
    d004:	463a      	mov	r2, r7
    d006:	4631      	mov	r1, r6
    d008:	4628      	mov	r0, r5
    d00a:	f7ff ff91 	bl	cf30 <lfs_dir_commitprog>
        if (err) {
    d00e:	b950      	cbnz	r0, d026 <lfs_dir_commitattr+0xb6>
    commit->ptag = tag & 0x7fffffff;
    d010:	f8c6 b008 	str.w	fp, [r6, #8]
}
    d014:	4650      	mov	r0, sl
    d016:	b007      	add	sp, #28
    d018:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                return err;
    d01c:	469a      	mov	sl, r3
    d01e:	e7f9      	b.n	d014 <lfs_dir_commitattr+0xa4>
        return LFS_ERR_NOSPC;
    d020:	f06f 0a1b 	mvn.w	sl, #27
    d024:	e7f6      	b.n	d014 <lfs_dir_commitattr+0xa4>
            return err;
    d026:	4682      	mov	sl, r0
    d028:	e7f4      	b.n	d014 <lfs_dir_commitattr+0xa4>

0000d02a <lfs_dir_commit_commit>:
static int lfs_dir_commit_commit(void *p, lfs_tag_t tag, const void *buffer) {
    d02a:	b508      	push	{r3, lr}
    d02c:	4613      	mov	r3, r2
    return lfs_dir_commitattr(commit->lfs, commit->commit, tag, buffer);
    d02e:	460a      	mov	r2, r1
    d030:	6841      	ldr	r1, [r0, #4]
    d032:	6800      	ldr	r0, [r0, #0]
    d034:	f7ff ff9c 	bl	cf70 <lfs_dir_commitattr>
}
    d038:	bd08      	pop	{r3, pc}

0000d03a <lfs_dir_commitcrc>:
static int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {
    d03a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d03e:	b08b      	sub	sp, #44	; 0x2c
    d040:	4607      	mov	r7, r0
    d042:	460d      	mov	r5, r1
    const lfs_off_t end = lfs_alignup(commit->off + 2*sizeof(uint32_t),
    d044:	684b      	ldr	r3, [r1, #4]
    d046:	f103 0808 	add.w	r8, r3, #8
            lfs->cfg->prog_size);
    d04a:	6e83      	ldr	r3, [r0, #104]	; 0x68
    d04c:	699a      	ldr	r2, [r3, #24]
	return lfs_aligndown(a + alignment-1, alignment);
    d04e:	4490      	add	r8, r2
    d050:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
	return a - (a % alignment);
    d054:	fbb8 f3f2 	udiv	r3, r8, r2
    d058:	fb02 8313 	mls	r3, r2, r3, r8
    d05c:	eba8 0803 	sub.w	r8, r8, r3
    uint32_t crc1 = 0;
    d060:	f04f 0a00 	mov.w	sl, #0
    lfs_off_t off1 = 0;
    d064:	46d1      	mov	r9, sl
    while (commit->off < end) {
    d066:	e00c      	b.n	d082 <lfs_dir_commitcrc+0x48>
        commit->off += sizeof(tag)+lfs_tag_size(tag);
    d068:	9b07      	ldr	r3, [sp, #28]
    return tag & 0x000003ff;
    d06a:	f3c3 0109 	ubfx	r1, r3, #0, #10
        commit->off += sizeof(tag)+lfs_tag_size(tag);
    d06e:	3104      	adds	r1, #4
    d070:	686a      	ldr	r2, [r5, #4]
    d072:	440a      	add	r2, r1
    d074:	606a      	str	r2, [r5, #4]
        commit->ptag = tag ^ ((lfs_tag_t)reset << 31);
    d076:	ea83 73c6 	eor.w	r3, r3, r6, lsl #31
    d07a:	60ab      	str	r3, [r5, #8]
        commit->crc = 0xffffffff; // reset crc for next "commit"
    d07c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d080:	60eb      	str	r3, [r5, #12]
    while (commit->off < end) {
    d082:	686b      	ldr	r3, [r5, #4]
    d084:	4543      	cmp	r3, r8
    d086:	d25b      	bcs.n	d140 <lfs_dir_commitcrc+0x106>
        lfs_off_t off = commit->off + sizeof(lfs_tag_t);
    d088:	f103 0b04 	add.w	fp, r3, #4
        lfs_off_t noff = lfs_min(end - off, 0x3fe) + off;
    d08c:	eba8 020b 	sub.w	r2, r8, fp
    d090:	f240 33fe 	movw	r3, #1022	; 0x3fe
    d094:	429a      	cmp	r2, r3
    d096:	bf94      	ite	ls
    d098:	eb0b 0402 	addls.w	r4, fp, r2
    d09c:	eb0b 0403 	addhi.w	r4, fp, r3
        if (noff < end) {
    d0a0:	4544      	cmp	r4, r8
    d0a2:	d204      	bcs.n	d0ae <lfs_dir_commitcrc+0x74>
            noff = lfs_min(noff, end - 2*sizeof(uint32_t));
    d0a4:	f1a8 0308 	sub.w	r3, r8, #8
	return (a < b) ? a : b;
    d0a8:	429c      	cmp	r4, r3
    d0aa:	bf28      	it	cs
    d0ac:	461c      	movcs	r4, r3
        lfs_tag_t tag = 0xffffffff;
    d0ae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d0b2:	9307      	str	r3, [sp, #28]
        int err = lfs_bd_read(lfs,
    d0b4:	2304      	movs	r3, #4
    d0b6:	9303      	str	r3, [sp, #12]
    d0b8:	aa07      	add	r2, sp, #28
    d0ba:	9202      	str	r2, [sp, #8]
    d0bc:	9401      	str	r4, [sp, #4]
    d0be:	682a      	ldr	r2, [r5, #0]
    d0c0:	9200      	str	r2, [sp, #0]
    d0c2:	463a      	mov	r2, r7
    d0c4:	2100      	movs	r1, #0
    d0c6:	4638      	mov	r0, r7
    d0c8:	f7ff f88a 	bl	c1e0 <lfs_bd_read>
        if (err && err != LFS_ERR_CORRUPT) {
    d0cc:	4602      	mov	r2, r0
    d0ce:	b110      	cbz	r0, d0d6 <lfs_dir_commitcrc+0x9c>
    d0d0:	f110 0f54 	cmn.w	r0, #84	; 0x54
    d0d4:	d16a      	bne.n	d1ac <lfs_dir_commitcrc+0x172>
        bool reset = ~lfs_frombe32(tag) >> 31;
    d0d6:	9e07      	ldr	r6, [sp, #28]
	return __builtin_bswap32(a);
    d0d8:	ba36      	rev	r6, r6
    d0da:	43f6      	mvns	r6, r6
    d0dc:	0ff6      	lsrs	r6, r6, #31
        tag = LFS_MKTAG(LFS_TYPE_CRC + reset, 0x3ff, noff - off);
    d0de:	f506 63a0 	add.w	r3, r6, #1280	; 0x500
    d0e2:	eba4 040b 	sub.w	r4, r4, fp
    d0e6:	ea44 5403 	orr.w	r4, r4, r3, lsl #20
    d0ea:	f444 247f 	orr.w	r4, r4, #1044480	; 0xff000
    d0ee:	f444 6440 	orr.w	r4, r4, #3072	; 0xc00
    d0f2:	9407      	str	r4, [sp, #28]
        footer[0] = lfs_tobe32(tag ^ commit->ptag);
    d0f4:	68ab      	ldr	r3, [r5, #8]
    d0f6:	405c      	eors	r4, r3
    d0f8:	ba24      	rev	r4, r4
    d0fa:	9408      	str	r4, [sp, #32]
        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
    d0fc:	ac08      	add	r4, sp, #32
    d0fe:	2204      	movs	r2, #4
    d100:	4621      	mov	r1, r4
    d102:	68e8      	ldr	r0, [r5, #12]
    d104:	f7fa fe6a 	bl	7ddc <lfs_crc>
    d108:	60e8      	str	r0, [r5, #12]
        footer[1] = lfs_tole32(commit->crc);
    d10a:	9009      	str	r0, [sp, #36]	; 0x24
        err = lfs_bd_prog(lfs,
    d10c:	2308      	movs	r3, #8
    d10e:	9303      	str	r3, [sp, #12]
    d110:	9402      	str	r4, [sp, #8]
    d112:	686b      	ldr	r3, [r5, #4]
    d114:	9301      	str	r3, [sp, #4]
    d116:	682b      	ldr	r3, [r5, #0]
    d118:	9300      	str	r3, [sp, #0]
    d11a:	2300      	movs	r3, #0
    d11c:	463a      	mov	r2, r7
    d11e:	f107 0110 	add.w	r1, r7, #16
    d122:	4638      	mov	r0, r7
    d124:	f7ff fab6 	bl	c694 <lfs_bd_prog>
        if (err) {
    d128:	4602      	mov	r2, r0
    d12a:	2800      	cmp	r0, #0
    d12c:	d13e      	bne.n	d1ac <lfs_dir_commitcrc+0x172>
        if (off1 == 0) {
    d12e:	f1b9 0f00 	cmp.w	r9, #0
    d132:	d199      	bne.n	d068 <lfs_dir_commitcrc+0x2e>
            off1 = commit->off + sizeof(uint32_t);
    d134:	686b      	ldr	r3, [r5, #4]
    d136:	f103 0904 	add.w	r9, r3, #4
            crc1 = commit->crc;
    d13a:	f8d5 a00c 	ldr.w	sl, [r5, #12]
    d13e:	e793      	b.n	d068 <lfs_dir_commitcrc+0x2e>
    int err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);
    d140:	2300      	movs	r3, #0
    d142:	463a      	mov	r2, r7
    d144:	f107 0110 	add.w	r1, r7, #16
    d148:	4638      	mov	r0, r7
    d14a:	f7ff faf2 	bl	c732 <lfs_bd_sync>
    if (err) {
    d14e:	4602      	mov	r2, r0
    d150:	bb60      	cbnz	r0, d1ac <lfs_dir_commitcrc+0x172>
    lfs_off_t off = commit->begin;
    d152:	692c      	ldr	r4, [r5, #16]
    while (off < end) {
    d154:	4643      	mov	r3, r8
    d156:	46c8      	mov	r8, r9
    d158:	9005      	str	r0, [sp, #20]
    d15a:	461e      	mov	r6, r3
    d15c:	42b4      	cmp	r4, r6
    d15e:	d240      	bcs.n	d1e2 <lfs_dir_commitcrc+0x1a8>
        uint32_t crc = 0xffffffff;
    d160:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    d164:	e017      	b.n	d196 <lfs_dir_commitcrc+0x15c>
                    NULL, &lfs->rcache, noff+sizeof(uint32_t)-i,
    d166:	eba8 0304 	sub.w	r3, r8, r4
            err = lfs_bd_read(lfs,
    d16a:	2201      	movs	r2, #1
    d16c:	9203      	str	r2, [sp, #12]
    d16e:	aa08      	add	r2, sp, #32
    d170:	9202      	str	r2, [sp, #8]
    d172:	9401      	str	r4, [sp, #4]
    d174:	682a      	ldr	r2, [r5, #0]
    d176:	9200      	str	r2, [sp, #0]
    d178:	3304      	adds	r3, #4
    d17a:	463a      	mov	r2, r7
    d17c:	2100      	movs	r1, #0
    d17e:	4638      	mov	r0, r7
    d180:	f7ff f82e 	bl	c1e0 <lfs_bd_read>
            if (err) {
    d184:	4603      	mov	r3, r0
    d186:	b980      	cbnz	r0, d1aa <lfs_dir_commitcrc+0x170>
            crc = lfs_crc(crc, &dat, 1);
    d188:	2201      	movs	r2, #1
    d18a:	a908      	add	r1, sp, #32
    d18c:	4658      	mov	r0, fp
    d18e:	f7fa fe25 	bl	7ddc <lfs_crc>
    d192:	4683      	mov	fp, r0
        for (lfs_off_t i = off; i < noff+sizeof(uint32_t); i++) {
    d194:	3401      	adds	r4, #1
    d196:	f108 0304 	add.w	r3, r8, #4
    d19a:	42a3      	cmp	r3, r4
    d19c:	d90a      	bls.n	d1b4 <lfs_dir_commitcrc+0x17a>
            if (i == off1 && crc != crc1) {
    d19e:	45a1      	cmp	r9, r4
    d1a0:	d1e1      	bne.n	d166 <lfs_dir_commitcrc+0x12c>
    d1a2:	45da      	cmp	sl, fp
    d1a4:	d0df      	beq.n	d166 <lfs_dir_commitcrc+0x12c>
                return LFS_ERR_CORRUPT;
    d1a6:	f06f 0353 	mvn.w	r3, #83	; 0x53
    d1aa:	461a      	mov	r2, r3
}
    d1ac:	4610      	mov	r0, r2
    d1ae:	b00b      	add	sp, #44	; 0x2c
    d1b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (crc != 0) {
    d1b4:	f1bb 0f00 	cmp.w	fp, #0
    d1b8:	d115      	bne.n	d1e6 <lfs_dir_commitcrc+0x1ac>
        off = lfs_min(end - noff, 0x3fe) + noff;
    d1ba:	eba6 0108 	sub.w	r1, r6, r8
    d1be:	f240 33fe 	movw	r3, #1022	; 0x3fe
    d1c2:	4299      	cmp	r1, r3
    d1c4:	bf94      	ite	ls
    d1c6:	eb08 0401 	addls.w	r4, r8, r1
    d1ca:	eb08 0403 	addhi.w	r4, r8, r3
        if (off < end) {
    d1ce:	42b4      	cmp	r4, r6
    d1d0:	d204      	bcs.n	d1dc <lfs_dir_commitcrc+0x1a2>
            off = lfs_min(off, end - 2*sizeof(uint32_t));
    d1d2:	f1a6 0308 	sub.w	r3, r6, #8
	return (a < b) ? a : b;
    d1d6:	429c      	cmp	r4, r3
    d1d8:	bf28      	it	cs
    d1da:	461c      	movcs	r4, r3
        noff = off + sizeof(uint32_t);
    d1dc:	f104 0804 	add.w	r8, r4, #4
    d1e0:	e7bc      	b.n	d15c <lfs_dir_commitcrc+0x122>
    d1e2:	9a05      	ldr	r2, [sp, #20]
    d1e4:	e7e2      	b.n	d1ac <lfs_dir_commitcrc+0x172>
            return LFS_ERR_CORRUPT;
    d1e6:	f06f 0253 	mvn.w	r2, #83	; 0x53
    d1ea:	e7df      	b.n	d1ac <lfs_dir_commitcrc+0x172>

0000d1ec <lfs_dir_split>:
        lfs_mdir_t *source, uint16_t split, uint16_t end) {
    d1ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    d1f0:	b08d      	sub	sp, #52	; 0x34
    d1f2:	4605      	mov	r5, r0
    d1f4:	460c      	mov	r4, r1
    d1f6:	4691      	mov	r9, r2
    d1f8:	461e      	mov	r6, r3
    d1fa:	f8bd 8054 	ldrh.w	r8, [sp, #84]	; 0x54
    int err = lfs_dir_alloc(lfs, &tail);
    d1fe:	a904      	add	r1, sp, #16
    d200:	f7ff fb1d 	bl	c83e <lfs_dir_alloc>
    if (err) {
    d204:	4607      	mov	r7, r0
    d206:	b118      	cbz	r0, d210 <lfs_dir_split+0x24>
}
    d208:	4638      	mov	r0, r7
    d20a:	b00d      	add	sp, #52	; 0x34
    d20c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    tail.split = dir->split;
    d210:	7de3      	ldrb	r3, [r4, #23]
    d212:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    tail.tail[0] = dir->tail[0];
    d216:	69a3      	ldr	r3, [r4, #24]
    d218:	930a      	str	r3, [sp, #40]	; 0x28
    tail.tail[1] = dir->tail[1];
    d21a:	69e3      	ldr	r3, [r4, #28]
    d21c:	930b      	str	r3, [sp, #44]	; 0x2c
    int res = lfs_dir_compact(lfs, &tail, attrs, attrcount, source, split, end);
    d21e:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    d222:	9302      	str	r3, [sp, #8]
    d224:	f8cd 8004 	str.w	r8, [sp, #4]
    d228:	9b14      	ldr	r3, [sp, #80]	; 0x50
    d22a:	9300      	str	r3, [sp, #0]
    d22c:	4633      	mov	r3, r6
    d22e:	464a      	mov	r2, r9
    d230:	a904      	add	r1, sp, #16
    d232:	4628      	mov	r0, r5
    d234:	f7f9 f8f0 	bl	6418 <lfs_dir_compact>
    if (res < 0) {
    d238:	2800      	cmp	r0, #0
    d23a:	db17      	blt.n	d26c <lfs_dir_split+0x80>
    dir->tail[0] = tail.pair[0];
    d23c:	9904      	ldr	r1, [sp, #16]
    d23e:	61a1      	str	r1, [r4, #24]
    dir->tail[1] = tail.pair[1];
    d240:	9a05      	ldr	r2, [sp, #20]
    d242:	61e2      	str	r2, [r4, #28]
    dir->split = true;
    d244:	2301      	movs	r3, #1
    d246:	75e3      	strb	r3, [r4, #23]
    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
    d248:	6823      	ldr	r3, [r4, #0]
    d24a:	6a28      	ldr	r0, [r5, #32]
    d24c:	4283      	cmp	r3, r0
    d24e:	d007      	beq.n	d260 <lfs_dir_split+0x74>
    d250:	6866      	ldr	r6, [r4, #4]
    d252:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    d254:	42a6      	cmp	r6, r4
    d256:	d003      	beq.n	d260 <lfs_dir_split+0x74>
    d258:	42a3      	cmp	r3, r4
    d25a:	d001      	beq.n	d260 <lfs_dir_split+0x74>
    d25c:	42b0      	cmp	r0, r6
    d25e:	d1d3      	bne.n	d208 <lfs_dir_split+0x1c>
    if (lfs_pair_cmp(dir->pair, lfs->root) == 0 && split == 0) {
    d260:	f1b8 0f00 	cmp.w	r8, #0
    d264:	d1d0      	bne.n	d208 <lfs_dir_split+0x1c>
        lfs->root[0] = tail.pair[0];
    d266:	6229      	str	r1, [r5, #32]
        lfs->root[1] = tail.pair[1];
    d268:	626a      	str	r2, [r5, #36]	; 0x24
    d26a:	e7cd      	b.n	d208 <lfs_dir_split+0x1c>
        return res;
    d26c:	4607      	mov	r7, r0
    d26e:	e7cb      	b.n	d208 <lfs_dir_split+0x1c>

0000d270 <lfs_dir_commit>:
        const struct lfs_mattr *attrs, int attrcount) {
    d270:	b510      	push	{r4, lr}
    d272:	4604      	mov	r4, r0
    int orphans = lfs_dir_orphaningcommit(lfs, dir, attrs, attrcount);
    d274:	f7f9 fc44 	bl	6b00 <lfs_dir_orphaningcommit>
    if (orphans < 0) {
    d278:	2800      	cmp	r0, #0
    d27a:	db00      	blt.n	d27e <lfs_dir_commit+0xe>
    if (orphans) {
    d27c:	b900      	cbnz	r0, d280 <lfs_dir_commit+0x10>
}
    d27e:	bd10      	pop	{r4, pc}
        int err = lfs_fs_deorphan(lfs, false);
    d280:	2100      	movs	r1, #0
    d282:	4620      	mov	r0, r4
    d284:	f7f9 fde2 	bl	6e4c <lfs_fs_deorphan>
        if (err) {
    d288:	e7f9      	b.n	d27e <lfs_dir_commit+0xe>

0000d28a <lfs_fs_demove>:
    return lfs_tag_type1(a->tag);
    d28a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    return (tag & 0x70000000) >> 20;
    d28c:	0d1b      	lsrs	r3, r3, #20
    if (!lfs_gstate_hasmove(&lfs->gdisk)) {
    d28e:	f413 6fe0 	tst.w	r3, #1792	; 0x700
    d292:	d101      	bne.n	d298 <lfs_fs_demove+0xe>
        return 0;
    d294:	2000      	movs	r0, #0
}
    d296:	4770      	bx	lr
static int lfs_fs_demove(lfs_t *lfs) {
    d298:	b530      	push	{r4, r5, lr}
    d29a:	b08b      	sub	sp, #44	; 0x2c
    d29c:	4604      	mov	r4, r0
    int err = lfs_dir_fetch(lfs, &movedir, lfs->gdisk.pair);
    d29e:	f100 0240 	add.w	r2, r0, #64	; 0x40
    d2a2:	4669      	mov	r1, sp
    d2a4:	f7ff fabd 	bl	c822 <lfs_dir_fetch>
    if (err) {
    d2a8:	b108      	cbz	r0, d2ae <lfs_fs_demove+0x24>
}
    d2aa:	b00b      	add	sp, #44	; 0x2c
    d2ac:	bd30      	pop	{r4, r5, pc}
    uint16_t moveid = lfs_tag_id(lfs->gdisk.tag);
    d2ae:	6be5      	ldr	r5, [r4, #60]	; 0x3c
    return (tag & 0x000ffc00) >> 10;
    d2b0:	f3c5 2589 	ubfx	r5, r5, #10, #10
    lfs_fs_prepmove(lfs, 0x3ff, NULL);
    d2b4:	2200      	movs	r2, #0
    d2b6:	f240 31ff 	movw	r1, #1023	; 0x3ff
    d2ba:	4620      	mov	r0, r4
    d2bc:	f7f8 f966 	bl	558c <lfs_fs_prepmove>
    err = lfs_dir_commit(lfs, &movedir, LFS_MKATTRS(
    d2c0:	02ab      	lsls	r3, r5, #10
    d2c2:	f043 439f 	orr.w	r3, r3, #1333788672	; 0x4f800000
    d2c6:	f443 03e0 	orr.w	r3, r3, #7340032	; 0x700000
    d2ca:	9308      	str	r3, [sp, #32]
    d2cc:	2300      	movs	r3, #0
    d2ce:	9309      	str	r3, [sp, #36]	; 0x24
    d2d0:	2301      	movs	r3, #1
    d2d2:	aa08      	add	r2, sp, #32
    d2d4:	4669      	mov	r1, sp
    d2d6:	4620      	mov	r0, r4
    d2d8:	f7ff ffca 	bl	d270 <lfs_dir_commit>
    if (err) {
    d2dc:	e7e5      	b.n	d2aa <lfs_fs_demove+0x20>

0000d2de <lfs_fs_forceconsistency>:
static int lfs_fs_forceconsistency(lfs_t *lfs) {
    d2de:	b510      	push	{r4, lr}
    d2e0:	4604      	mov	r4, r0
    int err = lfs_fs_demove(lfs);
    d2e2:	f7ff ffd2 	bl	d28a <lfs_fs_demove>
    if (err) {
    d2e6:	b100      	cbz	r0, d2ea <lfs_fs_forceconsistency+0xc>
}
    d2e8:	bd10      	pop	{r4, pc}
    err = lfs_fs_deorphan(lfs, true);
    d2ea:	2101      	movs	r1, #1
    d2ec:	4620      	mov	r0, r4
    d2ee:	f7f9 fdad 	bl	6e4c <lfs_fs_deorphan>
    if (err) {
    d2f2:	e7f9      	b.n	d2e8 <lfs_fs_forceconsistency+0xa>

0000d2f4 <lfs_file_rawsync>:
    if (file->flags & LFS_F_ERRED) {
    d2f4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    d2f6:	f413 2f00 	tst.w	r3, #524288	; 0x80000
    d2fa:	d001      	beq.n	d300 <lfs_file_rawsync+0xc>
        return 0;
    d2fc:	2000      	movs	r0, #0
}
    d2fe:	4770      	bx	lr
static int lfs_file_rawsync(lfs_t *lfs, lfs_file_t *file) {
    d300:	b530      	push	{r4, r5, lr}
    d302:	b087      	sub	sp, #28
    d304:	4605      	mov	r5, r0
    d306:	460c      	mov	r4, r1
    int err = lfs_file_flush(lfs, file);
    d308:	f7ff fc61 	bl	cbce <lfs_file_flush>
    if (err) {
    d30c:	2800      	cmp	r0, #0
    d30e:	d132      	bne.n	d376 <lfs_file_rawsync+0x82>
    if ((file->flags & LFS_F_DIRTY) &&
    d310:	6b23      	ldr	r3, [r4, #48]	; 0x30
    d312:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    d316:	d032      	beq.n	d37e <lfs_file_rawsync+0x8a>
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    d318:	68a2      	ldr	r2, [r4, #8]
    d31a:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    d31e:	d032      	beq.n	d386 <lfs_file_rawsync+0x92>
    d320:	68e2      	ldr	r2, [r4, #12]
    d322:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    d326:	d02c      	beq.n	d382 <lfs_file_rawsync+0x8e>
    d328:	4602      	mov	r2, r0
    if ((file->flags & LFS_F_DIRTY) &&
    d32a:	f012 0f01 	tst.w	r2, #1
    d32e:	d126      	bne.n	d37e <lfs_file_rawsync+0x8a>
        if (file->flags & LFS_F_INLINE) {
    d330:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    d334:	d029      	beq.n	d38a <lfs_file_rawsync+0x96>
            buffer = file->cache.buffer;
    d336:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
            size = file->ctz.size;
    d338:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
            type = LFS_TYPE_INLINESTRUCT;
    d33a:	f240 2201 	movw	r2, #513	; 0x201
        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
    d33e:	88a3      	ldrh	r3, [r4, #4]
    d340:	029b      	lsls	r3, r3, #10
    d342:	ea43 5202 	orr.w	r2, r3, r2, lsl #20
    d346:	4302      	orrs	r2, r0
    d348:	9202      	str	r2, [sp, #8]
    d34a:	9103      	str	r1, [sp, #12]
    d34c:	6d22      	ldr	r2, [r4, #80]	; 0x50
    d34e:	6891      	ldr	r1, [r2, #8]
    d350:	430b      	orrs	r3, r1
    d352:	f043 5381 	orr.w	r3, r3, #270532608	; 0x10200000
    d356:	9304      	str	r3, [sp, #16]
    d358:	6853      	ldr	r3, [r2, #4]
    d35a:	9305      	str	r3, [sp, #20]
    d35c:	2302      	movs	r3, #2
    d35e:	aa02      	add	r2, sp, #8
    d360:	f104 0108 	add.w	r1, r4, #8
    d364:	4628      	mov	r0, r5
    d366:	f7ff ff83 	bl	d270 <lfs_dir_commit>
        if (err) {
    d36a:	b9d0      	cbnz	r0, d3a2 <lfs_file_rawsync+0xae>
        file->flags &= ~LFS_F_DIRTY;
    d36c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    d36e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    d372:	6323      	str	r3, [r4, #48]	; 0x30
    d374:	e003      	b.n	d37e <lfs_file_rawsync+0x8a>
        file->flags |= LFS_F_ERRED;
    d376:	6b23      	ldr	r3, [r4, #48]	; 0x30
    d378:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    d37c:	6323      	str	r3, [r4, #48]	; 0x30
}
    d37e:	b007      	add	sp, #28
    d380:	bd30      	pop	{r4, r5, pc}
    return pair[0] == LFS_BLOCK_NULL || pair[1] == LFS_BLOCK_NULL;
    d382:	2201      	movs	r2, #1
    d384:	e7d1      	b.n	d32a <lfs_file_rawsync+0x36>
    d386:	2201      	movs	r2, #1
    d388:	e7cf      	b.n	d32a <lfs_file_rawsync+0x36>
            ctz = file->ctz;
    d38a:	466b      	mov	r3, sp
    d38c:	f104 0228 	add.w	r2, r4, #40	; 0x28
    d390:	e892 0003 	ldmia.w	r2, {r0, r1}
    d394:	e883 0003 	stmia.w	r3, {r0, r1}
            size = sizeof(ctz);
    d398:	2008      	movs	r0, #8
            buffer = &ctz;
    d39a:	4619      	mov	r1, r3
            type = LFS_TYPE_CTZSTRUCT;
    d39c:	f240 2202 	movw	r2, #514	; 0x202
    d3a0:	e7cd      	b.n	d33e <lfs_file_rawsync+0x4a>
            file->flags |= LFS_F_ERRED;
    d3a2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    d3a4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    d3a8:	6323      	str	r3, [r4, #48]	; 0x30
            return err;
    d3aa:	e7e8      	b.n	d37e <lfs_file_rawsync+0x8a>

0000d3ac <lfs_deinit>:
static int lfs_deinit(lfs_t *lfs) {
    d3ac:	b510      	push	{r4, lr}
    d3ae:	4604      	mov	r4, r0
    if (!lfs->cfg->read_buffer) {
    d3b0:	6e83      	ldr	r3, [r0, #104]	; 0x68
    d3b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    d3b4:	b13b      	cbz	r3, d3c6 <lfs_deinit+0x1a>
    if (!lfs->cfg->prog_buffer) {
    d3b6:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    d3b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    d3ba:	b143      	cbz	r3, d3ce <lfs_deinit+0x22>
    if (!lfs->cfg->lookahead_buffer) {
    d3bc:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    d3be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    d3c0:	b14b      	cbz	r3, d3d6 <lfs_deinit+0x2a>
}
    d3c2:	2000      	movs	r0, #0
    d3c4:	bd10      	pop	{r4, pc}

/* Deallocate memory, only used if buffers are not provided to littlefs */
static inline void lfs_free(void *p)
{
#ifndef LFS_NO_MALLOC
	free(p);
    d3c6:	68c0      	ldr	r0, [r0, #12]
    d3c8:	f7fd f903 	bl	a5d2 <free>
#else
	(void)p;
#endif
}
    d3cc:	e7f3      	b.n	d3b6 <lfs_deinit+0xa>
	free(p);
    d3ce:	69e0      	ldr	r0, [r4, #28]
    d3d0:	f7fd f8ff 	bl	a5d2 <free>
}
    d3d4:	e7f2      	b.n	d3bc <lfs_deinit+0x10>
	free(p);
    d3d6:	6e60      	ldr	r0, [r4, #100]	; 0x64
    d3d8:	f7fd f8fb 	bl	a5d2 <free>
}
    d3dc:	e7f1      	b.n	d3c2 <lfs_deinit+0x16>

0000d3de <lfs_init>:
static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
    d3de:	b510      	push	{r4, lr}
    d3e0:	4604      	mov	r4, r0
    lfs->cfg = cfg;
    d3e2:	6681      	str	r1, [r0, #104]	; 0x68
    if (lfs->cfg->read_buffer) {
    d3e4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    d3e6:	2b00      	cmp	r3, #0
    d3e8:	d036      	beq.n	d458 <lfs_init+0x7a>
        lfs->rcache.buffer = lfs->cfg->read_buffer;
    d3ea:	60c3      	str	r3, [r0, #12]
    if (lfs->cfg->prog_buffer) {
    d3ec:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    d3ee:	6b53      	ldr	r3, [r2, #52]	; 0x34
    d3f0:	2b00      	cmp	r3, #0
    d3f2:	d03d      	beq.n	d470 <lfs_init+0x92>
        lfs->pcache.buffer = lfs->cfg->prog_buffer;
    d3f4:	61e3      	str	r3, [r4, #28]
    lfs_cache_zero(lfs, &lfs->rcache);
    d3f6:	4621      	mov	r1, r4
    d3f8:	4620      	mov	r0, r4
    d3fa:	f7fe fec7 	bl	c18c <lfs_cache_zero>
    lfs_cache_zero(lfs, &lfs->pcache);
    d3fe:	f104 0110 	add.w	r1, r4, #16
    d402:	4620      	mov	r0, r4
    d404:	f7fe fec2 	bl	c18c <lfs_cache_zero>
    if (lfs->cfg->lookahead_buffer) {
    d408:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    d40a:	6b93      	ldr	r3, [r2, #56]	; 0x38
    d40c:	2b00      	cmp	r3, #0
    d40e:	d036      	beq.n	d47e <lfs_init+0xa0>
        lfs->free.buffer = lfs->cfg->lookahead_buffer;
    d410:	6663      	str	r3, [r4, #100]	; 0x64
    lfs->name_max = lfs->cfg->name_max;
    d412:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    d414:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    d416:	66e2      	str	r2, [r4, #108]	; 0x6c
    if (!lfs->name_max) {
    d418:	b90a      	cbnz	r2, d41e <lfs_init+0x40>
        lfs->name_max = LFS_NAME_MAX;
    d41a:	22ff      	movs	r2, #255	; 0xff
    d41c:	66e2      	str	r2, [r4, #108]	; 0x6c
    lfs->file_max = lfs->cfg->file_max;
    d41e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    d420:	6722      	str	r2, [r4, #112]	; 0x70
    if (!lfs->file_max) {
    d422:	b912      	cbnz	r2, d42a <lfs_init+0x4c>
        lfs->file_max = LFS_FILE_MAX;
    d424:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
    d428:	6722      	str	r2, [r4, #112]	; 0x70
    lfs->attr_max = lfs->cfg->attr_max;
    d42a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    d42c:	6763      	str	r3, [r4, #116]	; 0x74
    if (!lfs->attr_max) {
    d42e:	b913      	cbnz	r3, d436 <lfs_init+0x58>
        lfs->attr_max = LFS_ATTR_MAX;
    d430:	f240 33fe 	movw	r3, #1022	; 0x3fe
    d434:	6763      	str	r3, [r4, #116]	; 0x74
    lfs->root[0] = LFS_BLOCK_NULL;
    d436:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d43a:	6223      	str	r3, [r4, #32]
    lfs->root[1] = LFS_BLOCK_NULL;
    d43c:	6263      	str	r3, [r4, #36]	; 0x24
    lfs->mlist = NULL;
    d43e:	2000      	movs	r0, #0
    d440:	62a0      	str	r0, [r4, #40]	; 0x28
    lfs->seed = 0;
    d442:	62e0      	str	r0, [r4, #44]	; 0x2c
    lfs->gdisk = (lfs_gstate_t){0};
    d444:	63e0      	str	r0, [r4, #60]	; 0x3c
    d446:	6420      	str	r0, [r4, #64]	; 0x40
    d448:	6460      	str	r0, [r4, #68]	; 0x44
    lfs->gstate = (lfs_gstate_t){0};
    d44a:	6320      	str	r0, [r4, #48]	; 0x30
    d44c:	6360      	str	r0, [r4, #52]	; 0x34
    d44e:	63a0      	str	r0, [r4, #56]	; 0x38
    lfs->gdelta = (lfs_gstate_t){0};
    d450:	64a0      	str	r0, [r4, #72]	; 0x48
    d452:	64e0      	str	r0, [r4, #76]	; 0x4c
    d454:	6520      	str	r0, [r4, #80]	; 0x50
}
    d456:	bd10      	pop	{r4, pc}
	return malloc(size);
    d458:	6a88      	ldr	r0, [r1, #40]	; 0x28
    d45a:	f7f4 ff5d 	bl	2318 <malloc>
        lfs->rcache.buffer = lfs_malloc(lfs->cfg->cache_size);
    d45e:	60e0      	str	r0, [r4, #12]
        if (!lfs->rcache.buffer) {
    d460:	2800      	cmp	r0, #0
    d462:	d1c3      	bne.n	d3ec <lfs_init+0xe>
    lfs_deinit(lfs);
    d464:	4620      	mov	r0, r4
    d466:	f7ff ffa1 	bl	d3ac <lfs_deinit>
    return err;
    d46a:	f06f 000b 	mvn.w	r0, #11
    d46e:	e7f2      	b.n	d456 <lfs_init+0x78>
    d470:	6a90      	ldr	r0, [r2, #40]	; 0x28
    d472:	f7f4 ff51 	bl	2318 <malloc>
        lfs->pcache.buffer = lfs_malloc(lfs->cfg->cache_size);
    d476:	61e0      	str	r0, [r4, #28]
        if (!lfs->pcache.buffer) {
    d478:	2800      	cmp	r0, #0
    d47a:	d1bc      	bne.n	d3f6 <lfs_init+0x18>
    d47c:	e7f2      	b.n	d464 <lfs_init+0x86>
    d47e:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
    d480:	f7f4 ff4a 	bl	2318 <malloc>
        lfs->free.buffer = lfs_malloc(lfs->cfg->lookahead_size);
    d484:	6660      	str	r0, [r4, #100]	; 0x64
        if (!lfs->free.buffer) {
    d486:	2800      	cmp	r0, #0
    d488:	d1c3      	bne.n	d412 <lfs_init+0x34>
    d48a:	e7eb      	b.n	d464 <lfs_init+0x86>

0000d48c <lfs_rawunmount>:
static int lfs_rawunmount(lfs_t *lfs) {
    d48c:	b508      	push	{r3, lr}
    return lfs_deinit(lfs);
    d48e:	f7ff ff8d 	bl	d3ac <lfs_deinit>
}
    d492:	bd08      	pop	{r3, pc}

0000d494 <lfs_file_rawclose>:
static int lfs_file_rawclose(lfs_t *lfs, lfs_file_t *file) {
    d494:	b570      	push	{r4, r5, r6, lr}
    d496:	4606      	mov	r6, r0
    d498:	460c      	mov	r4, r1
    int err = lfs_file_rawsync(lfs, file);
    d49a:	f7ff ff2b 	bl	d2f4 <lfs_file_rawsync>
    d49e:	4605      	mov	r5, r0
    lfs_mlist_remove(lfs, (struct lfs_mlist*)file);
    d4a0:	4621      	mov	r1, r4
    d4a2:	4630      	mov	r0, r6
    d4a4:	f7fe fdf5 	bl	c092 <lfs_mlist_remove>
    if (!file->cfg->buffer) {
    d4a8:	6d23      	ldr	r3, [r4, #80]	; 0x50
    d4aa:	681b      	ldr	r3, [r3, #0]
    d4ac:	b10b      	cbz	r3, d4b2 <lfs_file_rawclose+0x1e>
}
    d4ae:	4628      	mov	r0, r5
    d4b0:	bd70      	pop	{r4, r5, r6, pc}
	free(p);
    d4b2:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    d4b4:	f7fd f88d 	bl	a5d2 <free>
    return err;
    d4b8:	e7f9      	b.n	d4ae <lfs_file_rawclose+0x1a>

0000d4ba <lfs_rawstat>:
static int lfs_rawstat(lfs_t *lfs, const char *path, struct lfs_info *info) {
    d4ba:	b530      	push	{r4, r5, lr}
    d4bc:	b08b      	sub	sp, #44	; 0x2c
    d4be:	4604      	mov	r4, r0
    d4c0:	9101      	str	r1, [sp, #4]
    d4c2:	4615      	mov	r5, r2
    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
    d4c4:	2300      	movs	r3, #0
    d4c6:	aa01      	add	r2, sp, #4
    d4c8:	a902      	add	r1, sp, #8
    d4ca:	f7f9 ff29 	bl	7320 <lfs_dir_find>
    if (tag < 0) {
    d4ce:	2800      	cmp	r0, #0
    d4d0:	db06      	blt.n	d4e0 <lfs_rawstat+0x26>
    return lfs_dir_getinfo(lfs, &cwd, lfs_tag_id(tag), info);
    d4d2:	462b      	mov	r3, r5
    d4d4:	f3c0 2289 	ubfx	r2, r0, #10, #10
    d4d8:	a902      	add	r1, sp, #8
    d4da:	4620      	mov	r0, r4
    d4dc:	f7fa fbd6 	bl	7c8c <lfs_dir_getinfo>
}
    d4e0:	b00b      	add	sp, #44	; 0x2c
    d4e2:	bd30      	pop	{r4, r5, pc}

0000d4e4 <lfs_format>:
#define LFS_UNLOCK(cfg) ((void)cfg)
#endif

// Public API
#ifndef LFS_READONLY
int lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {
    d4e4:	b508      	push	{r3, lr}
            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,
            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,
            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,
            cfg->name_max, cfg->file_max, cfg->attr_max);

    err = lfs_rawformat(lfs, cfg);
    d4e6:	f7f9 fd93 	bl	7010 <lfs_rawformat>

    LFS_TRACE("lfs_format -> %d", err);
    LFS_UNLOCK(cfg);
    return err;
}
    d4ea:	bd08      	pop	{r3, pc}

0000d4ec <lfs_mount>:
#endif

int lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {
    d4ec:	b508      	push	{r3, lr}
            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,
            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,
            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,
            cfg->name_max, cfg->file_max, cfg->attr_max);

    err = lfs_rawmount(lfs, cfg);
    d4ee:	f7f9 fdf9 	bl	70e4 <lfs_rawmount>

    LFS_TRACE("lfs_mount -> %d", err);
    LFS_UNLOCK(cfg);
    return err;
}
    d4f2:	bd08      	pop	{r3, pc}

0000d4f4 <lfs_unmount>:

int lfs_unmount(lfs_t *lfs) {
    d4f4:	b508      	push	{r3, lr}
    if (err) {
        return err;
    }
    LFS_TRACE("lfs_unmount(%p)", (void*)lfs);

    err = lfs_rawunmount(lfs);
    d4f6:	f7ff ffc9 	bl	d48c <lfs_rawunmount>

    LFS_TRACE("lfs_unmount -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d4fa:	bd08      	pop	{r3, pc}

0000d4fc <lfs_remove>:

#ifndef LFS_READONLY
int lfs_remove(lfs_t *lfs, const char *path) {
    d4fc:	b508      	push	{r3, lr}
    if (err) {
        return err;
    }
    LFS_TRACE("lfs_remove(%p, \"%s\")", (void*)lfs, path);

    err = lfs_rawremove(lfs, path);
    d4fe:	f7f9 ffcf 	bl	74a0 <lfs_rawremove>

    LFS_TRACE("lfs_remove -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d502:	bd08      	pop	{r3, pc}

0000d504 <lfs_rename>:
#endif

#ifndef LFS_READONLY
int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath) {
    d504:	b508      	push	{r3, lr}
    if (err) {
        return err;
    }
    LFS_TRACE("lfs_rename(%p, \"%s\", \"%s\")", (void*)lfs, oldpath, newpath);

    err = lfs_rawrename(lfs, oldpath, newpath);
    d506:	f7fa f893 	bl	7630 <lfs_rawrename>

    LFS_TRACE("lfs_rename -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d50a:	bd08      	pop	{r3, pc}

0000d50c <lfs_stat>:
#endif

int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {
    d50c:	b508      	push	{r3, lr}
    if (err) {
        return err;
    }
    LFS_TRACE("lfs_stat(%p, \"%s\", %p)", (void*)lfs, path, (void*)info);

    err = lfs_rawstat(lfs, path, info);
    d50e:	f7ff ffd4 	bl	d4ba <lfs_rawstat>

    LFS_TRACE("lfs_stat -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d512:	bd08      	pop	{r3, pc}

0000d514 <lfs_file_opencfg>:
}
#endif

int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
        const char *path, int flags,
        const struct lfs_file_config *cfg) {
    d514:	b500      	push	{lr}
    d516:	b083      	sub	sp, #12
                 ".buffer=%p, .attrs=%p, .attr_count=%"PRIu32"})",
            (void*)lfs, (void*)file, path, flags,
            (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);
    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    err = lfs_file_rawopencfg(lfs, file, path, flags, cfg);
    d518:	f8dd c010 	ldr.w	ip, [sp, #16]
    d51c:	f8cd c000 	str.w	ip, [sp]
    d520:	f7fa f9d6 	bl	78d0 <lfs_file_rawopencfg>

    LFS_TRACE("lfs_file_opencfg -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d524:	b003      	add	sp, #12
    d526:	f85d fb04 	ldr.w	pc, [sp], #4

0000d52a <lfs_file_close>:

int lfs_file_close(lfs_t *lfs, lfs_file_t *file) {
    d52a:	b508      	push	{r3, lr}
        return err;
    }
    LFS_TRACE("lfs_file_close(%p, %p)", (void*)lfs, (void*)file);
    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    err = lfs_file_rawclose(lfs, file);
    d52c:	f7ff ffb2 	bl	d494 <lfs_file_rawclose>

    LFS_TRACE("lfs_file_close -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d530:	bd08      	pop	{r3, pc}

0000d532 <lfs_file_sync>:

#ifndef LFS_READONLY
int lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {
    d532:	b508      	push	{r3, lr}
        return err;
    }
    LFS_TRACE("lfs_file_sync(%p, %p)", (void*)lfs, (void*)file);
    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    err = lfs_file_rawsync(lfs, file);
    d534:	f7ff fede 	bl	d2f4 <lfs_file_rawsync>

    LFS_TRACE("lfs_file_sync -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d538:	bd08      	pop	{r3, pc}

0000d53a <lfs_file_read>:
#endif

lfs_ssize_t lfs_file_read(lfs_t *lfs, lfs_file_t *file,
        void *buffer, lfs_size_t size) {
    d53a:	b508      	push	{r3, lr}
    }
    LFS_TRACE("lfs_file_read(%p, %p, %p, %"PRIu32")",
            (void*)lfs, (void*)file, buffer, size);
    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    lfs_ssize_t res = lfs_file_rawread(lfs, file, buffer, size);
    d53c:	f7ff fbc0 	bl	ccc0 <lfs_file_rawread>

    LFS_TRACE("lfs_file_read -> %"PRId32, res);
    LFS_UNLOCK(lfs->cfg);
    return res;
}
    d540:	bd08      	pop	{r3, pc}

0000d542 <lfs_file_write>:

#ifndef LFS_READONLY
lfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,
        const void *buffer, lfs_size_t size) {
    d542:	b508      	push	{r3, lr}
    }
    LFS_TRACE("lfs_file_write(%p, %p, %p, %"PRIu32")",
            (void*)lfs, (void*)file, buffer, size);
    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    lfs_ssize_t res = lfs_file_rawwrite(lfs, file, buffer, size);
    d544:	f7ff fc1b 	bl	cd7e <lfs_file_rawwrite>

    LFS_TRACE("lfs_file_write -> %"PRId32, res);
    LFS_UNLOCK(lfs->cfg);
    return res;
}
    d548:	bd08      	pop	{r3, pc}

0000d54a <lfs_file_seek>:
#endif

lfs_soff_t lfs_file_seek(lfs_t *lfs, lfs_file_t *file,
        lfs_soff_t off, int whence) {
    d54a:	b508      	push	{r3, lr}
    }
    LFS_TRACE("lfs_file_seek(%p, %p, %"PRId32", %d)",
            (void*)lfs, (void*)file, off, whence);
    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    lfs_soff_t res = lfs_file_rawseek(lfs, file, off, whence);
    d54c:	f7ff fbcb 	bl	cce6 <lfs_file_rawseek>

    LFS_TRACE("lfs_file_seek -> %"PRId32, res);
    LFS_UNLOCK(lfs->cfg);
    return res;
}
    d550:	bd08      	pop	{r3, pc}

0000d552 <lfs_file_truncate>:

#ifndef LFS_READONLY
int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
    d552:	b508      	push	{r3, lr}
    }
    LFS_TRACE("lfs_file_truncate(%p, %p, %"PRIu32")",
            (void*)lfs, (void*)file, size);
    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    err = lfs_file_rawtruncate(lfs, file, size);
    d554:	f7ff fc5a 	bl	ce0c <lfs_file_rawtruncate>

    LFS_TRACE("lfs_file_truncate -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d558:	bd08      	pop	{r3, pc}

0000d55a <lfs_file_tell>:
#endif

lfs_soff_t lfs_file_tell(lfs_t *lfs, lfs_file_t *file) {
    d55a:	b508      	push	{r3, lr}
        return err;
    }
    LFS_TRACE("lfs_file_tell(%p, %p)", (void*)lfs, (void*)file);
    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));

    lfs_soff_t res = lfs_file_rawtell(lfs, file);
    d55c:	f7fe fdf4 	bl	c148 <lfs_file_rawtell>

    LFS_TRACE("lfs_file_tell -> %"PRId32, res);
    LFS_UNLOCK(lfs->cfg);
    return res;
}
    d560:	bd08      	pop	{r3, pc}

0000d562 <lfs_mkdir>:
    LFS_UNLOCK(lfs->cfg);
    return res;
}

#ifndef LFS_READONLY
int lfs_mkdir(lfs_t *lfs, const char *path) {
    d562:	b508      	push	{r3, lr}
    if (err) {
        return err;
    }
    LFS_TRACE("lfs_mkdir(%p, \"%s\")", (void*)lfs, path);

    err = lfs_rawmkdir(lfs, path);
    d564:	f7fa fade 	bl	7b24 <lfs_rawmkdir>

    LFS_TRACE("lfs_mkdir -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d568:	bd08      	pop	{r3, pc}

0000d56a <lfs_dir_open>:
#endif

int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
    d56a:	b508      	push	{r3, lr}
        return err;
    }
    LFS_TRACE("lfs_dir_open(%p, %p, \"%s\")", (void*)lfs, (void*)dir, path);
    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)dir));

    err = lfs_dir_rawopen(lfs, dir, path);
    d56c:	f7fa f818 	bl	75a0 <lfs_dir_rawopen>

    LFS_TRACE("lfs_dir_open -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d570:	bd08      	pop	{r3, pc}

0000d572 <lfs_dir_close>:

int lfs_dir_close(lfs_t *lfs, lfs_dir_t *dir) {
    d572:	b508      	push	{r3, lr}
    if (err) {
        return err;
    }
    LFS_TRACE("lfs_dir_close(%p, %p)", (void*)lfs, (void*)dir);

    err = lfs_dir_rawclose(lfs, dir);
    d574:	f7fe fde3 	bl	c13e <lfs_dir_rawclose>

    LFS_TRACE("lfs_dir_close -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d578:	bd08      	pop	{r3, pc}

0000d57a <lfs_dir_read>:

int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
    d57a:	b508      	push	{r3, lr}
        return err;
    }
    LFS_TRACE("lfs_dir_read(%p, %p, %p)",
            (void*)lfs, (void*)dir, (void*)info);

    err = lfs_dir_rawread(lfs, dir, info);
    d57c:	f7fa fbd2 	bl	7d24 <lfs_dir_rawread>

    LFS_TRACE("lfs_dir_read -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}
    d580:	bd08      	pop	{r3, pc}

0000d582 <lfs_fs_size>:
    LFS_TRACE("lfs_dir_rewind -> %d", err);
    LFS_UNLOCK(lfs->cfg);
    return err;
}

lfs_ssize_t lfs_fs_size(lfs_t *lfs) {
    d582:	b508      	push	{r3, lr}
    if (err) {
        return err;
    }
    LFS_TRACE("lfs_fs_size(%p)", (void*)lfs);

    lfs_ssize_t res = lfs_fs_rawsize(lfs);
    d584:	f7f8 ff38 	bl	63f8 <lfs_fs_rawsize>

    LFS_TRACE("lfs_fs_size -> %"PRId32, res);
    LFS_UNLOCK(lfs->cfg);
    return res;
}
    d588:	bd08      	pop	{r3, pc}

0000d58a <_GetAvailWriteSpace>:
  RdOff = pRing->RdOff;
    d58a:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
    d58c:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
    d58e:	4293      	cmp	r3, r2
    d590:	d804      	bhi.n	d59c <_GetAvailWriteSpace+0x12>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
    d592:	6881      	ldr	r1, [r0, #8]
    d594:	1a8a      	subs	r2, r1, r2
    d596:	4413      	add	r3, r2
    d598:	1e58      	subs	r0, r3, #1
    d59a:	4770      	bx	lr
    r = RdOff - WrOff - 1u;
    d59c:	1a98      	subs	r0, r3, r2
    d59e:	3801      	subs	r0, #1
}
    d5a0:	4770      	bx	lr

0000d5a2 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    d5a2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d5a6:	4604      	mov	r4, r0
    d5a8:	4688      	mov	r8, r1
    d5aa:	4616      	mov	r6, r2
  WrOff = pRing->WrOff;
    d5ac:	68c5      	ldr	r5, [r0, #12]
  Rem = pRing->SizeOfBuffer - WrOff;
    d5ae:	6887      	ldr	r7, [r0, #8]
    d5b0:	eba7 0905 	sub.w	r9, r7, r5
  if (Rem > NumBytes) {
    d5b4:	4591      	cmp	r9, r2
    d5b6:	d909      	bls.n	d5cc <_WriteNoCheck+0x2a>
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    d5b8:	6840      	ldr	r0, [r0, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
    d5ba:	4428      	add	r0, r5
    d5bc:	f7fd f87e 	bl	a6bc <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    d5c0:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff + NumBytes;
    d5c4:	4435      	add	r5, r6
    d5c6:	60e5      	str	r5, [r4, #12]
}
    d5c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    d5cc:	6840      	ldr	r0, [r0, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
    d5ce:	464a      	mov	r2, r9
    d5d0:	4428      	add	r0, r5
    d5d2:	f7fd f873 	bl	a6bc <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
    d5d6:	1bed      	subs	r5, r5, r7
    d5d8:	4435      	add	r5, r6
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    d5da:	462a      	mov	r2, r5
    d5dc:	eb08 0109 	add.w	r1, r8, r9
    d5e0:	6860      	ldr	r0, [r4, #4]
    d5e2:	f7fd f86b 	bl	a6bc <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    d5e6:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = NumBytesAtOnce;
    d5ea:	60e5      	str	r5, [r4, #12]
}
    d5ec:	e7ec      	b.n	d5c8 <_WriteNoCheck+0x26>

0000d5ee <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    d5ee:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    d5f2:	4606      	mov	r6, r0
    d5f4:	4688      	mov	r8, r1
    d5f6:	4617      	mov	r7, r2
  WrOff = pRing->WrOff;
    d5f8:	68c5      	ldr	r5, [r0, #12]
  NumBytesWritten = 0u;
    d5fa:	f04f 0900 	mov.w	r9, #0
    d5fe:	e01a      	b.n	d636 <_WriteBlocking+0x48>
      NumBytesToWrite = RdOff - WrOff - 1u;
    d600:	1b5b      	subs	r3, r3, r5
    d602:	1e5a      	subs	r2, r3, #1
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
    d604:	68b3      	ldr	r3, [r6, #8]
    d606:	1b5c      	subs	r4, r3, r5
    d608:	4294      	cmp	r4, r2
    d60a:	bf28      	it	cs
    d60c:	4614      	movcs	r4, r2
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    d60e:	42bc      	cmp	r4, r7
    d610:	bf28      	it	cs
    d612:	463c      	movcs	r4, r7
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    d614:	6870      	ldr	r0, [r6, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
    d616:	4622      	mov	r2, r4
    d618:	4641      	mov	r1, r8
    d61a:	4428      	add	r0, r5
    d61c:	f7fd f84e 	bl	a6bc <memcpy>
    NumBytesWritten += NumBytesToWrite;
    d620:	44a1      	add	r9, r4
    pBuffer         += NumBytesToWrite;
    d622:	44a0      	add	r8, r4
    NumBytes        -= NumBytesToWrite;
    d624:	1b3f      	subs	r7, r7, r4
    WrOff           += NumBytesToWrite;
    d626:	4425      	add	r5, r4
    if (WrOff == pRing->SizeOfBuffer) {
    d628:	68b3      	ldr	r3, [r6, #8]
    d62a:	42ab      	cmp	r3, r5
    d62c:	d00b      	beq.n	d646 <_WriteBlocking+0x58>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    d62e:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
    d632:	60f5      	str	r5, [r6, #12]
  } while (NumBytes);
    d634:	b14f      	cbz	r7, d64a <_WriteBlocking+0x5c>
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
    d636:	6933      	ldr	r3, [r6, #16]
    if (RdOff > WrOff) {
    d638:	429d      	cmp	r5, r3
    d63a:	d3e1      	bcc.n	d600 <_WriteBlocking+0x12>
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    d63c:	68b2      	ldr	r2, [r6, #8]
    d63e:	1b5b      	subs	r3, r3, r5
    d640:	441a      	add	r2, r3
    d642:	3a01      	subs	r2, #1
    d644:	e7de      	b.n	d604 <_WriteBlocking+0x16>
      WrOff = 0u;
    d646:	2500      	movs	r5, #0
    d648:	e7f1      	b.n	d62e <_WriteBlocking+0x40>
}
    d64a:	4648      	mov	r0, r9
    d64c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000d650 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
    d650:	b508      	push	{r3, lr}
  _DoInit();
    d652:	f7fa fbe3 	bl	7e1c <_DoInit>
}
    d656:	bd08      	pop	{r3, pc}

0000d658 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(void)
{
    d658:	b508      	push	{r3, lr}

	SEGGER_RTT_Init();
    d65a:	f7ff fff9 	bl	d650 <SEGGER_RTT_Init>

	return 0;
}
    d65e:	2000      	movs	r0, #0
    d660:	bd08      	pop	{r3, pc}

0000d662 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    d662:	b160      	cbz	r0, d67e <z_device_is_ready+0x1c>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    d664:	68c3      	ldr	r3, [r0, #12]
    d666:	785a      	ldrb	r2, [r3, #1]
    d668:	f012 0f01 	tst.w	r2, #1
    d66c:	d003      	beq.n	d676 <z_device_is_ready+0x14>
    d66e:	781b      	ldrb	r3, [r3, #0]
    d670:	b11b      	cbz	r3, d67a <z_device_is_ready+0x18>
    d672:	2000      	movs	r0, #0
    d674:	4770      	bx	lr
    d676:	2000      	movs	r0, #0
    d678:	4770      	bx	lr
    d67a:	2001      	movs	r0, #1
    d67c:	4770      	bx	lr
		return false;
    d67e:	2000      	movs	r0, #0
}
    d680:	4770      	bx	lr

0000d682 <arch_system_halt>:
	__asm__ volatile(
    d682:	f04f 0220 	mov.w	r2, #32
    d686:	f3ef 8311 	mrs	r3, BASEPRI
    d68a:	f382 8812 	msr	BASEPRI_MAX, r2
    d68e:	f3bf 8f6f 	isb	sy
	for (;;) {
    d692:	e7fe      	b.n	d692 <arch_system_halt+0x10>

0000d694 <z_early_memset>:
{
    d694:	b508      	push	{r3, lr}
	(void) memset(dst, c, n);
    d696:	f7fd f840 	bl	a71a <memset>
}
    d69a:	bd08      	pop	{r3, pc}

0000d69c <z_early_memcpy>:
{
    d69c:	b508      	push	{r3, lr}
	(void) memcpy(dst, src, n);
    d69e:	f7fd f80d 	bl	a6bc <memcpy>
}
    d6a2:	bd08      	pop	{r3, pc}

0000d6a4 <k_heap_init>:
{
    d6a4:	b510      	push	{r4, lr}
    d6a6:	f100 040c 	add.w	r4, r0, #12
	list->head = (sys_dnode_t *)list;
    d6aa:	60c4      	str	r4, [r0, #12]
	list->tail = (sys_dnode_t *)list;
    d6ac:	6104      	str	r4, [r0, #16]
	sys_heap_init(&h->heap, mem, bytes);
    d6ae:	f7fc fa06 	bl	9abe <sys_heap_init>
}
    d6b2:	bd10      	pop	{r4, pc}

0000d6b4 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
    d6b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d6b8:	b085      	sub	sp, #20
    d6ba:	4607      	mov	r7, r0
    d6bc:	9103      	str	r1, [sp, #12]
    d6be:	4692      	mov	sl, r2
    d6c0:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    d6c2:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    d6c4:	4628      	mov	r0, r5
    d6c6:	4621      	mov	r1, r4
    d6c8:	f000 faba 	bl	dc40 <sys_clock_timeout_end_calc>
    d6cc:	4606      	mov	r6, r0
    d6ce:	4689      	mov	r9, r1
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
    d6d0:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
    d6d4:	bf08      	it	eq
    d6d6:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
    d6da:	d00d      	beq.n	d6f8 <k_heap_aligned_alloc+0x44>

	k_spinlock_key_t key = k_spin_lock(&h->lock);
    d6dc:	f107 0b14 	add.w	fp, r7, #20
    d6e0:	f04f 0320 	mov.w	r3, #32
    d6e4:	f3ef 8511 	mrs	r5, BASEPRI
    d6e8:	f383 8812 	msr	BASEPRI_MAX, r3
    d6ec:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");

	bool blocked_alloc = false;
    d6f0:	f04f 0800 	mov.w	r8, #0
	void *ret = NULL;
    d6f4:	4644      	mov	r4, r8

	while (ret == NULL) {
    d6f6:	e014      	b.n	d722 <k_heap_aligned_alloc+0x6e>
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
    d6f8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    d6fc:	f06f 4900 	mvn.w	r9, #2147483648	; 0x80000000
    d700:	e7ec      	b.n	d6dc <k_heap_aligned_alloc+0x28>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    d702:	9000      	str	r0, [sp, #0]
    d704:	9101      	str	r1, [sp, #4]
    d706:	f107 020c 	add.w	r2, r7, #12
    d70a:	4629      	mov	r1, r5
    d70c:	4658      	mov	r0, fp
    d70e:	f7fb f97d 	bl	8a0c <z_pend_curr>
    d712:	f04f 0320 	mov.w	r3, #32
    d716:	f3ef 8511 	mrs	r5, BASEPRI
    d71a:	f383 8812 	msr	BASEPRI_MAX, r3
    d71e:	f3bf 8f6f 	isb	sy
	while (ret == NULL) {
    d722:	b9ac      	cbnz	r4, d750 <k_heap_aligned_alloc+0x9c>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
    d724:	4652      	mov	r2, sl
    d726:	9903      	ldr	r1, [sp, #12]
    d728:	4638      	mov	r0, r7
    d72a:	f7fc f939 	bl	99a0 <sys_heap_aligned_alloc>
    d72e:	4604      	mov	r4, r0
		now = sys_clock_tick_get();
    d730:	f7fb fc92 	bl	9058 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
    d734:	b964      	cbnz	r4, d750 <k_heap_aligned_alloc+0x9c>
		    (ret != NULL) || ((end - now) <= 0)) {
    d736:	1a30      	subs	r0, r6, r0
    d738:	eb69 0101 	sbc.w	r1, r9, r1
    d73c:	2801      	cmp	r0, #1
    d73e:	f171 0300 	sbcs.w	r3, r1, #0
    d742:	db05      	blt.n	d750 <k_heap_aligned_alloc+0x9c>
		if (!blocked_alloc) {
    d744:	f1b8 0f00 	cmp.w	r8, #0
    d748:	d1db      	bne.n	d702 <k_heap_aligned_alloc+0x4e>
			blocked_alloc = true;
    d74a:	f04f 0801 	mov.w	r8, #1
    d74e:	e7d8      	b.n	d702 <k_heap_aligned_alloc+0x4e>
	__asm__ volatile(
    d750:	f385 8811 	msr	BASEPRI, r5
    d754:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
    d758:	4620      	mov	r0, r4
    d75a:	b005      	add	sp, #20
    d75c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d760 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
    d760:	b500      	push	{lr}
    d762:	b083      	sub	sp, #12
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
    d764:	e9cd 2300 	strd	r2, r3, [sp]
    d768:	460a      	mov	r2, r1
    d76a:	2104      	movs	r1, #4
    d76c:	f7ff ffa2 	bl	d6b4 <k_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, alloc, h, timeout, ret);

	return ret;
}
    d770:	b003      	add	sp, #12
    d772:	f85d fb04 	ldr.w	pc, [sp], #4

0000d776 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
    d776:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d778:	4604      	mov	r4, r0
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    d77a:	f100 0714 	add.w	r7, r0, #20
	__asm__ volatile(
    d77e:	f04f 0320 	mov.w	r3, #32
    d782:	f3ef 8511 	mrs	r5, BASEPRI
    d786:	f383 8812 	msr	BASEPRI_MAX, r3
    d78a:	f3bf 8f6f 	isb	sy

	sys_heap_free(&h->heap, mem);
    d78e:	f7fc f8b7 	bl	9900 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
    d792:	f104 000c 	add.w	r0, r4, #12
    d796:	f000 f9cc 	bl	db32 <z_unpend_all>
    d79a:	b920      	cbnz	r0, d7a6 <k_heap_free+0x30>
	__asm__ volatile(
    d79c:	f385 8811 	msr	BASEPRI, r5
    d7a0:	f3bf 8f6f 	isb	sy
		z_reschedule(&h->lock, key);
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
    d7a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		z_reschedule(&h->lock, key);
    d7a6:	4629      	mov	r1, r5
    d7a8:	4638      	mov	r0, r7
    d7aa:	f7fa ffe1 	bl	8770 <z_reschedule>
    d7ae:	e7f9      	b.n	d7a4 <k_heap_free+0x2e>

0000d7b0 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    d7b0:	68c2      	ldr	r2, [r0, #12]
    d7b2:	6903      	ldr	r3, [r0, #16]
    d7b4:	431a      	orrs	r2, r3
    d7b6:	f012 0203 	ands.w	r2, r2, #3
    d7ba:	d10d      	bne.n	d7d8 <create_free_list+0x28>
	slab->free_list = NULL;
    d7bc:	2100      	movs	r1, #0
    d7be:	6141      	str	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    d7c0:	e005      	b.n	d7ce <create_free_list+0x1e>
		*(char **)p = slab->free_list;
    d7c2:	6941      	ldr	r1, [r0, #20]
    d7c4:	6019      	str	r1, [r3, #0]
		slab->free_list = p;
    d7c6:	6143      	str	r3, [r0, #20]
		p += slab->block_size;
    d7c8:	68c1      	ldr	r1, [r0, #12]
    d7ca:	440b      	add	r3, r1
	for (j = 0U; j < slab->num_blocks; j++) {
    d7cc:	3201      	adds	r2, #1
    d7ce:	6881      	ldr	r1, [r0, #8]
    d7d0:	4291      	cmp	r1, r2
    d7d2:	d8f6      	bhi.n	d7c2 <create_free_list+0x12>
	return 0;
    d7d4:	2000      	movs	r0, #0
    d7d6:	4770      	bx	lr
		return -EINVAL;
    d7d8:	f06f 0015 	mvn.w	r0, #21
}
    d7dc:	4770      	bx	lr

0000d7de <k_mem_slab_init>:
{
    d7de:	b510      	push	{r4, lr}
    d7e0:	4604      	mov	r4, r0
	slab->num_blocks = num_blocks;
    d7e2:	6083      	str	r3, [r0, #8]
	slab->block_size = block_size;
    d7e4:	60c2      	str	r2, [r0, #12]
	slab->buffer = buffer;
    d7e6:	6101      	str	r1, [r0, #16]
	slab->num_used = 0U;
    d7e8:	2300      	movs	r3, #0
    d7ea:	6183      	str	r3, [r0, #24]
	rc = create_free_list(slab);
    d7ec:	f7ff ffe0 	bl	d7b0 <create_free_list>
	if (rc < 0) {
    d7f0:	2800      	cmp	r0, #0
    d7f2:	db01      	blt.n	d7f8 <k_mem_slab_init+0x1a>
	list->head = (sys_dnode_t *)list;
    d7f4:	6024      	str	r4, [r4, #0]
	list->tail = (sys_dnode_t *)list;
    d7f6:	6064      	str	r4, [r4, #4]
}
    d7f8:	bd10      	pop	{r4, pc}

0000d7fa <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    d7fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d7fe:	4604      	mov	r4, r0
    d800:	460d      	mov	r5, r1
	__asm__ volatile(
    d802:	f04f 0320 	mov.w	r3, #32
    d806:	f3ef 8611 	mrs	r6, BASEPRI
    d80a:	f383 8812 	msr	BASEPRI_MAX, r3
    d80e:	f3bf 8f6f 	isb	sy
    d812:	4637      	mov	r7, r6
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
    d814:	6943      	ldr	r3, [r0, #20]
    d816:	b16b      	cbz	r3, d834 <k_mem_slab_free+0x3a>
			z_ready_thread(pending_thread);
			z_reschedule(&slab->lock, key);
			return;
		}
	}
	**(char ***) mem = slab->free_list;
    d818:	682b      	ldr	r3, [r5, #0]
    d81a:	6962      	ldr	r2, [r4, #20]
    d81c:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
    d81e:	682b      	ldr	r3, [r5, #0]
    d820:	6163      	str	r3, [r4, #20]
	slab->num_used--;
    d822:	69a3      	ldr	r3, [r4, #24]
    d824:	3b01      	subs	r3, #1
    d826:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    d828:	f387 8811 	msr	BASEPRI, r7
    d82c:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
    d830:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d834:	f100 0808 	add.w	r8, r0, #8
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    d838:	f000 f959 	bl	daee <z_unpend_first_thread>
		if (pending_thread != NULL) {
    d83c:	2800      	cmp	r0, #0
    d83e:	d0eb      	beq.n	d818 <k_mem_slab_free+0x1e>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    d840:	682a      	ldr	r2, [r5, #0]
    d842:	2100      	movs	r1, #0
    d844:	6781      	str	r1, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    d846:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
    d848:	f000 f8ba 	bl	d9c0 <z_ready_thread>
			z_reschedule(&slab->lock, key);
    d84c:	4631      	mov	r1, r6
    d84e:	4640      	mov	r0, r8
    d850:	f7fa ff8e 	bl	8770 <z_reschedule>
			return;
    d854:	e7ec      	b.n	d830 <k_mem_slab_free+0x36>

0000d856 <setup_thread_stack>:
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    d856:	3207      	adds	r2, #7
    d858:	f022 0207 	bic.w	r2, r2, #7
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
    d85c:	6641      	str	r1, [r0, #100]	; 0x64
	new_thread->stack_info.size = stack_buf_size;
    d85e:	6682      	str	r2, [r0, #104]	; 0x68
	new_thread->stack_info.delta = delta;
    d860:	2300      	movs	r3, #0
    d862:	66c3      	str	r3, [r0, #108]	; 0x6c
}
    d864:	1888      	adds	r0, r1, r2
    d866:	4770      	bx	lr

0000d868 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    d868:	f3ef 8005 	mrs	r0, IPSR
}
    d86c:	3800      	subs	r0, #0
    d86e:	bf18      	it	ne
    d870:	2001      	movne	r0, #1
    d872:	4770      	bx	lr

0000d874 <k_thread_name_get>:
}
    d874:	2000      	movs	r0, #0
    d876:	4770      	bx	lr

0000d878 <z_impl_k_thread_start>:
{
    d878:	b508      	push	{r3, lr}
	z_sched_start(thread);
    d87a:	f7fb f88d 	bl	8998 <z_sched_start>
}
    d87e:	bd08      	pop	{r3, pc}

0000d880 <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    d880:	b410      	push	{r4}
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    d882:	2400      	movs	r4, #0
    d884:	6084      	str	r4, [r0, #8]
	thread_base->user_options = (uint8_t)options;
    d886:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    d888:	7342      	strb	r2, [r0, #13]

	thread_base->prio = priority;
    d88a:	7381      	strb	r1, [r0, #14]

	thread_base->sched_locked = 0U;
    d88c:	73c4      	strb	r4, [r0, #15]
	node->next = NULL;
    d88e:	6184      	str	r4, [r0, #24]
	node->prev = NULL;
    d890:	61c4      	str	r4, [r0, #28]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    d892:	bc10      	pop	{r4}
    d894:	4770      	bx	lr

0000d896 <z_pm_save_idle_exit>:
{
    d896:	b508      	push	{r3, lr}
	pm_system_resume();
    d898:	f7f3 fcbe 	bl	1218 <pm_system_resume>
	sys_clock_idle_exit();
    d89c:	f7fe f839 	bl	b912 <sys_clock_idle_exit>
}
    d8a0:	bd08      	pop	{r3, pc}

0000d8a2 <new_prio_for_inheritance>:
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
    d8a2:	4288      	cmp	r0, r1
    d8a4:	da00      	bge.n	d8a8 <new_prio_for_inheritance+0x6>
    d8a6:	4601      	mov	r1, r0
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
    d8a8:	f111 0f7f 	cmn.w	r1, #127	; 0x7f
    d8ac:	db01      	blt.n	d8b2 <new_prio_for_inheritance+0x10>
    d8ae:	4608      	mov	r0, r1
    d8b0:	4770      	bx	lr
    d8b2:	f06f 007e 	mvn.w	r0, #126	; 0x7e
}
    d8b6:	4770      	bx	lr

0000d8b8 <adjust_owner_prio>:
{
    d8b8:	b508      	push	{r3, lr}
	if (mutex->owner->base.prio != new_prio) {
    d8ba:	6880      	ldr	r0, [r0, #8]
    d8bc:	f990 300e 	ldrsb.w	r3, [r0, #14]
    d8c0:	428b      	cmp	r3, r1
    d8c2:	d101      	bne.n	d8c8 <adjust_owner_prio+0x10>
	return false;
    d8c4:	2000      	movs	r0, #0
}
    d8c6:	bd08      	pop	{r3, pc}
		return z_set_prio(mutex->owner, new_prio);
    d8c8:	f7fb f8bc 	bl	8a44 <z_set_prio>
    d8cc:	e7fb      	b.n	d8c6 <adjust_owner_prio+0xe>

0000d8ce <z_impl_k_mutex_init>:
{
    d8ce:	4603      	mov	r3, r0
	mutex->owner = NULL;
    d8d0:	2000      	movs	r0, #0
    d8d2:	6098      	str	r0, [r3, #8]
	mutex->lock_count = 0U;
    d8d4:	60d8      	str	r0, [r3, #12]
	list->head = (sys_dnode_t *)list;
    d8d6:	601b      	str	r3, [r3, #0]
	list->tail = (sys_dnode_t *)list;
    d8d8:	605b      	str	r3, [r3, #4]
}
    d8da:	4770      	bx	lr

0000d8dc <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
    d8dc:	b13a      	cbz	r2, d8ee <z_impl_k_sem_init+0x12>
    d8de:	428a      	cmp	r2, r1
    d8e0:	d308      	bcc.n	d8f4 <z_impl_k_sem_init+0x18>
	sem->count = initial_count;
    d8e2:	6081      	str	r1, [r0, #8]
	sem->limit = limit;
    d8e4:	60c2      	str	r2, [r0, #12]
	list->head = (sys_dnode_t *)list;
    d8e6:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
    d8e8:	6040      	str	r0, [r0, #4]
	return 0;
    d8ea:	2000      	movs	r0, #0
    d8ec:	4770      	bx	lr
		return -EINVAL;
    d8ee:	f06f 0015 	mvn.w	r0, #21
    d8f2:	4770      	bx	lr
    d8f4:	f06f 0015 	mvn.w	r0, #21
}
    d8f8:	4770      	bx	lr

0000d8fa <thread_active_elsewhere>:
}
    d8fa:	2000      	movs	r0, #0
    d8fc:	4770      	bx	lr

0000d8fe <pended_on_thread>:
}
    d8fe:	6880      	ldr	r0, [r0, #8]
    d900:	4770      	bx	lr

0000d902 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    d902:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
    d906:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
    d90a:	4283      	cmp	r3, r0
    d90c:	d001      	beq.n	d912 <z_sched_prio_cmp+0x10>
		return b2 - b1;
    d90e:	1ac0      	subs	r0, r0, r3
    d910:	4770      	bx	lr
	return 0;
    d912:	2000      	movs	r0, #0
}
    d914:	4770      	bx	lr

0000d916 <z_reschedule_irqlock>:
{
    d916:	b508      	push	{r3, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    d918:	4603      	mov	r3, r0
    d91a:	b928      	cbnz	r0, d928 <z_reschedule_irqlock+0x12>
    d91c:	f3ef 8205 	mrs	r2, IPSR
    d920:	b912      	cbnz	r2, d928 <z_reschedule_irqlock+0x12>
	ret = arch_swap(key);
    d922:	f7f3 ff77 	bl	1814 <arch_swap>
	return ret;
    d926:	e003      	b.n	d930 <z_reschedule_irqlock+0x1a>
    d928:	f383 8811 	msr	BASEPRI, r3
    d92c:	f3bf 8f6f 	isb	sy
}
    d930:	bd08      	pop	{r3, pc}

0000d932 <z_reschedule_unlocked>:
{
    d932:	b508      	push	{r3, lr}
	__asm__ volatile(
    d934:	f04f 0320 	mov.w	r3, #32
    d938:	f3ef 8011 	mrs	r0, BASEPRI
    d93c:	f383 8812 	msr	BASEPRI_MAX, r3
    d940:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    d944:	f7ff ffe7 	bl	d916 <z_reschedule_irqlock>
}
    d948:	bd08      	pop	{r3, pc}

0000d94a <z_priq_dumb_remove>:
	sys_dnode_t *const prev = node->prev;
    d94a:	684a      	ldr	r2, [r1, #4]
	sys_dnode_t *const next = node->next;
    d94c:	680b      	ldr	r3, [r1, #0]
	prev->next = next;
    d94e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    d950:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    d952:	2300      	movs	r3, #0
    d954:	600b      	str	r3, [r1, #0]
	node->prev = NULL;
    d956:	604b      	str	r3, [r1, #4]
}
    d958:	4770      	bx	lr

0000d95a <unpend_thread_no_timeout>:
{
    d95a:	b510      	push	{r4, lr}
    d95c:	4604      	mov	r4, r0
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    d95e:	f7ff ffce 	bl	d8fe <pended_on_thread>
    d962:	4621      	mov	r1, r4
    d964:	f7ff fff1 	bl	d94a <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    d968:	7b63      	ldrb	r3, [r4, #13]
    d96a:	f023 0302 	bic.w	r3, r3, #2
    d96e:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    d970:	2300      	movs	r3, #0
    d972:	60a3      	str	r3, [r4, #8]
}
    d974:	bd10      	pop	{r4, pc}

0000d976 <z_unpend_thread>:
{
    d976:	b538      	push	{r3, r4, r5, lr}
    d978:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
    d97a:	2300      	movs	r3, #0
    d97c:	f04f 0220 	mov.w	r2, #32
    d980:	f3ef 8511 	mrs	r5, BASEPRI
    d984:	f382 8812 	msr	BASEPRI_MAX, r2
    d988:	f3bf 8f6f 	isb	sy
    d98c:	e004      	b.n	d998 <z_unpend_thread+0x22>
	__asm__ volatile(
    d98e:	f385 8811 	msr	BASEPRI, r5
    d992:	f3bf 8f6f 	isb	sy
    d996:	2301      	movs	r3, #1
    d998:	b933      	cbnz	r3, d9a8 <z_unpend_thread+0x32>
		if (thread->base.pended_on != NULL) {
    d99a:	68a3      	ldr	r3, [r4, #8]
    d99c:	2b00      	cmp	r3, #0
    d99e:	d0f6      	beq.n	d98e <z_unpend_thread+0x18>
			unpend_thread_no_timeout(thread);
    d9a0:	4620      	mov	r0, r4
    d9a2:	f7ff ffda 	bl	d95a <unpend_thread_no_timeout>
    d9a6:	e7f2      	b.n	d98e <z_unpend_thread+0x18>
	return z_abort_timeout(&thread->base.timeout);
    d9a8:	f104 0018 	add.w	r0, r4, #24
    d9ac:	f000 f909 	bl	dbc2 <z_abort_timeout>
}
    d9b0:	bd38      	pop	{r3, r4, r5, pc}

0000d9b2 <z_priq_dumb_best>:
{
    d9b2:	4603      	mov	r3, r0
	return list->head == list;
    d9b4:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    d9b6:	4283      	cmp	r3, r0
    d9b8:	d000      	beq.n	d9bc <z_priq_dumb_best+0xa>
}
    d9ba:	4770      	bx	lr
	struct k_thread *thread = NULL;
    d9bc:	2000      	movs	r0, #0
	return thread;
    d9be:	e7fc      	b.n	d9ba <z_priq_dumb_best+0x8>

0000d9c0 <z_ready_thread>:
{
    d9c0:	b538      	push	{r3, r4, r5, lr}
    d9c2:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
    d9c4:	2300      	movs	r3, #0
	__asm__ volatile(
    d9c6:	f04f 0220 	mov.w	r2, #32
    d9ca:	f3ef 8511 	mrs	r5, BASEPRI
    d9ce:	f382 8812 	msr	BASEPRI_MAX, r2
    d9d2:	f3bf 8f6f 	isb	sy
    d9d6:	e004      	b.n	d9e2 <z_ready_thread+0x22>
	__asm__ volatile(
    d9d8:	f385 8811 	msr	BASEPRI, r5
    d9dc:	f3bf 8f6f 	isb	sy
    d9e0:	2301      	movs	r3, #1
    d9e2:	b943      	cbnz	r3, d9f6 <z_ready_thread+0x36>
		if (!thread_active_elsewhere(thread)) {
    d9e4:	4620      	mov	r0, r4
    d9e6:	f7ff ff88 	bl	d8fa <thread_active_elsewhere>
    d9ea:	2800      	cmp	r0, #0
    d9ec:	d1f4      	bne.n	d9d8 <z_ready_thread+0x18>
			ready_thread(thread);
    d9ee:	4620      	mov	r0, r4
    d9f0:	f7fa ff96 	bl	8920 <ready_thread>
    d9f4:	e7f0      	b.n	d9d8 <z_ready_thread+0x18>
}
    d9f6:	bd38      	pop	{r3, r4, r5, pc}

0000d9f8 <z_sched_wake_thread>:
{
    d9f8:	b570      	push	{r4, r5, r6, lr}
    d9fa:	4604      	mov	r4, r0
    d9fc:	460e      	mov	r6, r1
	LOCKED(&sched_spinlock) {
    d9fe:	2300      	movs	r3, #0
	__asm__ volatile(
    da00:	f04f 0220 	mov.w	r2, #32
    da04:	f3ef 8511 	mrs	r5, BASEPRI
    da08:	f382 8812 	msr	BASEPRI_MAX, r2
    da0c:	f3bf 8f6f 	isb	sy
    da10:	e007      	b.n	da22 <z_sched_wake_thread+0x2a>
			ready_thread(thread);
    da12:	4620      	mov	r0, r4
    da14:	f7fa ff84 	bl	8920 <ready_thread>
	__asm__ volatile(
    da18:	f385 8811 	msr	BASEPRI, r5
    da1c:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    da20:	2301      	movs	r3, #1
    da22:	b993      	cbnz	r3, da4a <z_sched_wake_thread+0x52>
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    da24:	7b63      	ldrb	r3, [r4, #13]
		if (!killed) {
    da26:	f013 0f28 	tst.w	r3, #40	; 0x28
    da2a:	d1f5      	bne.n	da18 <z_sched_wake_thread+0x20>
			if (thread->base.pended_on != NULL) {
    da2c:	68a3      	ldr	r3, [r4, #8]
    da2e:	b113      	cbz	r3, da36 <z_sched_wake_thread+0x3e>
				unpend_thread_no_timeout(thread);
    da30:	4620      	mov	r0, r4
    da32:	f7ff ff92 	bl	d95a <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    da36:	7b63      	ldrb	r3, [r4, #13]
    da38:	f023 0204 	bic.w	r2, r3, #4
    da3c:	7362      	strb	r2, [r4, #13]
			if (is_timeout) {
    da3e:	2e00      	cmp	r6, #0
    da40:	d0e7      	beq.n	da12 <z_sched_wake_thread+0x1a>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    da42:	f023 0314 	bic.w	r3, r3, #20
    da46:	7363      	strb	r3, [r4, #13]
}
    da48:	e7e3      	b.n	da12 <z_sched_wake_thread+0x1a>
}
    da4a:	bd70      	pop	{r4, r5, r6, pc}

0000da4c <z_thread_timeout>:
{
    da4c:	b508      	push	{r3, lr}
	z_sched_wake_thread(thread, true);
    da4e:	2101      	movs	r1, #1
    da50:	3818      	subs	r0, #24
    da52:	f7ff ffd1 	bl	d9f8 <z_sched_wake_thread>
}
    da56:	bd08      	pop	{r3, pc}

0000da58 <unpend_all>:
{
    da58:	b538      	push	{r3, r4, r5, lr}
    da5a:	4605      	mov	r5, r0
	return list->head == list;
    da5c:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    da5e:	42a5      	cmp	r5, r4
    da60:	d00d      	beq.n	da7e <unpend_all+0x26>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    da62:	b164      	cbz	r4, da7e <unpend_all+0x26>
		unpend_thread_no_timeout(thread);
    da64:	4620      	mov	r0, r4
    da66:	f7ff ff78 	bl	d95a <unpend_thread_no_timeout>
    da6a:	f104 0018 	add.w	r0, r4, #24
    da6e:	f000 f8a8 	bl	dbc2 <z_abort_timeout>
    da72:	2300      	movs	r3, #0
    da74:	67a3      	str	r3, [r4, #120]	; 0x78
		ready_thread(thread);
    da76:	4620      	mov	r0, r4
    da78:	f7fa ff52 	bl	8920 <ready_thread>
    da7c:	e7ee      	b.n	da5c <unpend_all+0x4>
}
    da7e:	bd38      	pop	{r3, r4, r5, pc}

0000da80 <add_to_waitq_locked>:
{
    da80:	b570      	push	{r4, r5, r6, lr}
    da82:	4605      	mov	r5, r0
    da84:	460e      	mov	r6, r1
	unready_thread(thread);
    da86:	f7fa ffa5 	bl	89d4 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    da8a:	7b6b      	ldrb	r3, [r5, #13]
    da8c:	f043 0302 	orr.w	r3, r3, #2
    da90:	736b      	strb	r3, [r5, #13]
	if (wait_q != NULL) {
    da92:	b1fe      	cbz	r6, dad4 <add_to_waitq_locked+0x54>
		thread->base.pended_on = wait_q;
    da94:	60ae      	str	r6, [r5, #8]
	return list->head == list;
    da96:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    da98:	42a6      	cmp	r6, r4
    da9a:	d108      	bne.n	daae <add_to_waitq_locked+0x2e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    da9c:	2400      	movs	r4, #0
    da9e:	e006      	b.n	daae <add_to_waitq_locked+0x2e>
	sys_dnode_t *const prev = successor->prev;
    daa0:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    daa2:	606b      	str	r3, [r5, #4]
	node->next = successor;
    daa4:	602c      	str	r4, [r5, #0]
	prev->next = node;
    daa6:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    daa8:	6065      	str	r5, [r4, #4]
}
    daaa:	e013      	b.n	dad4 <add_to_waitq_locked+0x54>
    daac:	2400      	movs	r4, #0
    daae:	b164      	cbz	r4, daca <add_to_waitq_locked+0x4a>
		if (z_sched_prio_cmp(thread, t) > 0) {
    dab0:	4621      	mov	r1, r4
    dab2:	4628      	mov	r0, r5
    dab4:	f7ff ff25 	bl	d902 <z_sched_prio_cmp>
    dab8:	2800      	cmp	r0, #0
    daba:	dcf1      	bgt.n	daa0 <add_to_waitq_locked+0x20>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    dabc:	2c00      	cmp	r4, #0
    dabe:	d0f6      	beq.n	daae <add_to_waitq_locked+0x2e>
	return (node == list->tail) ? NULL : node->next;
    dac0:	6873      	ldr	r3, [r6, #4]
    dac2:	429c      	cmp	r4, r3
    dac4:	d0f2      	beq.n	daac <add_to_waitq_locked+0x2c>
    dac6:	6824      	ldr	r4, [r4, #0]
    dac8:	e7f1      	b.n	daae <add_to_waitq_locked+0x2e>
	sys_dnode_t *const tail = list->tail;
    daca:	6873      	ldr	r3, [r6, #4]
	node->next = list;
    dacc:	602e      	str	r6, [r5, #0]
	node->prev = tail;
    dace:	606b      	str	r3, [r5, #4]
	tail->next = node;
    dad0:	601d      	str	r5, [r3, #0]
	list->tail = node;
    dad2:	6075      	str	r5, [r6, #4]
}
    dad4:	bd70      	pop	{r4, r5, r6, pc}

0000dad6 <pend_locked>:
{
    dad6:	b570      	push	{r4, r5, r6, lr}
    dad8:	4604      	mov	r4, r0
    dada:	4616      	mov	r6, r2
    dadc:	461d      	mov	r5, r3
	add_to_waitq_locked(thread, wait_q);
    dade:	f7ff ffcf 	bl	da80 <add_to_waitq_locked>
	add_thread_timeout(thread, timeout);
    dae2:	4632      	mov	r2, r6
    dae4:	462b      	mov	r3, r5
    dae6:	4620      	mov	r0, r4
    dae8:	f7fa fe0a 	bl	8700 <add_thread_timeout>
}
    daec:	bd70      	pop	{r4, r5, r6, pc}

0000daee <z_unpend_first_thread>:
{
    daee:	b570      	push	{r4, r5, r6, lr}
    daf0:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
    daf2:	2300      	movs	r3, #0
	__asm__ volatile(
    daf4:	f04f 0220 	mov.w	r2, #32
    daf8:	f3ef 8511 	mrs	r5, BASEPRI
    dafc:	f382 8812 	msr	BASEPRI_MAX, r2
    db00:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = NULL;
    db04:	461c      	mov	r4, r3
    db06:	e004      	b.n	db12 <z_unpend_first_thread+0x24>
	__asm__ volatile(
    db08:	f385 8811 	msr	BASEPRI, r5
    db0c:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    db10:	2301      	movs	r3, #1
    db12:	b963      	cbnz	r3, db2e <z_unpend_first_thread+0x40>
		thread = _priq_wait_best(&wait_q->waitq);
    db14:	4630      	mov	r0, r6
    db16:	f7ff ff4c 	bl	d9b2 <z_priq_dumb_best>
		if (thread != NULL) {
    db1a:	4604      	mov	r4, r0
    db1c:	2800      	cmp	r0, #0
    db1e:	d0f3      	beq.n	db08 <z_unpend_first_thread+0x1a>
			unpend_thread_no_timeout(thread);
    db20:	f7ff ff1b 	bl	d95a <unpend_thread_no_timeout>
    db24:	f104 0018 	add.w	r0, r4, #24
    db28:	f000 f84b 	bl	dbc2 <z_abort_timeout>
    db2c:	e7ec      	b.n	db08 <z_unpend_first_thread+0x1a>
}
    db2e:	4620      	mov	r0, r4
    db30:	bd70      	pop	{r4, r5, r6, pc}

0000db32 <z_unpend_all>:
{
    db32:	b538      	push	{r3, r4, r5, lr}
    db34:	4605      	mov	r5, r0
	int need_sched = 0;
    db36:	2000      	movs	r0, #0
	return list->head == list;
    db38:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    db3a:	42a5      	cmp	r5, r4
    db3c:	d008      	beq.n	db50 <z_unpend_all+0x1e>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    db3e:	b13c      	cbz	r4, db50 <z_unpend_all+0x1e>
		z_unpend_thread(thread);
    db40:	4620      	mov	r0, r4
    db42:	f7ff ff18 	bl	d976 <z_unpend_thread>
		z_ready_thread(thread);
    db46:	4620      	mov	r0, r4
    db48:	f7ff ff3a 	bl	d9c0 <z_ready_thread>
		need_sched = 1;
    db4c:	2001      	movs	r0, #1
    db4e:	e7f3      	b.n	db38 <z_unpend_all+0x6>
}
    db50:	bd38      	pop	{r3, r4, r5, pc}

0000db52 <init_ready_q>:
	sys_dlist_init(&rq->runq);
    db52:	1d03      	adds	r3, r0, #4
	list->head = (sys_dnode_t *)list;
    db54:	6043      	str	r3, [r0, #4]
	list->tail = (sys_dnode_t *)list;
    db56:	6083      	str	r3, [r0, #8]
}
    db58:	4770      	bx	lr

0000db5a <remove_timeout>:
{
    db5a:	b510      	push	{r4, lr}
    db5c:	4604      	mov	r4, r0
	if (next(t) != NULL) {
    db5e:	f7fb f97f 	bl	8e60 <next>
    db62:	b148      	cbz	r0, db78 <remove_timeout+0x1e>
    db64:	4602      	mov	r2, r0
		next(t)->dticks += t->dticks;
    db66:	6903      	ldr	r3, [r0, #16]
    db68:	6941      	ldr	r1, [r0, #20]
    db6a:	6920      	ldr	r0, [r4, #16]
    db6c:	181b      	adds	r3, r3, r0
    db6e:	6960      	ldr	r0, [r4, #20]
    db70:	eb41 0100 	adc.w	r1, r1, r0
    db74:	6113      	str	r3, [r2, #16]
    db76:	6151      	str	r1, [r2, #20]
	sys_dnode_t *const prev = node->prev;
    db78:	6862      	ldr	r2, [r4, #4]
	sys_dnode_t *const next = node->next;
    db7a:	6823      	ldr	r3, [r4, #0]
	prev->next = next;
    db7c:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    db7e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    db80:	2300      	movs	r3, #0
    db82:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
    db84:	6063      	str	r3, [r4, #4]
}
    db86:	bd10      	pop	{r4, pc}

0000db88 <next_timeout>:
{
    db88:	b510      	push	{r4, lr}
	struct _timeout *to = first();
    db8a:	f7fb f95f 	bl	8e4c <first>
    db8e:	4604      	mov	r4, r0
	int32_t ticks_elapsed = elapsed();
    db90:	f7fb f972 	bl	8e78 <elapsed>
	if ((to == NULL) ||
    db94:	b17c      	cbz	r4, dbb6 <next_timeout+0x2e>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
    db96:	6923      	ldr	r3, [r4, #16]
    db98:	6962      	ldr	r2, [r4, #20]
    db9a:	1a1b      	subs	r3, r3, r0
    db9c:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
    dba0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    dba4:	f172 0100 	sbcs.w	r1, r2, #0
    dba8:	da08      	bge.n	dbbc <next_timeout+0x34>
		ret = MAX(0, to->dticks - ticks_elapsed);
    dbaa:	2a00      	cmp	r2, #0
    dbac:	db01      	blt.n	dbb2 <next_timeout+0x2a>
    dbae:	4618      	mov	r0, r3
}
    dbb0:	bd10      	pop	{r4, pc}
		ret = MAX(0, to->dticks - ticks_elapsed);
    dbb2:	2300      	movs	r3, #0
    dbb4:	e7fb      	b.n	dbae <next_timeout+0x26>
		ret = MAX_WAIT;
    dbb6:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    dbba:	e7f9      	b.n	dbb0 <next_timeout+0x28>
    dbbc:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	return ret;
    dbc0:	e7f6      	b.n	dbb0 <next_timeout+0x28>

0000dbc2 <z_abort_timeout>:
{
    dbc2:	b570      	push	{r4, r5, r6, lr}
    dbc4:	4604      	mov	r4, r0
	LOCKED(&timeout_lock) {
    dbc6:	2300      	movs	r3, #0
	__asm__ volatile(
    dbc8:	f04f 0220 	mov.w	r2, #32
    dbcc:	f3ef 8611 	mrs	r6, BASEPRI
    dbd0:	f382 8812 	msr	BASEPRI_MAX, r2
    dbd4:	f3bf 8f6f 	isb	sy
	int ret = -EINVAL;
    dbd8:	f06f 0015 	mvn.w	r0, #21
    dbdc:	e004      	b.n	dbe8 <z_abort_timeout+0x26>
	__asm__ volatile(
    dbde:	f386 8811 	msr	BASEPRI, r6
    dbe2:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    dbe6:	2301      	movs	r3, #1
    dbe8:	461d      	mov	r5, r3
    dbea:	b93b      	cbnz	r3, dbfc <z_abort_timeout+0x3a>
	return node->next != NULL;
    dbec:	6823      	ldr	r3, [r4, #0]
		if (sys_dnode_is_linked(&to->node)) {
    dbee:	2b00      	cmp	r3, #0
    dbf0:	d0f5      	beq.n	dbde <z_abort_timeout+0x1c>
			remove_timeout(to);
    dbf2:	4620      	mov	r0, r4
    dbf4:	f7ff ffb1 	bl	db5a <remove_timeout>
			ret = 0;
    dbf8:	4628      	mov	r0, r5
    dbfa:	e7f0      	b.n	dbde <z_abort_timeout+0x1c>
}
    dbfc:	bd70      	pop	{r4, r5, r6, pc}

0000dbfe <z_get_next_timeout_expiry>:
{
    dbfe:	b510      	push	{r4, lr}
	LOCKED(&timeout_lock) {
    dc00:	2300      	movs	r3, #0
	__asm__ volatile(
    dc02:	f04f 0220 	mov.w	r2, #32
    dc06:	f3ef 8411 	mrs	r4, BASEPRI
    dc0a:	f382 8812 	msr	BASEPRI_MAX, r2
    dc0e:	f3bf 8f6f 	isb	sy
	int32_t ret = (int32_t) K_TICKS_FOREVER;
    dc12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    dc16:	e006      	b.n	dc26 <z_get_next_timeout_expiry+0x28>
		ret = next_timeout();
    dc18:	f7ff ffb6 	bl	db88 <next_timeout>
	__asm__ volatile(
    dc1c:	f384 8811 	msr	BASEPRI, r4
    dc20:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    dc24:	2301      	movs	r3, #1
    dc26:	2b00      	cmp	r3, #0
    dc28:	d0f6      	beq.n	dc18 <z_get_next_timeout_expiry+0x1a>
}
    dc2a:	bd10      	pop	{r4, pc}

0000dc2c <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    dc2c:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    dc2e:	f7fb fa13 	bl	9058 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    dc32:	bd08      	pop	{r3, pc}

0000dc34 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    dc34:	b900      	cbnz	r0, dc38 <z_impl_k_busy_wait+0x4>
    dc36:	4770      	bx	lr
{
    dc38:	b508      	push	{r3, lr}
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    dc3a:	f7fc fb6e 	bl	a31a <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    dc3e:	bd08      	pop	{r3, pc}

0000dc40 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
    dc40:	b538      	push	{r3, r4, r5, lr}
    dc42:	460c      	mov	r4, r1
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    dc44:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
    dc48:	bf08      	it	eq
    dc4a:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
    dc4e:	d020      	beq.n	dc92 <sys_clock_timeout_end_calc+0x52>
    dc50:	4605      	mov	r5, r0
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    dc52:	ea51 0300 	orrs.w	r3, r1, r0
    dc56:	d009      	beq.n	dc6c <sys_clock_timeout_end_calc+0x2c>
		return sys_clock_tick_get();
	} else {

		dt = timeout.ticks;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
    dc58:	f06f 0301 	mvn.w	r3, #1
    dc5c:	1a18      	subs	r0, r3, r0
    dc5e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    dc62:	eb63 0101 	sbc.w	r1, r3, r1
    dc66:	2900      	cmp	r1, #0
    dc68:	db03      	blt.n	dc72 <sys_clock_timeout_end_calc+0x32>
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
    dc6a:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get();
    dc6c:	f7fb f9f4 	bl	9058 <sys_clock_tick_get>
    dc70:	e7fb      	b.n	dc6a <sys_clock_timeout_end_calc+0x2a>
		return sys_clock_tick_get() + MAX(1, dt);
    dc72:	f7fb f9f1 	bl	9058 <sys_clock_tick_get>
    dc76:	4603      	mov	r3, r0
    dc78:	462a      	mov	r2, r5
    dc7a:	46a4      	mov	ip, r4
    dc7c:	2d01      	cmp	r5, #1
    dc7e:	f174 0400 	sbcs.w	r4, r4, #0
    dc82:	da02      	bge.n	dc8a <sys_clock_timeout_end_calc+0x4a>
    dc84:	2201      	movs	r2, #1
    dc86:	f04f 0c00 	mov.w	ip, #0
    dc8a:	1898      	adds	r0, r3, r2
    dc8c:	eb41 010c 	adc.w	r1, r1, ip
    dc90:	e7eb      	b.n	dc6a <sys_clock_timeout_end_calc+0x2a>
		return UINT64_MAX;
    dc92:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    dc96:	4601      	mov	r1, r0
    dc98:	e7e7      	b.n	dc6a <sys_clock_timeout_end_calc+0x2a>

0000dc9a <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    dc9a:	4770      	bx	lr
